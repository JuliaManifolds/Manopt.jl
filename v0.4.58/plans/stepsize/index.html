<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stepsize ¬∑ Manopt.jl</title><meta name="title" content="Stepsize ¬∑ Manopt.jl"/><meta property="og:title" content="Stepsize ¬∑ Manopt.jl"/><meta property="twitter:title" content="Stepsize ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/Optimize/">üèîÔ∏è Get started: optimize.</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../../tutorials/EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../../tutorials/HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../../tutorials/ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do constrained optimization</a></li><li><a class="tocitem" href="../../tutorials/GeodesicRegression/">Do geodesic regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">Introduction</a></li><li><a class="tocitem" href="../../solvers/adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/convex_bundle_method/">Convex bundle method</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/proximal_bundle_method/">Proximal bundle method</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../">Specify a Solver</a></li><li><a class="tocitem" href="../problem/">Problem</a></li><li><a class="tocitem" href="../objective/">Objective</a></li><li><a class="tocitem" href="../state/">Solver State</a></li><li class="is-active"><a class="tocitem" href>Stepsize</a><ul class="internal"><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../debug/">Debug Output</a></li><li><a class="tocitem" href="../record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plans</a></li><li class="is-active"><a href>Stepsize</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stepsize</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/plans/stepsize.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Stepsize"><a class="docs-heading-anchor" href="#Stepsize">Stepsize and line search</a><a id="Stepsize-1"></a><a class="docs-heading-anchor-permalink" href="#Stepsize" title="Permalink"></a></h1><p>Most iterative algorithms determine a direction along which the algorithm shall proceed and determine a step size to find the next iterate. How advanced the step size computation can be implemented depends (among others) on the properties the corresponding problem provides.</p><p>Within <code>Manopt.jl</code>, the step size determination is implemented as a <code>functor</code> which is a subtype of <a href="#Stepsize"><code>Stepsize</code></a> based on</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.Stepsize" href="#Manopt.Stepsize"><code>Manopt.Stepsize</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Stepsize</code></pre><p>An abstract type for the functors representing step sizes. These are callable structures. The naming scheme is <code>TypeOfStepSize</code>, for example <code>ConstantStepsize</code>.</p><p>Every Stepsize has to provide a constructor and its function has to have the interface <code>(p,o,i)</code> where a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> as well as <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> and the current number of iterations are the arguments and returns a number, namely the stepsize to use.</p><p><strong>See also</strong></p><p><a href="#Manopt.Linesearch"><code>Linesearch</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L1-L15">source</a></section></article><p>Usually, a constructor should take the manifold <code>M</code> as its first argument, for consistency, to allow general step size functors to be set up based on default values that might depend on the manifold currently under consideration.</p><p>Currently, the following step sizes are available</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AdaptiveWNGradient" href="#Manopt.AdaptiveWNGradient"><code>Manopt.AdaptiveWNGradient</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdaptiveWNGradient &lt;: DirectionUpdateRule</code></pre><p>Represent an adaptive gradient method introduced by [<a href="../../references/#GrapigliaStella:2023">GS23</a>].</p><p>Given a positive threshold <span>$\hat c \mathbb N$</span>, an minimal bound <span>$b_{\mathrm{min}} &gt; 0$</span>, an initial <span>$b_0 ‚â• b_{\mathrm{min}}$</span>, and a gradient reduction factor threshold <span>$\alpha ‚àà [0,1)$</span>.</p><p>Set <span>$c_0=0$</span> and use <span>$\omega_0 = \lVert \operatorname{grad} f(p_0) \rvert_{p_0}$</span>.</p><p>For the first iterate use the initial step size <span>$s_0 = \frac{1}{b_0}$</span>.</p><p>Then, given the last gradient <span>$X_{k-1} = \operatorname{grad} f(x_{k-1})$</span>, and a previous <span>$\omega_{k-1}$</span>, the values <span>$(b_k, \omega_k, c_k)$</span> are computed using <span>$X_k = \operatorname{grad} f(p_k)$</span> and the following cases</p><p>If <span>$\lVert X_k \rVert_{p_k} \leq \alpha\omega_{k-1}$</span>, then let <span>$\hat b_{k-1} ‚àà [b_\mathrm{min},b_{k-1}]$</span> and set</p><p class="math-container">\[(b_k, \omega_k, c_k) = \begin{cases}
\bigl(\hat b_{k-1}, \lVert X_k\rVert_{p_k}, 0 \bigr) &amp; \text{ if } c_{k-1}+1 = \hat c\\
\Bigl(b_{k-1} + \frac{\lVert X_k\rVert_{p_k}^2}{b_{k-1}}, \omega_{k-1}, c_{k-1}+1 \Bigr) &amp; \text{ if } c_{k-1}+1&lt;\hat c
\end{cases}\]</p><p>If <span>$\lVert X_k \rVert_{p_k} &gt; \alpha\omega_{k-1}$</span>, the set</p><p class="math-container">\[(b_k, \omega_k, c_k) =
\Bigl( b_{k-1} + \frac{\lVert X_k\rVert_{p_k}^2}{b_{k-1}}, \omega_{k-1}, 0)\]</p><p>and return the step size <span>$s_k = \frac{1}{b_k}$</span>.</p><p>Note that for <span>$Œ±=0$</span> this is the Riemannian variant of <code>WNGRad</code>.</p><p><strong>Fields</strong></p><ul><li><code>count_threshold::Int</code>: (<code>4</code>) an <code>Integer</code> for <span>$\hat c$</span></li><li><code>minimal_bound::Float64</code>: (<code>1e-4</code>) for <span>$b_{\mathrm{min}}$</span></li><li><code>alternate_bound::Function</code>: (<code>(bk, hat_c) -&gt; min(gradient_bound, max(gradient_bound, bk/(3*hat_c)</code>) how to determine <span>$\hat b_k$</span> as a function of <code>(bmin, bk, hat_c) -&gt; hat_bk</code></li><li><code>gradient_reduction::Float64</code>: (<code>0.9</code>)</li><li><code>gradient_bound</code> <code>norm(M, p0, grad_f(M,p0))</code> the bound <span>$b_k$</span>.</li></ul><p>as well as the internal fields</p><ul><li><code>weight</code> for <span>$œâ_k$</span> initialised to <span>$œâ_0 =$</span><code>norm(M, p0, grad_f(M,p0))</code> if this is not zero, <code>1.0</code> otherwise.</li><li><code>count</code> for the <span>$c_k$</span>, initialised to <span>$c_0 = 0$</span>.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">AdaptiveWNGrad(M=DefaultManifold, grad_f=(M, p) -&gt; zero_vector(M, rand(M)), p=rand(M); kwargs...)</code></pre><p>Where all fields with defaults are keyword arguments and additional keyword arguments are</p><ul><li><code>adaptive</code>:   (<code>true</code>) switches the <code>gradient_reduction</code><code>Œ±</code><code>to</code>0`.</li><li><code>evaluation</code>: (<code>AllocatingEvaluation()</code>) specifies whether the gradient (that is used for initialisation only) is mutating or allocating</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L1053-L1114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ArmijoLinesearch" href="#Manopt.ArmijoLinesearch"><code>Manopt.ArmijoLinesearch</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArmijoLinesearch &lt;: Linesearch</code></pre><p>A functor representing Armijo line search including the last runs state string the last stepsize.</p><p><strong>Fields</strong></p><ul><li><code>initial_stepsize</code>:          (<code>1.0</code>) and initial step size</li><li><code>retraction_method</code>:         (<code>default_retraction_method(M)</code>) the retraction to use</li><li><code>contraction_factor</code>:        (<code>0.95</code>) exponent for line search reduction</li><li><code>sufficient_decrease</code>:       (<code>0.1</code>) gain within Armijo&#39;s rule</li><li><code>last_stepsize</code>:             (<code>initialstepsize</code>) the last step size to start the search with</li><li><code>initial_guess</code>:             (<code>(p,s,i,l) -&gt; l</code>)  based on a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>p</code>, <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>s</code> and a current iterate <code>i</code> and a last step size <code>l</code>, this returns an initial guess. The default uses the last obtained stepsize</li></ul><p>as well as for internal use</p><ul><li><code>candidate_point</code>:           (<code>allocate_result(M, rand)</code>) to store an interim result</li></ul><p>Furthermore the following fields act as safeguards</p><ul><li><code>stop_when_stepsize_less</code>:    (<code>0.0</code>) smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_when_stepsize_exceeds</code>: (<a href="../../extensions/#Manopt.max_stepsize-Tuple{FiberBundle{ùîΩ, ManifoldsBase.TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any}"><code>max_stepsize</code></a><code>(M, p)</code>) largest stepsize when to stop.</li><li><code>stop_increasing_at_step</code>:    (<code>100</code>) last step to increase the stepsize (phase 1),</li><li><code>stop_decreasing_at_step</code>:    (<code>1000</code>) last step size to decrease the stepsize (phase 2),</li></ul><p>Pass <code>:Messages</code> to a <code>debug=</code> to see <code>@info</code>s when these happen.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ArmijoLinesearch(M=DefaultManifold())</code></pre><p>with the fields keyword arguments and the retraction is set to the default retraction on <code>M</code>.</p><p>The constructors return the functor to perform Armijo line search, where</p><pre><code class="nohighlight hljs">(a::ArmijoLinesearch)(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, i)</code></pre><p>of a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>, <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> and a current iterate <code>i</code> with keywords.</p><p><strong>Keyword arguments</strong></p><ul><li><code>candidate_point</code>: (<code>allocate_result(M, rand)</code>) to pass memory for the candidate point</li><li><code>Œ∑</code>:               (<code>-get_gradient(mp, get_iterate(s));</code>) the search direction to use,</li></ul><p>by default the steepest descent direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L202-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ConstantStepsize" href="#Manopt.ConstantStepsize"><code>Manopt.ConstantStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantStepsize &lt;: Stepsize</code></pre><p>A functor that always returns a fixed step size.</p><p><strong>Fields</strong></p><ul><li><code>length</code>: constant value for the step size</li><li><code>type</code>:   a symbol that indicates whether the stepsize is relatively (:relative),   with respect to the gradient norm, or absolutely (:absolute) constant.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConstantStepsize(s::Real, t::Symbol=:relative)</code></pre><p>initialize the stepsize to a constant <code>s</code> of type <code>t</code>.</p><pre><code class="nohighlight hljs">ConstantStepsize(M::AbstractManifold=DefaultManifold(2);
    stepsize=injectivity_radius(M)/2, type::Symbol=:relative
)</code></pre><p>initialize the stepsize to a constant <code>stepsize</code>, which by default is half the injectivity radius, unless the radius is infinity, then the default step size is <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L42-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.DecreasingStepsize" href="#Manopt.DecreasingStepsize"><code>Manopt.DecreasingStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DecreasingStepsize()</code></pre><p>A functor that represents several decreasing step sizes</p><p><strong>Fields</strong></p><ul><li><code>exponent</code>:   (<code>1</code>) a value <span>$e$</span> the current iteration numbers <span>$e$</span>th exponential is taken of</li><li><code>factor</code>:     (<code>1</code>) a value <span>$f$</span> to multiply the initial step size with every iteration</li><li><code>length</code>:     (<code>1</code>) the initial step size <span>$l$</span>.</li><li><code>subtrahend</code>: (<code>0</code>) a value <span>$a$</span> that is subtracted every iteration</li><li><code>shift</code>:      (<code>0</code>) shift the denominator iterator <span>$i$</span> by <span>$s$</span>`.</li><li><code>type</code>:       a symbol that indicates whether the stepsize is relatively (:relative),   with respect to the gradient norm, or absolutely (:absolute) constant.</li></ul><p>In total the complete formulae reads for the <span>$i$</span>th iterate as</p><p class="math-container">\[s_i = \frac{(l - i a)f^i}{(i+s)^e}\]</p><p>and hence the default simplifies to just <span>$s_i = \frac{l}{i}$</span></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DecreasingStepsize(l=1,f=1,a=0,e=1,s=0,type=:relative)</code></pre><p>Alternatively one can also use the following keyword.</p><pre><code class="nohighlight hljs">DecreasingStepsize(
    M::AbstractManifold=DefaultManifold(3);
    length=injectivity_radius(M)/2, multiplier=1.0, subtrahend=0.0,
    exponent=1.0, shift=0, type=:relative
)</code></pre><p>initializes all fields, where none of them is mandatory and the length is set to half and to <span>$1$</span> if the injectivity radius is infinite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L95-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.Linesearch" href="#Manopt.Linesearch"><code>Manopt.Linesearch</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Linesearch &lt;: Stepsize</code></pre><p>An abstract functor to represent line search type step size determinations, see <a href="#Stepsize"><code>Stepsize</code></a> for details. One example is the <a href="#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a> functor.</p><p>Compared to simple step sizes, the line search functors provide an interface of the form <code>(p,o,i,Œ∑) -&gt; s</code> with an additional (but optional) fourth parameter to provide a search direction; this should default to something reasonable, most prominently the negative gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L177-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.NonmonotoneLinesearch" href="#Manopt.NonmonotoneLinesearch"><code>Manopt.NonmonotoneLinesearch</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonmonotoneLinesearch &lt;: Linesearch</code></pre><p>A functor representing a nonmonotone line search using the Barzilai-Borwein step size [<a href="../../references/#IannazzoPorcelli:2017">IP17</a>]. Together with a gradient descent algorithm this line search represents the Riemannian Barzilai-Borwein with nonmonotone line-search (RBBNMLS) algorithm. The order is shifted in comparison of the algorithm steps from the paper by Iannazzo and Porcelli so that in each iteration this line search first finds</p><p class="math-container">\[y_{k} = \operatorname{grad}F(x_{k}) - \operatorname{T}_{x_{k-1} ‚Üí x_k}(\operatorname{grad}F(x_{k-1}))\]</p><p>and</p><p class="math-container">\[s_{k} = - Œ±_{k-1} * \operatorname{T}_{x_{k-1} ‚Üí x_k}(\operatorname{grad}F(x_{k-1})),\]</p><p>where <span>$Œ±_{k-1}$</span> is the step size computed in the last iteration and <span>$\operatorname{T}$</span> is a vector transport. Then the Barzilai‚ÄîBorwein step size is</p><p class="math-container">\[Œ±_k^{\text{BB}} = \begin{cases}
\min(Œ±_{\text{max}}, \max(Œ±_{\text{min}}, œÑ_{k})),  &amp; \text{if } ‚ü®s_{k}, y_{k}‚ü©_{x_k} &gt; 0,\\
Œ±_{\text{max}}, &amp; \text{else,}
\end{cases}\]</p><p>where</p><p class="math-container">\[œÑ_{k} = \frac{‚ü®s_{k}, s_{k}‚ü©_{x_k}}{‚ü®s_{k}, y_{k}‚ü©_{x_k}},\]</p><p>if the direct strategy is chosen,</p><p class="math-container">\[œÑ_{k} = \frac{‚ü®s_{k}, y_{k}‚ü©_{x_k}}{‚ü®y_{k}, y_{k}‚ü©_{x_k}},\]</p><p>in case of the inverse strategy and an alternation between the two in case of the alternating strategy. Then find the smallest <span>$h = 0, 1, 2, ‚Ä¶$</span> such that</p><p class="math-container">\[F(\operatorname{retr}_{x_k}(- œÉ^h Œ±_k^{\text{BB}} \operatorname{grad}F(x_k)))
\leq
\max_{1 ‚â§ j ‚â§ \min(k+1,m)} F(x_{k+1-j}) - Œ≥ œÉ^h Œ±_k^{\text{BB}} ‚ü®\operatorname{grad}F(x_k), \operatorname{grad}F(x_k)‚ü©_{x_k},\]</p><p>where <span>$œÉ$</span> is a step length reduction factor <span>$‚àà (0,1)$</span>, <span>$m$</span> is the number of iterations after which the function value has to be lower than the current one and <span>$Œ≥$</span> is the sufficient decrease parameter <span>$‚àà(0,1)$</span>. Then find the new stepsize by</p><p class="math-container">\[Œ±_k = œÉ^h Œ±_k^{\text{BB}}.\]</p><p><strong>Fields</strong></p><ul><li><code>initial_stepsize</code>:        (<code>1.0</code>) the step size to start the search with</li><li><code>memory_size</code>:             (<code>10</code>) number of iterations after which the cost value needs to be lower than the current one</li><li><code>bb_min_stepsize</code>:         (<code>1e-3</code>) lower bound for the Barzilai-Borwein step size greater than zero</li><li><code>bb_max_stepsize</code>:         (<code>1e3</code>) upper bound for the Barzilai-Borwein step size greater than min_stepsize</li><li><code>retraction_method</code>:       (<code>ExponentialRetraction()</code>) the retraction to use</li><li><code>strategy</code>:                (<code>direct</code>) defines if the new step size is computed using the direct, indirect or alternating strategy</li><li><code>storage</code>:                 (for <code>:Iterate</code> and <code>:Gradient</code>) a <a href="../state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a></li><li><code>stepsize_reduction</code>:      (<code>0.5</code>) step size reduction factor contained in the interval (0,1)</li><li><code>sufficient_decrease</code>:     (<code>1e-4</code>) sufficient decrease parameter contained in the interval (0,1)</li><li><code>vector_transport_method</code>: (<code>ParallelTransport()</code>) the vector transport method to use</li></ul><p>as well as for internal use</p><ul><li><code>candidate_point</code>:           (<code>allocate_result(M, rand)</code>) to store an interim result</li></ul><p>Furthermore the following fields act as safeguards</p><ul><li><code>stop_when_stepsize_less:     (</code>0.0`) smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_when_stepsize_exceeds</code>: (<a href="../../extensions/#Manopt.max_stepsize-Tuple{FiberBundle{ùîΩ, ManifoldsBase.TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any}"><code>max_stepsize</code></a><code>(M, p)</code>) largest stepsize when to stop.</li><li><code>stop_increasing_at_step</code>:    (^100`) last step to increase the stepsize (phase 1),</li><li><code>stop_decreasing_at_step</code>:    (<code>1000</code>) last step size to decrease the stepsize (phase 2),</li></ul><p>Pass <code>:Messages</code> to a <code>debug=</code> to see <code>@info</code>s when these happen.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">NonmonotoneLinesearch()</code></pre><p>with the fields their order as optional arguments (deprecated). THis is deprecated, since both defaults and the memory allocation for the candidate do not take into account which manifold the line search operates on.</p><pre><code class="nohighlight hljs">NonmonotoneLinesearch(M)</code></pre><p>with the fields as keyword arguments and where the retraction and vector transport are set to the default ones on <code>M</code>, respectively.</p><p>The constructors return the functor to perform nonmonotone line search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L447-L544">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.WolfePowellBinaryLinesearch" href="#Manopt.WolfePowellBinaryLinesearch"><code>Manopt.WolfePowellBinaryLinesearch</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WolfePowellBinaryLinesearch &lt;: Linesearch</code></pre><p>A <a href="#Manopt.Linesearch"><code>Linesearch</code></a> method that determines a step size <code>t</code> fulfilling the Wolfe conditions</p><p>based on a binary chop. Let <span>$Œ∑$</span> be a search direction and <span>$c1,c_2&gt;0$</span> be two constants. Then with</p><p class="math-container">\[A(t) = f(x_+) ‚â§ c1 t ‚ü®\operatorname{grad}f(x), Œ∑‚ü©_{x}
\quad\text{and}\quad
W(t) = ‚ü®\operatorname{grad}f(x_+), \text{V}_{x_+\gets x}Œ∑‚ü©_{x_+} ‚â• c_2 ‚ü®Œ∑, \operatorname{grad}f(x)‚ü©_x,\]</p><p>where <span>$x_+ = \operatorname{retr}_x(tŒ∑)$</span> is the current trial point, and <span>$\text{V}$</span> is a vector transport. Then the following Algorithm is performed similar to Algorithm 7 from [<a href="../../references/#Huang:2014">Hua14</a>]</p><ol><li>set <span>$Œ±=0$</span>, <span>$Œ≤=‚àû$</span> and <span>$t=1$</span>.</li><li>While either <span>$A(t)$</span> does not hold or <span>$W(t)$</span> does not hold do steps 3-5.</li><li>If <span>$A(t)$</span> fails, set <span>$Œ≤=t$</span>.</li><li>If <span>$A(t)$</span> holds but <span>$W(t)$</span> fails, set <span>$Œ±=t$</span>.</li><li>If <span>$Œ≤&lt;‚àû$</span> set <span>$t=\frac{Œ±+Œ≤}{2}$</span>, otherwise set <span>$t=2Œ±$</span>.</li></ol><p><strong>Constructors</strong></p><p>There exist two constructors, where, when provided the manifold <code>M</code> as a first (optional) parameter, its default retraction and vector transport are the default. In this case the retraction and the vector transport are also keyword arguments for ease of use. The other constructor is kept for backward compatibility.</p><pre><code class="nohighlight hljs">WolfePowellLinesearch(
    M=DefaultManifold(),
    c1::Float64=10^(-4),
    c2::Float64=0.999;
    retraction_method = default_retraction_method(M),
    vector_transport_method = default_vector_transport(M),
    linesearch_stopsize = 0.0
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L931-L970">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.WolfePowellLinesearch" href="#Manopt.WolfePowellLinesearch"><code>Manopt.WolfePowellLinesearch</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WolfePowellLinesearch &lt;: Linesearch</code></pre><p>Do a backtracking line search to find a step size <span>$Œ±$</span> that fulfils the Wolfe conditions along a search direction <span>$Œ∑$</span> starting from <span>$x$</span> by</p><p class="math-container">\[f\bigl( \operatorname{retr}_x(Œ±Œ∑) \bigr) ‚â§ f(x_k) + c_1 Œ±_k ‚ü®\operatorname{grad}f(x), Œ∑‚ü©_x
\quad\text{and}\quad
\frac{\mathrm{d}}{\mathrm{d}t} f\bigr(\operatorname{retr}_x(tŒ∑)\bigr)
\Big\vert_{t=Œ±}
‚â• c_2 \frac{\mathrm{d}}{\mathrm{d}t} f\bigl(\operatorname{retr}_x(tŒ∑)\bigr)\Big\vert_{t=0}.\]</p><p><strong>Constructors</strong></p><p>There exist two constructors, where, when provided the manifold <code>M</code> as a first (optional) parameter, its default retraction and vector transport are the default. In this case the retraction and the vector transport are also keyword arguments for ease of use. The other constructor is kept for backward compatibility. Note that the <code>stop_when_stepsize_less</code> to stop for too small stepsizes is only available in the new signature including <code>M</code>.</p><pre><code class="nohighlight hljs">WolfePowellLinesearch(M, c1::Float64=10^(-4), c2::Float64=0.999; kwargs...</code></pre><p>Generate a Wolfe-Powell line search</p><p><strong>Keyword arguments</strong></p><ul><li><code>candidate_point</code>:         (<code>allocate_result(M, rand)</code>) memory for a candidate</li><li><code>candidate_tangent</code>:       (<code>allocate_result(M, zero_vector, candidate_point)</code>) memory for a gradient</li><li><code>candidate_direcntion</code>:    (<code>allocate_result(M, zero_vector, candidate_point)</code>) memory for a direction</li><li><code>max_stepsize</code>:            (<a href="../../extensions/#Manopt.max_stepsize-Tuple{FiberBundle{ùîΩ, ManifoldsBase.TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any}"><code>max_stepsize</code></a><code>(M, p)</code>) largest stepsize allowed here.</li><li><code>retraction_method</code>:       (<code>ExponentialRetraction()</code>) the retraction to use</li><li><code>stop_when_stepsize_less</code>: (<code>0.0</code>) smallest stepsize when to stop (the last one before is taken)</li><li><code>vector_transport_method</code>: (<code>ParallelTransport()</code>) the vector transport method to use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L759-L795">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}" href="#Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}"><code>Manopt.default_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_stepsize(M::AbstractManifold, ams::AbstractManoptSolverState)</code></pre><p>Returns the default <a href="#Stepsize"><code>Stepsize</code></a> functor used when running the solver specified by the <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> running with an objective on the <code>AbstractManifold M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}" href="#Manopt.get_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}"><code>Manopt.get_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_stepsize(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, vars...)</code></pre><p>return the stepsize stored within <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> when solving the <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>. This method also works for decorated options and the <a href="#Stepsize"><code>Stepsize</code></a> function within the options, by default stored in <code>o.stepsize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L1211-L1218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.linesearch_backtrack!-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any, T}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any, T, Any}} where {TF, T}" href="#Manopt.linesearch_backtrack!-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any, T}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any, T, Any}} where {TF, T}"><code>Manopt.linesearch_backtrack!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(s, msg) = linesearch_backtrack!(M, q, F, p, X, s, decrease, contract Œ∑ = -X, f0 = f(p))</code></pre><p>Perform a line search backtrack in-place of <code>q</code>. For all details and options, see <a href="#Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T, Any}} where T"><code>linesearch_backtrack</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L378-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T, Any}} where T" href="#Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T, Any}} where T"><code>Manopt.linesearch_backtrack</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(s, msg) = linesearch_backtrack(M, F, p, X, s, decrease, contract Œ∑ = -X, f0 = f(p))
(s, msg) = linesearch_backtrack!(M, q, F, p, X, s, decrease, contract Œ∑ = -X, f0 = f(p))</code></pre><p>perform a line search</p><ul><li>on manifold <code>M</code></li><li>for the cost function <code>f</code>,</li><li>at the current point <code>p</code></li><li>with current gradient provided in <code>X</code></li><li>an initial stepsize <code>s</code></li><li>a sufficient <code>decrease</code></li><li>a <code>contract</code>ion factor <span>$œÉ$</span></li><li>a <code>retr</code>action, which defaults to the <code>default_retraction_method(M)</code></li><li>a search direction <span>$Œ∑ = -X$</span></li><li>an offset, <span>$f_0 = F(x)$</span></li></ul><p>the method can also be performed in-place of <code>q</code>, that is the resulting best point one reaches with the step size <code>s</code> as second argument.</p><p><strong>Keywords</strong></p><ul><li><code>retraction_method</code>:          (<code>default_retraction_method(M)</code>) the retraction to use.</li><li><code>stop_when_stepsize_less</code>:    (<code>0.0</code>) to avoid numerical underflow</li><li><code>stop_when_stepsize_exceeds</code>: (<a href="../../extensions/#Manopt.max_stepsize-Tuple{FiberBundle{ùîΩ, ManifoldsBase.TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any}"><code>max_stepsize</code></a><code>(M, p) / norm(M, p, Œ∑)</code>) to avoid leaving the injectivity radius on a manifold</li><li><code>stop_increasing_at_step</code>:    (<code>100</code>) stop the initial increase of step size after these many steps</li><li><code>stop_decreasing_at_step</code>:    (<code>1000</code>) stop the decreasing search after these many steps</li></ul><p>These keywords are used as safeguards, where only the max stepsize is a very manifold specific one.</p><p><strong>Return value</strong></p><p>A stepsize <code>s</code> and a message <code>msg</code> (in case any of the 4 criteria hit)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L337-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.max_stepsize-Tuple{AbstractManifold, Any}" href="#Manopt.max_stepsize-Tuple{AbstractManifold, Any}"><code>Manopt.max_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_stepsize(M::AbstractManifold, p)
max_stepsize(M::AbstractManifold)</code></pre><p>Get the maximum stepsize (at point <code>p</code>) on manifold <code>M</code>. It should be used to limit the distance an algorithm is trying to move in a single step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/342004e69427cfc859fe0ae0d32c4689db0ddee2/src/plans/stepsize.jl#L28-L34">source</a></section></article><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[GS23]</dt><dd><div>G.¬†N.¬†Grapiglia and G.¬†F.¬†Stella. <a href="https://optimization-online.org/wp-content/uploads/2022/04/8864.pdf"><em>An Adaptive Riemannian Gradient Method Without Function Evaluations</em></a>. <a href="https://doi.org/10.1007/s10957-023-02227-y">Journal¬†of¬†Optimization¬†Theory¬†and¬†Applications <strong>197</strong>, 1140‚Äì1160</a> (2023).</div></dd><dt>[Hua14]</dt><dd><div>W.¬†Huang. <a href="https://www.math.fsu.edu/~whuang2/pdf/Huang_W_Dissertation_2013.pdf"><em>Optimization algorithms on Riemannian manifolds with applications</em></a>. Ph.D. Thesis, Flordia State University (2014).</div></dd><dt>[IP17]</dt><dd><div>B.¬†Iannazzo and M.¬†Porcelli. <em>The Riemannian Barzilai‚ÄìBorwein method with nonmonotone line search and the matrix geometric mean computation</em>. <a href="https://doi.org/10.1093/imanum/drx015">IMA¬†Journal¬†of¬†Numerical¬†Analysis <strong>38</strong>, 495‚Äì517</a> (2017).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../state/">¬´ Solver State</a><a class="docs-footer-nextpage" href="../stopping_criteria/">Stopping Criteria ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 19 March 2024 07:48">Tuesday 19 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
