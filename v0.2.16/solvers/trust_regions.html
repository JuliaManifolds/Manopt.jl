<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Trust-Regions Solver · Manopt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Manopt.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../about.html">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../tutorials/MeanAndMedian.html">get Started: Optimize!</a></li><li><a class="tocitem" href="../tutorials/StochasticGradientDescent.html">do stochastic gradient descent</a></li><li><a class="tocitem" href="../tutorials/BezierCurves.html">work with Bézier curves</a></li><li><a class="tocitem" href="../tutorials/GradientOfSecondOrderDifference.html">see the gradient of <span>$d_2$</span></a></li><li><a class="tocitem" href="../tutorials/JacobiFields.html">use Jacobi Fields</a></li></ul></li><li><a class="tocitem" href="../plans/index.html">Plans</a></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="ChambollePock.html">Chambolle-Pock</a></li><li><a class="tocitem" href="conjugate_gradient_descent.html">Conjugate gradient descent</a></li><li><a class="tocitem" href="cyclic_proximal_point.html">Cyclic Proximal Point</a></li><li><a class="tocitem" href="DouglasRachford.html">Douglas–Rachford</a></li><li><a class="tocitem" href="gradient_descent.html">Gradient Descent</a></li><li><a class="tocitem" href="NelderMead.html">Nelder–Mead</a></li><li><a class="tocitem" href="particle_swarm.html">Particle Swarm Optimization</a></li><li><a class="tocitem" href="quasi_Newton.html">Quasi-Newton</a></li><li><a class="tocitem" href="stochastic_gradient_descent.html">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="subgradient.html">Subgradient method</a></li><li><a class="tocitem" href="truncated_conjugate_gradient_descent.html">Steihaug-Toint TCG Method</a></li><li class="is-active"><a class="tocitem" href="trust_regions.html">Trust-Regions Solver</a><ul class="internal"><li><a class="tocitem" href="#Initialization-1"><span>Initialization</span></a></li><li><a class="tocitem" href="#Iteration-1"><span>Iteration</span></a></li><li><a class="tocitem" href="#Result-1"><span>Result</span></a></li><li><a class="tocitem" href="#Remarks-1"><span>Remarks</span></a></li><li><a class="tocitem" href="#Interface-1"><span>Interface</span></a></li><li><a class="tocitem" href="#Options-1"><span>Options</span></a></li><li><a class="tocitem" href="#Approximation-of-the-Hessian-1"><span>Approximation of the Hessian</span></a></li></ul></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../functions/index.html">Introduction</a></li><li><a class="tocitem" href="../functions/bezier.html">Bézier curves</a></li><li><a class="tocitem" href="../functions/costs.html">Cost functions</a></li><li><a class="tocitem" href="../functions/differentials.html">Differentials</a></li><li><a class="tocitem" href="../functions/adjointdifferentials.html">Adjoint Differentials</a></li><li><a class="tocitem" href="../functions/gradients.html">Gradients</a></li><li><a class="tocitem" href="../functions/Jacobi_fields.html">Jacobi Fields</a></li><li><a class="tocitem" href="../functions/proximal_maps.html">Proximal Maps</a></li><li><a class="tocitem" href="../functions/manifold.html">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../helpers/data.html">Data</a></li><li><a class="tocitem" href="../helpers/errorMeasures.html">Error Measures</a></li><li><a class="tocitem" href="../helpers/exports.html">Exports</a></li></ul></li><li><a class="tocitem" href="../list.html">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href="trust_regions.html">Trust-Regions Solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="trust_regions.html">Trust-Regions Solver</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/solvers/trust_regions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="trust_regions-1"><a class="docs-heading-anchor" href="#trust_regions-1">The Riemannian Trust-Regions Solver</a><a class="docs-heading-anchor-permalink" href="#trust_regions-1" title="Permalink"></a></h1><p>The aim is to solve an optimization problem on a manifold</p><div>\[\operatorname*{min}_{x  ∈  \mathcal{M}} F(x)\]</div><p>by using the Riemannian trust-regions solver. It is number one choice for smooth optimization. This trust-region method uses the Steihaug-Toint truncated conjugate-gradient method <a href="truncated_conjugate_gradient_descent.html#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a> to solve the inner minimization problem called the trust-regions subproblem. This inner solve can be preconditioned by providing a preconditioner (symmetric and positive deﬁnite, an approximation of the inverse of the Hessian of <span>$F$</span>). If no Hessian of the cost function <span>$F$</span> is provided, a standard approximation of the Hessian based on the gradient <span>$\nabla F$</span> with <a href="trust_regions.html#Manopt.approxHessianFD"><code>approxHessianFD</code></a> will be computed.</p><h2 id="Initialization-1"><a class="docs-heading-anchor" href="#Initialization-1">Initialization</a><a class="docs-heading-anchor-permalink" href="#Initialization-1" title="Permalink"></a></h2><p>Initialize <span>$x_0 = x$</span> with an initial point <span>$x$</span> on the manifold. It can be given by the caller or set randomly. Set the initial trust-region radius <span>$\Delta =\frac{1}{8} \bar{\Delta}$</span> where <span>$\bar{\Delta}$</span> is the maximum radius the trust-region can have. Usually one uses the root of the manifold dimension <span>$\operatorname{dim}(\mathcal{M})$</span>. For accepting the next iterate and evaluating the new trust-region radius one needs an accept/reject threshold <span>$\rho&#39;  ∈  [0,\frac{1}{4})$</span>, which is <span>$\rho&#39; = 0.1$</span> on default. Set <span>$k=0$</span>.</p><h2 id="Iteration-1"><a class="docs-heading-anchor" href="#Iteration-1">Iteration</a><a class="docs-heading-anchor-permalink" href="#Iteration-1" title="Permalink"></a></h2><p>Repeat until a convergence criterion is reached</p><ol><li>Set <span>$\eta$</span> as a random tangent vector if using randomized approach. Else  set <span>$\eta$</span> as the zero vector in the tangential space <span>$T_{x_k}\mathcal{M}$</span>.</li><li>Set <span>$\eta^{* }$</span> as the solution of the trust-region subproblem, computed by  the tcg-method with <span>$\eta$</span> as initial vector.</li><li>If using randomized approach compare <span>$\eta^{* }$</span> with the Cauchy point  <span>$\eta_{c}^{* } = -\tau_{c} \frac{\Delta}{\operatorname{norm}(\operatorname{Grad}[f] (x_k))} \operatorname{Grad}[F] (x_k)$</span> by the model function <span>$m_{x_k}(\cdot)$</span>. If the  model decrease is larger by using the Cauchy point, set  <span>$\eta^{* } = \eta_{c}^{* }$</span>.</li><li>Set <span>${x}^{* } = \operatorname{Retr}_{x_k}(\eta^{* })$</span>.</li><li>Set <span>$\rho = \frac{F(x_k)-F({x}^{* })}{m_{x_k}(\eta)-m_{x_k}(\eta^{* })}$</span>, where  <span>$m_{x_k}(\cdot)$</span> describes the quadratic model function.</li><li>Update the trust-region radius:  <span>$\Delta = \begin{cases} \frac{1}{4} \Delta &amp; \rho &lt; \frac{1}{4} \,  \text{or} \, m_{x_k}(\eta)-m_{x_k}(\eta^{* }) \leq 0 \, \text{or}  \,  \rho = \pm  ∈ fty , \\ \operatorname{min}(2 \Delta, \bar{\Delta}) &amp;  \rho &gt; \frac{3}{4} \, \text{and the tcg-method stopped because of negative  curvature or exceeding the trust-region}, \\ \Delta &amp; \, \text{otherwise.}  \end{cases}$</span></li><li>If <span>$m_{x_k}(\eta)-m_{x_k}(\eta^{* }) \geq 0$</span> and <span>$\rho &gt; \rho&#39;$</span> set  <span>$x_k = {x}^{* }$</span>.</li><li>Set <span>$k = k+1$</span>.</li></ol><h2 id="Result-1"><a class="docs-heading-anchor" href="#Result-1">Result</a><a class="docs-heading-anchor-permalink" href="#Result-1" title="Permalink"></a></h2><p>The result is given by the last computed <span>$x_k$</span>.</p><h2 id="Remarks-1"><a class="docs-heading-anchor" href="#Remarks-1">Remarks</a><a class="docs-heading-anchor-permalink" href="#Remarks-1" title="Permalink"></a></h2><p>To the Initialization: A random point on the manifold.</p><p>To step number 1: Using randomized approach means using a random tangent vector as initial vector for the approximal solve of the trust-regions subproblem. If this is the case, keep in mind that the vector must be in the trust-region radius. This is achieved by multiplying <code>η</code> by <code>sqrt(4,eps(Float64))</code> as long as its norm is greater than the current trust-region radius <span>$\Delta$</span>. For not using randomized approach, one can get the zero tangent vector.</p><p>To step number 2: Obtain <span>$\eta^{* }$</span> by (approximately) solving the trust-regions subproblem</p><div>\[\operatorname*{arg\,min}_{\eta  ∈  T_{x_k}\mathcal{M}} m_{x_k}(\eta) = F(x_k) +
\langle \nabla F(x_k), \eta \rangle_{x_k} + \frac{1}{2} \langle
\operatorname{Hess}[F](\eta)_ {x_k}, \eta \rangle_{x_k}\]</div><div>\[\text{s.t.} \; \langle \eta, \eta \rangle_{x_k} \leq {\Delta}^2\]</div><p>with the Steihaug-Toint truncated conjugate-gradient (tcg) method. The problem as well as the solution method is described in the <a href="truncated_conjugate_gradient_descent.html#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a>.</p><p>To step number 3: If using a random tangent vector as an initial vector, compare the result of the tcg-method with the Cauchy point. Convergence proofs assume that one achieves at least (a fraction of) the reduction of the Cauchy point. The idea is to go in the direction of the gradient to an optimal point. This can be on the edge, but also before. The parameter <span>$\tau_{c}$</span> for the optimal length is defined by</p><div>\[\tau_{c} = \begin{cases} 1 &amp; \langle \operatorname{Grad}[F] (x_k), \,
\operatorname{Hess}[F] (\eta_k)_ {x_k}\rangle_{x_k} \leq 0 , \\
\operatorname{min}(\frac{{\operatorname{norm}(\operatorname{Grad}[F] (x_k))}^3}
{\Delta \langle \operatorname{Grad}[F] (x_k), \,
\operatorname{Hess}[F] (\eta_k)_ {x_k}\rangle_{x_k}}, 1) &amp; \, \text{otherwise.}
\end{cases}\]</div><p>To check the model decrease one compares <span>$m_{x_k}(\eta_{c}^{* }) = F(x_k) + \langle \eta_{c}^{* }, \operatorname{Grad}[F] (x_k)\rangle_{x_k} + \frac{1}{2}\langle \eta_{c}^{* }, \operatorname{Hess}[F] (\eta_{c}^{* })_ {x_k}\rangle_{x_k}$</span> with <span>$m_{x_k}(\eta^{* }) = F(x_k) + \langle \eta^{* }, \operatorname{Grad}[F] (x_k)\rangle_{x_k} + \frac{1}{2}\langle \eta^{* }, \operatorname{Hess}[F] (\eta^{* })_ {x_k}\rangle_{x_k}$</span>. If <span>$m_{x_k}(\eta_{c}^{* }) &lt; m_{x_k}(\eta^{* })$</span> then is <span>$m_{x_k}(\eta_{c}^{* })$</span> the better choice.</p><p>To step number 4: <span>$\operatorname{Retr}_{x_k}(\cdot)$</span> denotes the retraction, a mapping <span>$\operatorname{Retr}_{x_k}:T_{x_k}\mathcal{M} \rightarrow \mathcal{M}$</span> wich approximates the exponential map. In some cases it is cheaper to use this instead of the exponential.</p><p>To step number 6: One knows that the <a href="truncated_conjugate_gradient_descent.html#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a> algorithm stopped for these reasons when the stopping criteria <a href="truncated_conjugate_gradient_descent.html#Manopt.StopWhenCurvatureIsNegative"><code>StopWhenCurvatureIsNegative</code></a>, <a href="truncated_conjugate_gradient_descent.html#Manopt.StopWhenTrustRegionIsExceeded"><code>StopWhenTrustRegionIsExceeded</code></a> are activated.</p><p>To step number 7: The last step is to decide if the new point <span>${x}^{* }$</span> is accepted.</p><h2 id="Interface-1"><a class="docs-heading-anchor" href="#Interface-1">Interface</a><a class="docs-heading-anchor-permalink" href="#Interface-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.trust_regions" href="#Manopt.trust_regions"><code>Manopt.trust_regions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trust_regions(M, F, ∇F, x, H)</code></pre><p>evaluate the Riemannian trust-regions solver for optimization on manifolds. It will attempt to minimize the cost function F on the Manifold M. If no Hessian H is provided, a standard approximation of the Hessian based on the gradient ∇F will be computed. For solving the the inner trust-region subproblem of finding an update-vector, it uses the Steihaug-Toint truncated conjugate-gradient method. For a description of the algorithm and more details see</p><ul><li>P.-A. Absil, C.G. Baker, K.A. Gallivan,   Trust-region methods on Riemannian manifolds, FoCM, 2007.   doi: <a href="https://doi.org/10.1007/s10208-005-0179-9">10.1007/s10208-005-0179-9</a></li><li>A. R. Conn, N. I. M. Gould, P. L. Toint, Trust-region methods, SIAM,   MPS, 2000. doi: <a href="https://doi.org/10.1137/1.9780898719857">10.1137/1.9780898719857</a></li></ul><p><strong>Input</strong></p><ul><li><code>M</code> – a manifold <span>$\mathcal M$</span></li><li><code>F</code> – a cost function <span>$F \colon \mathcal M \to \mathbb R$</span> to minimize</li><li><code>∇F</code>- the gradient <span>$\nabla F \colon \mathcal M \to T \mathcal M$</span> of <span>$F$</span></li><li><code>x</code> – an initial value <span>$x  ∈  \mathcal M$</span></li><li><code>H</code> – the hessian <span>$H( \mathcal M, x, \xi)$</span> of <span>$F$</span></li></ul><p><strong>Optional</strong></p><ul><li><code>retraction</code> – approximation of the exponential map</li><li><code>preconditioner</code> – a preconditioner (a symmetric, positive definite operator that should approximate the inverse of the Hessian)</li><li><code>stopping_criterion</code> – (<a href="index.html#Manopt.StopWhenAny"><code>StopWhenAny</code></a>(<a href="index.html#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(1000)</code>, <a href="index.html#Manopt.StopWhenGradientNormLess"><code>StopWhenGradientNormLess</code></a><code>(10^(-6))</code>) a functor inheriting from <a href="index.html#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> indicating when to stop.</li><li><code>Δ_bar</code> – the maximum trust-region radius</li><li><code>Δ</code> - the (initial) trust-region radius</li><li><code>useRandom</code> – set to true if the trust-region solve is to be initiated with a random tangent vector. If set to true, no preconditioner will be used. This option is set to true in some scenarios to escape saddle points, but is otherwise seldom activated.</li><li><code>ρ_prime</code> – Accept/reject threshold: if ρ (the performance ratio for the iterate) is at least ρ&#39;, the outer iteration is accepted. Otherwise, it is rejected. In case it is rejected, the trust-region radius will have been decreased. To ensure this, ρ&#39; &gt;= 0 must be strictly smaller than 1/4. If ρ_prime is negative, the algorithm is not guaranteed to produce monotonically decreasing cost values. It is strongly recommended to set ρ&#39; &gt; 0, to aid convergence.</li><li><code>ρ_regularization</code> – Close to convergence, evaluating the performance ratio ρ is numerically challenging. Meanwhile, close to convergence, the quadratic model should be a good fit and the steps should be accepted. Regularization lets ρ go to 1 as the model decrease and the actual decrease go to zero. Set this option to zero to disable regularization (not recommended). When this is not zero, it may happen that the iterates produced are not monotonically improving the cost when very close to convergence. This is because the corrected cost improvement could change sign if it is negative but very small.</li><li><code>return_options</code> – (<code>false</code>) – if actiavated, the extended result, i.e. the complete <a href="../plans/index.html#Manopt.Options"><code>Options</code></a> are returned. This can be used to access recorded values. If set to false (default) just the optimal value <code>x_opt</code> is returned</li></ul><p><strong>Output</strong></p><ul><li><code>x</code> – the last reached point on the manifold</li></ul><p><strong>see also</strong></p><p><a href="truncated_conjugate_gradient_descent.html#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/72f07b25f6259eef60f10487365fd562fa9a33b0/src/solvers/trust_regions.jl#L1-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.trust_regions!" href="#Manopt.trust_regions!"><code>Manopt.trust_regions!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trust_regions!(M, F, ∇F, x, H; kwargs...)</code></pre><p>evaluate the Riemannian trust-regions solver for optimization on manifolds in place of <code>x</code>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – a manifold <span>$\mathcal M$</span></li><li><code>F</code> – a cost function <span>$F \colon \mathcal M \to \mathbb R$</span> to minimize</li><li><code>∇F</code>- the gradient <span>$\nabla F \colon \mathcal M \to T \mathcal M$</span> of <span>$F$</span></li><li><code>x</code> – an initial value <span>$x  ∈  \mathcal M$</span></li><li><code>H</code> – the hessian <span>$H( \mathcal M, x, \xi)$</span> of <span>$F$</span></li></ul><p>for more details and all options, see <a href="trust_regions.html#Manopt.trust_regions"><code>trust_regions</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/72f07b25f6259eef60f10487365fd562fa9a33b0/src/solvers/trust_regions.jl#L69-L82">source</a></section></article><h2 id="Options-1"><a class="docs-heading-anchor" href="#Options-1">Options</a><a class="docs-heading-anchor-permalink" href="#Options-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.TrustRegionsOptions" href="#Manopt.TrustRegionsOptions"><code>Manopt.TrustRegionsOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TrustRegionsOptions &lt;: HessianOptions</code></pre><p>describe the trust-regions solver, with</p><p><strong>Fields</strong></p><p>a default value is given in brackets if a parameter can be left out in initialization.</p><ul><li><code>x</code> : a point as starting point</li><li><code>stop</code> : a function s,r = @(o,iter) returning a stop   indicator and a reason based on an iteration number and the gradient</li><li><code>Δ</code> : the (initial) trust-region radius</li><li><code>Δ_bar</code> : the maximum trust-region radius</li><li><code>useRand</code> : indicates if the trust-region solve is to be initiated with a       random tangent vector. If set to true, no preconditioner will be       used. This option is set to true in some scenarios to escape saddle       points, but is otherwise seldom activated.</li><li><code>ρ_prime</code> : a lower bound of the performance ratio for the iterate that       decides if the iteration will be accepted or not. If not, the       trust-region radius will have been decreased. To ensure this,       ρ&#39;&gt;= 0 must be strictly smaller than 1/4. If ρ&#39; is negative,       the algorithm is not guaranteed to produce monotonically decreasing       cost values. It is strongly recommended to set ρ&#39; &gt; 0, to aid       convergence.</li><li><code>ρ_regularization</code> : Close to convergence, evaluating the performance ratio ρ       is numerically challenging. Meanwhile, close to convergence, the       quadratic model should be a good fit and the steps should be       accepted. Regularization lets ρ go to 1 as the model decrease and       the actual decrease go to zero. Set this option to zero to disable       regularization (not recommended). When this is not zero, it may happen       that the iterates produced are not monotonically improving the cost       when very close to convergence. This is because the corrected cost       improvement could change sign if it is negative but very small.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">TrustRegionsOptions(x, stop, delta, delta_bar, uR, rho_prime, rho_reg)</code></pre><p>construct a trust-regions Option with the fields as above.</p><p><strong>See also</strong></p><p><a href="trust_regions.html#Manopt.trust_regions"><code>trust_regions</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/72f07b25f6259eef60f10487365fd562fa9a33b0/src/plans/hessian_plan.jl#L84-L126">source</a></section></article><h2 id="Approximation-of-the-Hessian-1"><a class="docs-heading-anchor" href="#Approximation-of-the-Hessian-1">Approximation of the Hessian</a><a class="docs-heading-anchor-permalink" href="#Approximation-of-the-Hessian-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.approxHessianFD" href="#Manopt.approxHessianFD"><code>Manopt.approxHessianFD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">approxHessianFD(p,x,ξ,[stepsize=2.0^(-14)])</code></pre><p>return an approximated solution of the Hessian of the cost function applied to a tangent vector <code>ξ</code> by using a generic finite difference approximation based on computations of the gradient.</p><p>Input</p><ul><li><code>p</code> – a Manopt problem structure (already containing the manifold and enough       information to compute the cost gradient)</li><li><code>x</code> – a point where the Hessian is ​​to be approximated</li><li><code>ξ</code> – a tangent vector on which the approximated Hessian is ​​to be applied</li></ul><p><strong>Optional</strong></p><ul><li><code>stepsize</code> – the length of the step with which the method should work</li></ul><p><strong>Output</strong></p><ul><li>a tangent vector generated by applying the approximated Hessian to the   tangent vector ξ</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/72f07b25f6259eef60f10487365fd562fa9a33b0/src/plans/hessian_plan.jl#L171-L190">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="truncated_conjugate_gradient_descent.html">« Steihaug-Toint TCG Method</a><a class="docs-footer-nextpage" href="../functions/index.html">Introduction »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 7 February 2021 19:32">Sunday 7 February 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
