<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solver State · Manopt.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/Optimize!/">Get started: Optimize!</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using Inplace computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use Automatic Differentiation</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a Cache</a></li><li><a class="tocitem" href="../../tutorials/HowToDebug/">Perform Debug Output</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a Solver</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do Contrained Optimization</a></li><li><a class="tocitem" href="../../tutorials/GeodesicRegression/">Do Geodesic Regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">Introduction</a></li><li><a class="tocitem" href="../../solvers/adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas–Rachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg–Marquardt</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder–Mead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../">Specify a Solver</a></li><li><a class="tocitem" href="../problem/">Problem</a></li><li><a class="tocitem" href="../objective/">Objective</a></li><li class="is-active"><a class="tocitem" href>Solver State</a><ul class="internal"><li><a class="tocitem" href="#Decorators-for-AbstractManoptSolverState"><span>Decorators for AbstractManoptSolverState</span></a></li><li><a class="tocitem" href="#State-Actions"><span>State Actions</span></a></li><li><a class="tocitem" href="#Abstract-States"><span>Abstract States</span></a></li></ul></li><li><a class="tocitem" href="../stepsize/">Stepsize</a></li><li><a class="tocitem" href="../stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../debug/">Debug Output</a></li><li><a class="tocitem" href="../record/">Recording values</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../functions/">Introduction</a></li><li><a class="tocitem" href="../../functions/bezier/">Bézier curves</a></li><li><a class="tocitem" href="../../functions/costs/">Cost functions</a></li><li><a class="tocitem" href="../../functions/differentials/">Differentials</a></li><li><a class="tocitem" href="../../functions/adjoint_differentials/">Adjoint Differentials</a></li><li><a class="tocitem" href="../../functions/gradients/">Gradients</a></li><li><a class="tocitem" href="../../functions/proximal_maps/">Proximal Maps</a></li><li><a class="tocitem" href="../../functions/manifold/">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/data/">Data</a></li><li><a class="tocitem" href="../../helpers/errorMeasures/">Error Measures</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plans</a></li><li class="is-active"><a href>Solver State</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solver State</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/plans/state.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SolverStateSection"><a class="docs-heading-anchor" href="#SolverStateSection">The Solver State</a><a id="SolverStateSection-1"></a><a class="docs-heading-anchor-permalink" href="#SolverStateSection" title="Permalink"></a></h1><p>Given an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a>, that is a certain optimisation task, the state specifies the solver to use. It contains the parameters of a solver and all fields necessary during the algorithm, e.g. the current iterate, a <a href="../stopping_criteria/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> or a <a href="../stepsize/#Manopt.Stepsize"><code>Stepsize</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractManoptSolverState" href="#Manopt.AbstractManoptSolverState"><code>Manopt.AbstractManoptSolverState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractManoptSolverState</code></pre><p>A general super type for all solver states.</p><p><strong>Fields</strong></p><p>The following fields are assumed to be default. If you use different ones, provide the access functions accordingly</p><ul><li><code>p</code> a point on a manifold with the current iterate</li><li><code>stop</code> a <a href="../stopping_criteria/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_state" href="#Manopt.get_state"><code>Manopt.get_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_state(s::AbstractManoptSolverState, recursive::Bool=true)</code></pre><p>return the (one step) undecorated <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> of the (possibly) decorated <code>s</code>. As long as your decorated state stores the state within <code>s.state</code> and the <a href="../objective/#Manopt.dispatch_objective_decorator"><code>dispatch_objective_decorator</code></a> is set to <code>Val{true}</code>, the internal state are extracted automatically.</p><p>By default the state that is stored within a decorated state is assumed to be at <code>s.state</code>. Overwrtie <code>_get_state(s, ::Val{true}, recursive) to change this bevahiour for your state</code>s` for both the recursive and the nonrecursive case.</p><p>If <code>recursive</code> is set to <code>false</code>, only the most outer decorator is taken away instead of all.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L137-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_count" href="#Manopt.get_count"><code>Manopt.get_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_count(ams::AbstractManoptSolverState, ::Symbol)</code></pre><p>Obtain the count for a certain countable size, e.g. the <code>:Iterations</code>. This function returns 0 if there was nothing to count</p><p>Available symbols from within the solver state</p><ul><li><code>:Iterations</code> is passed on to the <code>stop</code> field to obtain the iterataion at which the solver stopped.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L612-L622">source</a></section><section><div><pre><code class="nohighlight hljs">get_count(co::ManifoldCountObjective, s::Symbol, mode::Symbol=:None)</code></pre><p>Get the number of counts for a certain symbel <code>s</code>.</p><p>Depending on the <code>mode</code> different results appear if the symbol does not exist in the dictionary</p><ul><li><code>:None</code> – (default) silent mode, returns <code>-1</code> for non-existing entries</li><li><code>:warn</code> – issues a warning if a field does not exist</li><li><code>:error</code> – issues an error if a field does not exist</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/count.jl#L116-L126">source</a></section></article><p>Since every subtype of an <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> directly relate to a solver, the concrete states are documented together with the corresponding <a href="../../solvers/#SolversSection">solvers</a>. This page documents the general functionality available for every state.</p><p>A first example is to access, i.e. obtain or set, the current iterate. This might be useful to continue investigation at the current iterate, or to set up a solver for a next experiment, respectively.</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_iterate" href="#Manopt.get_iterate"><code>Manopt.get_iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_iterate(O::AbstractManoptSolverState)</code></pre><p>return the (last stored) iterate within <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a><code></code>s`. By default also undecorates the state beforehand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L189-L194">source</a></section><section><div><pre><code class="nohighlight hljs">get_iterate(agst::AbstractGradientSolverState)</code></pre><p>return the iterate stored within gradient options. THe default resturns <code>agst.p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/gradient_plan.jl#L225-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.set_iterate!" href="#Manopt.set_iterate!"><code>Manopt.set_iterate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_iterate!(s::AbstractManoptSolverState, M::AbstractManifold, p)</code></pre><p>set the iterate within an <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> to some (start) value <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L205-L209">source</a></section><section><div><pre><code class="nohighlight hljs">set_iterate!(agst::AbstractGradientSolverState, M, p)</code></pre><p>set the (current) iterate stored within an <a href="#Manopt.AbstractGradientSolverState"><code>AbstractGradientSolverState</code></a> to <code>p</code>. The default function modifies <code>s.p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/gradient_plan.jl#L233-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_gradient-Tuple{AbstractManifoldGradientObjective}" href="#Manopt.get_gradient-Tuple{AbstractManifoldGradientObjective}"><code>Manopt.get_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p, k)
get_gradient!(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, Y, p, k)</code></pre><p>Evaluate one of the summands gradients <span>$\operatorname{grad}f_k$</span>, <span>$k∈\{1,…,n\}$</span>, at <code>x</code> (in place of <code>Y</code>).</p><p>If you use a single function for the stochastic gradient, that works inplace, then <code>get_gradient</code> is not available, since the length (or number of elements of the gradient required for allocation) can not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/stochastic_gradient_plan.jl#L177-L185">source</a></section><section><div><pre><code class="nohighlight hljs">get_gradient(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p)
get_gradient!(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, X, p)</code></pre><p>Evaluate the complete gradient <span>$\operatorname{grad} f = \displaystyle\sum_{i=1}^n \operatorname{grad} f_i(p)$</span> at <code>p</code> (in place of <code>X</code>).</p><p>If you use a single function for the stochastic gradient, that works inplace, then <code>get_gradient</code> is not available, since the length (or number of elements of the gradient required for allocation) can not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/stochastic_gradient_plan.jl#L269-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.set_gradient!" href="#Manopt.set_gradient!"><code>Manopt.set_gradient!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_gradient!(s::AbstractManoptSolverState, M::AbstractManifold, p, X)</code></pre><p>set the gradient within an (possibly decorated) <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> to some (start) value <code>X</code> in the tangent space at <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L171-L176">source</a></section><section><div><pre><code class="nohighlight hljs">set_gradient!(agst::AbstractGradientSolverState, M, p, X)</code></pre><p>set the (current) gradient stored within an <a href="#Manopt.AbstractGradientSolverState"><code>AbstractGradientSolverState</code></a> to <code>X</code>. The default function modifies <code>s.X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/gradient_plan.jl#L214-L219">source</a></section></article><p>An internal function working on the state and elements within a state is used to pass messages from (sub) activities of a state to the corresponding <a href="../debug/#Manopt.DebugMessages"><code>DebugMessages</code></a></p><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_message" href="#Manopt.get_message"><code>Manopt.get_message</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_message(du::AbstractManoptSolverState)</code></pre><p>get a message (String) from e.g. performing a step computation. This should return any message a sub-step might have issued</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L46-L51">source</a></section></article><p>Furthermore, to access the stopping criterion use</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_stopping_criterion" href="#Manopt.get_stopping_criterion"><code>Manopt.get_stopping_criterion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_stopping_criterion(ams::AbstractManoptSolverState)</code></pre><p>Return the <a href="../stopping_criteria/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> stored within the <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code>.</p><p>For an undecorated state, this is assumed to be in <code>ams.stop</code>. Overwrite <code>_get_stopping_criterion(yms::YMS)</code> to change this for your manopt solver (<code>yms</code>) assuming it has type YMS`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L59-L67">source</a></section></article><h2 id="Decorators-for-AbstractManoptSolverState"><a class="docs-heading-anchor" href="#Decorators-for-AbstractManoptSolverState">Decorators for AbstractManoptSolverState</a><a id="Decorators-for-AbstractManoptSolverState-1"></a><a class="docs-heading-anchor-permalink" href="#Decorators-for-AbstractManoptSolverState" title="Permalink"></a></h2><p>A solver state can be decorated using the following trait and function to initialize</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.dispatch_state_decorator" href="#Manopt.dispatch_state_decorator"><code>Manopt.dispatch_state_decorator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dispatch_state_decorator(s::AbstractManoptSolverState)</code></pre><p>Indicate internally, whether an <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>s</code> to be of decorating type, i.e. it stores (encapsulates) a state in itself, by default in the field <code>s.state</code>.</p><p>Decorators indicate this by returning <code>Val{true}</code> for further dispatch.</p><p>The default is <code>Val{false}</code>, i.e. by default an state is not decorated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L34-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.is_state_decorator" href="#Manopt.is_state_decorator"><code>Manopt.is_state_decorator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_state_decorator(s::AbstractManoptSolverState)</code></pre><p>Indicate, whether <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>s</code> are of decorator type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.decorate_state!" href="#Manopt.decorate_state!"><code>Manopt.decorate_state!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decorate_state!(s::AbstractManoptSolverState)</code></pre><p>decorate the <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a><code>s</code> with specific decorators.</p><p><strong>Optional Arguments</strong></p><p>optional arguments provide necessary details on the decorators. A specific one is used to activate certain decorators.</p><ul><li><code>debug</code> – (<code>Array{Union{Symbol,DebugAction,String,Int},1}()</code>) a set of symbols representing <a href="../debug/#Manopt.DebugAction"><code>DebugAction</code></a>s, <code>Strings</code> used as dividers and a subsampling integer. These are passed as a <a href="../debug/#Manopt.DebugGroup"><code>DebugGroup</code></a> within <code>:All</code> to the <a href="../debug/#Manopt.DebugSolverState"><code>DebugSolverState</code></a> decorator dictionary. Only excention is <code>:Stop</code> that is passed to <code>:Stop</code>.</li><li><code>record</code> – (<code>Array{Union{Symbol,RecordAction,Int},1}()</code>) specify recordings by using <code>Symbol</code>s or <a href="../record/#Manopt.RecordAction"><code>RecordAction</code></a>s directly. The integer can again be used for only recording every <span>$i$</span>th iteration.</li><li><code>return_state</code> - (<code>false</code>) indicate whether to wrap the options in a <a href="#Manopt.ReturnSolverState"><code>ReturnSolverState</code></a>, indicating that the solver should return options and not (only) the minimizer.</li></ul><p>other keywords are ignored.</p><p><strong>See also</strong></p><p><a href="../debug/#Manopt.DebugSolverState"><code>DebugSolverState</code></a>, <a href="../record/#Manopt.RecordSolverState"><code>RecordSolverState</code></a>, <a href="#Manopt.ReturnSolverState"><code>ReturnSolverState</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/solvers/solver.jl#L1-L25">source</a></section></article><p>A simple example is the</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.ReturnSolverState" href="#Manopt.ReturnSolverState"><code>Manopt.ReturnSolverState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReturnSolverState{O&lt;:AbstractManoptSolverState} &lt;: AbstractManoptSolverState</code></pre><p>This internal type is used to indicate that the contained <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>state</code> should be returned at the end of a solver instead of the usual minimizer.</p><p><strong>See also</strong></p><p><a href="../../solvers/#Manopt.get_solver_result"><code>get_solver_result</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L82-L91">source</a></section></article><p>as well as <a href="../debug/#Manopt.DebugSolverState"><code>DebugSolverState</code></a> and <a href="../record/#Manopt.RecordSolverState"><code>RecordSolverState</code></a>.</p><h2 id="State-Actions"><a class="docs-heading-anchor" href="#State-Actions">State Actions</a><a id="State-Actions-1"></a><a class="docs-heading-anchor-permalink" href="#State-Actions" title="Permalink"></a></h2><p>A state action is a struct for callback functions that can be attached within for example the just mentioned debug decorator or the record decorator.</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractStateAction" href="#Manopt.AbstractStateAction"><code>Manopt.AbstractStateAction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractStateAction</code></pre><p>a common <code>Type</code> for <code>AbstractStateActions</code> that might be triggered in decoraters, for example within the <a href="../debug/#Manopt.DebugSolverState"><code>DebugSolverState</code></a> or within the <a href="../record/#Manopt.RecordSolverState"><code>RecordSolverState</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L273-L278">source</a></section></article><p>Several state decorators or actions might store intermediate values like the (last) iterate to compute some change or the last gradient. In order to minimise the storage of these, there is a generic <a href="#Manopt.StoreStateAction"><code>StoreStateAction</code></a> that acts as generic common storage that can be shared among different actions.</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.StoreStateAction" href="#Manopt.StoreStateAction"><code>Manopt.StoreStateAction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StoreStateAction &lt;: AbstractStateAction</code></pre><p>internal storage for <a href="#Manopt.AbstractStateAction"><code>AbstractStateAction</code></a>s to store a tuple of fields from an <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a>s</p><p>This functor posesses the usual interface of functions called during an iteration, i.e. acts on <code>(p,o,i)</code>, where <code>p</code> is a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a>, <code>o</code> is an <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> and <code>i</code> is the current iteration.</p><p><strong>Fields</strong></p><ul><li><code>values</code> – a dictionary to store interims values based on certain <code>Symbols</code></li><li><code>keys</code> – a <code>Vector</code> of <code>Symbols</code> to refer to fields of <code>AbstractManoptSolverState</code></li><li><code>point_values</code> – a <code>NamedTuple</code> of mutable values of points on a manifold to be stored in <code>StoreStateAction</code>. Manifold is later determined by <code>AbstractManoptProblem</code> passed to <code>update_storage!</code>.</li><li><code>point_init</code> – a <code>NamedTuple</code> of boolean values indicating whether a point in <code>point_values</code> with matching key has been already initialized to a value. When it is false, it corresponds to a general value not being stored for the key present in the vector <code>keys</code>.</li><li><code>vector_values</code> – a <code>NamedTuple</code> of mutable values of tangent vectors on a manifold to be stored in <code>StoreStateAction</code>. Manifold is later determined by <code>AbstractManoptProblem</code> passed to <code>update_storage!</code>. It is not specified at which point the vectors are tangent but for storage it should not matter.</li><li><code>vector_init</code> – a <code>NamedTuple</code> of boolean values indicating whether a tangent vector in <code>vector_values</code> with matching key has been already initialized to a value. When it is false, it corresponds to a general value not being stored for the key present in the vector <code>keys</code>.</li><li><code>once</code> – whether to update the internal values only once per iteration</li><li><code>lastStored</code> – last iterate, where this <code>AbstractStateAction</code> was called (to determine <code>once</code>)</li></ul><p>To handle the general storage, use <code>get_storage</code> and <code>has_storage</code> with keys as <code>Symbol</code>s. For the point storage use <code>PointStorageKey</code>. For tangent vector storage use <code>VectorStorageKey</code>. Point and tangent storage have been optimized to be more efficient.</p><p><strong>Constructiors</strong></p><p>StoreStateAction(s::Vector{Symbol})</p><p>This is equivalent as providing <code>s</code> to the keyword <code>store_fields</code>, just that here, no manifold is necessay for the construciton.</p><pre><code class="nohighlight hljs">StoreStateAction(M)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>store_fields</code> (<code>Symbol[]</code>)</li><li><code>store_points</code> (<code>Symbol[]</code>)</li><li><code>store_vectors</code> (<code>Symbol[]</code>)</li></ul><p>as vectors of symbols each referring to fields of the state (lower case symbols) or semantic ones (upper case).</p><ul><li><code>p_init</code> (<code>rand(M)</code>)</li><li><code>X_init</code> (<code>zero_vector(M, p_init)</code>)</li></ul><p>are used to initialize the point and vector storages, change these if you use other types (than the default) for your points/vectors on <code>M</code>.</p><ul><li><code>once</code> (<code>true</code>) whether to update internal storage only once per iteration or on every update call</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L306-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_storage" href="#Manopt.get_storage"><code>Manopt.get_storage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_storage(a::AbstractStateAction, key::Symbol)</code></pre><p>Return the internal value of the <a href="#Manopt.AbstractStateAction"><code>AbstractStateAction</code></a> <code>a</code> at the <code>Symbol</code> <code>key</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L465-L470">source</a></section><section><div><pre><code class="nohighlight hljs">get_storage(a::AbstractStateAction, ::PointStorageKey{key}) where {key}</code></pre><p>Return the internal value of the <a href="#Manopt.AbstractStateAction"><code>AbstractStateAction</code></a> <code>a</code> at the <code>Symbol</code> <code>key</code> that represents a point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L473-L478">source</a></section><section><div><pre><code class="nohighlight hljs">get_storage(a::AbstractStateAction, ::VectorStorageKey{key}) where {key}</code></pre><p>Return the internal value of the <a href="#Manopt.AbstractStateAction"><code>AbstractStateAction</code></a> <code>a</code> at the <code>Symbol</code> <code>key</code> that represents a vector vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L492-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.has_storage" href="#Manopt.has_storage"><code>Manopt.has_storage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_storage(a::AbstractStateAction, key::Symbol)</code></pre><p>Return whether the <a href="#Manopt.AbstractStateAction"><code>AbstractStateAction</code></a> <code>a</code> has a value stored at the <code>Symbol</code> <code>key</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L511-L516">source</a></section><section><div><pre><code class="nohighlight hljs">has_storage(a::AbstractStateAction, ::PointStorageKey{key}) where {key}</code></pre><p>Return whether the <a href="#Manopt.AbstractStateAction"><code>AbstractStateAction</code></a> <code>a</code> has a point value stored at the <code>Symbol</code> <code>key</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L519-L524">source</a></section><section><div><pre><code class="nohighlight hljs">has_storage(a::AbstractStateAction, ::VectorStorageKey{key}) where {key}</code></pre><p>Return whether the <a href="#Manopt.AbstractStateAction"><code>AbstractStateAction</code></a> <code>a</code> has a point value stored at the <code>Symbol</code> <code>key</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L533-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.update_storage!" href="#Manopt.update_storage!"><code>Manopt.update_storage!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_storage!(a::AbstractStateAction, amp::AbstractManoptProblem, s::AbstractManoptSolverState)</code></pre><p>Update the <a href="#Manopt.AbstractStateAction"><code>AbstractStateAction</code></a> <code>a</code> internal values to the ones given on the <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>s</code>. Optimized using the information from <code>amp</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L547-L553">source</a></section><section><div><pre><code class="nohighlight hljs">update_storage!(a::AbstractStateAction, d::Dict{Symbol,&lt;:Any})</code></pre><p>Update the <a href="#Manopt.AbstractStateAction"><code>AbstractStateAction</code></a> <code>a</code> internal values to the ones given in the dictionary <code>d</code>. The values are merged, where the values from <code>d</code> are preferred.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L600-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.PointStorageKey" href="#Manopt.PointStorageKey"><code>Manopt.PointStorageKey</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PointStorageKey{key} end</code></pre><p>Refer to point storage of <a href="#Manopt.StoreStateAction"><code>StoreStateAction</code></a> in <code>get_storage</code> and <code>has_storage</code> functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L252-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.VectorStorageKey" href="#Manopt.VectorStorageKey"><code>Manopt.VectorStorageKey</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VectorStorageKey{key} end</code></pre><p>Refer to tangent storage of <a href="#Manopt.StoreStateAction"><code>StoreStateAction</code></a> in <code>get_storage</code> and <code>has_storage</code> functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L261-L266">source</a></section></article><p>as well as two internal functions</p><article class="docstring"><header><a class="docstring-binding" id="Manopt._storage_copy_vector" href="#Manopt._storage_copy_vector"><code>Manopt._storage_copy_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_storage_copy_vector(M::AbstractManifold, X)</code></pre><p>Make a copy of tangent vector <code>X</code> from manifold <code>M</code> for storage in <a href="#Manopt.StoreStateAction"><code>StoreStateAction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L298-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt._storage_copy_point" href="#Manopt._storage_copy_point"><code>Manopt._storage_copy_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_storage_copy_point(M::AbstractManifold, p)</code></pre><p>Make a copy of point <code>p</code> from manifold <code>M</code> for storage in <a href="#Manopt.StoreStateAction"><code>StoreStateAction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L290-L294">source</a></section></article><h2 id="Abstract-States"><a class="docs-heading-anchor" href="#Abstract-States">Abstract States</a><a id="Abstract-States-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-States" title="Permalink"></a></h2><p>In a few cases it is useful to have a hierarchy of types. These are</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractSubProblemSolverState" href="#Manopt.AbstractSubProblemSolverState"><code>Manopt.AbstractSubProblemSolverState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSubProblemSolverState &lt;: AbstractManoptSolverState</code></pre><p>An abstract type for problems that involve a subsolver</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/subsolver_plan.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractGradientSolverState" href="#Manopt.AbstractGradientSolverState"><code>Manopt.AbstractGradientSolverState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGradientSolverState &lt;: AbstractManoptSolverState</code></pre><p>A generic <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> type for gradient based options data.</p><p>It assumes that</p><ul><li>the iterate is stored in the field <code>p</code></li><li>the gradient at <code>p</code> is stored in <code>X</code>.</li></ul><p><strong>see also</strong></p><p><a href="../../solvers/gradient_descent/#Manopt.GradientDescentState"><code>GradientDescentState</code></a>, <a href="../../solvers/stochastic_gradient_descent/#Manopt.StochasticGradientDescentState"><code>StochasticGradientDescentState</code></a>, <a href="../../solvers/subgradient/#Manopt.SubGradientMethodState"><code>SubGradientMethodState</code></a>, <a href="../../solvers/quasi_Newton/#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/solver_state.jl#L19-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractHessianSolverState" href="#Manopt.AbstractHessianSolverState"><code>Manopt.AbstractHessianSolverState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHessianSolverState &lt;: AbstractGradientSolverState</code></pre><p>An <a href="#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> type to represent algorithms that employ the Hessian. These options are assumed to have a field (<code>gradient</code>) to store the current gradient <span>$\operatorname{grad}f(x)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/hessian_plan.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractPrimalDualSolverState" href="#Manopt.AbstractPrimalDualSolverState"><code>Manopt.AbstractPrimalDualSolverState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPrimalDualSolverState</code></pre><p>A general type for all primal dual based options to be used within primal dual based algorithms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/primal_dual_plan.jl#L497-L502">source</a></section></article><p>For the sub problem state, there are two access functions</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_sub_problem" href="#Manopt.get_sub_problem"><code>Manopt.get_sub_problem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_sub_problem(ams::AbstractSubProblemSolverState)</code></pre><p>Access the sub problem of a solver state that involves a sub optimisation task. By default this returns <code>ams.sub_problem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/subsolver_plan.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_sub_state" href="#Manopt.get_sub_state"><code>Manopt.get_sub_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_sub_state(ams::AbstractSubProblemSolverState)</code></pre><p>Access the sub state of a solver state that involves a sub optimisation task. By default this returns <code>ams.sub_state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/0ab53d62d897233bee3cac212d0c6bcc3c683280/src/plans/subsolver_plan.jl#L16-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../objective/">« Objective</a><a class="docs-footer-nextpage" href="../stepsize/">Stepsize »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 23 August 2023 15:52">Wednesday 23 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
