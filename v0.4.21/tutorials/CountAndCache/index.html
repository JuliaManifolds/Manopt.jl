<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Count and use a Cache · Manopt.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../Optimize!/">Get started: Optimize!</a></li><li><a class="tocitem" href="../InplaceGradient/">Speedup using Inplace computations</a></li><li><a class="tocitem" href="../AutomaticDifferentiation/">Use Automatic Differentiation</a></li><li class="is-active"><a class="tocitem" href>Count and use a Cache</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Technical-Background"><span>Technical Background</span></a></li><li><a class="tocitem" href="#Counting"><span>Counting</span></a></li></ul></li><li><a class="tocitem" href="../HowToRecord/">Record values</a></li><li><a class="tocitem" href="../ConstrainedOptimization/">Do Contrained Optimization</a></li><li><a class="tocitem" href="../GeodesicRegression/">Do Geodesic Regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">Introduction</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas–Rachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg–Marquardt</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder–Mead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../../plans/problem/">Problem</a></li><li><a class="tocitem" href="../../plans/objective/">Objective</a></li><li><a class="tocitem" href="../../plans/state/">Solver State</a></li><li><a class="tocitem" href="../../plans/stepsize/">Stepsize</a></li><li><a class="tocitem" href="../../plans/stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../../plans/debug/">Debug Output</a></li><li><a class="tocitem" href="../../plans/record/">Recording values</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../functions/">Introduction</a></li><li><a class="tocitem" href="../../functions/bezier/">Bézier curves</a></li><li><a class="tocitem" href="../../functions/costs/">Cost functions</a></li><li><a class="tocitem" href="../../functions/differentials/">Differentials</a></li><li><a class="tocitem" href="../../functions/adjointdifferentials/">Adjoint Differentials</a></li><li><a class="tocitem" href="../../functions/gradients/">Gradients</a></li><li><a class="tocitem" href="../../functions/proximal_maps/">Proximal Maps</a></li><li><a class="tocitem" href="../../functions/manifold/">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/data/">Data</a></li><li><a class="tocitem" href="../../helpers/errorMeasures/">Error Measures</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../list/">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to...</a></li><li class="is-active"><a href>Count and use a Cache</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Count and use a Cache</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/tutorials/CountAndCache.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="How-to-Count-and-Cache-Function-Calls"><a class="docs-heading-anchor" href="#How-to-Count-and-Cache-Function-Calls">How to Count and Cache Function Calls</a><a id="How-to-Count-and-Cache-Function-Calls-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Count-and-Cache-Function-Calls" title="Permalink"></a></h1><p>Ronny Bergmann</p><p>In this tutorial, we want to investigate the caching and counting (i.e. statistics) features of <a href="https://manoptjl.org">Manopt.jl</a>. We will reuse the optimization tasks from the introductionary tutorial <a href="https://manoptjl.org/stable/tutorials/Optimize!.html">Get Started: Optimize!</a>.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>There are surely many ways to keep track for example of how often the cost function is called, for example with a <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">functor</a>, as we used in an example in <a href="https://manoptjl.org/stable/tutorials/HowtoRecord.html">How to Record Data</a></p><pre><code class="language-julia hljs">mutable struct MyCost{I&lt;:Integer}
    count::I
end
MyCost() = MyCost{Int64}(0)
function (c::MyCost)(M, x)
    c.count += 1
    # [ .. Actual implementation of the cost here ]
end</code></pre><p>This still leaves a bit of work to the user, especially for tracking more than just the number of cost function evaluations.</p><p>When the a function like objective or gradient is expensive to compute, it may make sense to cache its results. Manopt.jl tries to minimize the number of repeated calls but sometimes they are necessary and harmless when the function is cheap to compute. Caching of expensive function calls can for example be added using <a href="https://github.com/JuliaCollections/Memoize.jl">Memoize.jl</a> by the user. The approach in the solvers of <a href="https://manoptjl.org">Manopt.jl</a> aims to simplify adding both these capabilities on the level of calling a solver.</p><h2 id="Technical-Background"><a class="docs-heading-anchor" href="#Technical-Background">Technical Background</a><a id="Technical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-Background" title="Permalink"></a></h2><p>The two ingdredients for a solver in <a href="https://manoptjl.org">Manopt.jl</a> are the <a href="../../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> and the <a href="../../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a>, where the former consists of the domain, that is the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types.html#The-AbstractManifold">manifold</a> and <a href="../../plans/objective/#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a>.</p><p>Both recording and debug capabilities are implemented in a decorator pattern to the solver state. They can be easily added using the <code>record=</code> and <code>debug=</code> in any solver call. This pattern was recently extended, such that also the objective can be decorated. This is how both caching and counting are implemented, as decorators of the <a href="../../plans/objective/#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> and hence for example changing/extending the behaviour of a call to <a href="../../plans/objective/#Manopt.get_cost"><code>get_cost</code></a>.</p><p>Let’s finish off the technical background by loading the necessary packages. Besides <a href="https://manoptjl.org">Manopt.jl</a> and <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/">Manifolds.jl</a> we also need <a href="https://github.com/JuliaCollections/LRUCache.jl">LRUCaches.jl</a> which are (since Julia 1.9) a weak dependency and provide the <em>least recently used</em> strategy for our caches.</p><pre><code class="language-julia hljs">using Manopt, Manifolds, Random, LRUCache</code></pre><h2 id="Counting"><a class="docs-heading-anchor" href="#Counting">Counting</a><a id="Counting-1"></a><a class="docs-heading-anchor-permalink" href="#Counting" title="Permalink"></a></h2><p>We first define our task, the Riemannian Center of Mass from the <a href="https://manoptjl.org/stable/tutorials/Optimize!.html">Get Started: Optimize!</a> tutorial.</p><pre><code class="language-julia hljs">n = 100
σ = π / 8
M = Sphere(2)
p = 1 / sqrt(2) * [1.0, 0.0, 1.0]
data = [exp(M, p,  σ * rand(M; vector_at=p)) for i in 1:n];
f(M, p) = sum(1 / (2 * n) * distance.(Ref(M), Ref(p), data) .^ 2)
grad_f(M, p) = sum(1 / n * grad_distance.(Ref(M), data, Ref(p)));</code></pre><p>to now count how often the cost and the gradient are called, we use the <code>count=</code> keyword argument that works in any solver to specify the elements of the objective whose calls we want to count calls to. A full list is available in the documentation of the <a href="../../plans/objective/#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a>. To also see the result, we have to set <code>return_objective=true</code>. This returns <code>(objective, p)</code> instead of just the solver result <code>p</code>. We can further also set <code>return_state=true</code> to get even more information about the solver run.</p><pre><code class="language-julia hljs">gradient_descent(M, f, grad_f, data[1]; count=[:Cost, :Gradient], return_objective=true, return_state=true)</code></pre><pre><code class="nohighlight hljs"># Solver state for `Manopt.jl`s Gradient Descent
After 72 iterations

## Parameters
* retraction method: ExponentialRetraction()

## Stepsize
ArmijoLineseach() with keyword parameters
  * initial_stepsize    = 1.0
  * retraction_method   = ExponentialRetraction()
  * contraction_factor  = 0.95
  * sufficient_decrease = 0.1

## Stopping Criterion
Stop When _one_ of the following are fulfilled:
    Max Iteration 200:  not reached
    |grad f| &lt; 1.0e-9: reached
Overall: reached
This indicates convergence: Yes

## Statistics on function calls
  * :Gradient :  217
  * :Cost     :  298
on a ManifoldGradientObjective{AllocatingEvaluation}</code></pre><p>And we see that statistics are shown in the end. To now also cache these calls, we can use the <code>cache=</code> keyword argument. Since now both the cache and the count “extend” the functionality of the objective, the order is important: On the high-level interface, the <code>count</code> is treated first, which means that only actual function calls and not cache look-ups are counted. With the proper initialisation, you can use any caches here that support the <code>get!(function, cache, key)!</code> update. All parts of the objective that can currently be cached are listed at <a href="../../plans/objective/#Manopt.ManifoldCachedObjective"><code>ManifoldCachedObjective</code></a>. The solver call has a keyword <code>cache</code> that takes a tuple<code>(c, vs, n)</code> of three arguments, where <code>c</code> is a symbol for the type of cache, <code>vs</code> is a vector of symbols, which calls to cache and <code>n</code> is the size of the cache. If the last element is not provided, a suitable default (currently<code>n=10</code>) is used.</p><p>Here we want to use <code>c=:LRU</code> caches for <code>vs=[Cost, :Gradient]</code> with a size of <code>n=25</code>.</p><pre><code class="language-julia hljs">r = gradient_descent(M, f, grad_f, data[1];
    count=[:Cost, :Gradient],
    cache=(:LRU, [:Cost, :Gradient], 25),
    return_objective=true, return_state=true)</code></pre><pre><code class="nohighlight hljs"># Solver state for `Manopt.jl`s Gradient Descent
After 72 iterations

## Parameters
* retraction method: ExponentialRetraction()

## Stepsize
ArmijoLineseach() with keyword parameters
  * initial_stepsize    = 1.0
  * retraction_method   = ExponentialRetraction()
  * contraction_factor  = 0.95
  * sufficient_decrease = 0.1

## Stopping Criterion
Stop When _one_ of the following are fulfilled:
    Max Iteration 200:  not reached
    |grad f| &lt; 1.0e-9: reached
Overall: reached
This indicates convergence: Yes

## Statistics on function calls
  * :Gradient :  72
  * :Cost     :  164
on a ManifoldGradientObjective{AllocatingEvaluation}</code></pre><p>Since the default setup with <a href="../../plans/stepsize/#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a> needs the gradient and the cost, and similarly the stopping criterion might (independently) evaluate the gradient, the caching is quite helpful here.</p><p>And of course also for this advanced return value of the solver, we can still access the result as usual:</p><pre><code class="language-julia hljs">get_solver_result(r)</code></pre><pre><code class="nohighlight hljs">3-element Vector{Float64}:
 0.7298774364923435
 0.047665824852873
 0.6819141418393224</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../AutomaticDifferentiation/">« Use Automatic Differentiation</a><a class="docs-footer-nextpage" href="../HowToRecord/">Record values »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 22 May 2023 09:32">Monday 22 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
