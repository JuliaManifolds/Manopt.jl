<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · Manopt.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Manopt.jl logo"/></a><h1>Manopt.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manifolds</span><ul><li class="current"><a class="toctext" href>Introduction</a><ul class="internal"><li><a class="toctext" href="#Manifolds-1">List of available Manifolds</a></li><li><a class="toctext" href="#Special-Types-of-Manifolds-1">Special Types of Manifolds</a></li><li><a class="toctext" href="#Functions-that-need-to-be-implemented-for-a-Manifold-1">Functions that need to be implemented for a Manifold</a></li><li><a class="toctext" href="#Functions-implemented-for-a-general-manifold-1">Functions implemented for a general manifold</a></li><li><a class="toctext" href="#A-decorator-for-checks-and-validation-1">A decorator for checks and validation</a></li></ul></li><li><a class="toctext" href="combined/">Combinations of Manifolds</a></li><li><a class="toctext" href="circle/">The Circle <span>$\mathbb S^1$</span></a></li><li><a class="toctext" href="euclidean/">The Euclidean Space <span>$\mathbb R^n$</span></a></li><li><a class="toctext" href="grassmannian/">The Grassmannian Manifold <span>$\mathrm{Gr}(k,n)$</span></a></li><li><a class="toctext" href="hyperbolic/">The Hyperbolic Space <span>$\mathbb H^n$</span></a></li><li><a class="toctext" href="rotations/">The Special Orthogonal Group <span>$\mathrm{SO}(n)$</span></a></li><li><a class="toctext" href="sphere/">The Sphere <span>$\mathbb S^n$</span></a></li><li><a class="toctext" href="stiefel/">The Stiefel Manifold <span>$\mathrm{St}(k,n)$</span></a></li><li><a class="toctext" href="symmetric/">The Symmetric Matrices <span>$\mathrm{Sym}(n)$</span></a></li><li><a class="toctext" href="symmetricpositivedefinite/">The Symmetric Positive Definite Matrices <span>$\mathcal P(n)$</span></a></li></ul></li><li><a class="toctext" href="../plans/">Plans</a></li><li><span class="toctext">Solvers</span><ul><li><a class="toctext" href="../solvers/">Introduction</a></li><li><a class="toctext" href="../solvers/cyclicProximalPoint/">Cyclic Proximal Point</a></li><li><a class="toctext" href="../solvers/DouglasRachford/">Douglas–Rachford</a></li><li><a class="toctext" href="../solvers/gradientDescent/">Gradient Descent</a></li><li><a class="toctext" href="../solvers/subGradientMethod/">Subgradient Method</a></li></ul></li><li><span class="toctext">Functions</span><ul><li><a class="toctext" href="../functions/">Introduction</a></li><li><a class="toctext" href="../functions/costFunctions/">cost functions</a></li><li><a class="toctext" href="../functions/differentials/">Differentials</a></li><li><a class="toctext" href="../functions/adjointDifferentials/">Adjoint Differentials</a></li><li><a class="toctext" href="../functions/gradients/">Gradients</a></li><li><a class="toctext" href="../functions/jacobiFields/">JacobiFields</a></li><li><a class="toctext" href="../functions/proximalMaps/">Proximal Maps</a></li></ul></li><li><span class="toctext">Helpers</span><ul><li><a class="toctext" href="../helpers/data/">Data</a></li><li><a class="toctext" href="../helpers/errorMeasures/">Error Measures</a></li><li><a class="toctext" href="../helpers/exports/">Exports</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/MeanAndMedian/">Getting Started: Optimize!</a></li><li><a class="toctext" href="../tutorials/GradientOfSecondOrderDifference/">Gradient of <span>$d_2$</span></a></li><li><a class="toctext" href="../tutorials/JacobiFields/">Jacobi Fields</a></li></ul></li><li><a class="toctext" href="../list/">Function Index</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manifolds</li><li><a href>Introduction</a></li></ul><a class="edit-page" href="https://github.com/kellertuer/Manopt.jl/blob/master/docs/src/manifolds/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="RiemannianManifolds-1" href="#RiemannianManifolds-1">Riemannian Manifolds</a></h1><p>All manifolds inherit from <a href="#Manopt.Manifold"><code>Manifold</code></a> to store their main properties, which is most prominently the manifold dimension and the name of the manifold. This will be extended in the future, for example properties denoting whether the manifold is explicitly given in the sense of a closed form exponential and logarithmic map for example, or only approximately.</p><p>A Riemannian manifold in <code>Manopt.jl</code> consist of three types:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.Manifold" href="#Manopt.Manifold"><code>Manopt.Manifold</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An abstract manifold <span>$\mathcal M$</span> to keep global information on a specific manifold</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.MPoint" href="#Manopt.MPoint"><code>Manopt.MPoint</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An abstract point <span>$x$</span> on a <a href="#Manopt.Manifold"><code>Manifold</code></a> <span>$\mathcal M$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.TVector" href="#Manopt.TVector"><code>Manopt.TVector</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A tangent vector <span>$\xi \in T_x\mathcal M$</span> at a <a href="#Manopt.MPoint"><code>MPoint</code></a> point <span>$x$</span> on a <a href="#Manopt.Manifold"><code>Manifold</code></a> <span>$\mathcal M$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L24">source</a></section><h2><a class="nav-anchor" id="Manifolds-1" href="#Manifolds-1">List of available Manifolds</a></h2><p>Furthermore there are two types accompanying each manifold – a point on the manifold inheriting from <a href="#Manopt.MPoint"><code>MPoint</code></a> and the tangent vector <a href="#Manopt.TVector"><code>TVector</code></a>. For both the term manifold is shortened to <code>M</code> for concise naming. Each manifold also inherits such a short abbreviation, see <code>Abbr.</code> in the following table.</p><table><tr><th style="text-align: left">Manifold <span>$\mathcal M$</span></th><th style="text-align: left">File</th><th style="text-align: center">Abbr.</th><th style="text-align: left">Comment</th></tr><tr><td style="text-align: left">A manifold <span>$\mathcal M$</span></td><td style="text-align: left"><code>Manifold.jl</code></td><td style="text-align: center"><code>M</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="circle/#CircleManifold-1"><span>$1$</span>-sphere <span>$\mathbb S^1$</span></a></td><td style="text-align: left"><code>Circle.jl</code></td><td style="text-align: center"><code>S1</code></td><td style="text-align: left">represented as angles <span>$x\in[-\pi,\pi)$</span></td></tr><tr><td style="text-align: left"><a href="euclidean/#EuclideanSpace-1">Euclidean space <span>$\mathbb R^n$</span></a></td><td style="text-align: left"><code>Euclidean.jl</code></td><td style="text-align: center"><code>Rn</code></td><td style="text-align: left"><span>$n$</span>-dimensional Euclidean space <span>$\mathbb R^n$</span></td></tr><tr><td style="text-align: left"><a href="grassmannian/#GrassmannianManifold-1">Grassmannian manifold <span>$\mathrm{Gr}(k,n)$</span></a></td><td style="text-align: left"><code>Grassmannian.jl</code></td><td style="text-align: center"><code>Gr</code></td><td style="text-align: left">embedded in <span>$\mathbb R^{n\times k}$</span></td></tr><tr><td style="text-align: left"><a href="hyperbolic/#HyperbolicManifold-1"><span>$n$</span>-dim. Hyperbolic space <span>$\mathbb H^n$</span></a></td><td style="text-align: left"><code>Hyperbolic.jl</code></td><td style="text-align: center"><code>Hn</code></td><td style="text-align: left">embedded in <span>$\mathbb R^{n+1}$</span></td></tr><tr><td style="text-align: left"><a href="rotations/#SOn-1">special orthogonal group <span>$\mathrm{SO}(n)$</span></a></td><td style="text-align: left"><code>Rotations.jl</code></td><td style="text-align: center"><code>SO</code></td><td style="text-align: left">represented as rotation matrices</td></tr><tr><td style="text-align: left"><a href="sphere/#SphereManifold-1"><span>$n$</span>-sphere <span>$\mathbb S^n$</span></a></td><td style="text-align: left"><code>Sphere.jl</code></td><td style="text-align: center"><code>Sn</code></td><td style="text-align: left">embedded in <span>$\mathbb R^{n+1}$</span></td></tr><tr><td style="text-align: left"><a href="stiefel/#StiefelManifold-1">Stiefel <span>$\mathrm{St}(k,n)$</span></a></td><td style="text-align: left"><code>Stiefel.jl</code></td><td style="text-align: center"><code>St</code></td><td style="text-align: left">contains both the real- ad the complex-valued case</td></tr><tr><td style="text-align: left"><a href="symmetric/#SymmetricManifold-1">symmetric matrices <span>$\mathcal{Sym}(n)$</span></a></td><td style="text-align: left"><code>Symmetric.jl</code></td><td style="text-align: center"><code>Sym</code></td><td style="text-align: left"><span>$n\times n$</span> symmetric matrices</td></tr><tr><td style="text-align: left"><a href="symmetricpositivedefinite/#SymmetricPositiveDefiniteManifold-1">symmetric positive definite matrices <span>$\mathcal P(n)$</span></a></td><td style="text-align: left"><code>SymmetricPositiveDefinite.jl</code></td><td style="text-align: center"><code>SPD</code></td><td style="text-align: left"><span>$n\times n$</span> symmetric positive matrices using the affine metric</td></tr></table><p>If you&#39;re missing your favorite manifold, <a href="https://github.com/kellertuer/Manopt.jl/issues">give us a note on Github</a>.</p><h2><a class="nav-anchor" id="Special-Types-of-Manifolds-1" href="#Special-Types-of-Manifolds-1">Special Types of Manifolds</a></h2><h3><a class="nav-anchor" id="Manifolds-build-upon-Manifolds-1" href="#Manifolds-build-upon-Manifolds-1">Manifolds build upon Manifolds</a></h3><table><tr><th style="text-align: right">Manifold <span>$\mathcal M$</span></th><th style="text-align: right">File</th><th style="text-align: right">Abbr.</th><th style="text-align: right">Comment</th></tr><tr><td style="text-align: right">Power manifold</td><td style="text-align: right"><code>Power.jl</code></td><td style="text-align: right"><code>Pow</code></td><td style="text-align: right">Builds <span>$\mathcal N^{d_1\times\cdot\times d_k}$</span> of any manifold <span>$\mathcal N$</span></td></tr><tr><td style="text-align: right">Product manifold</td><td style="text-align: right"><code>Product.jl</code></td><td style="text-align: right"><code>Prod</code></td><td style="text-align: right">Build the product manifold <span>$\mathcal N_1\times\cdots\times\mathcal N_k$</span> of manifolds</td></tr><tr><td style="text-align: right">Tangent bundle</td><td style="text-align: right"><code>TangentBundle.jl</code></td><td style="text-align: right"><code>TB</code></td><td style="text-align: right">tangent bundle of a manifold, i.e. the set of all tuples <span>$(x,\xi), \xi \in T_x\mathcal M$</span>, <span>$x\in\mathcal M$</span> with the induced metric.</td></tr></table><p>for more details see <a href="combined/#CombinedManifolds-1">Combined Manifolds</a></p><h3><a class="nav-anchor" id="Special-Properties-of-Manifolds-1" href="#Special-Properties-of-Manifolds-1">Special Properties of Manifolds</a></h3><p>Special types of manifolds are introduced by <a href="https://github.com/mauro3/SimpleTraits.jl">SimpleTraits.jl</a>. They can be used to clarify that a manifold possesses a certain property. For example two points on a matrix manifold can be multiplied, though the result is not necessarily a point on the manifold anymore. Traits have to goals here: Provide functions that are common for all manifolds of such a type (e.g. the <a href="#Manopt.:⊗"><code>⊗</code></a> for Lie groups) as a common interface and to specify certain functions or solvers for these certain types, that for example take advantage of <a href="#Manopt.:⊗"><code>⊗</code></a> then.</p><h4><a class="nav-anchor" id="Embedded-Manifold-1" href="#Embedded-Manifold-1">Embedded Manifold</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.IsEmbeddedM" href="#Manopt.IsEmbeddedM"><code>Manopt.IsEmbeddedM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IsEmbeddedM{X}</code></pre><p>An abstract <a href="#Manopt.Manifold"><code>Manifold</code></a> that is embedded in some Euclidean space. These manifolds may have projections and converters for gradient and Hessian.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/traits/EmbeddedManifold.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.IsEmbeddedP" href="#Manopt.IsEmbeddedP"><code>Manopt.IsEmbeddedP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IsEmbeddedP{X}</code></pre><p>An abstract <a href="#Manopt.MPoint"><code>MPoint</code></a> belonging to an embedded manifold.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/traits/EmbeddedManifold.jl#L16-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.IsEmbeddedV" href="#Manopt.IsEmbeddedV"><code>Manopt.IsEmbeddedV</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IsEmbeddedV{X}</code></pre><p>An abstract <a href="#Manopt.TVector"><code>TVector</code></a> belonging to an embedded manifold.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/traits/EmbeddedManifold.jl#L21-L24">source</a></section><h4><a class="nav-anchor" id="LieGroup-1" href="#LieGroup-1">Lie Group Manifold</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.IsLieGroupM" href="#Manopt.IsLieGroupM"><code>Manopt.IsLieGroupM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IsLieGroupM{X}</code></pre><p>Indicates that <code>X</code> is a <a href="#Manopt.Manifold"><code>Manifold</code></a> with a Lie group structure. This also introdcues a group operation <a href="#Manopt.:⊗"><code>⊗</code></a> of two <a href="#Manopt.MPoint"><code>MPoint</code></a>s of <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/traits/LieGroup.jl#L8-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.IsLieGroupP" href="#Manopt.IsLieGroupP"><code>Manopt.IsLieGroupP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IsLieGroupP{X}</code></pre><p>An abstract <a href="#Manopt.MPoint"><code>MPoint</code></a> belonging to a Lie group manifold.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/traits/LieGroup.jl#L14-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.IsLieGroupV" href="#Manopt.IsLieGroupV"><code>Manopt.IsLieGroupV</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IsLieGroupV{X}</code></pre><p>An abstract <a href="#Manopt.TVector"><code>TVector</code></a> belonging to a Lie group manifold.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/traits/LieGroup.jl#L19-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.:⊗" href="#Manopt.:⊗"><code>Manopt.:⊗</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">⊗(x,y)</code></pre><p>the binary operator <code>x ⊗ y</code> represents the Lie group action for a Lie group <a href="#Manopt.Manifold"><code>Manifold</code></a>, see <a href="#Manopt.IsLieGroupM"><code>IsLieGroupM</code></a>. </p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/traits/LieGroup.jl#L24">source</a></section><h4><a class="nav-anchor" id="MatrixManifold-1" href="#MatrixManifold-1">Matrix Manifold</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.IsMatrixM" href="#Manopt.IsMatrixM"><code>Manopt.IsMatrixM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IsMatrixM{X}</code></pre><p>An abstract Manifold to represent a manifold whose points are matrices. For these manifolds the usual operators (+,-,*) are overloaded for points. Furthermore, the <code>transpose</code> is also overloaded, though it returns the matrix, since the dimensions mit be different for rectangular matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/traits/MatrixManifold.jl#L13-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.IsMatrixP" href="#Manopt.IsMatrixP"><code>Manopt.IsMatrixP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IsMatrixP{X}</code></pre><p>An abstract Manifold Point belonging to a matrix manifold.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/traits/MatrixManifold.jl#L21-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.IsMatrixTV" href="#Manopt.IsMatrixTV"><code>Manopt.IsMatrixTV</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IsMatrixTV{X}</code></pre><p>An abstract Manifold Point belonging to a matrix manifold.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/traits/MatrixManifold.jl#L26-L29">source</a></section><h2><a class="nav-anchor" id="Functions-that-need-to-be-implemented-for-a-Manifold-1" href="#Functions-that-need-to-be-implemented-for-a-Manifold-1">Functions that need to be implemented for a Manifold</a></h2><p>If you plan to implement a new manifold within <code>Manopt.jl</code>, the following functions should be implemented. If you only implement a few of these functions, not all algorithms might work. all these functions have a fallback providing an error message if the function is not (yet) implemented. Otherwise, for example, if the field of the inner representant of <a href="#Manopt.MPoint"><code>MPoint</code></a> or <a href="#Manopt.TVector"><code>TVector</code></a> is the field <code>.value</code> of your data structure, the default implementation of <a href="combined/#Manopt.getValue-Tuple{TBTVector}"><code>getValue</code></a> directly works. In the following list <code>M &lt;: Manifold</code> the manifold type  represents the manifold <code>Q</code>,<code>P &lt;: MPoint</code> the type of a point on the new manifold, <code>T &lt;: TVector</code> a corresponding tangent vector in a suitable tangent space,</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.addNoise-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P,Vararg{Any,N} where N}} where P&lt;:MPoint where mT&lt;:Manifold" href="#Manopt.addNoise-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P,Vararg{Any,N} where N}} where P&lt;:MPoint where mT&lt;:Manifold"><code>Manopt.addNoise</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">addNoise(M,x)</code></pre><p>add noise to a <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code> by using the <a href="combined/#Manopt.randomTVector-Tuple{TangentBundle,TBPoint}"><code>randomTVector</code></a> method and doing an exponential step. Optional parameters, like the type of noise and parameters for the noise may be given and are just passed on-</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.distance-Union{Tuple{T}, Tuple{mT}, Tuple{mT,T,T}} where T&lt;:MPoint where mT&lt;:Manifold" href="#Manopt.distance-Union{Tuple{T}, Tuple{mT}, Tuple{mT,T,T}} where T&lt;:MPoint where mT&lt;:Manifold"><code>Manopt.distance</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">distance(M,x,y)</code></pre><p>computes the gedoesic distance between two <a href="#Manopt.MPoint"><code>MPoint</code></a>s <code>x</code> and <code>y</code> on a <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{S}, Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T,S}} where S&lt;:TVector where T&lt;:TVector where P&lt;:MPoint where mT&lt;:Manifold" href="#LinearAlgebra.dot-Union{Tuple{S}, Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T,S}} where S&lt;:TVector where T&lt;:TVector where P&lt;:MPoint where mT&lt;:Manifold"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">dot(M, x, ξ, ν)</code></pre><p>Computes the inner product of two <a href="#Manopt.TVector"><code>TVector</code></a>s <code>ξ</code> and <code>ν</code> from the tangent space at the <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp-Union{Tuple{N}, Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}, Tuple{mT,P,T,Float64}} where N&lt;:Number where T&lt;:TVector where P&lt;:MPoint where mT&lt;:Manifold" href="#Base.exp-Union{Tuple{N}, Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}, Tuple{mT,P,T,Float64}} where N&lt;:Number where T&lt;:TVector where P&lt;:MPoint where mT&lt;:Manifold"><code>Base.exp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">exp(M,x,ξ,[t=1.0])</code></pre><p>computes the exponential map at an <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code> for the <a href="#Manopt.TVector"><code>TVector</code></a> <code>ξ</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>. The optional parameter <code>t</code> can be used to shorten <code>ξ</code> to <code>tξ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L41-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.getValue-Union{Tuple{P}, Tuple{P}} where P&lt;:MPoint" href="#Manopt.getValue-Union{Tuple{P}, Tuple{P}} where P&lt;:MPoint"><code>Manopt.getValue</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">getValue(x)</code></pre><p>get the value representing the <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code>. This function defaults to returning <code>x.value</code>; if your representation is  different, you should implement this function for your type</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.getValue-Union{Tuple{T}, Tuple{T}} where T&lt;:TVector" href="#Manopt.getValue-Union{Tuple{T}, Tuple{T}} where T&lt;:TVector"><code>Manopt.getValue</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">getValue(ξ)</code></pre><p>get the value representing the <a href="#Manopt.TVector"><code>TVector</code></a> <code>ξ</code>. This function defaults to returning <code>ξ.value</code>; if your representation is  different, you should implement this function for your type</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.log-Union{Tuple{Q}, Tuple{P}, Tuple{mT}, Tuple{mT,P,Q}} where Q&lt;:MPoint where P&lt;:MPoint where mT&lt;:Manifold" href="#Base.log-Union{Tuple{Q}, Tuple{P}, Tuple{mT}, Tuple{mT,P,Q}} where Q&lt;:MPoint where P&lt;:MPoint where mT&lt;:Manifold"><code>Base.log</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">log(M,x,y)</code></pre><p>computes the <a href="#Manopt.TVector"><code>TVector</code></a> in the tangent space <span>$T_x\mathcal M$</span> at the <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code> such that the corresponding geodesic reaches the <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>y</code> after time 1 on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.manifoldDimension-Union{Tuple{P}, Tuple{P}} where P&lt;:MPoint" href="#Manopt.manifoldDimension-Union{Tuple{P}, Tuple{P}} where P&lt;:MPoint"><code>Manopt.manifoldDimension</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">manifoldDimension(x)</code></pre><p>return the dimension of the manifold <code>M</code> the point <code>x</code> belongs to.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.manifoldDimension-Union{Tuple{mT}, Tuple{mT}} where mT&lt;:Manifold" href="#Manopt.manifoldDimension-Union{Tuple{mT}, Tuple{mT}} where mT&lt;:Manifold"><code>Manopt.manifoldDimension</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">manifoldDimension(M)</code></pre><p>returns the dimension of the manifold <code>M</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}} where T&lt;:TVector where P&lt;:MPoint where mT&lt;:Manifold" href="#LinearAlgebra.norm-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}} where T&lt;:TVector where P&lt;:MPoint where mT&lt;:Manifold"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">norm(M,x,ξ)</code></pre><p>computes the length of a <a href="#Manopt.TVector"><code>TVector</code></a> <code>ξ</code> in the tangent space of the <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code> induced by the inner product.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.parallelTransport-Union{Tuple{T}, Tuple{Q}, Tuple{P}, Tuple{mT}, Tuple{mT,P,Q,T}} where T&lt;:TVector where Q&lt;:MPoint where P&lt;:MPoint where mT&lt;:Manifold" href="#Manopt.parallelTransport-Union{Tuple{T}, Tuple{Q}, Tuple{P}, Tuple{mT}, Tuple{mT,P,Q,T}} where T&lt;:TVector where Q&lt;:MPoint where P&lt;:MPoint where mT&lt;:Manifold"><code>Manopt.parallelTransport</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">parallelTransport(M,x,y,ξ)</code></pre><p>Parallel transport of a vector <code>ξ</code> given at the tangent space <span>$T_x\mathcal M$</span> of <code>x</code> to the tangent space <span>$T_y\mathcal M$</span> at <code>y</code> along the geodesic form <code>x</code> to <code>y</code>. If the geodesic is not unique, this function takes the same choice as <code>geodesic</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.randomMPoint-Union{Tuple{mT}, Tuple{mT,Symbol,Vararg{Any,N} where N}} where mT&lt;:Manifold" href="#Manopt.randomMPoint-Union{Tuple{mT}, Tuple{mT,Symbol,Vararg{Any,N} where N}} where mT&lt;:Manifold"><code>Manopt.randomMPoint</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">randomMPoint(M,x [,:Gaussian,options...])</code></pre><p>generate a random <a href="#Manopt.MPoint"><code>MPoint</code></a> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code> by falling back to the default <code>:Gaussian</code> noise with the default standard deviation on the specific manifold.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.randomTVector-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P,Symbol,Vararg{Any,N} where N}} where P&lt;:MPoint where mT&lt;:Manifold" href="#Manopt.randomTVector-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P,Symbol,Vararg{Any,N} where N}} where P&lt;:MPoint where mT&lt;:Manifold"><code>Manopt.randomTVector</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">randomTVector(M,x [,:Gaussian,options...])</code></pre><p>generate a random tangent vector at <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code> using <code>:Gaussian</code> noise where options usually contain the standard deviation σ on the specific manifold.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.tangentONB-Union{Tuple{Q}, Tuple{P}, Tuple{mT}, Tuple{mT,P,Q}} where Q&lt;:MPoint where P&lt;:MPoint where mT&lt;:Manifold" href="#Manopt.tangentONB-Union{Tuple{Q}, Tuple{P}, Tuple{mT}, Tuple{mT,P,Q}} where Q&lt;:MPoint where P&lt;:MPoint where mT&lt;:Manifold"><code>Manopt.tangentONB</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">(Ξ,κ) = tangentONB(M,x,y)</code></pre><p>compute an ONB within the tangent space <span>$T_x\mathcal M$</span> such that <span>$\xi=\log_xy$</span> is the first vector and compute the eigenvalues of the curvature tensor <span>$R(\Xi,\dot g)\dot g$</span>, where <span>$g=g_{x,\xi}$</span> is the geodesic with <span>$g(0)=x$</span>, <span>$\dot g(0) = \xi$</span>, i.e. <span>$\kappa_1$</span> corresponding to <span>$\Xi_1=\xi$</span> is zero.</p><p><strong>See also</strong></p><p><a href="#Manopt.jacobiField"><code>jacobiField</code></a>, <a href="#Manopt.adjointJacobiField"><code>adjointJacobiField</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.tangentONB-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}} where T&lt;:TVector where P&lt;:MPoint where mT&lt;:Manifold" href="#Manopt.tangentONB-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}} where T&lt;:TVector where P&lt;:MPoint where mT&lt;:Manifold"><code>Manopt.tangentONB</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">(Ξ,κ) = tangentONB(M,x,ξ)</code></pre><p>compute an ONB within the tangent space <span>$T_x\mathcal M$</span> such that <span>$\xi$</span> is the first vector and compute the eigenvalues of the curvature tensor <span>$R(\Xi,\dot g)\dot g$</span>, where <span>$g=g_{x,\xi}$</span> is the geodesic with <span>$g(0)=x$</span>, <span>$\dot g(0) = \xi$</span>, i.e. <span>$\kappa_1$</span> corresponding to <span>$\Xi_1=\xi$</span> is zero.</p><p><strong>See also</strong></p><p><a href="#Manopt.jacobiField"><code>jacobiField</code></a>, <a href="#Manopt.adjointJacobiField"><code>adjointJacobiField</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.typeofMPoint-Union{Tuple{T}, Tuple{T}} where T&lt;:TVector" href="#Manopt.typeofMPoint-Union{Tuple{T}, Tuple{T}} where T&lt;:TVector"><code>Manopt.typeofMPoint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">typeofMPoint(ξ)</code></pre><p>return the <a href="#Manopt.MPoint"><code>MPoint</code></a> belonging to the <a href="#Manopt.TVector"><code>TVector</code></a> type of <code>ξ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L256-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.typeofMPoint-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:TVector" href="#Manopt.typeofMPoint-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:TVector"><code>Manopt.typeofMPoint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">typeofMPoint(T)</code></pre><p>return the <a href="#Manopt.MPoint"><code>MPoint</code></a> belonging to the <a href="#Manopt.TVector"><code>TVector</code></a> type <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L110-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.typeofTVector-Union{Tuple{P}, Tuple{P}} where P&lt;:MPoint" href="#Manopt.typeofTVector-Union{Tuple{P}, Tuple{P}} where P&lt;:MPoint"><code>Manopt.typeofTVector</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">typeofTVector(x)</code></pre><p>return the <a href="#Manopt.TVector"><code>TVector</code></a> belonging to the <a href="#Manopt.MPoint"><code>MPoint</code></a> type of <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L262-L266">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.typeofTVector-Union{Tuple{Type{P}}, Tuple{P}} where P&lt;:MPoint" href="#Manopt.typeofTVector-Union{Tuple{Type{P}}, Tuple{P}} where P&lt;:MPoint"><code>Manopt.typeofTVector</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">typeofTVector(P)</code></pre><p>returns the <a href="#Manopt.TVector"><code>TVector</code></a> belonging to the <a href="#Manopt.MPoint"><code>MPoint</code></a> type <code>P</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L119-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.typicalDistance-Union{Tuple{mT}, Tuple{mT}} where mT&lt;:Manifold" href="#Manopt.typicalDistance-Union{Tuple{mT}, Tuple{mT}} where mT&lt;:Manifold"><code>Manopt.typicalDistance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">typicalDistance(M)</code></pre><p>returns the typical distance on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>, which is for example the longest distance in a unit cell or injectivity radius.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L128-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.zeroTVector-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P}} where P&lt;:MPoint where mT&lt;:Manifold" href="#Manopt.zeroTVector-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P}} where P&lt;:MPoint where mT&lt;:Manifold"><code>Manopt.zeroTVector</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">ξ = zeroTVector(M,x)</code></pre><p>returns a zero vector in the tangent space <span>$T_x\mathcal M$</span> of the <a href="#Manopt.MPoint"><code>MPoint</code></a> <span>$x\in\mathcal M$</span> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L179">source</a></section><h2><a class="nav-anchor" id="Functions-implemented-for-a-general-manifold-1" href="#Functions-implemented-for-a-general-manifold-1">Functions implemented for a general manifold</a></h2><p>the following base functions are implemented for general manifolds and are based on the functions from the last section</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.adjointJacobiField" href="#Manopt.adjointJacobiField"><code>Manopt.adjointJacobiField</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">ζ = adjointJacobiField(M,x,y,t,η,w)</code></pre><p>compute the AdjointJacobiField <span>$J$</span> along the geodesic <span>$g_{x,y}$</span> on the manifold <span>$\mathcal M$</span> with initial conditions (depending on the application) <span>$\eta\in T_{g(t;x,y)\mathcal M}$</span> and weights <span>$\beta$</span>. The result is a vector <span>$\zeta \in T_x\mathcal M$</span>. The main difference to <a href="#Manopt.jacobiField"><code>jacobiField</code></a> is the, that the input <span>$\eta$</span> and the output <span>$\zeta$</span> switched tangent spaces.</p><p>For detais see <a href="#Manopt.jacobiField"><code>jacobiField</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.geodesic" href="#Manopt.geodesic"><code>Manopt.geodesic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">geodesic(M,x,y)</code></pre><p>return a function to evaluate the geodesic connecting the two <a href="#Manopt.MPoint"><code>MPoint</code></a>s <code>x</code> and <code>y</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L110-L115">source</a><div><div><pre><code class="language-none">geodesic(M,x,y,n)</code></pre><p>return vector containing the equispaced <code>n</code> sample-values along the geodesic connecting the two <a href="#Manopt.MPoint"><code>MPoint</code></a>s <code>x</code> and <code>y</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L118-L122">source</a><div><div><pre><code class="language-none">geodesic(M,x,y,t)</code></pre><p>return the point along the geodesic from <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code> to <code>y</code> given by at value <code>t</code> (in <code>[0,1]</code>) on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L125-L130">source</a><div><div><pre><code class="language-none">geodesic(M,x,y,T)</code></pre><p>return vector containing the <a href="#Manopt.MPoint"><code>MPoint</code></a> along the geodesic from <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code> to <code>y</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code> specified by the points from the vector <code>T</code> (of numbers between 0 and 1).</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L133-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.jacobiField" href="#Manopt.jacobiField"><code>Manopt.jacobiField</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">ζ = jacobiField(M,x,y,t,η,β)</code></pre><p>compute the jacobiField <span>$J$</span> along the geodesic <span>$g_{x,y}$</span> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code> <span>$\mathcal M$</span> with initial conditions (depending on the application) <span>$\eta\in T_x\mathcal M$</span> and weights <span>$\beta$</span>. The result is a <a href="#Manopt.TVector"><code>TVector</code></a> in <span>$\zeta \in T_{g(t;x,y)}\mathcal M$</span>.</p><p><strong>See also</strong></p><p><a href="#Manopt.adjointJacobiField"><code>adjointJacobiField</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.mean" href="#Statistics.mean"><code>Statistics.mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">y = mean(M,x)</code></pre><p>compute the Riemannian center of mass of the data given by the vector of <a href="#Manopt.MPoint"><code>MPoint</code></a>s <code>x</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>. calculates the Riemannian Center of Mass (Karcher mean) of the input data <code>x</code> as an <code>Array</code> of <a href="#Manopt.MPoint"><code>MPoint</code></a>s on the <a href="#Manopt.Manifold"><code>Manifold</code></a> with a <a href="../solvers/gradientDescent/#Manopt.steepestDescent"><code>steepestDescent</code></a> or a <a href="../solvers/cyclicProximalPoint/#Manopt.cyclicProximalPoint"><code>cyclicProximalPoint</code></a>.</p><p><strong>Optional</strong></p><ul><li><code>initialValue</code> – (<code>x[1]</code>) the value to initialize the algorithm to</li><li><code>method</code> – (<code>:GradientDescent</code>) symbol indicating the algorithm to use, so the second variant is <code>:CyclicProximalPoint</code></li><li><code>weights</code> – (<code>1/n</code>) compute a weighted Karcher mean, i.e. the dault is to set all weights to be <code>1/n</code> where <code>n</code> is the length of <code>x</code>.</li></ul><p>as well as optional parameters that are passed down to the corresponding algorithm</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/algorithms/basicAlgorithms.jl#L18-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.median" href="#Statistics.median"><code>Statistics.median</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">y = median(M,x)</code></pre><p>compute the median of the data given by the vector of <a href="#Manopt.MPoint"><code>MPoint</code></a>s <code>x</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>. calculates the Riemannian Center of Mass (Karcher mean) of the input data <code>x</code> as an <code>Array</code> of <a href="#Manopt.MPoint"><code>MPoint</code></a>s on the <a href="#Manopt.Manifold"><code>Manifold</code></a> with a <a href="../solvers/cyclicProximalPoint/#Manopt.cyclicProximalPoint"><code>cyclicProximalPoint</code></a>.</p><p><strong>Optional</strong></p><ul><li><code>initialValue</code> – (<code>x[1]</code>) the value to initialize the algorithm to</li><li><code>method</code> – (<code>:CyclicProximalPoint</code>) symbol indicating the algorithm to use</li><li><code>weights</code> – (<code>1/n</code>) compute a weighted Karcher mean, i.e. the dault is to set all weights to be <code>1/n</code> where <code>n</code> is the length of <code>x</code>.</li></ul><p>as well as optional parameters that are passed down to the corresponding algorithm</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/algorithms/basicAlgorithms.jl#L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.midPoint" href="#Manopt.midPoint"><code>Manopt.midPoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">midPoint(M,x,y,z)</code></pre><p>compute the mid point between x and y. If there is more than one mid point of (not neccessarily miniizing) geodesics (i.e. on the sphere), the one nearest to z.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L85-L91">source</a><div><div><pre><code class="language-none">midPoint(M,x,y)</code></pre><p>compute the (geodesic) mid point of the two <a href="#Manopt.MPoint"><code>MPoint</code></a>s <code>x</code> and <code>y</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>. If the geodesic is not unique, either a deterministic choice is returned or an error is raised. For the deteministic choixe, see <a href="#Manopt.midPoint"><code>midPoint(M,x,y,z)</code></a>, the mid point closest to a third <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>z</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L97-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.reflection" href="#Manopt.reflection"><code>Manopt.reflection</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">y = reflection(M,p,x)</code></pre><p>reflect the <code>MPoint x</code> at <code>MPoint p</code>, i.e. compute <span>$y = R_p(x) = \exp_p(-\log_px)$</span>. On Euclidean space this results in the point reflection <span>$R_p(x) = p - (x-p) = 2p-x$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>M</code> – a <a href="#Manopt.Manifold"><code>Manifold</code></a> <span>$\mathcal M$</span></li><li><code>p</code> – an <a href="#Manopt.MPoint"><code>MPoint</code></a> <span>$p\in\mathcal M$</span> to relfect at</li><li><code>x</code> – an <a href="#Manopt.MPoint"><code>MPoint</code></a> <span>$x\in\mathcal M$</span> that is reflected</li></ul><p><strong>Output</strong></p><ul><li><code>y</code> – the resulting reflection.</li></ul></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/Manifold.jl#L239">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.variance" href="#Manopt.variance"><code>Manopt.variance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">variance(M,x)</code></pre><p>returns the variance of the vector <code>x</code> of <a href="#Manopt.MPoint"><code>MPoint</code></a>s on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/algorithms/basicAlgorithms.jl#L84-L89">source</a></section><h2><a class="nav-anchor" id="A-decorator-for-checks-and-validation-1" href="#A-decorator-for-checks-and-validation-1">A decorator for checks and validation</a></h2><p>In order to check and/or validate tangent vectors, the decorator pattern <a href="#Manopt.TVectorE"><code>TVectorE</code></a> is available for any subtype of <a href="#Manopt.TVector"><code>TVector</code></a> as follows</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.TVectorE" href="#Manopt.TVectorE"><code>Manopt.TVectorE</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">TVectorE &lt;: MPoint</code></pre><p>A decorator pattern based extension of TVector to additionally store the base point. The decorator is then used to verify, that exp and dot are only called with correct base points.</p><p><strong>Constructors</strong></p><pre><code class="language-none">TVectorE(ξ,x [,v=true])</code></pre><p>constructs an extended tangential vector based on the <a href="#Manopt.TVector"><code>TVector</code></a> <code>ξ</code> with base <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code> with optional <code>validation v</code>. If none of the first two arguments is an extended element, <code>v</code> defaults to <code>true</code>, otherwise, the one which is an extended is inherited or the <code>&amp;&amp;</code> of both validations.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/extendedData.jl#L37">source</a></section><p>together with a small helper <a href="#Manopt.MPointE"><code>MPointE</code></a> that indicates to the <code>log</code> to returns an extended tangent vector as soon as one of its arguments is an extended manifold point.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.MPointE" href="#Manopt.MPointE"><code>Manopt.MPointE</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">MPointE &lt;: MPoint</code></pre><p>A decorator pattern based extension of MPoint to identify when to switch to the extended <code>TVectorE</code> for functions just working on points, e.g. <code>log</code>. The constructor avoids multiple encapsualtions of extensions.</p><p><strong>Constructors</strong></p><pre><code class="language-none">MPointE(x [,v=true])</code></pre><p>the point can constructed by extending an existing <a href="#Manopt.MPoint"><code>MPoint</code></a>. optionally, the <code>validation</code> can be turned off (but is <code>true</code>by default). If <code>x</code> is a <a href="#Manopt.MPointE"><code>MPointE</code></a> the default of <code>v</code> is taken from <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/extendedData.jl#L15">source</a></section><p>for these two data items, the following additional features that are activated</p><h3><a class="nav-anchor" id="Inheritance-1" href="#Inheritance-1">Inheritance</a></h3><p>Basic functions like <code>exp</code>, <code>log</code>, <code>parallelTransport</code>, and <a href="combined/#Manopt.randomTVector-Tuple{TangentBundle,TBPoint}"><code>randomTVector</code></a> return an extended <a href="#Manopt.MPointE"><code>MPointE</code></a> or <a href="#Manopt.TVectorE"><code>TVectorE</code></a> whenever one of its arguments is an extended input. This enables, that setting (only) one input for a calculation to an extended version, this property propagates this into all the algorithm.</p><p>Note that this might increase memory usage and hence reduce performance, since for any <a href="#Manopt.TVectorE"><code>TVectorE</code></a> internally stores both a <a href="#Manopt.TVector"><code>TVector</code></a> as well as its base <a href="#Manopt.MPoint"><code>MPoint</code></a> (as extension).</p><h3><a class="nav-anchor" id="Checks-1" href="#Checks-1">Checks</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.checkBasePoint" href="#Manopt.checkBasePoint"><code>Manopt.checkBasePoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">checkBasePoint(ξ,ν)</code></pre><p>checks, whether the base of two tangent vectors is identical, if both tangent vectors are of type <code>TVectorE</code>. If one of them is not an extended vector, the function returns true, expecting the tangent vector implicitly to be correct.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/extendedData.jl#L116-L122">source</a><div><div><pre><code class="language-none">checkBasePoint(ξ,x)</code></pre><p>checks, whether the base of the tangent vector <code>ξ</code> is <code>x</code>. If <code>ξ</code> is not an extended tangent vector <code>TVectorE</code> the function returns true, assuming the base implicitly to be correct</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/extendedData.jl#L134-L140">source</a></section><p>For extended data decorators, whenever possible in the basic functions listed above a <a href="#Manopt.checkBasePoint"><code>checkBasePoint</code></a> completely automatically performed. For example, when calling <code>exp(M,x,ξ)</code>, as soon as <code>ξ</code> is an extended vector, <code>checkBasePoint(x,ξ)</code> is called before performing the original exponential map.</p><p>This way, as many checks are performed, whether corresponding points and vectors or two vectors involved have the correct base points.</p><h3><a class="nav-anchor" id="Validation-1" href="#Validation-1">Validation</a></h3><p>Every extended type carries a further boolean <code>validation</code>, whose default is <code>true</code>, i.e. to perform validation. activating validation one needs to implement the following two functions, otherwise, a lot of warnings might occur.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.validateMPoint-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P}} where P&lt;:MPoint where mT&lt;:Manifold" href="#Manopt.validateMPoint-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P}} where P&lt;:MPoint where mT&lt;:Manifold"><code>Manopt.validateMPoint</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">validateMPoint(M,x)</code></pre><p>check, whether the data in the <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code> is a valid point on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>. This is used to validate parameters and results during computations using <a href="#Manopt.MPointE"><code>MPointE</code></a>s. Note that the default fallback is just a warning that no validation is available.</p><p>The function should throw an error if <code>x</code> is not point on the manifold <code>M</code>, otherwise it should return <code>true</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.validateTVector-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}} where T&lt;:TVector where P&lt;:MPoint where mT&lt;:Manifold" href="#Manopt.validateTVector-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}} where T&lt;:TVector where P&lt;:MPoint where mT&lt;:Manifold"><code>Manopt.validateTVector</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">validateTVector(M,x,ξ)</code></pre><p>check, whether the data in the <a href="#Manopt.TVector"><code>TVector</code></a> <code>ξ</code> is a valid tangent vector #to the <a href="#Manopt.MPoint"><code>MPoint</code></a> <code>x</code> on the <a href="#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>. This is used to validate parameters and results during computations when using <a href="#Manopt.MPointE"><code>MPointE</code></a>s.  Note that the default fallback is just a warning that no validation is available.</p><p>Available validations should throw an error if <code>x</code> is not on <code>M</code> or <code>ξ</code> is not in the tangent space of <code>x</code>. If <code>ξ</code> is valid, the function returns true.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/manifoldFallbacks.jl#L157">source</a></section><p>whenever possible (see <a href="#Manopt.checkBasePoint"><code>checkBasePoint</code></a> above). Since such a validation might not be available for your favorite manifold, you can deactivate validation by setting the boolean to <code>false</code>. Every new extended type inherits the false, whenever one of its part (i.e. either the <a href="#Manopt.TVector"><code>TVector</code></a> <em>or</em> <a href="#Manopt.MPoint"><code>MPoint</code></a>) has validation set to false.</p><p>So while checking as often as possible, this feature can easily be deactivated.</p><h3><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h3><p>To access the inner value of <a href="#Manopt.MPointE"><code>MPointE</code></a> and the base stored in <a href="#Manopt.TVectorE"><code>TVectorE</code></a> you can use</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.strip" href="#Base.strip"><code>Base.strip</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">strip(ξ)</code></pre><p>returns the internal <a href="#Manopt.TVector"><code>TVector</code></a> of an extended tangent vector <a href="#Manopt.TVectorE"><code>TVectorE</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/extendedData.jl#L72-L77">source</a><div><div><pre><code class="language-none">strip(x)</code></pre><p>returns the <a href="#Manopt.MPoint"><code>MPoint</code></a> the <a href="#Manopt.MPointE"><code>MPointE</code></a> <code>x</code> stores internally. If applied to an already non-extended <a href="#Manopt.MPoint"><code>MPoint</code></a>, nothing happens.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/extendedData.jl#L98-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.getBasePoint" href="#Manopt.getBasePoint"><code>Manopt.getBasePoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getBasePoint(ξ)</code></pre><p>returns the base point of an extended tangent vector. To continue promotion of the extended type, the result is always a <a href="#Manopt.MPointE"><code>MPointE</code></a>. To eliminate the decorator, use <a href="#Base.strip"><code>strip</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/manifolds/defaults/extendedData.jl#L64-L70">source</a></section><p>Furthermore the following functions are mapping to the internally stored data and encapsulate the results with the extended variant if applicable</p><ul><li><a href="combined/#Manopt.getValue-Tuple{TBTVector}"><code>getValue</code></a></li><li><a href="#Manopt.addNoise-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P,Vararg{Any,N} where N}} where P&lt;:MPoint where mT&lt;:Manifold"><code>addNoise</code></a></li><li><a href="combined/#Manopt.distance-Tuple{TangentBundle,TBPoint,TBPoint}"><code>distance</code></a></li><li><a href="combined/#LinearAlgebra.dot-Tuple{TangentBundle,TBPoint,TBTVector,TBTVector}"><code>dot</code></a></li><li><a href="combined/#Base.exp"><code>exp</code></a></li><li><a href="combined/#Manopt.getValue-Tuple{TBTVector}"><code>getValue</code></a></li><li><a href="combined/#Base.log-Tuple{TangentBundle,TBPoint,TBPoint}"><code>log</code></a></li><li><a href="combined/#Manopt.manifoldDimension-Tuple{TBPoint}"><code>manifoldDimension</code></a></li><li><a href="combined/#LinearAlgebra.norm-Tuple{TangentBundle,TBPoint,TBTVector}"><code>norm</code></a></li><li><a href="combined/#Manopt.parallelTransport-Tuple{TangentBundle,TBPoint,TBPoint,TBTVector}"><code>parallelTransport</code></a></li><li><a href="combined/#Manopt.randomMPoint-Tuple{TangentBundle}"><code>randomMPoint</code></a></li><li><a href="combined/#Manopt.randomTVector-Tuple{TangentBundle,TBPoint}"><code>randomTVector</code></a></li><li><a href="combined/#Manopt.tangentONB-Tuple{TangentBundle,TBPoint,TBPoint}"><code>tangentONB</code></a></li><li><a href="combined/#Manopt.typicalDistance-Tuple{TangentBundle}"><code>typicalDistance</code></a></li><li><a href="combined/#Manopt.zeroTVector-Union{Tuple{P}, Tuple{Mt}, Tuple{TangentBundle{Mt},TBPoint{P,T} where T&lt;:TVector}} where P&lt;:MPoint where Mt&lt;:Manifold"><code>zeroTVector</code></a></li></ul><p>as well as mathematical operators on tangent vectors and comparison operators.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="combined/"><span class="direction">Next</span><span class="title">Combinations of Manifolds</span></a></footer></article></body></html>
