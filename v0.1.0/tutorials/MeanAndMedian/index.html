<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started: Optimize! · Manopt.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Manopt.jl logo"/></a><h1>Manopt.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manifolds</span><ul><li><a class="toctext" href="../../manifolds/">Introduction</a></li><li><a class="toctext" href="../../manifolds/combined/">Combinations of Manifolds</a></li><li><a class="toctext" href="../../manifolds/circle/">The Circle <span>$\mathbb S^1$</span></a></li><li><a class="toctext" href="../../manifolds/euclidean/">The Euclidean Space <span>$\mathbb R^n$</span></a></li><li><a class="toctext" href="../../manifolds/grassmannian/">The Grassmannian Manifold <span>$\mathrm{Gr}(k,n)$</span></a></li><li><a class="toctext" href="../../manifolds/hyperbolic/">The Hyperbolic Space <span>$\mathbb H^n$</span></a></li><li><a class="toctext" href="../../manifolds/rotations/">The Special Orthogonal Group <span>$\mathrm{SO}(n)$</span></a></li><li><a class="toctext" href="../../manifolds/sphere/">The Sphere <span>$\mathbb S^n$</span></a></li><li><a class="toctext" href="../../manifolds/stiefel/">The Stiefel Manifold <span>$\mathrm{St}(k,n)$</span></a></li><li><a class="toctext" href="../../manifolds/symmetric/">The Symmetric Matrices <span>$\mathrm{Sym}(n)$</span></a></li><li><a class="toctext" href="../../manifolds/symmetricpositivedefinite/">The Symmetric Positive Definite Matrices <span>$\mathcal P(n)$</span></a></li></ul></li><li><a class="toctext" href="../../plans/">Plans</a></li><li><span class="toctext">Solvers</span><ul><li><a class="toctext" href="../../solvers/">Introduction</a></li><li><a class="toctext" href="../../solvers/cyclicProximalPoint/">Cyclic Proximal Point</a></li><li><a class="toctext" href="../../solvers/DouglasRachford/">Douglas–Rachford</a></li><li><a class="toctext" href="../../solvers/gradientDescent/">Gradient Descent</a></li><li><a class="toctext" href="../../solvers/subGradientMethod/">Subgradient Method</a></li></ul></li><li><span class="toctext">Functions</span><ul><li><a class="toctext" href="../../functions/">Introduction</a></li><li><a class="toctext" href="../../functions/costFunctions/">cost functions</a></li><li><a class="toctext" href="../../functions/differentials/">Differentials</a></li><li><a class="toctext" href="../../functions/adjointDifferentials/">Adjoint Differentials</a></li><li><a class="toctext" href="../../functions/gradients/">Gradients</a></li><li><a class="toctext" href="../../functions/jacobiFields/">JacobiFields</a></li><li><a class="toctext" href="../../functions/proximalMaps/">Proximal Maps</a></li></ul></li><li><span class="toctext">Helpers</span><ul><li><a class="toctext" href="../../helpers/data/">Data</a></li><li><a class="toctext" href="../../helpers/errorMeasures/">Error Measures</a></li><li><a class="toctext" href="../../helpers/exports/">Exports</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li class="current"><a class="toctext" href>Getting Started: Optimize!</a><ul class="internal"><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#The-given-Dataset-1">The given Dataset</a></li><li><a class="toctext" href="#Computing-the-Mean-1">Computing the Mean</a></li><li><a class="toctext" href="#Computing-the-Median-1">Computing the Median</a></li><li><a class="toctext" href="#Literature-1">Literature</a></li></ul></li><li><a class="toctext" href="../GradientOfSecondOrderDifference/">Gradient of <span>$d_2$</span></a></li><li><a class="toctext" href="../JacobiFields/">Jacobi Fields</a></li></ul></li><li><a class="toctext" href="../../list/">Function Index</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Getting Started: Optimize!</a></li></ul><a class="edit-page" href="https://github.com/kellertuer/Manopt.jl/blob/master/src/tutorials/MeanAndMedian.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Getting Started: Optimize!</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Optimize-1" href="#Optimize-1">Getting Started: Optimize!</a></h1><p>This example illustrates how to set up and solve optimization problems and how to further get data from the algorithm using <a href="../../plans/#Manopt.DebugOptions"><code>DebugOptions</code></a> and <a href="../../plans/#Manopt.RecordOptions"><code>RecordOptions</code></a></p><p>To start from the quite general case: A <strong>Solver</strong> is an algorithm that aims to solve</p><div>\[\operatorname*{argmin}_{x\in\mathcal M} f(x)\]</div><p>where <span>$\mathcal M$</span> is a <a href="../../manifolds/#Manopt.Manifold"><code>Manifold</code></a> and <span>$f\colon\mathcal M \to \mathbb R$</span> is the cost function.</p><p>In <code>Manopt.jl</code> a <strong>Solver</strong> is an algorithm that requires a <a href="../../plans/#Manopt.Problem"><code>Problem</code></a> <code>p</code> and <a href="../../plans/#Manopt.Options"><code>Options</code></a> <code>o</code>. While former contains <strong>static</strong> data, most prominently the manifold <span>$\mathcal M$</span> (usually as <code>p.M</code>) and the cost function <span>$f$</span> (usually as <code>p.costFunction</code>), the latter contains <strong>dynamic</strong> data, i.e. things that usually change during the algorithm, are allowed to change, or specify the details of the algorithm to use. Together they form a <code>plan</code>. A <code>plan</code> uniquely determines the algorithm to use and provide all necessary information to run the algorithm.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>A gradient plan consists of a <a href="../../plans/#Manopt.GradientProblem"><code>GradientProblem</code></a> with the fields <code>M</code>, cost function <span>$f$</span> as well as <code>gradient</code> storing the gradient function corresponding to <span>$f$</span>. Accessing both functions can be done directly but should be encapsulated using <a href="../../plans/#Manopt.getCost"><code>getCost</code></a><code>(p,x)</code> and <a href="../../plans/#Manopt.getGradient"><code>getGradient</code></a><code>(p,x)</code>, where in both cases <code>x</code> is an <a href="../../manifolds/#Manopt.MPoint"><code>MPoint</code></a> on the <a href="../../manifolds/#Manopt.Manifold"><code>Manifold</code></a> <code>M</code>. Second, the <a href="../../solvers/gradientDescent/#Manopt.GradientDescentOptions"><code>GradientDescentOptions</code></a> specify that the algorithm to solve the <a href="../../plans/#Manopt.GradientProblem"><code>GradientProblem</code></a> will be the <a href="https://en.wikipedia.org/wiki/Gradient_descent">gradient descent</a> algorithm. It requires an initial value <code>o.x0</code>, a <a href="../../solvers/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> <code>o.stop</code>, a <a href="../../plans/#Manopt.Stepsize"><code>Stepsize</code></a> <code>o.stepsize</code> and a retraction <code>o.retraction</code> and it internally stores the last evaluation of the gradient at <code>o.∇</code> for convenience. The only mandatory parameter is the initial value <code>x0</code>, though the defaults for both the stopping criterion (<a href="../../solvers/#Manopt.stopAfterIteration"><code>stopAfterIteration</code></a><code>(100)</code>) as well as the stepsize (<a href="../../plans/#Manopt.ConstantStepsize"><code>ConstantStepsize</code></a><code>(1.)</code> are quite conservative, but are chosen to be as simple as possible.</p><p>With these two at hand, running the algorithm just requires to call <code>xOpt = solve(p,o)</code>.</p><p>In the following two examples we will see, how to use a higher level interface that allows to more easily activate for example a debug output or record values during the iterations</p><h2><a class="nav-anchor" id="The-given-Dataset-1" href="#The-given-Dataset-1">The given Dataset</a></h2><pre><code class="language-julia">using Manopt
using Random, Colors</code></pre><p>For a persistent random set we use</p><pre><code class="language-julia">n = 100
σ = π/8
M = Sphere(2)
x = SnPoint(1/sqrt(2)*[1., 0., 1.])
Random.seed!(42)
data = addNoise.(Ref(M), repeat([x],n),Ref(σ))</code></pre><p>and we define some colors from <a href="https://personal.sron.nl/~pault/">Paul Tol</a></p><pre><code class="language-julia">black = RGBA{Float64}(colorant&quot;#000000&quot;)
TolVibrantOrange = RGBA{Float64}(colorant&quot;#EE7733&quot;)
TolVibrantBlue = RGBA{Float64}(colorant&quot;#0077BB&quot;)
TolVibrantTeal = RGBA{Float64}(colorant&quot;#009988&quot;)
TolVibrantMagenta = RGBA{Float64}(colorant&quot;#EE3377&quot;)</code></pre><p>Then our data looks like</p><pre><code class="language-julia">asyResolution = 2</code></pre><pre><code class="language-julia">renderAsymptote(&quot;startDataAndCenter.asy&quot;,asyExportS2Signals;
    render = asyResolution,
    points = [ [x], data],
    colors=Dict(:points =&gt; [TolVibrantBlue, TolVibrantTeal]),
    dotSize = 3.5, cameraPosition = (1.,.5,.5)
)</code></pre><p><img src="../../assets/images/tutorials/startDataAndCenter.png" alt="The data of noisy versions of \$x\$"/></p><h2><a class="nav-anchor" id="Computing-the-Mean-1" href="#Computing-the-Mean-1">Computing the Mean</a></h2><p>To compute the mean on the manifold we use the characterization, that the Euclidean mean minimizes the sum of squared distances, and end up with the following cost function. Its minimizer is called <a href="https://arxiv.org/abs/1407.2087">Riemannian Center of Mass</a>.</p><pre><code class="language-julia">F = y -&gt; sum(1/(2*n) * distance.(Ref(M),Ref(y),data).^2)
∇F = y -&gt; sum(1/n*gradDistance.(Ref(M),data,Ref(y)))</code></pre><p>note that the <a href="../../functions/gradients/#Manopt.gradDistance"><code>gradDistance</code></a> defaults to the case <code>p=2</code>, i.e. the gradient of the squared distance. For details on convergence of the gradient descent for this problem, see [<a href="#AfsariTronVidal2013">Afsari, Tron, Vidal, 2013</a>]</p><p>The easiest way to call the gradient descent is now to call <a href="../../solvers/gradientDescent/#Manopt.steepestDescent"><code>steepestDescent</code></a></p><pre><code class="language-julia">xMean = steepestDescent(M,F,∇F,data[1])</code></pre><p>but in order to get more details, we further add the <code>debug=</code> options, which act as a <a href="https://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a> using the <a href="../../plans/#Manopt.DebugOptions"><code>DebugOptions</code></a> and <a href="../../plans/#Manopt.DebugAction"><code>DebugAction</code></a>s. The latter store values if that&#39;s necessary, for example for the <a href="../../plans/#Manopt.DebugChange"><code>DebugChange</code></a> that prints the change during the last iteration. The following debug prints</p><p><code># i | x: | Last Change: | F(x):</code>`</p><p>as well as the reason why the algorithm stopped at the end. Here, the format shorthand and the [<code>DebugFactory</code>] are used, which returns a <a href="../../plans/#Manopt.DebugGroup"><code>DebugGroup</code></a> of <a href="../../plans/#Manopt.DebugAction"><code>DebugAction</code></a> performed each iteration and the stop, respectively.</p><pre><code class="language-julia">xMean = steepestDescent(M,F,∇F,data[1];
   debug = [:Iteration,&quot; | &quot;, :x, &quot; | &quot;, :Change, &quot; | &quot;, :Cost, &quot;\n&quot;, :Stop]
)</code></pre><pre><code class="language-none">Initial | x: Sn([0.573734, -0.172865, 0.800592]) |  | F(x): 0.22606088442202962
# 1 | x: Sn([0.782389, 0.085569, 0.616884]) | Last Change: 0.38188652881305785 | F(x): 0.1492472828108876
# 2 | x: Sn([0.791738, 0.0972092, 0.603077]) | Last Change: 0.020335997468975846 | F(x): 0.14902948995714208
# 3 | x: Sn([0.792283, 0.097716, 0.602278]) | Last Change: 0.001092107177198496 | F(x): 0.14902886086292977
# 4 | x: Sn([0.792316, 0.0977379, 0.602232]) | Last Change: 6.034189486653822e-5 | F(x): 0.14902885894006085
# 5 | x: Sn([0.792317, 0.0977388, 0.602229]) | Last Change: 3.405428846127275e-6 | F(x): 0.14902885893393106
# 6 | x: Sn([0.792318, 0.0977389, 0.602229]) | Last Change: 1.9428737179048833e-7 | F(x): 0.149028858933911
# 7 | x: Sn([0.792318, 0.0977389, 0.602229]) | Last Change: 0.0 | F(x): 0.14902885893391096
The algorithm reached approximately critical point; the gradient norm (6.549991892754451e-10) is less than 1.0e-8.</code></pre><pre><code class="language-julia">renderAsymptote(&quot;startDataCenterMean.asy&quot;,asyExportS2Signals;
    render = asyResolution,
    points = [ [x], data, [xMean] ],
    colors=Dict(:points =&gt; [TolVibrantBlue, TolVibrantTeal, TolVibrantOrange]),
    dotSize = 3.5, cameraPosition = (1.,.5,.5)
)</code></pre><p><img src="../../assets/images/tutorials/startDataCenterMean.png" alt="The resulting mean (orange)"/></p><h2><a class="nav-anchor" id="Computing-the-Median-1" href="#Computing-the-Median-1">Computing the Median</a></h2><p>Similar to the mean you can also define the median as the minimizer of the distances, see for example [<a href="#Bačák2014">Bačák, 2014</a>], but since this problem is not differentiable, we employ the Cyclic Proximal Point (CPP) algorithm, described in the same reference. We define</p><pre><code class="language-julia">F2 = y -&gt; sum( 1/(2*n) * distance.(Ref(M),Ref(y),data))
proxes = Function[ (λ,y) -&gt; proxDistance(M,λ/n,di,y,1) for di in data ]</code></pre><p>where the <code>Function</code> is a helper for global scope to infer the correct type.</p><p>We then call the <a href="../../solvers/cyclicProximalPoint/#Manopt.cyclicProximalPoint"><code>cyclicProximalPoint</code></a> as</p><pre><code class="language-julia">xMedian, values = cyclicProximalPoint(M,F2,proxes,data[1];
    debug = [:Iteration,&quot; | &quot;, :x, &quot; | &quot;, :Change, &quot; | &quot;, :Cost, &quot;\n&quot;, 50, :Stop],
    record = [:Iteration, :Change, :Cost]
)</code></pre><pre><code class="language-none">Initial | x: Sn([0.573734, -0.172865, 0.800592]) |  | F(x): 0.2986800792881026
# 50 | x: Sn([0.790207, 0.0790575, 0.607719]) | Last Change: 0.024872284599065892 | F(x): 0.24545404985253558
# 100 | x: Sn([0.790176, 0.0789142, 0.607778]) | Last Change: 0.00015168198899823736 | F(x): 0.24545402494915822
# 150 | x: Sn([0.790164, 0.0788666, 0.6078]) | Last Change: 5.238563566485724e-5 | F(x): 0.24545402020641963
# 200 | x: Sn([0.790157, 0.0788428, 0.607812]) | Last Change: 2.648767643184091e-5 | F(x): 0.2454540185347789
# 250 | x: Sn([0.790153, 0.0788287, 0.607819]) | Last Change: 1.5975504268680515e-5 | F(x): 0.2454540177590461
# 300 | x: Sn([0.790151, 0.0788192, 0.607824]) | Last Change: 1.0681066695042033e-5 | F(x): 0.2454540173372077
# 350 | x: Sn([0.790149, 0.0788125, 0.607827]) | Last Change: 7.642872252139065e-6 | F(x): 0.245454017082742
# 400 | x: Sn([0.790147, 0.0788075, 0.60783]) | Last Change: 5.73880456603777e-6 | F(x): 0.2454540169175623
# 450 | x: Sn([0.790146, 0.0788035, 0.607832]) | Last Change: 4.467068899786066e-6 | F(x): 0.24545401680431816
# 500 | x: Sn([0.790145, 0.0788004, 0.607833]) | Last Change: 3.5756577509035908e-6 | F(x): 0.24545401672332376
# 550 | x: Sn([0.790144, 0.0787979, 0.607835]) | Last Change: 2.926703380869698e-6 | F(x): 0.24545401666340602
# 600 | x: Sn([0.790144, 0.0787957, 0.607836]) | Last Change: 2.439789287793762e-6 | F(x): 0.24545401661784128
# 650 | x: Sn([0.790143, 0.0787939, 0.607837]) | Last Change: 2.0649805308965548e-6 | F(x): 0.24545401658238772
# 700 | x: Sn([0.790143, 0.0787924, 0.607838]) | Last Change: 1.7701676374577805e-6 | F(x): 0.2454540165542612
# 750 | x: Sn([0.790142, 0.0787911, 0.607838]) | Last Change: 1.5343131692766127e-6 | F(x): 0.24545401653157428
The algorithm performed a step with a change (0.0) less than 1.0e-12.</code></pre><p>where the differences to <a href="../../solvers/gradientDescent/#Manopt.steepestDescent"><code>steepestDescent</code></a> are as follows</p><ul><li>the third parameter is now an Array of proximal maps</li><li>debug is reduces to only every 50th iteration</li><li>we further activated a <a href="../../plans/#Manopt.RecordAction"><code>RecordAction</code></a> using the <code>record=</code> optional parameter. These work very similar to those in debug, but they collect their data in an array. The high level interface then returns two variables; the <code>values</code> do contain an array of recorded datum per iteration. Here a Tuple containing the iteration, last change and cost respectively; see <a href="../../plans/#Manopt.RecordGroup"><code>RecordGroup</code></a>, <a href="../../plans/#Manopt.RecordIteration"><code>RecordIteration</code></a>, <a href="../../plans/#Manopt.RecordChange"><code>RecordChange</code></a>, <a href="../../plans/#Manopt.RecordCost"><code>RecordCost</code></a> as well as the <a href="../../plans/#Manopt.RecordFactory-Union{Tuple{O}, Tuple{O,Array{#s12,1} where #s12}} where O&lt;:Options"><code>RecordFactory</code></a> for details. The <code>values</code> contains hence a tuple per iteration, that itself consists of (by order of specification) the iteration number, the last change and the cost function value.</li></ul><p>These recorded entries read</p><pre><code class="language-julia">values</code></pre><pre><code class="language-none">795-element Array{Tuple{Int64,Float64,Float64},1}:
 (1, 0.36238005253323424, 0.245641044732753)      
 (2, 0.01809306050631564, 0.24547241697343175)    
 (3, 0.004524562287640276, 0.24545924567218239)   
 (4, 0.0016977276677696115, 0.2454567202442458)   
 (5, 0.0008065520445980736, 0.2454558352426111)   
 (6, 0.00045408132637338595, 0.2454553806689513)  
 (7, 0.00029150358326490163, 0.24545509464651913) 
 (8, 0.00020667645140366966, 0.24545489511003585) 
 (9, 0.00015736137044969613, 0.2454547477323262)  
 (10, 0.00012587009545694195, 0.24545463490344233)
 ⋮                                                
 (787, 2.9802322387695312e-8, 0.24545401651749799)
 (788, 2.580956827951785e-8, 0.24545401651714466) 
 (789, 2.580956827951785e-8, 0.24545401651679308) 
 (790, 2.9802322387695312e-8, 0.24545401651644255)
 (791, 2.580956827951785e-8, 0.2454540165160933)  
 (792, 2.1073424255447017e-8, 0.2454540165157455) 
 (793, 2.1073424255447017e-8, 0.24545401651539903)
 (794, 1.4901161193847656e-8, 0.24545401651505386)
 (795, 0.0, 0.24545401651470997)                  </code></pre><p>The resulting median and mean for the data hence are</p><pre><code class="language-julia">renderAsymptote(&quot;startDataCenterMean.asy&quot;,asyExportS2Signals;
    render = asyResolution,
    points = [ [x], data, [xMean], [xMedian] ],
    colors=Dict(:points =&gt; [TolVibrantBlue, TolVibrantTeal, TolVibrantOrange, TolVibrantMagenta]),
    dotSize = 3.5, cameraPosition = (1.,.5,.5)
)</code></pre><p><img src="../../assets/images/tutorials/startDataCenterMedianAndMean.png" alt="The resulting mean (orange) and median (magenta)"/></p><h2><a class="nav-anchor" id="Literature-1" href="#Literature-1">Literature</a></h2><ul>
<li id="Bačák2014">[<a>Bačák, 2014</a>]
  Bačák, M: <emph>Computing Medians and Means in Hadamard Spaces.</emph>,
  SIAM Journal on Optimization, Volume 24, Number 3, pp. 1542–1566,
  doi: <a href="https://doi.org/10.1137/140953393">10.1137/140953393</a>,
  arxiv: <a href="https://arxiv.org/abs/1210.2145">1210.2145</a>.</li>
  <li id="AfsariTronVidal2013">[<a>Afsari, Tron, Vidal, 2013</a>]
   Afsari, B; Tron, R.; Vidal, R.: <emph>On the Convergence of Gradient
   Descent for Finding the Riemannian Center of Mass</emph>,
   SIAM Journal on Control and Optimization, Volume 51, Issue 3,
   pp. 2230–2260.
   doi: <a href="https://doi.org/10.1137/12086282X">10.1137/12086282X</a>,
   arxiv: <a href="https://arxiv.org/abs/1201.0925">1201.0925</a></li>
</ul><footer><hr/><a class="previous" href="../../helpers/exports/"><span class="direction">Previous</span><span class="title">Exports</span></a><a class="next" href="../GradientOfSecondOrderDifference/"><span class="direction">Next</span><span class="title">Gradient of <span>$d_2$</span></span></a></footer></article></body></html>
