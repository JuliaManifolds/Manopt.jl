<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · Manopt.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Manopt.jl logo"/></a><h1>Manopt.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manifolds</span><ul><li><a class="toctext" href="../manifolds/">Introduction</a></li><li><a class="toctext" href="../manifolds/combined/">Combinations of Manifolds</a></li><li><a class="toctext" href="../manifolds/circle/">The Circle <span>$\mathbb S^1$</span></a></li><li><a class="toctext" href="../manifolds/euclidean/">The Euclidean Space <span>$\mathbb R^n$</span></a></li><li><a class="toctext" href="../manifolds/grassmannian/">The Grassmannian Manifold <span>$\mathrm{Gr}(k,n)$</span></a></li><li><a class="toctext" href="../manifolds/hyperbolic/">The Hyperbolic Space <span>$\mathbb H^n$</span></a></li><li><a class="toctext" href="../manifolds/rotations/">The Special Orthogonal Group <span>$\mathrm{SO}(n)$</span></a></li><li><a class="toctext" href="../manifolds/sphere/">The Sphere <span>$\mathbb S^n$</span></a></li><li><a class="toctext" href="../manifolds/stiefel/">The Stiefel Manifold <span>$\mathrm{St}(k,n)$</span></a></li><li><a class="toctext" href="../manifolds/symmetric/">The Symmetric Matrices <span>$\mathrm{Sym}(n)$</span></a></li><li><a class="toctext" href="../manifolds/symmetricpositivedefinite/">The Symmetric Positive Definite Matrices <span>$\mathcal P(n)$</span></a></li></ul></li><li><a class="toctext" href="../plans/">Plans</a></li><li><span class="toctext">Solvers</span><ul><li class="current"><a class="toctext" href>Introduction</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#List-of-Algorithms-1">List of Algorithms</a></li><li><a class="toctext" href="#StoppingCriteria-1">StoppingCriteria</a></li><li><a class="toctext" href="#DecoratedSolvers-1">Decorated Solvers</a></li><li><a class="toctext" href="#Technical-Details-1">Technical Details</a></li></ul></li><li><a class="toctext" href="cyclicProximalPoint/">Cyclic Proximal Point</a></li><li><a class="toctext" href="DouglasRachford/">Douglas–Rachford</a></li><li><a class="toctext" href="gradientDescent/">Gradient Descent</a></li><li><a class="toctext" href="subGradientMethod/">Subgradient Method</a></li></ul></li><li><span class="toctext">Functions</span><ul><li><a class="toctext" href="../functions/">Introduction</a></li><li><a class="toctext" href="../functions/costFunctions/">cost functions</a></li><li><a class="toctext" href="../functions/differentials/">Differentials</a></li><li><a class="toctext" href="../functions/adjointDifferentials/">Adjoint Differentials</a></li><li><a class="toctext" href="../functions/gradients/">Gradients</a></li><li><a class="toctext" href="../functions/jacobiFields/">JacobiFields</a></li><li><a class="toctext" href="../functions/proximalMaps/">Proximal Maps</a></li></ul></li><li><span class="toctext">Helpers</span><ul><li><a class="toctext" href="../helpers/data/">Data</a></li><li><a class="toctext" href="../helpers/errorMeasures/">Error Measures</a></li><li><a class="toctext" href="../helpers/exports/">Exports</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/MeanAndMedian/">Getting Started: Optimize!</a></li><li><a class="toctext" href="../tutorials/GradientOfSecondOrderDifference/">Gradient of <span>$d_2$</span></a></li><li><a class="toctext" href="../tutorials/JacobiFields/">Jacobi Fields</a></li></ul></li><li><a class="toctext" href="../list/">Function Index</a></li></ul></nav><article id="docs"><header><nav><ul><li>Solvers</li><li><a href>Introduction</a></li></ul><a class="edit-page" href="https://github.com/kellertuer/Manopt.jl/blob/master/docs/src/solvers/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Solvers-1" href="#Solvers-1">Solvers</a></h1><p>Solvers can be applied to <a href="../plans/#Manopt.Problem"><code>Problem</code></a>s with solver specific <a href="../plans/#Manopt.Options"><code>Options</code></a>.</p><h1><a class="nav-anchor" id="List-of-Algorithms-1" href="#List-of-Algorithms-1">List of Algorithms</a></h1><p>The following algorithms are currently available</p><table><tr><th style="text-align: right">Solver</th><th style="text-align: right">File</th><th style="text-align: right">Problem &amp; Option</th></tr><tr><td style="text-align: right"><a href="gradientDescent/#GradientDescentSolver-1">steepest Descent</a></td><td style="text-align: right"><code>steepestDescent.jl</code></td><td style="text-align: right"><a href="../plans/#Manopt.GradientProblem"><code>GradientProblem</code></a>, <a href="gradientDescent/#Manopt.GradientDescentOptions"><code>GradientDescentOptions</code></a></td></tr><tr><td style="text-align: right"><a href="cyclicProximalPoint/#CPPSolver-1">Cyclic Proximal Point</a></td><td style="text-align: right"><code>cyclicProximalPoint.jl</code></td><td style="text-align: right"><a href="../plans/#Manopt.ProximalProblem"><code>ProximalProblem</code></a>, <a href="cyclicProximalPoint/#Manopt.CyclicProximalPointOptions"><code>CyclicProximalPointOptions</code></a></td></tr><tr><td style="text-align: right"><a href="DouglasRachford/#DRSolver-1">Douglas–Rachford</a></td><td style="text-align: right"><code>DouglasRachford.jl</code></td><td style="text-align: right"><a href="../plans/#Manopt.ProximalProblem"><code>ProximalProblem</code></a>, <a href="DouglasRachford/#Manopt.DouglasRachfordOptions"><code>DouglasRachfordOptions</code></a></td></tr><tr><td style="text-align: right"><a href="subGradientMethod/#SubgradientSolver-1">Subgradient Method</a></td><td style="text-align: right"><code>subGradientMethod.jl</code></td><td style="text-align: right"><a href="../plans/#Manopt.SubGradientProblem"><code>SubGradientProblem</code></a>, <a href="subGradientMethod/#Manopt.SubGradientMethodOptions"><code>SubGradientMethodOptions</code></a></td></tr></table><p>Note that the <a href="../plans/#Manopt.Options"><code>Options</code></a> can also be decorated to enhance your algorithm by general additional properties.</p><h2><a class="nav-anchor" id="StoppingCriteria-1" href="#StoppingCriteria-1">StoppingCriteria</a></h2><p>Stopping criteria are implemented as a <code>functor</code>, i.e. inherit from the base type</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.StoppingCriterion" href="#Manopt.StoppingCriterion"><code>Manopt.StoppingCriterion</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">StoppingCriterion</code></pre><p>An abstract type for the functors representing stoping criteria, i.e. they are callable structures. The naming Scheme follows functions, see for example <a href="#Manopt.stopAfterIteration"><code>stopAfterIteration</code></a>.</p><p>Every StoppingCriterion has to provide a constructor and its function has to have the interface <code>(p,o,i)</code> where a <a href="../plans/#Manopt.Problem"><code>Problem</code></a> as well as <a href="../plans/#Manopt.Options"><code>Options</code></a> and the current number of iterations are the arguments and returns a Bool whether to stop or not.</p><p>By default each <code>StoppingCriterion</code> should provide a fiels <code>reason</code> to provide details when a criteion is met (and that is empty otherwise).</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/plans/options.jl#L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.stopAfter" href="#Manopt.stopAfter"><code>Manopt.stopAfter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">stopAfter &lt;: StoppingCriterion</code></pre><p>store a threshold when to stop looking at the complete runtime. It uses <code>time_ns()</code> to measure the time and you provide a <code>Period</code> as a time limit, i.e. <code>Minute(15)</code></p><p><strong>Constructor</strong></p><pre><code class="language-none">stopAfter(t)</code></pre><p>initialize the stopping criterion to a <code>Period t</code> to stop after.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/plans/stoppingCriterion.jl#L174-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.stopAfterIteration" href="#Manopt.stopAfterIteration"><code>Manopt.stopAfterIteration</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">stopAfterIteration &lt;: StoppingCriterion</code></pre><p>A functor for an easy stopping criterion, i.e. to stop after a maximal number of iterations.</p><p><strong>Fields</strong></p><ul><li><code>maxIter</code> – stores the maximal iteration number where to stop at</li><li><code>reason</code> – stores a reason of stopping if the stopping criterion has one be reached, see <a href="#Manopt.getReason"><code>getReason</code></a>.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">stopAfterIteration(maxIter)</code></pre><p>initialize the stopafterIteration functor to indicate to stop after <code>maxIter</code> iterations.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/plans/stoppingCriterion.jl#L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.stopWhenAll" href="#Manopt.stopWhenAll"><code>Manopt.stopWhenAll</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">stopWhenAll &lt;: StoppingCriterion</code></pre><p>store an array of <a href="#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> elements and indicates to stop, when <em>all</em> indicate to stop. The <code>reseason</code> is given by the concatenation of all reasons.</p><p><strong>Constructor</strong></p><pre><code class="language-none">stopWhenAll(c::Array{StoppingCriterion,1})
stopWhenAll(c::StoppingCriterion,...)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/plans/stoppingCriterion.jl#L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.stopWhenAny" href="#Manopt.stopWhenAny"><code>Manopt.stopWhenAny</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">stopWhenAny &lt;: StoppingCriterion</code></pre><p>store an array of <a href="#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> elements and indicates to stop, when <em>any</em> single one indicates to stop. The <code>reseason</code> is given by the concatenation of all reasons (assuming that all non-indicating return <code>&quot;&quot;</code>).</p><p><strong>Constructor</strong></p><pre><code class="language-none">stopWhenAny(c::Array{StoppingCriterion,1})
stopWhenAny(c::StoppingCriterion,...)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/plans/stoppingCriterion.jl#L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.stopWhenChangeLess" href="#Manopt.stopWhenChangeLess"><code>Manopt.stopWhenChangeLess</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">stopWhenChangeLess &lt;: StoppingCriterion</code></pre><p>stores a threshold when to stop looking at the norm of the change of the optimization variable from within a <a href="../plans/#Manopt.Options"><code>Options</code></a>, i.e <code>o.x</code>. For the storage a <a href="../plans/#Manopt.StoreOptionsAction"><code>StoreOptionsAction</code></a> is used</p><p><strong>Constructor</strong></p><pre><code class="language-none">stopWhenChangeLess(ε[, a])</code></pre><p>initialize the stopping criterion to a threshold <code>ε</code> using the <a href="../plans/#Manopt.StoreOptionsAction"><code>StoreOptionsAction</code></a> <code>a</code>, which is initialized to just store <code>:x</code> by default.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/plans/stoppingCriterion.jl#L66-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.stopWhenCostLess" href="#Manopt.stopWhenCostLess"><code>Manopt.stopWhenCostLess</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">stopWhenCostLess &lt;: StoppingCriterion</code></pre><p>store a threshold when to stop looking at the cost function of the optimization problem from within a <a href="../plans/#Manopt.Problem"><code>Problem</code></a>, i.e <code>getCost(p,o.x)</code>.</p><p><strong>Constructor</strong></p><pre><code class="language-none">stopWhenCostLess(ε)</code></pre><p>initialize the stopping criterion to a threshold <code>ε</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/plans/stoppingCriterion.jl#L149-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.stopWhenGradientNormLess" href="#Manopt.stopWhenGradientNormLess"><code>Manopt.stopWhenGradientNormLess</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">stopWhenGradientNormLess &lt;: StoppingCriterion</code></pre><p>stores a threshold when to stop looking at the norm of the gradient from within a <a href="../plans/#Manopt.GradientProblem"><code>GradientProblem</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/plans/stoppingCriterion.jl#L48-L53">source</a></section><p>as well as the function</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.getReason" href="#Manopt.getReason"><code>Manopt.getReason</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">getReason(o)</code></pre><p>return the current reason stored within the <a href="#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> from within the <a href="../plans/#Manopt.Options"><code>Options</code></a> This reason is empty if the criterion has never been met.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/plans/options.jl#L117">source</a><div><pre><code class="language-none">getReason(c)</code></pre><p>return the current reason stored within a <a href="#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> <code>c</code>. This reason is empty if the criterion has never been met.</p></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/plans/stoppingCriterion.jl#L10">source</a></section><p>further stopping criteria might be available for individual Solvers.</p><h2><a class="nav-anchor" id="DecoratedSolvers-1" href="#DecoratedSolvers-1">Decorated Solvers</a></h2><p>The following decorators are available.</p><h3><a class="nav-anchor" id="DebugSolver-1" href="#DebugSolver-1">Debug Solver</a></h3><p>The decorator to print debug during the iterations can be activated by decorating the <a href="../plans/#Manopt.Options"><code>Options</code></a> with <a href="../plans/#Manopt.DebugOptions"><code>DebugOptions</code></a> and implementing your own <a href="../plans/#Manopt.DebugAction"><code>DebugAction</code></a>s. For example printing a gradient from the <a href="gradientDescent/#Manopt.GradientDescentOptions"><code>GradientDescentOptions</code></a> is automatically available, as explained in the <a href="gradientDescent/#Manopt.steepestDescent"><code>steepestDescent</code></a> solver.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.initializeSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:DebugOptions where P&lt;:Problem" href="#Manopt.initializeSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:DebugOptions where P&lt;:Problem"><code>Manopt.initializeSolver!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">initializeSolver!(p,o)</code></pre><p>Initialize the solver to the optimization <a href="../plans/#Manopt.Problem"><code>Problem</code></a> by initializing all values in the <a href="../plans/#Manopt.DebugOptions"><code>DebugOptions</code></a><code>o</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/debugSolver.jl#L13-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.doSolverStep!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Any}} where O&lt;:DebugOptions where P&lt;:Problem" href="#Manopt.doSolverStep!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Any}} where O&lt;:DebugOptions where P&lt;:Problem"><code>Manopt.doSolverStep!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">doSolverStep!(p,o,iter)</code></pre><p>Do one iteration step (the <code>iter</code>th) for <a href="../plans/#Manopt.Problem"><code>Problem</code></a><code>p</code> by modifying the values in the <a href="../plans/#Manopt.Options"><code>Options</code></a><code>o.options</code> and print <code>Debug</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/debugSolver.jl#L23-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.getSolverResult-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:DebugOptions where P&lt;:Problem" href="#Manopt.getSolverResult-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:DebugOptions where P&lt;:Problem"><code>Manopt.getSolverResult</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getSolverResult(p,o)</code></pre><p>Return the final result after all iterations that is stored within the (modified during the iterations) <a href="../plans/#Manopt.Options"><code>Options</code></a> <code>o</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/debugSolver.jl#L33-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.stopSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Int64}} where O&lt;:DebugOptions where P&lt;:Problem" href="#Manopt.stopSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Int64}} where O&lt;:DebugOptions where P&lt;:Problem"><code>Manopt.stopSolver!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stopSolver!(p,o,i)</code></pre><p>determine whether the solver for <a href="../plans/#Manopt.Problem"><code>Problem</code></a> <code>p</code> and the <a href="../plans/#Manopt.DebugOptions"><code>DebugOptions</code></a> <code>o</code> should stop at iteration <code>i</code>. If so, print all debug from <code>:All</code> and <code>:Final</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/debugSolver.jl#L41-L46">source</a></section><h3><a class="nav-anchor" id="RecordSolver-1" href="#RecordSolver-1">Record Solver</a></h3><p>The decorator to record certain values during the iterations can be activated by decorating the <a href="../plans/#Manopt.Options"><code>Options</code></a> with <a href="../plans/#Manopt.RecordOptions"><code>RecordOptions</code></a> and implementing your own <a href="../plans/#Manopt.RecordAction"><code>RecordAction</code></a>s. For example recording the gradient from the <a href="gradientDescent/#Manopt.GradientDescentOptions"><code>GradientDescentOptions</code></a> is automatically available, as explained in the <a href="gradientDescent/#Manopt.steepestDescent"><code>steepestDescent</code></a> solver.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.initializeSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:RecordOptions where P&lt;:Problem" href="#Manopt.initializeSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:RecordOptions where P&lt;:Problem"><code>Manopt.initializeSolver!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">initializeSolver!(p,o)</code></pre><p>Initialize the solver to the optimization <a href="../plans/#Manopt.Problem"><code>Problem</code></a> by initializing the encapsulated <code>options</code> from within the <a href="../plans/#Manopt.RecordOptions"><code>RecordOptions</code></a><code>o</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/recordSolver.jl#L7-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.doSolverStep!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Any}} where O&lt;:RecordOptions where P&lt;:Problem" href="#Manopt.doSolverStep!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Any}} where O&lt;:RecordOptions where P&lt;:Problem"><code>Manopt.doSolverStep!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">doSolverStep!(p,o,iter)</code></pre><p>Do one iteration step (the <code>iter</code>th) for <a href="../plans/#Manopt.Problem"><code>Problem</code></a><code>p</code> by modifying the values in the <a href="../plans/#Manopt.Options"><code>Options</code></a><code>o.options</code> and record the result(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/recordSolver.jl#L18-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.getSolverResult-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:RecordOptions where P&lt;:Problem" href="#Manopt.getSolverResult-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:RecordOptions where P&lt;:Problem"><code>Manopt.getSolverResult</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getSolverResult(p,o)</code></pre><p>Return the final result after all iterations that is stored within the (modified during the iterations) <a href="../plans/#Manopt.Options"><code>Options</code></a><code>o</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/recordSolver.jl#L29-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.stopSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Int64}} where O&lt;:RecordOptions where P&lt;:Problem" href="#Manopt.stopSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Int64}} where O&lt;:RecordOptions where P&lt;:Problem"><code>Manopt.stopSolver!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stopSolver!(p,o,i)</code></pre><p>determine whether the solver for <a href="../plans/#Manopt.Problem"><code>Problem</code></a> <code>p</code> and the <a href="../plans/#Manopt.RecordOptions"><code>RecordOptions</code></a> <code>o</code> should stop at iteration <code>i</code>.  If so, do a (final) record to <code>:All</code> and <code>:Stop</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/recordSolver.jl#L38-L44">source</a></section><h2><a class="nav-anchor" id="Technical-Details-1" href="#Technical-Details-1">Technical Details</a></h2><p>The main function a solver calls is</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.solve-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:Options where P&lt;:Problem" href="#Manopt.solve-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:Options where P&lt;:Problem"><code>Manopt.solve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">solve(p,o)</code></pre><p>run the solver implemented for the <a href="../plans/#Manopt.Problem"><code>Problem</code></a><code>p</code> and the <a href="../plans/#Manopt.Options"><code>Options</code></a><code>o</code> employing <a href="#Manopt.initializeSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:DebugOptions where P&lt;:Problem"><code>initializeSolver!</code></a>, <a href="#Manopt.doSolverStep!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Any}} where O&lt;:DebugOptions where P&lt;:Problem"><code>doSolverStep!</code></a>, as well as the <a href="#Manopt.stopSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Int64}} where O&lt;:DebugOptions where P&lt;:Problem"><code>stopSolver!</code></a> of the solver.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/solver.jl#L90-L96">source</a></section><p>which is a framework, that you in general should not change or redefine. It uses the following methods, which also need to be implemented on your own algorithm, if you want to provide one.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.initializeSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:Options where P&lt;:Problem" href="#Manopt.initializeSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:Options where P&lt;:Problem"><code>Manopt.initializeSolver!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">initializeSolver!(p,o)</code></pre><p>Initialize the solver to the optimization <a href="../plans/#Manopt.Problem"><code>Problem</code></a> by initializing all values in the <a href="../plans/#Manopt.Options"><code>Options</code></a><code>o</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/solver.jl#L48-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.doSolverStep!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Any}} where O&lt;:Options where P&lt;:Problem" href="#Manopt.doSolverStep!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Any}} where O&lt;:Options where P&lt;:Problem"><code>Manopt.doSolverStep!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">doSolverStep!(p,o,iter)</code></pre><p>Do one iteration step (the <code>iter</code>th) for <a href="../plans/#Manopt.Problem"><code>Problem</code></a><code>p</code> by modifying the values in the <a href="../plans/#Manopt.Options"><code>Options</code></a> <code>o</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/solver.jl#L59-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.getSolverResult-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:Options where P&lt;:Problem" href="#Manopt.getSolverResult-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O&lt;:Options where P&lt;:Problem"><code>Manopt.getSolverResult</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getSolverResult(p,o)</code></pre><p>Return the final result after all iterations that is stored within the (modified during the iterations) <a href="../plans/#Manopt.Options"><code>Options</code></a> <code>o</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/solver.jl#L70-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manopt.stopSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Int64}} where O&lt;:Options where P&lt;:Problem" href="#Manopt.stopSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Int64}} where O&lt;:Options where P&lt;:Problem"><code>Manopt.stopSolver!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stopSolver!(p,o,i)</code></pre><p>depending on the current <a href="../plans/#Manopt.Problem"><code>Problem</code></a> <code>p</code>, the current state of the solver stored in <a href="../plans/#Manopt.Options"><code>Options</code></a> <code>o</code> and the current iterate <code>i</code> this function determines whether to stop the solver by calling the <a href="#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kellertuer/Manopt.jl/blob/fec4a245acae4c975df392611a9cb763fd522e52/src/solvers/solver.jl#L81-L87">source</a></section><footer><hr/><a class="previous" href="../plans/"><span class="direction">Previous</span><span class="title">Plans</span></a><a class="next" href="cyclicProximalPoint/"><span class="direction">Next</span><span class="title">Cyclic Proximal Point</span></a></footer></article></body></html>
