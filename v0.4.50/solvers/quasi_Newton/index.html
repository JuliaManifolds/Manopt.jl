<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quasi-Newton ¬∑ Manopt.jl</title><meta name="title" content="Quasi-Newton ¬∑ Manopt.jl"/><meta property="og:title" content="Quasi-Newton ¬∑ Manopt.jl"/><meta property="twitter:title" content="Quasi-Newton ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/Optimize/">üèîÔ∏è Get started: optimize.</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../../tutorials/EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../../tutorials/HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../../tutorials/ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do constrained optimization</a></li><li><a class="tocitem" href="../../tutorials/GeodesicRegression/">Do geodesic regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="../exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="../NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="../particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li class="is-active"><a class="tocitem" href>Quasi-Newton</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Direction-updates"><span>Direction updates</span></a></li><li><a class="tocitem" href="#Hessian-update-rules"><span>Hessian update rules</span></a></li><li><a class="tocitem" href="#State"><span>State</span></a></li><li><a class="tocitem" href="#sec-qn-technical-details"><span>Technical details</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../../plans/problem/">Problem</a></li><li><a class="tocitem" href="../../plans/objective/">Objective</a></li><li><a class="tocitem" href="../../plans/state/">Solver State</a></li><li><a class="tocitem" href="../../plans/stepsize/">Stepsize</a></li><li><a class="tocitem" href="../../plans/stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../../plans/debug/">Debug Output</a></li><li><a class="tocitem" href="../../plans/record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>Quasi-Newton</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quasi-Newton</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/solvers/quasi_Newton.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="quasiNewton"><a class="docs-heading-anchor" href="#quasiNewton">Riemannian quasi-Newton methods</a><a id="quasiNewton-1"></a><a class="docs-heading-anchor-permalink" href="#quasiNewton" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.quasi_Newton" href="#Manopt.quasi_Newton"><code>Manopt.quasi_Newton</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quasi_Newton(M, f, grad_f, p)</code></pre><p>Perform a quasi Newton iteration for <code>f</code> on the manifold <code>M</code> starting in the point <code>p</code>.</p><p>The <span>$k$</span>th iteration consists of</p><ol><li>Compute the search direction <span>$Œ∑_k = -\mathcal{B}_k [\operatorname{grad}f (p_k)]$</span> or solve <span>$\mathcal{H}_k [Œ∑_k] = -\operatorname{grad}f (p_k)]$</span>.</li><li>Determine a suitable stepsize <span>$Œ±_k$</span> along the curve <span>$\gamma(Œ±) = R_{p_k}(Œ± Œ∑_k)$</span> e.g. by using <a href="../../plans/stepsize/#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a>.</li><li>Compute <code>p_{k+1} = R_{p_k}(Œ±_k Œ∑_k)</code>`.</li><li>Define <span>$s_k = T_{p_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k)$</span> and <span>$y_k = \operatorname{grad}f(p_{k+1}) - T_{p_k, Œ±_k Œ∑_k}(\operatorname{grad}f(p_k))$</span>.</li><li>Compute the new approximate Hessian <span>$H_{k+1}$</span> or its inverse <span>$B_k$</span>.</li></ol><p><strong>Input</strong></p><ul><li><code>M</code>      a manifold <span>$\mathcal{M}$</span>.</li><li><code>f</code>      a cost function <span>$F : \mathcal{M} ‚Üí‚Ñù$</span> to minimize.</li><li><code>grad_f</code> the gradient <span>$\operatorname{grad}F : \mathcal{M} ‚ÜíT_x\mathcal M$</span> of <span>$F$</span>.</li><li><code>p</code>      an initial value <span>$p ‚àà \mathcal{M}$</span>.</li></ul><p><strong>Optional</strong></p><ul><li><code>basis</code>                   (<code>DefaultOrthonormalBasis()</code>) basis within the tangent space(s)</li></ul><p>to represent the Hessian (inverse).</p><ul><li><code>cautious_update</code>         (<code>false</code>) ‚Äì whether or not to use a <a href="#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>QuasiNewtonCautiousDirectionUpdate</code></a></li><li><code>cautious_function</code>       (<code>(x) -&gt; x*10^(-4)</code>) ‚Äì a monotone increasing function that is zero at 0 and strictly increasing at 0 for the cautious update.</li><li><code>direction_update</code>        (<a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a><code>()</code>) the update rule to use.</li><li><code>evaluation</code>              (<a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) specify whether the gradient works by  allocation (default) form <code>gradF(M, x)</code> or <a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> in place, i.e.  is of the form <code>gradF!(M, X, x)</code>.</li><li><code>initial_operator</code>        (<code>Matrix{Float64}(I,n,n)</code>) initial matrix to use die the approximation, where <code>n=manifold_dimension(M)</code>, see also <code>scale_initial_operator</code>.</li><li><code>memory_size</code>             (<code>20</code>) limited memory, number of <span>$s_k, y_k$</span> to store. Set to a negative value to use a full memory representation</li><li><code>retraction_method</code>       (<code>default_retraction_method(M, typeof(p))</code>) a retraction method to use</li><li><code>scale_initial_operator</code>  (<code>true</code>) scale initial operator with <span>$\frac{‚ü®s_k,y_k‚ü©_{p_k}}{\lVert y_k\rVert_{p_k}}$</span> in the computation</li><li><code>stabilize</code>               (<code>true</code>) stabilize the method numerically by projecting computed (Newton-) directions to the tangent space to reduce numerical errors</li><li><code>stepsize</code>                (<a href="../../plans/stepsize/#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a><code>(retraction_method, vector_transport_method)</code>) specify a <a href="../../plans/stepsize/#Manopt.Stepsize"><code>Stepsize</code></a>.</li><li><code>stopping_criterion</code>      (<a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(max(1000, memory_size)) |</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenGradientNormLess"><code>StopWhenGradientNormLess</code></a><code>(1e-6)</code>) specify a <a href="../../plans/stopping_criteria/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a></li><li><code>vector_transport_method</code> (<code>default_vector_transport_method(M, typeof(p))</code>) a vector transport to use.</li></ul><p><strong>Output</strong></p><p>the obtained (approximate) minimizer <span>$p^*$</span>, see <a href="../#Manopt.get_solver_return"><code>get_solver_return</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/solvers/quasi_Newton.jl#L155-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.quasi_Newton!" href="#Manopt.quasi_Newton!"><code>Manopt.quasi_Newton!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quasi_Newton!(M, F, gradF, x; options...)</code></pre><p>Perform a quasi Newton iteration for <code>F</code> on the manifold <code>M</code> starting in the point <code>x</code> using a retraction <span>$R$</span> and a vector transport <span>$T$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code>     a manifold <span>$\mathcal{M}$</span>.</li><li><code>F</code>     a cost function <span>$F: \mathcal{M} ‚Üí‚Ñù$</span> to minimize.</li><li><code>gradF</code> the gradient <span>$\operatorname{grad}F : \mathcal{M} ‚Üí T_x\mathcal M$</span> of <span>$F$</span> implemented as <code>gradF(M,p)</code>.</li><li><code>x</code>     an initial value <span>$x ‚àà \mathcal{M}$</span>.</li></ul><p>For all optional parameters, see <a href="#Manopt.quasi_Newton"><code>quasi_Newton</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/solvers/quasi_Newton.jl#L240-L253">source</a></section></article><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>The aim is to minimize a real-valued function on a Riemannian manifold, that is</p><p class="math-container">\[\min f(x), \quad x ‚àà \mathcal{M}.\]</p><p>Riemannian quasi-Newtonian methods are as generalizations of their Euclidean counterparts Riemannian line search methods. These methods determine a search direction <span>$Œ∑_k ‚àà T_{x_k} \mathcal{M}$</span> at the current iterate <span>$x_k$</span> and a suitable stepsize <span>$Œ±_k$</span> along <span>$\gamma(Œ±) = R_{x_k}(Œ± Œ∑_k)$</span>, where <span>$R: T \mathcal{M} ‚Üí\mathcal{M}$</span> is a retraction. The next iterate is obtained by</p><p class="math-container">\[x_{k+1} = R_{x_k}(Œ±_k Œ∑_k).\]</p><p>In quasi-Newton methods, the search direction is given by</p><p class="math-container">\[Œ∑_k = -{\mathcal{H}_k}^{-1}[\operatorname{grad}f (x_k)] = -\mathcal{B}_k [\operatorname{grad} (x_k)],\]</p><p>where <span>$\mathcal{H}_k : T_{x_k} \mathcal{M} ‚ÜíT_{x_k} \mathcal{M}$</span> is a positive definite self-adjoint operator, which approximates the action of the Hessian <span>$\operatorname{Hess} f (x_k)[‚ãÖ]$</span> and <span>$\mathcal{B}_k = {\mathcal{H}_k}^{-1}$</span>. The idea of quasi-Newton methods is instead of creating a complete new approximation of the Hessian operator <span>$\operatorname{Hess} f(x_{k+1})$</span> or its inverse at every iteration, the previous operator <span>$\mathcal{H}_k$</span> or <span>$\mathcal{B}_k$</span> is updated by a convenient formula using the obtained information about the curvature of the objective function during the iteration. The resulting operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> acts on the tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span> of the freshly computed iterate <span>$x_{k+1}$</span>. In order to get a well-defined method, the following requirements are placed on the new operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> that is created by an update. Since the Hessian <span>$\operatorname{Hess} f(x_{k+1})$</span> is a self-adjoint operator on the tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>, and <span>$\mathcal{H}_{k+1}$</span> approximates it, one requirement is, that <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> is also self-adjoint on <span>$T_{x_{k+1}} \mathcal{M}$</span>. In order to achieve a steady descent, the next requirement is that <span>$Œ∑_k$</span> is a descent direction in each iteration. Hence a further requirement is that <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> is a positive definite operator on <span>$T_{x_{k+1}} \mathcal{M}$</span>. In order to get information about the curvature of the objective function into the new operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span>, the last requirement is a form of a Riemannian quasi-Newton equation:</p><p class="math-container">\[\mathcal{H}_{k+1} [T_{x_k \rightarrow x_{k+1}}({R_{x_k}}^{-1}(x_{k+1}))] = \operatorname{grad}(x_{k+1}) - T_{x_k \rightarrow x_{k+1}}(\operatorname{grad}f(x_k))\]</p><p>or</p><p class="math-container">\[\mathcal{B}_{k+1} [\operatorname{grad}f(x_{k+1}) - T_{x_k \rightarrow x_{k+1}}(\operatorname{grad}f(x_k))] = T_{x_k \rightarrow x_{k+1}}({R_{x_k}}^{-1}(x_{k+1}))\]</p><p>where <span>$T_{x_k \rightarrow x_{k+1}} : T_{x_k} \mathcal{M} ‚ÜíT_{x_{k+1}} \mathcal{M}$</span> and the chosen retraction <span>$R$</span> is the associated retraction of <span>$T$</span>. Note that, of course, not all updates in all situations meet these conditions in every iteration. For specific quasi-Newton updates, the fulfilment of the Riemannian curvature condition, which requires that</p><p class="math-container">\[g_{x_{k+1}}(s_k, y_k) &gt; 0\]</p><p>holds, is a requirement for the inheritance of the self-adjointness and positive definiteness of the <span>$\mathcal{H}_k$</span> or <span>$\mathcal{B}_k$</span> to the operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span>. Unfortunately, the fulfilment of the Riemannian curvature condition is not given by a step size <span>$\alpha_k &gt; 0$</span> that satisfies the generalized Wolfe conditions. However, to create a positive definite operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> in each iteration, the so-called locking condition was introduced in [<a href="../../references/#HuangGallivanAbsil:2015">HGA15</a>], which requires that the isometric vector transport <span>$T^S$</span>, which is used in the update formula, and its associate retraction <span>$R$</span> fulfil</p><p class="math-container">\[T^{S}{x, Œæ_x}(Œæ_x) = Œ≤ T^{R}{x, Œæ_x}(Œæ_x), \quad Œ≤ = \frac{\lVert Œæ_x \rVert_x}{\lVert T^{R}{x, Œæ_x}(Œæ_x) \rVert_{R_{x}(Œæ_x)}},\]</p><p>where <span>$T^R$</span> is the vector transport by differentiated retraction. With the requirement that the isometric vector transport <span>$T^S$</span> and its associated retraction <span>$R$</span> satisfies the locking condition and using the tangent vector</p><p class="math-container">\[y_k = {Œ≤_k}^{-1} \operatorname{grad}f(x_{k+1}) - T^{S}{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)),\]</p><p>where</p><p class="math-container">\[Œ≤_k = \frac{\lVert Œ±_k Œ∑_k \rVert_{x_k}}{\lVert T^{R}{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \rVert_{x_{k+1}}},\]</p><p>in the update, it can be shown that choosing a stepsize <span>$Œ±_k &gt; 0$</span> that satisfies the Riemannian Wolfe conditions leads to the fulfilment of the Riemannian curvature condition, which in turn implies that the operator generated by the updates is positive definite. In the following the specific operators are denoted in matrix notation and hence use <span>$H_k$</span> and <span>$B_k$</span>, respectively.</p><h2 id="Direction-updates"><a class="docs-heading-anchor" href="#Direction-updates">Direction updates</a><a id="Direction-updates-1"></a><a class="docs-heading-anchor-permalink" href="#Direction-updates" title="Permalink"></a></h2><p>In general there are different ways to compute a fixed <a href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a>. In general these are represented by</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractQuasiNewtonDirectionUpdate" href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>Manopt.AbstractQuasiNewtonDirectionUpdate</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractQuasiNewtonDirectionUpdate</code></pre><p>An abstract representation of an Quasi Newton Update rule to determine the next direction given current <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>.</p><p>All subtypes should be functors, i.e. one should be able to call them as <code>H(M,x,d)</code> to compute a new direction update.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonMatrixDirectionUpdate" href="#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>Manopt.QuasiNewtonMatrixDirectionUpdate</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonMatrixDirectionUpdate &lt;: AbstractQuasiNewtonDirectionUpdate</code></pre><p>The <code>QuasiNewtonMatrixDirectionUpdate</code> representa a quasi-Newton update rule, where the operator is stored as a matrix. A distinction is made between the update of the approximation of the Hessian, <span>$H_k \mapsto H_{k+1}$</span>, and the update of the approximation of the Hessian inverse, <span>$B_k \mapsto B_{k+1}$</span>. For the first case, the coordinates of the search direction <span>$Œ∑_k$</span> with respect to a basis <span>$\{b_i\}^{n}_{i=1}$</span> are determined by solving a linear system of equations</p><p class="math-container">\[\text{Solve} \quad \hat{Œ∑_k} = - H_k \widehat{\operatorname{grad}f(x_k)},\]</p><p>where <span>$H_k$</span> is the matrix representing the operator with respect to the basis <span>$\{b_i\}^{n}_{i=1}$</span> and <span>$\widehat{\operatorname{grad}f(x_k)}$</span> represents the coordinates of the gradient of the objective function <span>$f$</span> in <span>$x_k$</span> with respect to the basis <span>$\{b_i\}^{n}_{i=1}$</span>. If a method is chosen where Hessian inverse is approximated, the coordinates of the search direction <span>$Œ∑_k$</span> with respect to a basis <span>$\{b_i\}^{n}_{i=1}$</span> are obtained simply by matrix-vector multiplication</p><p class="math-container">\[\hat{Œ∑_k} = - B_k \widehat{\operatorname{grad}f(x_k)},\]</p><p>where <span>$B_k$</span> is the matrix representing the operator with respect to the basis <span>$\{b_i\}^{n}_{i=1}$</span> and <span>$\widehat{\operatorname{grad}f(x_k)}$</span> as above. In the end, the search direction <span>$Œ∑_k$</span> is generated from the coordinates <span>$\hat{eta_k}$</span> and the vectors of the basis <span>$\{b_i\}^{n}_{i=1}$</span> in both variants. The <a href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a> indicates which quasi-Newton update rule is used. In all of them, the Euclidean update formula is used to generate the matrix <span>$H_{k+1}$</span> and <span>$B_{k+1}$</span>, and the basis <span>$\{b_i\}^{n}_{i=1}$</span> is transported into the upcoming tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>, preferably with an isometric vector transport, or generated there.</p><p><strong>Provided functors</strong></p><ul><li><code>(mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction</li><li><code>(Œ∑, mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction inplace of <code>Œ∑</code></li></ul><p><strong>Fields</strong></p><ul><li><code>basis</code>                   an <code>AbstractBasis</code> to use in the tangent spaces</li><li><code>matrix</code>                  (<code>Matrix{Float64}(I, manifold_dimension(M), manifold_dimension(M))</code>) the matrix which represents the approximating operator.</li><li><code>scale</code>                   (`true) indicates whether the initial matrix (= identity matrix) should be scaled before the first update.</li><li><code>update</code>                  a <a href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a>.</li><li><code>vector_transport_method</code> (<code>vector_transport_method</code>)an <code>AbstractVectorTransportMethod</code></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonMatrixDirectionUpdate(
    M::AbstractManifold,
    update,
    basis::B=DefaultOrthonormalBasis(),
    m=Matrix{Float64}(I, manifold_dimension(M), manifold_dimension(M));
    kwargs...
)</code></pre><p><strong>Keyword Arguments</strong></p><ul><li><code>scale</code>, <code>vector_transport_method</code> for the two fields above</li></ul><p>Generate the Update rule with defaults from a manifold and the names corresponding to the fields above.</p><p><strong>See also</strong></p><p><a href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a> <a href="#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>QuasiNewtonCautiousDirectionUpdate</code></a> <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L287-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonLimitedMemoryDirectionUpdate" href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>Manopt.QuasiNewtonLimitedMemoryDirectionUpdate</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonLimitedMemoryDirectionUpdate &lt;: AbstractQuasiNewtonDirectionUpdate</code></pre><p>This <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> represents the limited-memory Riemannian BFGS update, where the approximating operator is represented by <span>$m$</span> stored pairs of tangent vectors <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m}^{k-1}$</span> in the <span>$k$</span>-th iteration. For the calculation of the search direction <span>$Œ∑_k$</span>, the generalisation of the two-loop recursion is used (see <a href="../../references/#HuangGallivanAbsil:2015">Huang, Gallican, Absil, SIAM J. Optim., 2015</a>), since it only requires inner products and linear combinations of tangent vectors in <span>$T_{x_k} \mathcal{M}$</span>. For that the stored pairs of tangent vectors <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m}^{k-1}$</span>, the gradient <span>$\operatorname{grad}f(x_k)$</span> of the objective function <span>$f$</span> in <span>$x_k$</span> and the positive definite self-adjoint operator</p><p class="math-container">\[\mathcal{B}^{(0)}_k[‚ãÖ] = \frac{g_{x_k}(s_{k-1}, y_{k-1})}{g_{x_k}(y_{k-1}, y_{k-1})} \; \mathrm{id}_{T_{x_k} \mathcal{M}}[‚ãÖ]\]</p><p>are used. The two-loop recursion can be understood as that the <a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a> update is executed <span>$m$</span> times in a row on <span>$\mathcal{B}^{(0)}_k[‚ãÖ]$</span> using the tangent vectors <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m}^{k-1}$</span>, and in the same time the resulting operator <span>$\mathcal{B}^{LRBFGS}_k [‚ãÖ]$</span> is directly applied on <span>$\operatorname{grad}f(x_k)$</span>. When updating there are two cases: if there is still free memory, i.e. <span>$k &lt; m$</span>, the previously stored vector pairs <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m}^{k-1}$</span> have to be transported into the upcoming tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>; if there is no free memory, the oldest pair <span>$\{ \widetilde{s}_{k‚àím}, \widetilde{y}_{k‚àím}\}$</span> has to be discarded and then all the remaining vector pairs <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m+1}^{k-1}$</span> are transported into the tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>. After that we calculate and store <span>$s_k = \widetilde{s}_k = T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k)$</span> and <span>$y_k = \widetilde{y}_k$</span>. This process ensures that new information about the objective function is always included and the old, probably no longer relevant, information is discarded.</p><p><strong>Provided functors</strong></p><ul><li><code>(mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction</li><li><code>(Œ∑, mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction inplace of <code>Œ∑</code></li></ul><p><strong>Fields</strong></p><ul><li><code>memory_s</code>                the set of the stored (and transported) search directions times step size <span>$\{ \widetilde{s}_i\}_{i=k-m}^{k-1}$</span>.</li><li><code>memory_y</code>                set of the stored gradient differences <span>$\{ \widetilde{y}_i\}_{i=k-m}^{k-1}$</span>.</li><li><code>Œæ</code>                       a variable used in the two-loop recursion.</li><li><code>œÅ</code>                       a variable used in the two-loop recursion.</li><li><code>scale</code>                   initial scaling of the Hessian</li><li><code>vector_transport_method</code> a <code>AbstractVectorTransportMethod</code></li><li><code>message</code>                 a string containing a potential warning that might have appeared</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonLimitedMemoryDirectionUpdate(
    M::AbstractManifold,
    x,
    update::AbstractQuasiNewtonUpdateRule,
    memory_size;
    initial_vector=zero_vector(M,x),
    scale::Real=1.0
    project::Bool=true
)</code></pre><p><strong>See also</strong></p><p><a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a> <a href="#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>QuasiNewtonCautiousDirectionUpdate</code></a> <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L417-L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonCautiousDirectionUpdate" href="#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>Manopt.QuasiNewtonCautiousDirectionUpdate</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonCautiousDirectionUpdate &lt;: AbstractQuasiNewtonDirectionUpdate</code></pre><p>These <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a>s represent any quasi-Newton update rule, which are based on the idea of a so-called cautious update. The search direction is calculated as given in <a href="#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> or <a href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a>, butut the update  then is only executed if</p><p class="math-container">\[\frac{g_{x_{k+1}}(y_k,s_k)}{\lVert s_k \rVert^{2}_{x_{k+1}}} \geq \theta(\lVert \operatorname{grad}f(x_k) \rVert_{x_k}),\]</p><p>is satisfied, where <span>$\theta$</span> is a monotone increasing function satisfying <span>$\theta(0) = 0$</span> and <span>$\theta$</span> is strictly increasing at <span>$0$</span>. If this is not the case, the corresponding update will be skipped, which means that for <a href="#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> the matrix <span>$H_k$</span> or <span>$B_k$</span> is not updated. The basis <span>$\{b_i\}^{n}_{i=1}$</span> is nevertheless transported into the upcoming tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>, and for <a href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a> neither the oldest vector pair <span>$\{ \widetilde{s}_{k‚àím}, \widetilde{y}_{k‚àím}\}$</span> is discarded nor the newest vector pair <span>$\{ \widetilde{s}_{k}, \widetilde{y}_{k}\}$</span> is added into storage, but all stored vector pairs <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m}^{k-1}$</span> are transported into the tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>. If <a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a> or <a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a> is chosen as update, then the resulting method follows the method of <a href="../../references/#HuangAbsilGallivan:2018">Huang, Absil, Gallivan, SIAM J. Optim., 2018</a>, taking into account that the corresponding step size is chosen.</p><p><strong>Provided functors</strong></p><ul><li><code>(mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction</li><li><code>(Œ∑, mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction inplace of <code>Œ∑</code></li></ul><p><strong>Fields</strong></p><ul><li><code>update</code> ‚Äì an <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a></li><li><code>Œ∏</code> ‚Äì a monotone increasing function satisfying <span>$Œ∏(0) = 0$</span> and <span>$Œ∏$</span> is strictly increasing at <span>$0$</span>.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonCautiousDirectionUpdate(U::QuasiNewtonMatrixDirectionUpdate; Œ∏ = x -&gt; x)
QuasiNewtonCautiousDirectionUpdate(U::QuasiNewtonLimitedMemoryDirectionUpdate; Œ∏ = x -&gt; x)</code></pre><p>Generate a cautious update for either a matrix based or a limited memorz based update rule.</p><p><strong>See also</strong></p><p><a href="#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> <a href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L580-L627">source</a></section></article><h2 id="Hessian-update-rules"><a class="docs-heading-anchor" href="#Hessian-update-rules">Hessian update rules</a><a id="Hessian-update-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Hessian-update-rules" title="Permalink"></a></h2><p>Using</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.update_hessian!" href="#Manopt.update_hessian!"><code>Manopt.update_hessian!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_hessian!(d, amp, st, p_old, iter)</code></pre><p>update the hessian within the <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a> <code>o</code> given a <a href="../../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> as well as the an <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> <code>d</code> and the last iterate <code>p_old</code>. Note that the current (<code>iter</code>th) iterate is already stored in <code>o.x</code>.</p><p>See also <a href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a> for the different rules that are available within <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/solvers/quasi_Newton.jl#L384-L393">source</a></section></article><p>the following update formulae for either <span>$H_{k+1}$</span> or <span>$B_{k+1}$</span> are available.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractQuasiNewtonUpdateRule" href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>Manopt.AbstractQuasiNewtonUpdateRule</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractQuasiNewtonUpdateRule</code></pre><p>Specify a type for the different <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a>s, that is, e.g. for a <a href="#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> there are several different updates to the matrix, while the default for <a href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a> the most prominent is <a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.BFGS" href="#Manopt.BFGS"><code>Manopt.BFGS</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BFGS &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian BFGS update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{H}_k^\mathrm{BFGS}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{BFGS}_{k+1} = \widetilde{H}^\mathrm{BFGS}_k  + \frac{y_k y^{\mathrm{T}}_k }{s^{\mathrm{T}}_k y_k} - \frac{\widetilde{H}^\mathrm{BFGS}_k s_k s^{\mathrm{T}}_k \widetilde{H}^\mathrm{BFGS}_k }{s^{\mathrm{T}}_k \widetilde{H}^\mathrm{BFGS}_k s_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.DFP" href="#Manopt.DFP"><code>Manopt.DFP</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DFP &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in an <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian DFP update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{H}_k^\mathrm{DFP}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{DFP}_{k+1} = \Bigl(
  \mathrm{id}_{T_{x_{k+1}} \mathcal{M}} - \frac{y_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
\Bigr)
\widetilde{H}^\mathrm{DFP}_k
\Bigl(
  \mathrm{id}_{T_{x_{k+1}} \mathcal{M}} - \frac{s_k y^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
\Bigr) + \frac{y_k y^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L74-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.Broyden" href="#Manopt.Broyden"><code>Manopt.Broyden</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Broyden &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian Broyden update is used in the Riemannian quasi-Newton method, which is as a convex combination of <a href="#Manopt.BFGS"><code>BFGS</code></a> and <a href="#Manopt.DFP"><code>DFP</code></a>.</p><p>We denote by <span>$\widetilde{H}_k^\mathrm{Br}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{Br}_{k+1} = \widetilde{H}^\mathrm{Br}_k
  - \frac{\widetilde{H}^\mathrm{Br}_k s_k s^{\mathrm{T}}_k \widetilde{H}^\mathrm{Br}_k}{s^{\mathrm{T}}_k \widetilde{H}^\mathrm{Br}_k s_k} + \frac{y_k y^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
  + œÜ_k s^{\mathrm{T}}_k \widetilde{H}^\mathrm{Br}_k s_k
  \Bigl(
        \frac{y_k}{s^{\mathrm{T}}_k y_k} - \frac{\widetilde{H}^\mathrm{Br}_k s_k}{s^{\mathrm{T}}_k \widetilde{H}^\mathrm{Br}_k s_k}
  \Bigr)
  \Bigl(
        \frac{y_k}{s^{\mathrm{T}}_k y_k} - \frac{\widetilde{H}^\mathrm{Br}_k s_k}{s^{\mathrm{T}}_k \widetilde{H}^\mathrm{Br}_k s_k}
  \Bigr)^{\mathrm{T}}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal{M},\]</p><p>respectively, and <span>$œÜ_k$</span> is the Broyden factor which is <code>:constant</code> by default but can also be set to <code>:Davidon</code>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">Broyden(œÜ, update_rule::Symbol = :constant)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L208-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.SR1" href="#Manopt.SR1"><code>Manopt.SR1</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SR1 &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian SR1 update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{H}_k^\mathrm{SR1}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{SR1}_{k+1} = \widetilde{H}^\mathrm{SR1}_k
+ \frac{
  (y_k - \widetilde{H}^\mathrm{SR1}_k s_k) (y_k - \widetilde{H}^\mathrm{SR1}_k s_k)^{\mathrm{T}}
}{
(y_k - \widetilde{H}^\mathrm{SR1}_k s_k)^{\mathrm{T}} s_k
}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p><p>This method can be stabilized by only performing the update if denominator is larger than <span>$r\lVert s_k\rVert_{x_{k+1}}\lVert y_k - \widetilde{H}^\mathrm{SR1}_k s_k \rVert_{x_{k+1}}$</span> for some <span>$r&gt;0$</span>. For more details, see Section 6.2 in <a href="../../references/#NocedalWright:2006">Nocedal, Wright, Springer, 2006</a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SR1(r::Float64=-1.0)</code></pre><p>Generate the <code>SR1</code> update, which by default does not include the check (since the default sets <span>$t&lt;0$</span>`)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L127-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseBFGS" href="#Manopt.InverseBFGS"><code>Manopt.InverseBFGS</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InverseBFGS &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the inverse Riemannian BFGS update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{B}_k^\mathrm{BFGS}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{BFGS}_{k+1}  = \Bigl(
  \mathrm{id}_{T_{x_{k+1}} \mathcal{M}} - \frac{s_k y^{\mathrm{T}}_k }{s^{\mathrm{T}}_k y_k}
\Bigr)
\widetilde{B}^\mathrm{BFGS}_k
\Bigl(
  \mathrm{id}_{T_{x_{k+1}} \mathcal{M}} - \frac{y_k s^{\mathrm{T}}_k }{s^{\mathrm{T}}_k y_k}
\Bigr) + \frac{s_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L45-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseDFP" href="#Manopt.InverseDFP"><code>Manopt.InverseDFP</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InverseDFP &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the inverse Riemannian DFP update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{B}_k^\mathrm{DFP}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{DFP}_{k+1} = \widetilde{B}^\mathrm{DFP}_k + \frac{s_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
  - \frac{\widetilde{B}^\mathrm{DFP}_k y_k y^{\mathrm{T}}_k \widetilde{B}^\mathrm{DFP}_k}{y^{\mathrm{T}}_k \widetilde{B}^\mathrm{DFP}_k y_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L103-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseBroyden" href="#Manopt.InverseBroyden"><code>Manopt.InverseBroyden</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InverseBroyden &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>Indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian Broyden update is used in the Riemannian quasi-Newton method, which is as a convex combination of <a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a> and <a href="#Manopt.InverseDFP"><code>InverseDFP</code></a>.</p><p>We denote by <span>$\widetilde{H}_k^\mathrm{Br}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{Br}_{k+1} = \widetilde{B}^\mathrm{Br}_k
 - \frac{\widetilde{B}^\mathrm{Br}_k y_k y^{\mathrm{T}}_k \widetilde{B}^\mathrm{Br}_k}{y^{\mathrm{T}}_k \widetilde{B}^\mathrm{Br}_k y_k}
   + \frac{s_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
 + œÜ_k y^{\mathrm{T}}_k \widetilde{B}^\mathrm{Br}_k y_k
 \Bigl(
     \frac{s_k}{s^{\mathrm{T}}_k y_k} - \frac{\widetilde{B}^\mathrm{Br}_k y_k}{y^{\mathrm{T}}_k \widetilde{B}^\mathrm{Br}_k y_k}
    \Bigr) \Bigl(
        \frac{s_k}{s^{\mathrm{T}}_k y_k} - \frac{\widetilde{B}^\mathrm{Br}_k y_k}{y^{\mathrm{T}}_k \widetilde{B}^\mathrm{Br}_k y_k}
 \Bigr)^{\mathrm{T}}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal{M},\]</p><p>respectively, and <span>$œÜ_k$</span> is the Broyden factor which is <code>:constant</code> by default but can also be set to <code>:Davidon</code>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">InverseBroyden(œÜ, update_rule::Symbol = :constant)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L246-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseSR1" href="#Manopt.InverseSR1"><code>Manopt.InverseSR1</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InverseSR1 &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the inverse Riemannian SR1 update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{B}_k^\mathrm{SR1}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{SR1}_{k+1} = \widetilde{B}^\mathrm{SR1}_k
+ \frac{
  (s_k - \widetilde{B}^\mathrm{SR1}_k y_k) (s_k - \widetilde{B}^\mathrm{SR1}_k y_k)^{\mathrm{T}}
}{
  (s_k - \widetilde{B}^\mathrm{SR1}_k y_k)^{\mathrm{T}} y_k
}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p><p>This method can be stabilized by only performing the update if denominator is larger than <span>$r\lVert y_k\rVert_{x_{k+1}}\lVert s_k - \widetilde{H}^\mathrm{SR1}_k y_k \rVert_{x_{k+1}}$</span> for some <span>$r&gt;0$</span>. For more details, see Section 6.2 in <a href="../../references/#NocedalWright:2006">Nocedal, Wright, Springer, 2006</a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">InverseSR1(r::Float64=-1.0)</code></pre><p>Generate the <code>InverseSR1</code> update, which by default does not include the check, since the default sets <span>$t&lt;0$</span>`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/plans/quasi_newton_plan.jl#L167-L202">source</a></section></article><h2 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h2><p>The quasi Newton algorithm is based on a <a href="../../plans/problem/#Manopt.DefaultManoptProblem"><code>DefaultManoptProblem</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonState" href="#Manopt.QuasiNewtonState"><code>Manopt.QuasiNewtonState</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonState &lt;: AbstractManoptSolverState</code></pre><p>These Quasi Newton <a href="../../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> represent any quasi-Newton based method and can be used with any update rule for the direction.</p><p><strong>Fields</strong></p><ul><li><code>p</code>                 the current iterate, a point on a manifold</li><li><code>X</code>                 the current gradient</li><li><code>sk</code>                the current step</li><li><code>yk</code>                the current gradient difference</li><li><code>direction_update</code>  an <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> rule.</li><li><code>retraction_method</code> an <code>AbstractRetractionMethod</code></li><li><code>stop</code>              a <a href="../../plans/stopping_criteria/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a></li></ul><p>as well as for internal use</p><ul><li><code>p_old</code>             the last iterate</li><li><code>Œ∑</code>                 the current update direction</li><li><code>X_old</code>             the last gradient</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonState(
    M::AbstractManifold,
    x;
    initial_vector=zero_vector(M,x),
    direction_update::D=QuasiNewtonLimitedMemoryDirectionUpdate(M, x, InverseBFGS(), 20;
        vector_transport_method=vector_transport_method,
    )
    stopping_criterion=StopAfterIteration(1000) | StopWhenGradientNormLess(1e-6),
    retraction_method::RM=default_retraction_method(M, typeof(p)),
    vector_transport_method::VTM=default_vector_transport_method(M, typeof(p)),
    stepsize=default_stepsize(M; QuasiNewtonState)
)</code></pre><p><strong>See also</strong></p><p><a href="#Manopt.quasi_Newton"><code>quasi_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/b3893400a15d5bdf2b7e58d5419d9db8db2c881f/src/solvers/quasi_Newton.jl#L1-L41">source</a></section></article><h2 id="sec-qn-technical-details"><a class="docs-heading-anchor" href="#sec-qn-technical-details">Technical details</a><a id="sec-qn-technical-details-1"></a><a class="docs-heading-anchor-permalink" href="#sec-qn-technical-details" title="Permalink"></a></h2><p>The <a href="#Manopt.quasi_Newton"><code>quasi_Newton</code></a> solver requires the following functions of a manifold to be available</p><ul><li>A <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/"><code>retract!</code></a><code>(M, q, p, X)</code>; it is recommended to set the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple{AbstractManifold}"><code>default_retraction_method</code></a> to a favourite retraction. If this default is set, a <code>retraction_method=</code> does not have to be specified.</li><li>A <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/"><code>vector_transport_to!</code></a><code>M, Y, p, X, q)</code>; it is recommended to set the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a> to a favourite retraction. If this default is set, a <code>vector_transport_method=</code> or <code>vector_transport_method_dual=</code> (for <span>$\mathcal N$</span>) does not have to be specified.</li><li>By default quasi Newton uses <a href="../../plans/stepsize/#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a> which requires <a href="../../extensions/#Manopt.max_stepsize-Tuple{FiberBundle{ùîΩ, ManifoldsBase.TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any}"><code>max_stepsize</code></a><code>(M)</code> to be set and an implementation of <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.inner-Tuple%7BAbstractManifold,%20Any,%20Any,%20Any%7D"><code>inner</code></a><code>(M, p, X)</code>.</li><li>the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#LinearAlgebra.norm-Tuple{AbstractManifold,%20Any,%20Any}"><code>norm</code></a> as well, to stop when the norm of the gradient is small, but if you implemented <code>inner</code>, the norm is provided already.</li><li>A <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.copyto!-Tuple{AbstractManifold,%20Any,%20Any}"><code>copyto!</code></a><code>(M, q, p)</code> and <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.copy-Tuple{AbstractManifold,%20Any}"><code>copy</code></a><code>(M,p)</code> for points and similarly <code>copy(M, p, X)</code> for tangent vectors.</li><li>By default the tangent vector storing the gradient is initialized calling <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple{AbstractManifold,%20Any}"><code>zero_vector</code></a><code>(M,p)</code>.</li></ul><p>Most Hessian approximations further require <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.get_coordinates-Tuple{AbstractManifold,%20Any,%20Any,%20ManifoldsBase.AbstractBasis}"><code>get_coordinates</code></a><code>(M, p, X, b)</code> with respect to the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a> <code>b</code> provided, which is <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.AbstractOrthonormalBasis"><code>DefaultOrthonormalBasis</code></a> by default from the <code>basis=</code> keyword.</p><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[HAG18]</dt><dd><div>W.¬†Huang, P.-A.¬†Absil and K.¬†A.¬†Gallivan. <em>A Riemannian BFGS method without differentiated retraction for nonconvex optimization problems</em>. <a href="https://doi.org/10.1137/17M1127582">SIAM¬†Journal¬†on¬†Optimization <strong>28</strong>, 470‚Äì495</a> (2018).</div></dd><dt>[HGA15]</dt><dd><div>W.¬†Huang, K.¬†A.¬†Gallivan and P.-A.¬†Absil. <em>A Broyden class of quasi-Newton methods for Riemannian optimization</em>. <a href="https://doi.org/10.1137/140955483">SIAM¬†Journal¬†on¬†Optimization <strong>25</strong>, 1660‚Äì1685</a> (2015).</div></dd><dt>[NW06]</dt><dd><div>J.¬†Nocedal and S.¬†J.¬†Wright. <a href="https://doi.org/10.1007/978-0-387-40065-5"><em>Numerical Optimization</em></a>. 2¬†Edition (Springer, New York, 2006).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../primal_dual_semismooth_Newton/">¬´ Primal-dual Riemannian semismooth Newton</a><a class="docs-footer-nextpage" href="../stochastic_gradient_descent/">Stochastic Gradient Descent ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 26 January 2024 15:24">Friday 26 January 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
