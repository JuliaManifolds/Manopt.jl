<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stepsize ¬∑ Manopt.jl</title><meta name="title" content="Stepsize ¬∑ Manopt.jl"/><meta property="og:title" content="Stepsize ¬∑ Manopt.jl"/><meta property="twitter:title" content="Stepsize ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/getstarted/">üèîÔ∏è Get started with Manopt.jl</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../../tutorials/EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../../tutorials/HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../../tutorials/ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do constrained optimization</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">List of Solvers</a></li><li><a class="tocitem" href="../../solvers/adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/cma_es/">CMA-ES</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/conjugate_residual/">Conjugate Residual</a></li><li><a class="tocitem" href="../../solvers/convex_bundle_method/">Convex bundle method</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/interior_point_Newton/">Interior Point Newton</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="../../solvers/mesh_adaptive_direct_search/">MADS</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/projected_gradient_method/">Projected Gradient Method</a></li><li><a class="tocitem" href="../../solvers/proximal_bundle_method/">Proximal bundle method</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../">Specify a Solver</a></li><li><a class="tocitem" href="../problem/">Problem</a></li><li><a class="tocitem" href="../objective/">Objective</a></li><li><a class="tocitem" href="../state/">Solver State</a></li><li class="is-active"><a class="tocitem" href>Stepsize</a><ul class="internal"><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../debug/">Debug Output</a></li><li><a class="tocitem" href="../record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plans</a></li><li class="is-active"><a href>Stepsize</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stepsize</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/plans/stepsize.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Stepsize"><a class="docs-heading-anchor" href="#Stepsize">Stepsize and line search</a><a id="Stepsize-1"></a><a class="docs-heading-anchor-permalink" href="#Stepsize" title="Permalink"></a></h1><p>Most iterative algorithms determine a direction along which the algorithm shall proceed and determine a step size to find the next iterate. How advanced the step size computation can be implemented depends (among others) on the properties the corresponding problem provides.</p><p>Within <code>Manopt.jl</code>, the step size determination is implemented as a <code>functor</code> which is a subtype of <a href="#Stepsize"><code>Stepsize</code></a> based on</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.Stepsize" href="#Manopt.Stepsize"><code>Manopt.Stepsize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Stepsize</code></pre><p>An abstract type for the functors representing step sizes. These are callable structures. The naming scheme is <code>TypeOfStepSize</code>, for example <code>ConstantStepsize</code>.</p><p>Every Stepsize has to provide a constructor and its function has to have the interface <code>(p,o,i)</code> where a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> as well as <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> and the current number of iterations are the arguments and returns a number, namely the stepsize to use.</p><p>For most it is adviable to employ a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a>. Then the function creating the factory should either be called <code>TypeOf</code> or if that is confusing or too generic, <code>TypeOfLength</code></p><p><strong>See also</strong></p><p><a href="#Manopt.Linesearch"><code>Linesearch</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L1-L18">source</a></section></article><p>Usually, a constructor should take the manifold <code>M</code> as its first argument, for consistency, to allow general step size functors to be set up based on default values that might depend on the manifold currently under consideration.</p><p>Currently, the following step sizes are available</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AdaptiveWNGradient" href="#Manopt.AdaptiveWNGradient"><code>Manopt.AdaptiveWNGradient</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdaptiveWNGradient(; kwargs...)
AdaptiveWNGradient(M::AbstractManifold; kwargs...)</code></pre><p>A stepsize based on the adaptive gradient method introduced by [<a href="../../references/#GrapigliaStella:2023">GS23</a>].</p><p>Given a positive threshold <span>$\hat{c} ‚àà ‚Ñï$</span>, an minimal bound <span>$b_{\text{min}} &gt; 0$</span>, an initial <span>$b_0 ‚â• b_{\text{min}}$</span>, and a gradient reduction factor threshold <span>$Œ± ‚àà [0,1)$</span>.</p><p>Set <span>$c_0=0$</span> and use <span>$œâ_0 = \lVert \operatorname{grad} f(p_0) \rVert_{p_0}$</span>.</p><p>For the first iterate use the initial step size <span>$s_0 = \frac{1}{b_0}$</span>.</p><p>Then, given the last gradient <span>$X_{k-1} = \operatorname{grad} f(x_{k-1})$</span>, and a previous <span>$œâ_{k-1}$</span>, the values <span>$(b_k, œâ_k, c_k)$</span> are computed using <span>$X_k = \operatorname{grad} f(p_k)$</span> and the following cases</p><p>If <span>$\lVert X_k \rVert_{p_k} ‚â§ Œ±œâ_{k-1}$</span>, then let <span>$\hat{b}_{k-1} ‚àà [b_{\text{min}},b_{k-1}]$</span> and set</p><p class="math-container">\[(b_k, œâ_k, c_k) = \begin{cases}   \bigl(\hat{b}_{k-1}, \lVert X_k \rVert_{p_k}, 0 \bigr) &amp; \text{ if } c_{k-1}+1 = \hat{c}\\\\    \bigl( b_{k-1} + \frac{\lVert X_k \rVert_{p_k}^2}{b_{k-1}}, œâ_{k-1}, c_{k-1}+1 \Bigr) &amp; \text{ if } c_{k-1}+1&lt;\hat{c}\end{cases}\]</p><p>If <span>$\lVert X_k \rVert_{p_k} &gt; Œ±œâ_{k-1}$</span>, the set</p><p class="math-container">\[(b_k, œâ_k, c_k) = \Bigl( b_{k-1} + \frac{\lVert X_k \rVert_{p_k}^2}{b_{k-1}}, œâ_{k-1}, 0 \Bigr)\]</p><p>and return the step size <span>$s_k = \frac{1}{b_k}$</span>.</p><p>Note that for <span>$Œ±=0$</span> this is the Riemannian variant of <code>WNGRad</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>adaptive=true</code>: switches the <code>gradient_reduction</code><code>Œ±</code><code>(if</code>true<code>) to</code>0`.</li><li><code>alternate_bound = (bk, hat_c) -&gt;  min(gradient_bound == 0 ? 1.0 : gradient_bound, max(minimal_bound, bk / (3 * hat_c))</code>: how to determine <span>$\hat{k}_k$</span> as a function of <code>(bmin, bk, hat_c) -&gt; hat_bk</code></li><li><code>count_threshold=4</code>:  an <code>Integer</code> for <span>$\hat{c}$</span></li><li><code>gradient_reduction::R=adaptive ? 0.9 : 0.0</code>: the gradient reduction factor threshold <span>$Œ± ‚àà [0,1)$</span></li><li><code>gradient_bound=norm(M, p, X)</code>: the bound <span>$b_k$</span>.</li><li><code>minimal_bound=1e-4</code>: the value <span>$b_{\text{min}}$</span></li><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>only used to define the <code>gradient_bound</code></li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>only used to define the <code>gradient_bound</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L613-L660">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ArmijoLinesearch" href="#Manopt.ArmijoLinesearch"><code>Manopt.ArmijoLinesearch</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ArmijoLinesearch(; kwargs...)
ArmijoLinesearch(M::AbstractManifold; kwargs...)</code></pre><p>Specify a step size that performs an Armijo line search. Given a Function <span>$f:\mathcal M‚Üí‚Ñù$</span> and its Riemannian Gradient <span>$\operatorname{grad}f: \mathcal M‚ÜíT\mathcal M$</span>, the curent point <span>$p‚àà\mathcal M$</span> and a search direction <span>$X‚ààT_{p}\mathcal M$</span>.</p><p>Then the step size <span>$s$</span> is found by reducing the initial step size <span>$s$</span> until</p><p class="math-container">\[f(\operatorname{retr}_p(sX)) ‚â§ f(p) - œÑs ‚ü® X, \operatorname{grad}f(p) ‚ü©_p\]</p><p>is fulfilled. for a sufficient decrease value <span>$œÑ ‚àà (0,1)$</span>.</p><p>To be a bit more optimistic, if <span>$s$</span> already fulfils this, a first search is done, <strong>increasing</strong> the given <span>$s$</span> until for a first time this step does not hold.</p><p>Overall, we look for step size, that provides <em>enough decrease</em>, see [<a href="../../references/#Boumal:2023">Bou23</a>, p. 58] for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><code>additional_decrease_condition=(M, p) -&gt; true</code>: specify an additional criterion that has to be met to accept a step size in the decreasing loop</li><li><code>additional_increase_condition::IF=(M, p) -&gt; true</code>: specify an additional criterion that has to be met to accept a step size in the (initial) increase loop</li><li><code>candidate_point=allocate_result(M, rand)</code>: speciy a point to be used as memory for the candidate points.</li><li><code>contraction_factor=0.95</code>: how to update <span>$s$</span> in the decrease step</li><li><code>initial_stepsize=1.0</code>`: specify an initial step size</li><li><code>initial_guess=</code><a href="#Manopt.armijo_initial_guess-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Int64, Real}"><code>armijo_initial_guess</code></a>: Compute the initial step size of a line search based on this function. The funtion required is <code>(p,s,k,l) -&gt; Œ±</code> and computes the initial step size <span>$Œ±$</span> based on a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>p</code>, <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>s</code>, the current iterate <code>k</code> and a last step size <code>l</code>.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less=0.0</code>: a safeguard, stop when the decreasing step is below this (nonnegative) bound.</li><li><code>stop_when_stepsize_exceeds=max_stepsize(M)</code>: a safeguard to not choose a too long step size when initially increasing</li><li><code>stop_increasing_at_step=100</code>: stop the initial increasing loop after this amount of steps. Set to <code>0</code> to never increase in the beginning</li><li><code>stop_decreasing_at_step=1000</code>: maximal number of Armijo decreases / tests to perform</li><li><code>sufficient_decrease=0.1</code>: the sufficient decrease parameter <span>$œÑ$</span></li></ul><p>For the stop safe guards you can pass <code>:Messages</code> to a <code>debug=</code> to see <code>@info</code> messages when these happen.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function generates a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.ArmijoLinesearchStepsize"><code>ArmijoLinesearchStepsize</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L444-L491">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ConstantLength" href="#Manopt.ConstantLength"><code>Manopt.ConstantLength</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConstantLength(s; kwargs...)
ConstantLength(M::AbstractManifold, s; kwargs...)</code></pre><p>Specify a <a href="#Stepsize"><code>Stepsize</code></a> that is constant.</p><p><strong>Input</strong></p><ul><li><code>M</code> (optional)</li></ul><p><code>s=min( injectivity_radius(M)/2, 1.0)</code> : the length to use.</p><p><strong>Keyword argument</strong></p><ul><li><code>type::Symbol=relative</code> specify the type of constant step size.<ul><li><code>:relative</code> ‚Äì scale the gradient tangent vector <span>$X$</span> to <span>$s*X$</span></li><li><code>:absolute</code> ‚Äì scale the gradient to an absolute step length <span>$s$</span>, that is <span>$\frac{s}{\lVert X \rVert_{}}X$</span></li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function generates a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.ConstantStepsize"><code>ConstantStepsize</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L111-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.DecreasingLength" href="#Manopt.DecreasingLength"><code>Manopt.DecreasingLength</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DegreasingLength(; kwargs...)
DecreasingLength(M::AbstractManifold; kwargs...)</code></pre><p>Specify a [<code>Stepsize</code>]  that is decreasing as ``s_k = \frac{(l - ak)f^i}{(k+s)^e} with the following</p><p><strong>Keyword arguments</strong></p><ul><li><code>exponent=1.0</code>:   the exponent <span>$e$</span> in the denominator</li><li><code>factor=1.0</code>:     the factor <span>$f$</span> in the nominator</li><li><code>length=min(injectivity_radius(M)/2, 1.0)</code>: the initial step size <span>$l$</span>.</li><li><code>subtrahend=0.0</code>: a value <span>$a$</span> that is subtracted every iteration</li><li><code>shift=0.0</code>:      shift the denominator iterator <span>$k$</span> by <span>$s$</span>.</li><li><code>type::Symbol=relative</code> specify the type of constant step size.</li><li><code>:relative</code> ‚Äì scale the gradient tangent vector <span>$X$</span> to <span>$s_k*X$</span></li><li><code>:absolute</code> ‚Äì scale the gradient to an absolute step length <span>$s_k$</span>, that is <span>$\frac{s_k}{\lVert X \rVert_{}}X$</span></li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function generates a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.DecreasingStepsize"><code>DecreasingStepsize</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L210-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.NonmonotoneLinesearch" href="#Manopt.NonmonotoneLinesearch"><code>Manopt.NonmonotoneLinesearch</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonmonotoneLinesearch(; kwargs...)
NonmonotoneLinesearch(M::AbstractManifold; kwargs...)</code></pre><p>A functor representing a nonmonotone line search using the Barzilai-Borwein step size [<a href="../../references/#IannazzoPorcelli:2017">IP17</a>].</p><p>This method first computes</p><p>(x -&gt; p, F-&gt; f)</p><p class="math-container">\[y_{k} = \operatorname{grad}f(p_{k}) - \mathcal T_{p_k‚Üêp_{k-1}}\operatorname{grad}f(p_{k-1})\]</p><p>and</p><p class="math-container">\[s_{k} = - Œ±_{k-1} ‚ãÖ \mathcal T_{p_k‚Üêp_{k-1}}\operatorname{grad}f(p_{k-1}),\]</p><p>where <span>$Œ±_{k-1}$</span> is the step size computed in the last iteration and <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> is a vector transport. Then the Barzilai‚ÄîBorwein step size is</p><p class="math-container">\[Œ±_k^{\text{BB}} = \begin{cases}   \min(Œ±_{\text{max}}, \max(Œ±_{\text{min}}, œÑ_{k})), &amp; \text{if} ‚ü®s_{k}, y_{k}‚ü©_{p_k} &gt; 0,\\\\    Œ±_{\text{max}}, &amp; \text{else,}\end{cases}\]</p><p>where</p><p class="math-container">\[œÑ_{k} = \frac{‚ü®s_{k}, s_{k}‚ü©_{p_k}}{‚ü®s_{k}, y_{k}‚ü©_{p_k}},\]</p><p>if the direct strategy is chosen, or</p><p class="math-container">\[œÑ_{k} =  \frac{‚ü®s_{k}, y_{k}‚ü©_{p_k}}{‚ü®y_{k}, y_{k}‚ü©_{p_k}},\]</p><p>in case of the inverse strategy or an alternation between the two in cases for the alternating strategy. Then find the smallest <span>$h = 0, 1, 2, ‚Ä¶$</span> such that</p><p class="math-container">\[f(\operatorname{retr}_{p_k}(- œÉ^h Œ±_k^{\text{BB}} \operatorname{grad}f(p_k)))  ‚â§
\max_{1 ‚â§ j ‚â§ \max(k+1,m)} f(p_{k+1-j}) - Œ≥ œÉ^h Œ±_k^{\text{BB}} ‚ü®\operatorname{grad}F(p_k), \operatorname{grad}F(p_k)‚ü©_{p_k},\]</p><p>where <span>$œÉ ‚àà (0,1)$</span> is a step length reduction factor , <span>$m$</span> is the number of iterations after which the function value has to be lower than the current one and <span>$Œ≥ ‚àà (0,1)$</span> is the sufficient decrease parameter. Finally the step size is computed as</p><p class="math-container">\[Œ±_k = œÉ^h Œ±_k^{\text{BB}}.\]</p><p><strong>Keyword arguments</strong></p><ul><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>to store an interim result</li><li><code>p=allocate_result(M, rand)</code>: to store an interim result</li><li><code>initial_stepsize=1.0</code>: the step size to start the search with</li><li><code>memory_size=10</code>: number of iterations after which the cost value needs to be lower than the current one</li><li><code>bb_min_stepsize=1e-3</code>: lower bound for the Barzilai-Borwein step size greater than zero</li><li><code>bb_max_stepsize=1e3</code>: upper bound for the Barzilai-Borwein step size greater than min_stepsize</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>strategy=direct</code>: defines if the new step size is computed using the <code>:direct</code>, <code>:indirect</code> or <code>:alternating</code> strategy</li><li><code>storage=</code><a href="../state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a><code>(M; store_fields=[:Iterate, :Gradient])</code>: increase efficiency by using a <a href="../state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a> for <code>:Iterate</code> and <code>:Gradient</code>.</li><li><code>stepsize_reduction=0.5</code>:  step size reduction factor contained in the interval <span>$(0,1)$</span></li><li><code>sufficient_decrease=1e-4</code>: sufficient decrease parameter contained in the interval <span>$(0,1)$</span></li><li><code>stop_when_stepsize_less=0.0</code>: smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_when_stepsize_exceeds=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>): largest stepsize when to stop to avoid leaving the injectivity radius</li><li><code>stop_increasing_at_step=100</code>:  last step to increase the stepsize (phase 1),</li><li><code>stop_decreasing_at_step=1000</code>: last step size to decrease the stepsize (phase 2),</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L1046-L1111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.Polyak" href="#Manopt.Polyak"><code>Manopt.Polyak</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Polyak(; kwargs...)
Polyak(M::AbstractManifold; kwargs...)</code></pre><p>Compute a step size according to a method propsed by Polyak, cf. the Dynamic step size discussed in Section 3.2 of [<a href="../../references/#Bertsekas:2015">Ber15</a>]. This has been generalised here to both the Riemannian case and to approximate the minimum cost value.</p><p>Let <span>$f_{\text{best}$</span> be the best cost value seen until now during some iterative optimisation algorithm and let <span>$Œ≥_k$</span> be a sequence of numbers that is square summable, but not summable.</p><p>Then the step size computed here reads</p><p class="math-container">\[s_k = \frac{f(p^{(k)}) - f_{\text{best} + Œ≥_k}{\lVert ‚àÇf(p^{(k)})} \rVert_{}},\]</p><p>where <span>$‚àÇf$</span> denotes a nonzero-subgradient of <span>$f$</span> at the current iterate <span>$p^{(k)}$</span>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">Polyak(; Œ≥ = k -&gt; 1/k, initial_cost_estimate=0.0)</code></pre><p>initialize the Polyak stepsize to a certain sequence and an initial estimate of <span>$f_{	ext{best}}$</span>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function generates a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.PolyakStepsize"><code>PolyakStepsize</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L1174-L1201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.WolfePowellLinesearch" href="#Manopt.WolfePowellLinesearch"><code>Manopt.WolfePowellLinesearch</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WolfePowellLinesearch(; kwargs...)
WolfePowellLinesearch(M::AbstractManifold; kwargs...)</code></pre><p>Perform a lineseach to fulfull both the Armijo-Goldstein conditions</p><p class="math-container">\[f\bigl( \operatorname{retr}_{p}(Œ±X) \bigr) ‚â§ f(p) + c_1 Œ±_k ‚ü®\operatorname{grad} f(p), X‚ü©_{p}\]</p><p>as well as the Wolfe conditions</p><p class="math-container">\[\frac{\mathrm{d}}{\mathrm{d}t} f\bigl(\operatorname{retr}_{p}(tX)\bigr)
\Big\vert_{t=Œ±}
‚â• c_2 \frac{\mathrm{d}}{\mathrm{d}t} f\bigl(\operatorname{retr}_{p}(tX)\bigr)\Big\vert_{t=0}.\]</p><p>for some given sufficient decrease coefficient <span>$c_1$</span> and some sufficient curvature condition coefficient<span>$c_2$</span>.</p><p>This is adopted from [<a href="../../references/#NocedalWright:2006">NW06</a>, Section 3.1]</p><p><strong>Keyword arguments</strong></p><ul><li><code>sufficient_decrease=10^(-4)</code></li><li><code>sufficient_curvature=0.999</code></li><li><code>p::P</code>: a point on the manifold <span>$\mathcal M$</span>as temporary storage for candidates</li><li><code>X::T</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>as type of memory allocated for the candidates direction and tangent</li><li><code>max_stepsize=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>: largest stepsize allowed here.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less=0.0</code>: smallest stepsize when to stop (the last one before is taken)</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L1377-L1407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.WolfePowellBinaryLinesearch" href="#Manopt.WolfePowellBinaryLinesearch"><code>Manopt.WolfePowellBinaryLinesearch</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WolfePowellBinaryLinesearch(; kwargs...)
WolfePowellBinaryLinesearch(M::AbstractManifold; kwargs...)</code></pre><p>Perform a lineseach to fulfull both the Armijo-Goldstein conditions for some given sufficient decrease coefficient <span>$c_1$</span> and some sufficient curvature condition coefficient<span>$c_2$</span>. Compared to <a href="#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a> which tries a simpler method, this linesearch performs the following algorithm</p><p>With</p><p class="math-container">\[A(t) = f(p_+) ‚â§ c_1 t ‚ü®\operatorname{grad}f(p), X‚ü©_{x}
\quad\text{ and }\quad
W(t) = ‚ü®\operatorname{grad}f(x_+), \mathcal T_{p_+‚Üêp}X‚ü©_{p_+} ‚â• c_2 ‚ü®X, \operatorname{grad}f(x)‚ü©_x,\]</p><p>where <span>$p_+ =\operatorname{retr}_p(tX)$</span> is the current trial point, and <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> denotes a vector transport. Then the following Algorithm is performed similar to Algorithm 7 from [<a href="../../references/#Huang:2014">Hua14</a>]</p><ol><li>set <span>$Œ±=0$</span>, <span>$Œ≤=‚àû$</span> and <span>$t=1$</span>.</li><li>While either <span>$A(t)$</span> does not hold or <span>$W(t)$</span> does not hold do steps 3-5.</li><li>If <span>$A(t)$</span> fails, set <span>$Œ≤=t$</span>.</li><li>If <span>$A(t)$</span> holds but <span>$W(t)$</span> fails, set <span>$Œ±=t$</span>.</li><li>If <span>$Œ≤&lt;‚àû$</span> set <span>$t=\frac{Œ±+Œ≤}{2}$</span>, otherwise set <span>$t=2Œ±$</span>.</li></ol><p><strong>Keyword arguments</strong></p><ul><li><code>sufficient_decrease=10^(-4)</code></li><li><code>sufficient_curvature=0.999</code></li><li><code>max_stepsize=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>: largest stepsize allowed here.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less=0.0</code>: smallest stepsize when to stop (the last one before is taken)</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L1552-L1570">source</a></section></article><p>Some step sizes use <a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a> function as a rough upper estimate for the trust region size. It is by default equal to injectivity radius of the exponential map but in some cases a different value is used. For the <code>FixedRankMatrices</code> manifold an estimate from Manopt is used. Tangent bundle with the Sasaki metric has 0 injectivity radius, so the maximum stepsize of the underlying manifold is used instead. <code>Hyperrectangle</code> also has 0 injectivity radius and an estimate based on maximum of dimensions along each index is used instead. For manifolds with corners, however, a line search capable of handling break points along the projected search direction should be used, and such algorithms do not call <code>max_stepsize</code>.</p><p>Internally these step size functions create a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a>. Internally these use</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.armijo_initial_guess-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Int64, Real}" href="#Manopt.armijo_initial_guess-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Int64, Real}"><code>Manopt.armijo_initial_guess</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">armijo_initial_guess(mp::AbstractManoptProblem, s::AbstractManoptSolverState, k, l)</code></pre><p><strong>Input</strong></p><ul><li><code>mp</code>: the <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> we are aiminig to minimize</li><li><code>s</code>:  the <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> for the current solver</li><li><code>k</code>:  the current iteration</li><li><code>l</code>:  the last step size computed in the previous iteration.</li></ul><p>Return an initial guess for the <a href="#Manopt.ArmijoLinesearchStepsize"><code>ArmijoLinesearchStepsize</code></a>.</p><p>The default provided is based on the <a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M)</code>, which we denote by <span>$m$</span>. Let further <span>$X$</span> be the current descent direction with norm <span>$n=\lVert X \rVert_{p}$</span> its length. Then this (default) initial guess returns</p><ul><li><span>$l$</span> if <span>$m$</span> is not finite</li><li><span>$\min(l, \frac{m}{n})$</span> otherwise</li></ul><p>This ensures that the initial guess does not yield to large (initial) steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L248-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}" href="#Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}"><code>Manopt.default_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_stepsize(M::AbstractManifold, ams::AbstractManoptSolverState)</code></pre><p>Returns the default <a href="#Stepsize"><code>Stepsize</code></a> functor used when running the solver specified by the <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> running with an objective on the <code>AbstractManifold M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_last_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}" href="#Manopt.get_last_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}"><code>Manopt.get_last_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_last_stepsize(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, vars...)</code></pre><p>return the last computed stepsize stored within <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> when solving the <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>.</p><p>This method takes into account that <code>ams</code> might be decorated. In case this returns <code>NaN</code>, a concrete call to the stored stepsize is performed. For this, usually, the first of the <code>vars...</code> should be the current iterate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L1628-L1637">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_last_stepsize-Tuple{Stepsize, Vararg{Any}}" href="#Manopt.get_last_stepsize-Tuple{Stepsize, Vararg{Any}}"><code>Manopt.get_last_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_last_stepsize(::Stepsize, vars...)</code></pre><p>return the last computed stepsize from within the stepsize. If no last step size is stored, this returns <code>NaN</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L1656-L1661">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}" href="#Manopt.get_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}"><code>Manopt.get_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_stepsize(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, vars...)</code></pre><p>return the stepsize stored within <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> when solving the <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>. This method also works for decorated options and the <a href="#Stepsize"><code>Stepsize</code></a> function within the options, by default stored in <code>ams.stepsize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L1574-L1581">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.linesearch_backtrack!-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any, T}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any, T, Any}} where {TF, T}" href="#Manopt.linesearch_backtrack!-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any, T}, Tuple{AbstractManifold, Any, TF, Any, T, Any, Any, Any, T, Any}} where {TF, T}"><code>Manopt.linesearch_backtrack!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(s, msg) = linesearch_backtrack!(M, q, F, p, X, s, decrease, contract Œ∑ = -X, f0 = f(p))</code></pre><p>Perform a line search backtrack in-place of <code>q</code>. For all details and options, see <a href="#Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T, Any}} where T"><code>linesearch_backtrack</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L707-L712">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T, Any}} where T" href="#Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T}, Tuple{AbstractManifold, Any, Any, T, Any, Any, Any, T, Any}} where T"><code>Manopt.linesearch_backtrack</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(s, msg) = linesearch_backtrack(M, F, p, X, s, decrease, contract Œ∑ = -X, f0 = f(p); kwargs...)
(s, msg) = linesearch_backtrack!(M, q, F, p, X, s, decrease, contract Œ∑ = -X, f0 = f(p); kwargs...)</code></pre><p>perform a line search</p><ul><li>on manifold <code>M</code></li><li>for the cost function <code>f</code>,</li><li>at the current point <code>p</code></li><li>with current gradient provided in <code>X</code></li><li>an initial stepsize <code>s</code></li><li>a sufficient <code>decrease</code></li><li>a <code>contract</code>ion factor <span>$œÉ$</span></li><li>a search direction <span>$Œ∑ = -X$</span></li><li>an offset, <span>$f_0 = F(x)$</span></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less=0.0</code>: to avoid numerical underflow</li><li><code>stop_when_stepsize_exceeds=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p) / norm(M, p, Œ∑)</code>) to avoid leaving the injectivity radius on a manifold</li><li><code>stop_increasing_at_step=100</code>: stop the initial increase of step size after these many steps</li><li><code>stop_decreasing_at_step=</code>1000`: stop the decreasing search after these many steps</li><li><code>additional_increase_condition=(M,p) -&gt; true</code>: impose an additional condition for an increased step size to be accepted</li><li><code>additional_decrease_condition=(M,p) -&gt; true</code>: impose an additional condition for an decreased step size to be accepted</li></ul><p>These keywords are used as safeguards, where only the max stepsize is a very manifold specific one.</p><p><strong>Return value</strong></p><p>A stepsize <code>s</code> and a message <code>msg</code> (in case any of the 4 criteria hit)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L668-L699">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.max_stepsize-Tuple{AbstractManifold, Any}" href="#Manopt.max_stepsize-Tuple{AbstractManifold, Any}"><code>Manopt.max_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">max_stepsize(M::AbstractManifold, p)
max_stepsize(M::AbstractManifold)</code></pre><p>Get the maximum stepsize (at point <code>p</code>) on manifold <code>M</code>. It should be used to limit the distance an algorithm is trying to move in a single step.</p><p>By default, this returns <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.injectivity_radius-Tuple%7BAbstractManifold%7D"><code>injectivity_radius</code></a><code>(M)</code>, if this exists. If this is not available on the the method returns <code>Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L31-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AdaptiveWNGradientStepsize" href="#Manopt.AdaptiveWNGradientStepsize"><code>Manopt.AdaptiveWNGradientStepsize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdaptiveWNGradientStepsize{I&lt;:Integer,R&lt;:Real,F&lt;:Function} &lt;: Stepsize</code></pre><p>A functor <code>problem, state, k, X) -&gt; s to an adaptive gradient method introduced by [GrapigliaStella:2023](@cite). See [</code>AdaptiveWNGradient`](@ref) for the mathematical details.</p><p><strong>Fields</strong></p><ul><li><code>count_threshold::I</code>: an <code>Integer</code> for <span>$\hat{c}$</span></li><li><code>minimal_bound::R</code>: the value for <span>$b_{\text{min}}$</span></li><li><code>alternate_bound::F</code>: how to determine <span>$\hat{k}_k$</span> as a function of <code>(bmin, bk, hat_c) -&gt; hat_bk</code></li><li><code>gradient_reduction::R</code>: the gradient reduction factor threshold <span>$Œ± ‚àà [0,1)$</span></li><li><code>gradient_bound::R</code>: the bound <span>$b_k$</span>.</li><li><code>weight::R</code>: <span>$œâ_k$</span> initialised to <span>$œâ_0 =$</span><code>norm(M, p, X)</code> if this is not zero, <code>1.0</code> otherwise.</li><li><code>count::I</code>: <span>$c_k$</span>, initialised to <span>$c_0 = 0$</span>.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">AdaptiveWNGrad(M::AbstractManifold; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>adaptive=true</code>: switches the <code>gradient_reduction</code><code>Œ±</code><code>(if</code>true<code>) to</code>0`.</li><li><code>alternate_bound = (bk, hat_c) -&gt;  min(gradient_bound == 0 ? 1.0 : gradient_bound, max(minimal_bound, bk / (3 * hat_c))</code></li><li><code>count_threshold=4</code></li><li><code>gradient_reduction::R=adaptive ? 0.9 : 0.0</code></li><li><code>gradient_bound=norm(M, p, X)</code></li><li><code>minimal_bound=1e-4</code></li><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>only used to define the <code>gradient_bound</code></li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>only used to define the <code>gradient_bound</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L496-L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ArmijoLinesearchStepsize" href="#Manopt.ArmijoLinesearchStepsize"><code>Manopt.ArmijoLinesearchStepsize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ArmijoLinesearchStepsize &lt;: Linesearch</code></pre><p>A functor <code>problem, state, k, X) -&gt; s to provide an Armijo line search to compute step size, based on the search direction</code>X`</p><p><strong>Fields</strong></p><ul><li><code>candidate_point</code>:               to store an interim result</li><li><code>initial_stepsize</code>:              and initial step size</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>contraction_factor</code>:            exponent for line search reduction</li><li><code>sufficient_decrease</code>:           gain within Armijo&#39;s rule</li><li><code>last_stepsize</code>:                 the last step size to start the search with</li><li><code>initial_guess</code>:                 a function to provide an initial guess for the step size, it maps <code>(m,p,k,l) -&gt; Œ±</code> based on a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>p</code>, <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>s</code>, the current iterate <code>k</code> and a last step size <code>l</code>. It returns the initial guess <code>Œ±</code>.</li><li><code>additional_decrease_condition</code>: specify a condition a new point has to additionally fulfill. The default accepts all points.</li><li><code>additional_increase_condition</code>: specify a condtion that additionally to checking a valid increase has to be fulfilled. The default accepts all points.</li><li><code>stop_when_stepsize_less</code>:       smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_when_stepsize_exceeds</code>:    largest stepsize when to stop.</li><li><code>stop_increasing_at_step</code>:       last step to increase the stepsize (phase 1),</li><li><code>stop_decreasing_at_step</code>:       last step size to decrease the stepsize (phase 2),</li></ul><p>Pass <code>:Messages</code> to a <code>debug=</code> to see <code>@info</code>s when these happen.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ArmijoLinesearchStepsize(M::AbstractManifold; kwarg...)</code></pre><p>with the fields keyword arguments and the retraction is set to the default retraction on <code>M</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>candidate_point=</code>(<code>allocate_result(M, rand)</code>)</li><li><code>initial_stepsize=1.0</code></li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>contraction_factor=0.95</code></li><li><code>sufficient_decrease=0.1</code></li><li><code>last_stepsize=initialstepsize</code></li><li><code>initial_guess=</code><a href="#Manopt.armijo_initial_guess-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Int64, Real}"><code>armijo_initial_guess</code></a><code>‚Äì (p,s,i,l) -&gt; l</code></li><li><code>stop_when_stepsize_less=0.0</code>: stop when the stepsize decreased below this version.</li><li><code>stop_when_stepsize_exceeds=[</code>max_step<code>](@ref)</code>(M)`: provide an absolute maximal step size.</li><li><code>stop_increasing_at_step=100</code>: for the initial increase test, stop after these many steps</li><li><code>stop_decreasing_at_step=1000</code>: in the backtrack, stop after these many steps</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L280-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ConstantStepsize" href="#Manopt.ConstantStepsize"><code>Manopt.ConstantStepsize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConstantStepsize &lt;: Stepsize</code></pre><p>A functor <code>(problem, state, ...) -&gt; s</code> to provide a constant step size <code>s</code>.</p><p><strong>Fields</strong></p><ul><li><code>length</code>: constant value for the step size</li><li><code>type</code>:   a symbol that indicates whether the stepsize is relatively (:relative),   with respect to the gradient norm, or absolutely (:absolute) constant.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConstantStepsize(s::Real, t::Symbol=:relative)</code></pre><p>initialize the stepsize to a constant <code>s</code> of type <code>t</code>.</p><pre><code class="nohighlight hljs">ConstantStepsize(
    M::AbstractManifold=DefaultManifold(),
    s=min(1.0, injectivity_radius(M)/2);
    type::Symbol=:relative
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L62-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.DecreasingStepsize" href="#Manopt.DecreasingStepsize"><code>Manopt.DecreasingStepsize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DecreasingStepsize()</code></pre><p>A functor <code>(problem, state, ...) -&gt; s</code> to provide a constant step size <code>s</code>.</p><p><strong>Fields</strong></p><ul><li><code>exponent</code>:   a value <span>$e$</span> the current iteration numbers <span>$e$</span>th exponential is taken of</li><li><code>factor</code>:     a value <span>$f$</span> to multiply the initial step size with every iteration</li><li><code>length</code>:     the initial step size <span>$l$</span>.</li><li><code>subtrahend</code>: a value <span>$a$</span> that is subtracted every iteration</li><li><code>shift</code>:      shift the denominator iterator <span>$i$</span> by <span>$s$</span>`.</li><li><code>type</code>:       a symbol that indicates whether the stepsize is relatively (:relative),   with respect to the gradient norm, or absolutely (:absolute) constant.</li></ul><p>In total the complete formulae reads for the <span>$i$</span>th iterate as</p><p class="math-container">\[s_i = \frac{(l - i a)f^i}{(i+s)^e}\]</p><p>and hence the default simplifies to just <span>$s_i = rac{l}{i}$</span></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DecreasingStepsize(M::AbstractManifold;
    length=min(injectivity_radius(M)/2, 1.0),
    factor=1.0,
    subtrahend=0.0,
    exponent=1.0,
    shift=0.0,
    type=:relative,
)</code></pre><p>initializes all fields, where none of them is mandatory and the length is set to half and to <span>$1$</span> if the injectivity radius is infinite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L134-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.Linesearch" href="#Manopt.Linesearch"><code>Manopt.Linesearch</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Linesearch &lt;: Stepsize</code></pre><p>An abstract functor to represent line search type step size determinations, see <a href="#Stepsize"><code>Stepsize</code></a> for details. One example is the <a href="#Manopt.ArmijoLinesearchStepsize"><code>ArmijoLinesearchStepsize</code></a> functor.</p><p>Compared to simple step sizes, the line search functors provide an interface of the form <code>(p,o,i,X) -&gt; s</code> with an additional (but optional) fourth parameter to provide a search direction; this should default to something reasonable, most prominently the negative gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L234-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.NonmonotoneLinesearchStepsize" href="#Manopt.NonmonotoneLinesearchStepsize"><code>Manopt.NonmonotoneLinesearchStepsize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonmonotoneLinesearchStepsize{P,T,R&lt;:Real} &lt;: Linesearch</code></pre><p>A functor representing a nonmonotone line search using the Barzilai-Borwein step size [<a href="../../references/#IannazzoPorcelli:2017">IP17</a>].</p><p><strong>Fields</strong></p><ul><li><code>initial_stepsize=1.0</code>:     the step size to start the search with</li><li><code>memory_size=10</code>:           number of iterations after which the cost value needs to be lower than the current one</li><li><code>bb_min_stepsize=1e-3</code>:     lower bound for the Barzilai-Borwein step size greater than zero</li><li><code>bb_max_stepsize=1e3</code>:      upper bound for the Barzilai-Borwein step size greater than min_stepsize</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>strategy=direct</code>:          defines if the new step size is computed using the <code>:direct</code>, <code>:indirect</code> or <code>:alternating</code> strategy</li><li><code>storage</code>:                  (for <code>:Iterate</code> and <code>:Gradient</code>) a <a href="../state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a></li><li><code>stepsize_reduction</code>:       step size reduction factor contained in the interval (0,1)</li><li><code>sufficient_decrease</code>:     sufficient decrease parameter contained in the interval (0,1)</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li><li><code>candidate_point</code>:          to store an interim result</li><li><code>stop_when_stepsize_less</code>:    smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_when_stepsize_exceeds</code>: largest stepsize when to stop.</li><li><code>stop_increasing_at_step</code>:    last step to increase the stepsize (phase 1),</li><li><code>stop_decreasing_at_step</code>:    last step size to decrease the stepsize (phase 2),</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">NonmonotoneLinesearchStepsize(M::AbstractManifold; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>p=allocate_result(M, rand)</code>: to store an interim result</li><li><code>initial_stepsize=1.0</code></li><li><code>memory_size=10</code></li><li><code>bb_min_stepsize=1e-3</code></li><li><code>bb_max_stepsize=1e3</code></li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>strategy=direct</code></li><li><code>storage=[</code>StoreStateAction<code>](@ref)</code>(M; store_fields=[:Iterate, :Gradient])``</li><li><code>stepsize_reduction=0.5</code></li><li><code>sufficient_decrease=1e-4</code></li><li><code>stop_when_stepsize_less=0.0</code></li><li><code>stop_when_stepsize_exceeds=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>)</li><li><code>stop_increasing_at_step=100</code></li><li><code>stop_decreasing_at_step=1000</code></li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L782-L826">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.PolyakStepsize" href="#Manopt.PolyakStepsize"><code>Manopt.PolyakStepsize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PolyakStepsize &lt;: Stepsize</code></pre><p>A functor <code>(problem, state, ...) -&gt; s</code> to provide a step size due to Polyak, cf. Section 3.2 of [<a href="../../references/#Bertsekas:2015">Ber15</a>].</p><p><strong>Fields</strong></p><ul><li><code>Œ≥</code>               : a function <code>k -&gt; ...</code> representing a seuqnce.</li><li><code>best_cost_value</code> : storing the best cost value</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PolyakStepsize(;
    Œ≥ = i -&gt; 1/i,
    initial_cost_estimate=0.0
)</code></pre><p>Construct a stepsize of Polyak type.</p><p><strong>See also</strong></p><p><a href="#Manopt.Polyak"><code>Polyak</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L1123-L1144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.WolfePowellBinaryLinesearchStepsize" href="#Manopt.WolfePowellBinaryLinesearchStepsize"><code>Manopt.WolfePowellBinaryLinesearchStepsize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WolfePowellBinaryLinesearchStepsize{R} &lt;: Linesearch</code></pre><p>Do a backtracking line search to find a step size <span>$Œ±$</span> that fulfils the Wolfe conditions along a search direction <span>$X$</span> starting from <span>$p$</span>. See <a href="#Manopt.WolfePowellBinaryLinesearch"><code>WolfePowellBinaryLinesearch</code></a> for the math details.</p><p><strong>Fields</strong></p><ul><li><code>sufficient_decrease::R</code>, <code>sufficient_curvature::R</code> two constants in the line search</li><li><code>last_stepsize::R</code></li><li><code>max_stepsize::R</code></li><li><code>retraction_method::AbstractRetractionMethod</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less::R</code>: a safeguard to stop when the stepsize gets too small</li><li><code>vector_transport_method::AbstractVectorTransportMethodP</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>sufficient_decrease=10^(-4)</code></li><li><code>sufficient_curvature=0.999</code></li><li><code>max_stepsize=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>: largest stepsize allowed here.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less=0.0</code>: smallest stepsize when to stop (the last one before is taken)</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L1412-L1437">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.WolfePowellLinesearchStepsize" href="#Manopt.WolfePowellLinesearchStepsize"><code>Manopt.WolfePowellLinesearchStepsize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WolfePowellLinesearchStepsize{R&lt;:Real} &lt;: Linesearch</code></pre><p>Do a backtracking line search to find a step size <span>$Œ±$</span> that fulfils the Wolfe conditions along a search direction <span>$X$</span> starting from <span>$p$</span>. See <a href="#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a> for the math details</p><p><strong>Fields</strong></p><ul><li><code>sufficient_decrease::R</code>, <code>sufficient_curvature::R</code> two constants in the line search</li><li><code>candidate_direction::T</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span></li><li><code>candidate_point::P</code>: a point on the manifold <span>$\mathcal M$</span>as temporary storage for candidates</li><li><code>candidate_tangent::T</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span></li><li><code>last_stepsize::R</code></li><li><code>max_stepsize::R</code></li><li><code>retraction_method::AbstractRetractionMethod</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less::R</code>: a safeguard to stop when the stepsize gets too small</li><li><code>vector_transport_method::AbstractVectorTransportMethodP</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>sufficient_decrease=10^(-4)</code></li><li><code>sufficient_curvature=0.999</code></li><li><code>p::P</code>: a point on the manifold <span>$\mathcal M$</span>as temporary storage for candidates</li><li><code>X::T</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>as type of memory allocated for the candidates direction and tangent</li><li><code>max_stepsize=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>: largest stepsize allowed here.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less=0.0</code>: smallest stepsize when to stop (the last one before is taken)</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/stepsize.jl#L1208-L1237">source</a></section></article><p>Some solvers have a different iterate from the one used for the line search. Then the following state can be used to wrap these locally</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.StepsizeState" href="#Manopt.StepsizeState"><code>Manopt.StepsizeState</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StepsizeState{P,T} &lt;: AbstractManoptSolverState</code></pre><p>A state to store a point and a descent direction used within a linesearch, if these are different from the iterate and search direction of the main solver.</p><p><strong>Fields</strong></p><ul><li><code>p::P</code>: a point on a manifold</li><li><code>X::T</code>: a tangent vector at <code>p</code>.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">StepsizeState(p,X)
StepsizeState(M::AbstractManifold; p=rand(M), x=zero_vector(M,p)</code></pre><p><strong>See also</strong></p><p><a href="../../solvers/interior_point_Newton/#Manopt.interior_point_Newton"><code>interior_point_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L1-L20">source</a></section></article><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[Ber15]</dt><dd><div>D.¬†P.¬†Bertsekas. <em>Convex Optimization Algorithms</em> (Athena Scientific, 2015); p.¬†576.</div></dd><dt>[Bou23]</dt><dd><div>N.¬†Boumal. <a href="https://www.nicolasboumal.net/book/index.html"><em>An Introduction to Optimization on Smooth Manifolds</em></a>. First¬†Edition (<a href="https://doi.org/10.1017/9781009166164">Cambridge University Press, 2023</a>).</div></dd><dt>[GS23]</dt><dd><div>G.¬†N.¬†Grapiglia and G.¬†F.¬†Stella. <a href="https://optimization-online.org/wp-content/uploads/2022/04/8864.pdf"><em>An Adaptive Riemannian Gradient Method Without Function Evaluations</em></a>. <a href="https://doi.org/10.1007/s10957-023-02227-y">Journal¬†of¬†Optimization¬†Theory¬†and¬†Applications <strong>197</strong>, 1140‚Äì1160</a> (2023).</div></dd><dt>[Hua14]</dt><dd><div>W.¬†Huang. <a href="https://www.math.fsu.edu/~whuang2/pdf/Huang_W_Dissertation_2013.pdf"><em>Optimization algorithms on Riemannian manifolds with applications</em></a>. Ph.D. Thesis, Flordia State University (2014).</div></dd><dt>[IP17]</dt><dd><div>B.¬†Iannazzo and M.¬†Porcelli. <em>The Riemannian Barzilai‚ÄìBorwein method with nonmonotone line search and the matrix geometric mean computation</em>. <a href="https://doi.org/10.1093/imanum/drx015">IMA¬†Journal¬†of¬†Numerical¬†Analysis <strong>38</strong>, 495‚Äì517</a> (2017).</div></dd><dt>[NW06]</dt><dd><div>J.¬†Nocedal and S.¬†J.¬†Wright. <a href="https://doi.org/10.1007/978-0-387-40065-5"><em>Numerical Optimization</em></a>. 2¬†Edition (Springer, New York, 2006).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../state/">¬´ Solver State</a><a class="docs-footer-nextpage" href="../stopping_criteria/">Stopping Criteria ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Sunday 13 April 2025 10:16">Sunday 13 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
