<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interior Point Newton ¬∑ Manopt.jl</title><meta name="title" content="Interior Point Newton ¬∑ Manopt.jl"/><meta property="og:title" content="Interior Point Newton ¬∑ Manopt.jl"/><meta property="twitter:title" content="Interior Point Newton ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/getstarted/">üèîÔ∏è Get started with Manopt.jl</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../../tutorials/EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../../tutorials/HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../../tutorials/ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do constrained optimization</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../">List of Solvers</a></li><li><a class="tocitem" href="../adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../cma_es/">CMA-ES</a></li><li><a class="tocitem" href="../conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../conjugate_residual/">Conjugate Residual</a></li><li><a class="tocitem" href="../convex_bundle_method/">Convex bundle method</a></li><li><a class="tocitem" href="../cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="../exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../gradient_descent/">Gradient Descent</a></li><li class="is-active"><a class="tocitem" href>Interior Point Newton</a><ul class="internal"><li><a class="tocitem" href="#State"><span>State</span></a></li><li><a class="tocitem" href="#Subproblem-functions"><span>Subproblem functions</span></a></li><li><a class="tocitem" href="#Helpers"><span>Helpers</span></a></li><li><a class="tocitem" href="#Additional-stopping-criteria"><span>Additional stopping criteria</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="../mesh_adaptive_direct_search/">MADS</a></li><li><a class="tocitem" href="../NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="../particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../projected_gradient_method/">Projected Gradient Method</a></li><li><a class="tocitem" href="../proximal_bundle_method/">Proximal bundle method</a></li><li><a class="tocitem" href="../quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../../plans/problem/">Problem</a></li><li><a class="tocitem" href="../../plans/objective/">Objective</a></li><li><a class="tocitem" href="../../plans/state/">Solver State</a></li><li><a class="tocitem" href="../../plans/stepsize/">Stepsize</a></li><li><a class="tocitem" href="../../plans/stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../../plans/debug/">Debug Output</a></li><li><a class="tocitem" href="../../plans/record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>Interior Point Newton</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interior Point Newton</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/solvers/interior_point_Newton.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Interior-point-Newton-method"><a class="docs-heading-anchor" href="#Interior-point-Newton-method">Interior point Newton method</a><a id="Interior-point-Newton-method-1"></a><a class="docs-heading-anchor-permalink" href="#Interior-point-Newton-method" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.interior_point_Newton" href="#Manopt.interior_point_Newton"><code>Manopt.interior_point_Newton</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interior_point_Newton(M, f, grad_f, Hess_f, p=rand(M); kwargs...)
interior_point_Newton(M, cmo::ConstrainedManifoldObjective, p=rand(M); kwargs...)
interior_point_Newton!(M, f, grad]_f, Hess_f, p; kwargs...)
interior_point_Newton(M, ConstrainedManifoldObjective, p; kwargs...)</code></pre><p>perform the interior point Newton method following [<a href="../../references/#LaiYoshise:2024">LY24</a>].</p><p>In order to solve the constrained problem</p><p class="math-container">\[\begin{aligned}
\operatorname*{arg\,min}_{p ‚àà \mathcal M} &amp; f(p)\\
\text{subject to}\quad&amp;g_i(p) ‚â§ 0 \quad \text{ for } i= 1, ‚Ä¶, m,\\
\quad &amp; h_j(p)=0 \quad \text{ for } j=1,‚Ä¶,n,
\end{aligned}\]</p><p>This algorithms iteratively solves the linear system based on extending the KKT system by a slack variable <code>s</code>.</p><p class="math-container">\[\operatorname{J} F(p, Œº, Œª, s)[X, Y, Z, W] = -F(p, Œº, Œª, s),
\text{ where }
X ‚àà T_{p}\mathcal M, Y,W ‚àà ‚Ñù^m, Z ‚àà ‚Ñù^n,\]</p><p>see <a href="#Manopt.CondensedKKTVectorFieldJacobian"><code>CondensedKKTVectorFieldJacobian</code></a> and <a href="#Manopt.CondensedKKTVectorField"><code>CondensedKKTVectorField</code></a>, respectively, for the reduced form, this is usually solved in. From the resulting <code>X</code> and <code>Z</code> in the reeuced form, the other two, <span>$Y$</span>, <span>$W$</span>, are then computed.</p><p>From the gradient <span>$(X,Y,Z,W)$</span> at the current iterate <span>$(p, Œº, Œª, s)$</span>, a line search is performed using the <a href="#Manopt.KKTVectorFieldNormSq"><code>KKTVectorFieldNormSq</code></a> norm of the KKT vector field (squared) and its gradient <a href="#Manopt.KKTVectorFieldNormSqGradient"><code>KKTVectorFieldNormSqGradient</code></a> together with the <a href="#Manopt.InteriorPointCentralityCondition"><code>InteriorPointCentralityCondition</code></a>.</p><p>Note that since the vector field <span>$F$</span> includes the gradients of the constraint functions <span>$g, h$</span>, its gradient or Jacobian requires the Hessians of the constraints.</p><p>For that seach direction a line search is performed, that additionally ensures that the constraints are further fulfilled.</p><p><strong>Input</strong></p><ul><li><code>M</code>: a Riemannian manifold <span>$\mathcal M$</span></li><li><code>f</code>: a cost function <span>$f: \mathcal M‚Üí ‚Ñù$</span> implemented as <code>(M, p) -&gt; v</code></li><li><code>grad_f</code>: the (Riemannian) gradient <span>$\operatorname{grad}f: \mathcal M ‚Üí T_{p}\mathcal M$</span> of f as a function <code>(M, p) -&gt; X</code> or a function <code>(M, X, p) -&gt; X</code> computing <code>X</code> in-place</li><li><code>Hess_f</code>: the (Riemannian) Hessian <span>$\operatorname{Hess}f: T_{p}\mathcal M ‚Üí T_{p}\mathcal M$</span> of f as a function <code>(M, p, X) -&gt; Y</code> or a function <code>(M, Y, p, X) -&gt; Y</code> computing <code>Y</code> in-place</li><li><code>p</code>: a point on the manifold <span>$\mathcal M$</span></li></ul><p>or a <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code> containing <code>f</code>, <code>grad_f</code>, <code>Hess_f</code>, and the constraints</p><p><strong>Keyword arguments</strong></p><p>The keyword arguments related to the constraints (the first eleven) are ignored if you pass a <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code></p><ul><li><code>centrality_condition=missing</code>; an additional condition when to accept a step size. This can be used to ensure that the resulting iterate is still an interior point if you provide a check <code>(N,q) -&gt; true/false</code>, where <code>N</code> is the manifold of the <code>step_problem</code>.</li><li><code>equality_constraints=nothing</code>: the number <span>$n$</span> of equality constraints.</li><li><code>evaluation=</code><a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.</li><li><code>g=nothing</code>: the inequality constraints</li><li><code>grad_g=nothing</code>: the gradient of the inequality constraints</li><li><code>grad_h=nothing</code>: the gradient of the equality constraints</li><li><code>gradient_range=nothing</code>: specify how gradients are represented, where <code>nothing</code> is equivalent to <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/metamanifolds/#ManifoldsBase.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a></li><li><code>gradient_equality_range=gradient_range</code>: specify how the gradients of the equality constraints are represented</li><li><code>gradient_inequality_range=gradient_range</code>: specify how the gradients of the inequality constraints are represented</li><li><code>h=nothing</code>: the equality constraints</li><li><code>Hess_g=nothing</code>: the Hessian of the inequality constraints</li><li><code>Hess_h=nothing</code>: the Hessian of the equality constraints</li><li><code>inequality_constraints=nothing</code>: the number <span>$m$</span> of inequality constraints.</li><li><code>Œª=ones(length(h(M, p)))</code>: the Lagrange multiplier with respect to the equality constraints <span>$h$</span></li><li><code>Œº=ones(length(g(M, p)))</code>: the Lagrange multiplier with respect to the inequality constraints <span>$g$</span></li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>œÅ=Œº&#39;s / length(Œº)</code>:  store the orthogonality <code>Œº&#39;s/m</code> to compute the barrier parameter <code>Œ≤</code> in the sub problem.</li><li><code>s=copy(Œº)</code>: initial value for the slack variables</li><li><code>œÉ=</code><a href="#Manopt.calculate_œÉ"><code>calculate_œÉ</code></a><code>(M, cmo, p, Œº, Œª, s)</code>:  scaling factor for the barrier parameter <code>Œ≤</code> in the sub problem, which is updated during the iterations</li><li><code>step_objective</code>: a <a href="../../plans/objective/#Manopt.ManifoldGradientObjective"><code>ManifoldGradientObjective</code></a> of the norm of the KKT vector field <a href="#Manopt.KKTVectorFieldNormSq"><code>KKTVectorFieldNormSq</code></a> and its gradient <a href="#Manopt.KKTVectorFieldNormSqGradient"><code>KKTVectorFieldNormSqGradient</code></a></li><li><code>step_problem</code>: the manifold <span>$\mathcal M √ó ‚Ñù^m √ó ‚Ñù^n √ó ‚Ñù^m$</span> together with the <code>step_objective</code> as the problem the linesearch <code>stepsize=</code> employs for determining a step size</li><li><code>step_state</code>: the <a href="../../plans/stepsize/#Manopt.StepsizeState"><code>StepsizeState</code></a> with point and search direction</li><li><code>stepsize=</code><a href="../../plans/stepsize/#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a><code>()</code>: a functor inheriting from <a href="../../plans/stepsize/#Stepsize"><code>Stepsize</code></a> to determine a step size with the <code>centrality_condtion</code> keyword as additional criterion to accept a step, if this is provided</li><li><code>stopping_criterion=</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(200)</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenAny"><code>|</code></a><a href="#Manopt.StopWhenKKTResidualLess"><code>StopWhenKKTResidualLess</code></a><code>(1e-8)</code>: a functor indicating that the stopping criterion is fulfilled a stopping criterion, by default depending on the residual of the KKT vector field or a maximal number of steps, which ever hits first.</li><li><code>sub_kwargs=(;)</code>: keyword arguments to decorate the sub options, for example debug, that automatically respects the main solvers debug options (like sub-sampling) as well</li><li><code>sub_objective</code>: The <a href="../conjugate_residual/#Manopt.SymmetricLinearSystemObjective"><code>SymmetricLinearSystemObjective</code></a> modelling the system of equations to use in the sub solver, includes the <a href="#Manopt.CondensedKKTVectorFieldJacobian"><code>CondensedKKTVectorFieldJacobian</code></a> <span>$\mathcal A(X)$</span> and the <a href="#Manopt.CondensedKKTVectorField"><code>CondensedKKTVectorField</code></a> <span>$b$</span> in <span>$\mathcal A(X) + b = 0$</span> we aim to solve. This is used to define the <code>sub_problem=</code> keyword and has hence no effect, if you set <code>sub_problem</code> directly.</li><li><code>sub_stopping_criterion=</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(manifold_dimension(M))</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenAny"><code>|</code></a><a href="../conjugate_residual/#Manopt.StopWhenRelativeResidualLess"><code>StopWhenRelativeResidualLess</code></a><code>(c,1e-8)</code>, where <span>$c = \lVert b \rVert_{}$</span> from the system to solve. This is used to define the <code>sub_state=</code> keyword and has hence no effect, if you set <code>sub_state</code> directly.</li><li><code>sub_problem=</code><a href="../../plans/problem/#Manopt.DefaultManoptProblem"><code>DefaultManoptProblem</code></a><code>(M, sub_objective)</code>:  specify a problem for a solver or a closed form solution function, which can be allocating or in-place.</li><li><code>sub_state=</code><a href="../conjugate_residual/#Manopt.ConjugateResidualState"><code>ConjugateResidualState</code></a>:  a state to specify the sub solver to use. For a closed form solution, this indicates the type of function.</li><li><code>vector_space=</code><a href="../../extensions/#Manopt.Rn"><code>Rn</code></a> a function that, given an integer, returns the manifold to be used for the vector space components <span>$‚Ñù^m,‚Ñù^n$</span></li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M,p)</code>: th initial gradient with respect to <code>p</code>.</li><li><code>Y=zero(Œº)</code>:  the initial gradient with respct to <code>Œº</code></li><li><code>Z=zero(Œª)</code>:  the initial gradient with respct to <code>Œª</code></li><li><code>W=zero(s)</code>:  the initial gradient with respct to <code>s</code></li></ul><p>As well as internal keywords used to set up these given keywords like <code>_step_M</code>, <code>_step_p</code>, <code>_sub_M</code>, <code>_sub_p</code>, and <code>_sub_X</code>, that should not be changed.</p><p>All other keyword arguments are passed to <a href="../../plans/state/#Manopt.decorate_state!"><code>decorate_state!</code></a> for state decorators or <a href="../../plans/objective/#Manopt.decorate_objective!"><code>decorate_objective!</code></a> for objective, respectively.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>centrality_condition=mising</code> disables to check centrality during the line search, but you can pass <a href="#Manopt.InteriorPointCentralityCondition"><code>InteriorPointCentralityCondition</code></a><code>(cmo, Œ≥)</code>, where <code>Œ≥</code> is a constant, to activate this check.</p></div></div><p><strong>Output</strong></p><p>The obtained approximate constrained minimizer <span>$p^*$</span>. To obtain the whole final state of the solver, see <a href="../#Manopt.get_solver_return"><code>get_solver_return</code></a> for details, especially the <code>return_state=</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/solvers/interior_point_Newton.jl#L114-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.interior_point_Newton!" href="#Manopt.interior_point_Newton!"><code>Manopt.interior_point_Newton!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interior_point_Newton(M, f, grad_f, Hess_f, p=rand(M); kwargs...)
interior_point_Newton(M, cmo::ConstrainedManifoldObjective, p=rand(M); kwargs...)
interior_point_Newton!(M, f, grad]_f, Hess_f, p; kwargs...)
interior_point_Newton(M, ConstrainedManifoldObjective, p; kwargs...)</code></pre><p>perform the interior point Newton method following [<a href="../../references/#LaiYoshise:2024">LY24</a>].</p><p>In order to solve the constrained problem</p><p class="math-container">\[\begin{aligned}
\operatorname*{arg\,min}_{p ‚àà \mathcal M} &amp; f(p)\\
\text{subject to}\quad&amp;g_i(p) ‚â§ 0 \quad \text{ for } i= 1, ‚Ä¶, m,\\
\quad &amp; h_j(p)=0 \quad \text{ for } j=1,‚Ä¶,n,
\end{aligned}\]</p><p>This algorithms iteratively solves the linear system based on extending the KKT system by a slack variable <code>s</code>.</p><p class="math-container">\[\operatorname{J} F(p, Œº, Œª, s)[X, Y, Z, W] = -F(p, Œº, Œª, s),
\text{ where }
X ‚àà T_{p}\mathcal M, Y,W ‚àà ‚Ñù^m, Z ‚àà ‚Ñù^n,\]</p><p>see <a href="#Manopt.CondensedKKTVectorFieldJacobian"><code>CondensedKKTVectorFieldJacobian</code></a> and <a href="#Manopt.CondensedKKTVectorField"><code>CondensedKKTVectorField</code></a>, respectively, for the reduced form, this is usually solved in. From the resulting <code>X</code> and <code>Z</code> in the reeuced form, the other two, <span>$Y$</span>, <span>$W$</span>, are then computed.</p><p>From the gradient <span>$(X,Y,Z,W)$</span> at the current iterate <span>$(p, Œº, Œª, s)$</span>, a line search is performed using the <a href="#Manopt.KKTVectorFieldNormSq"><code>KKTVectorFieldNormSq</code></a> norm of the KKT vector field (squared) and its gradient <a href="#Manopt.KKTVectorFieldNormSqGradient"><code>KKTVectorFieldNormSqGradient</code></a> together with the <a href="#Manopt.InteriorPointCentralityCondition"><code>InteriorPointCentralityCondition</code></a>.</p><p>Note that since the vector field <span>$F$</span> includes the gradients of the constraint functions <span>$g, h$</span>, its gradient or Jacobian requires the Hessians of the constraints.</p><p>For that seach direction a line search is performed, that additionally ensures that the constraints are further fulfilled.</p><p><strong>Input</strong></p><ul><li><code>M</code>: a Riemannian manifold <span>$\mathcal M$</span></li><li><code>f</code>: a cost function <span>$f: \mathcal M‚Üí ‚Ñù$</span> implemented as <code>(M, p) -&gt; v</code></li><li><code>grad_f</code>: the (Riemannian) gradient <span>$\operatorname{grad}f: \mathcal M ‚Üí T_{p}\mathcal M$</span> of f as a function <code>(M, p) -&gt; X</code> or a function <code>(M, X, p) -&gt; X</code> computing <code>X</code> in-place</li><li><code>Hess_f</code>: the (Riemannian) Hessian <span>$\operatorname{Hess}f: T_{p}\mathcal M ‚Üí T_{p}\mathcal M$</span> of f as a function <code>(M, p, X) -&gt; Y</code> or a function <code>(M, Y, p, X) -&gt; Y</code> computing <code>Y</code> in-place</li><li><code>p</code>: a point on the manifold <span>$\mathcal M$</span></li></ul><p>or a <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code> containing <code>f</code>, <code>grad_f</code>, <code>Hess_f</code>, and the constraints</p><p><strong>Keyword arguments</strong></p><p>The keyword arguments related to the constraints (the first eleven) are ignored if you pass a <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code></p><ul><li><code>centrality_condition=missing</code>; an additional condition when to accept a step size. This can be used to ensure that the resulting iterate is still an interior point if you provide a check <code>(N,q) -&gt; true/false</code>, where <code>N</code> is the manifold of the <code>step_problem</code>.</li><li><code>equality_constraints=nothing</code>: the number <span>$n$</span> of equality constraints.</li><li><code>evaluation=</code><a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.</li><li><code>g=nothing</code>: the inequality constraints</li><li><code>grad_g=nothing</code>: the gradient of the inequality constraints</li><li><code>grad_h=nothing</code>: the gradient of the equality constraints</li><li><code>gradient_range=nothing</code>: specify how gradients are represented, where <code>nothing</code> is equivalent to <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/metamanifolds/#ManifoldsBase.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a></li><li><code>gradient_equality_range=gradient_range</code>: specify how the gradients of the equality constraints are represented</li><li><code>gradient_inequality_range=gradient_range</code>: specify how the gradients of the inequality constraints are represented</li><li><code>h=nothing</code>: the equality constraints</li><li><code>Hess_g=nothing</code>: the Hessian of the inequality constraints</li><li><code>Hess_h=nothing</code>: the Hessian of the equality constraints</li><li><code>inequality_constraints=nothing</code>: the number <span>$m$</span> of inequality constraints.</li><li><code>Œª=ones(length(h(M, p)))</code>: the Lagrange multiplier with respect to the equality constraints <span>$h$</span></li><li><code>Œº=ones(length(g(M, p)))</code>: the Lagrange multiplier with respect to the inequality constraints <span>$g$</span></li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>œÅ=Œº&#39;s / length(Œº)</code>:  store the orthogonality <code>Œº&#39;s/m</code> to compute the barrier parameter <code>Œ≤</code> in the sub problem.</li><li><code>s=copy(Œº)</code>: initial value for the slack variables</li><li><code>œÉ=</code><a href="#Manopt.calculate_œÉ"><code>calculate_œÉ</code></a><code>(M, cmo, p, Œº, Œª, s)</code>:  scaling factor for the barrier parameter <code>Œ≤</code> in the sub problem, which is updated during the iterations</li><li><code>step_objective</code>: a <a href="../../plans/objective/#Manopt.ManifoldGradientObjective"><code>ManifoldGradientObjective</code></a> of the norm of the KKT vector field <a href="#Manopt.KKTVectorFieldNormSq"><code>KKTVectorFieldNormSq</code></a> and its gradient <a href="#Manopt.KKTVectorFieldNormSqGradient"><code>KKTVectorFieldNormSqGradient</code></a></li><li><code>step_problem</code>: the manifold <span>$\mathcal M √ó ‚Ñù^m √ó ‚Ñù^n √ó ‚Ñù^m$</span> together with the <code>step_objective</code> as the problem the linesearch <code>stepsize=</code> employs for determining a step size</li><li><code>step_state</code>: the <a href="../../plans/stepsize/#Manopt.StepsizeState"><code>StepsizeState</code></a> with point and search direction</li><li><code>stepsize=</code><a href="../../plans/stepsize/#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a><code>()</code>: a functor inheriting from <a href="../../plans/stepsize/#Stepsize"><code>Stepsize</code></a> to determine a step size with the <code>centrality_condtion</code> keyword as additional criterion to accept a step, if this is provided</li><li><code>stopping_criterion=</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(200)</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenAny"><code>|</code></a><a href="#Manopt.StopWhenKKTResidualLess"><code>StopWhenKKTResidualLess</code></a><code>(1e-8)</code>: a functor indicating that the stopping criterion is fulfilled a stopping criterion, by default depending on the residual of the KKT vector field or a maximal number of steps, which ever hits first.</li><li><code>sub_kwargs=(;)</code>: keyword arguments to decorate the sub options, for example debug, that automatically respects the main solvers debug options (like sub-sampling) as well</li><li><code>sub_objective</code>: The <a href="../conjugate_residual/#Manopt.SymmetricLinearSystemObjective"><code>SymmetricLinearSystemObjective</code></a> modelling the system of equations to use in the sub solver, includes the <a href="#Manopt.CondensedKKTVectorFieldJacobian"><code>CondensedKKTVectorFieldJacobian</code></a> <span>$\mathcal A(X)$</span> and the <a href="#Manopt.CondensedKKTVectorField"><code>CondensedKKTVectorField</code></a> <span>$b$</span> in <span>$\mathcal A(X) + b = 0$</span> we aim to solve. This is used to define the <code>sub_problem=</code> keyword and has hence no effect, if you set <code>sub_problem</code> directly.</li><li><code>sub_stopping_criterion=</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(manifold_dimension(M))</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenAny"><code>|</code></a><a href="../conjugate_residual/#Manopt.StopWhenRelativeResidualLess"><code>StopWhenRelativeResidualLess</code></a><code>(c,1e-8)</code>, where <span>$c = \lVert b \rVert_{}$</span> from the system to solve. This is used to define the <code>sub_state=</code> keyword and has hence no effect, if you set <code>sub_state</code> directly.</li><li><code>sub_problem=</code><a href="../../plans/problem/#Manopt.DefaultManoptProblem"><code>DefaultManoptProblem</code></a><code>(M, sub_objective)</code>:  specify a problem for a solver or a closed form solution function, which can be allocating or in-place.</li><li><code>sub_state=</code><a href="../conjugate_residual/#Manopt.ConjugateResidualState"><code>ConjugateResidualState</code></a>:  a state to specify the sub solver to use. For a closed form solution, this indicates the type of function.</li><li><code>vector_space=</code><a href="../../extensions/#Manopt.Rn"><code>Rn</code></a> a function that, given an integer, returns the manifold to be used for the vector space components <span>$‚Ñù^m,‚Ñù^n$</span></li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M,p)</code>: th initial gradient with respect to <code>p</code>.</li><li><code>Y=zero(Œº)</code>:  the initial gradient with respct to <code>Œº</code></li><li><code>Z=zero(Œª)</code>:  the initial gradient with respct to <code>Œª</code></li><li><code>W=zero(s)</code>:  the initial gradient with respct to <code>s</code></li></ul><p>As well as internal keywords used to set up these given keywords like <code>_step_M</code>, <code>_step_p</code>, <code>_sub_M</code>, <code>_sub_p</code>, and <code>_sub_X</code>, that should not be changed.</p><p>All other keyword arguments are passed to <a href="../../plans/state/#Manopt.decorate_state!"><code>decorate_state!</code></a> for state decorators or <a href="../../plans/objective/#Manopt.decorate_objective!"><code>decorate_objective!</code></a> for objective, respectively.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>centrality_condition=mising</code> disables to check centrality during the line search, but you can pass <a href="#Manopt.InteriorPointCentralityCondition"><code>InteriorPointCentralityCondition</code></a><code>(cmo, Œ≥)</code>, where <code>Œ≥</code> is a constant, to activate this check.</p></div></div><p><strong>Output</strong></p><p>The obtained approximate constrained minimizer <span>$p^*$</span>. To obtain the whole final state of the solver, see <a href="../#Manopt.get_solver_return"><code>get_solver_return</code></a> for details, especially the <code>return_state=</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/solvers/interior_point_Newton.jl#L158-L275">source</a></section></article><h2 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InteriorPointNewtonState" href="#Manopt.InteriorPointNewtonState"><code>Manopt.InteriorPointNewtonState</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InteriorPointNewtonState{P,T} &lt;: AbstractHessianSolverState</code></pre><p><strong>Fields</strong></p><ul><li><code>Œª</code>:           the Lagrange multiplier with respect to the equality constraints</li><li><code>Œº</code>:           the Lagrange multiplier with respect to the inequality constraints</li><li><code>p::P</code>: a point on the manifold <span>$\mathcal M$</span>storing the current iterate</li><li><code>s</code>:           the current slack variable</li><li><code>sub_problem::Union{AbstractManoptProblem, F}</code>:  specify a problem for a solver or a closed form solution function, which can be allocating or in-place.</li><li><code>sub_state::Union{AbstractManoptProblem, F}</code>:  a state to specify the sub solver to use. For a closed form solution, this indicates the type of function.</li><li><code>X</code>:           the current gradient with respect to <code>p</code></li><li><code>Y</code>:           the current gradient with respect to <code>Œº</code></li><li><code>Z</code>:           the current gradient with respect to <code>Œª</code></li><li><code>W</code>:           the current gradient with respect to <code>s</code></li><li><code>œÅ</code>:           store the orthogonality <code>Œº&#39;s/m</code> to compute the barrier parameter <code>Œ≤</code> in the sub problem</li><li><code>œÉ</code>:           scaling factor for the barrier parameter <code>Œ≤</code> in the sub problem</li><li><code>stop::StoppingCriterion</code>: a functor indicating that the stopping criterion is fulfilled</li><li><code>retraction_method::AbstractRetractionMethod</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stepsize::Stepsize</code>: a functor inheriting from <a href="../../plans/stepsize/#Stepsize"><code>Stepsize</code></a> to determine a step size</li><li><code>step_problem</code>: an <a href="../../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> storing the manifold and objective for the line search</li><li><code>step_state</code>: storing iterate and search direction in a state for the line search, see <a href="../../plans/stepsize/#Manopt.StepsizeState"><code>StepsizeState</code></a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">InteriorPointNewtonState(
    M::AbstractManifold,
    cmo::ConstrainedManifoldObjective,
    sub_problem::Pr,
    sub_state::St;
    kwargs...
)</code></pre><p>Initialize the state, where both the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> and the <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> are used to fill in reasonable defaults for the keywords.</p><p><strong>Input</strong></p><ul><li><code>M::</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code></code>: a Riemannian manifold <span>$\mathcal M$</span></li><li><code>cmo</code>:         a <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a></li><li><code>sub_problem</code>:  specify a problem for a solver or a closed form solution function, which can be allocating or in-place.</li><li><code>sub_state</code>:  a state to specify the sub solver to use. For a closed form solution, this indicates the type of function.</li></ul><p><strong>Keyword arguments</strong></p><p>Let <code>m</code> and <code>n</code> denote the number of inequality and equality constraints, respectively</p><ul><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>to specify the initial value</li><li><code>Œº=ones(m)</code></li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M,p)</code></li><li><code>Y=zero(Œº)</code></li><li><code>Œª=zeros(n)</code></li><li><code>Z=zero(Œª)</code></li><li><code>s=ones(m)</code></li><li><code>W=zero(s)</code></li><li><code>œÅ=Œº&#39;s/m</code></li><li><code>œÉ=</code><a href="#Manopt.calculate_œÉ"><code>calculate_œÉ</code></a><code>(M, cmo, p, Œº, Œª, s)</code></li><li><code>stopping_criterion=</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(200)</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenAny"><code>|</code></a><a href="../../plans/stopping_criteria/#Manopt.StopWhenChangeLess"><code>StopWhenChangeLess</code></a><code>(1e-8)</code>: a functor indicating that the stopping criterion is fulfilled</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>step_objective=</code><a href="../../plans/objective/#Manopt.ManifoldGradientObjective"><code>ManifoldGradientObjective</code></a><code>(</code><a href="#Manopt.KKTVectorFieldNormSq"><code>KKTVectorFieldNormSq</code></a><code>(cmo)</code>, <a href="#Manopt.KKTVectorFieldNormSqGradient"><code>KKTVectorFieldNormSqGradient</code></a><code>(cmo)</code>; evaluation=<a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a><code>())</code></li><li><code>vector_space=</code><a href="../../extensions/#Manopt.Rn"><code>Rn</code></a>: a function that, given an integer, returns the manifold to be used for the vector space components <span>$‚Ñù^m,‚Ñù^n$</span></li><li><code>step_problem</code>: wrap the manifold <span>$\mathcal M √ó ‚Ñù^m √ó ‚Ñù^n √ó ‚Ñù^m$</span></li><li><code>step_state</code>: the <a href="../../plans/stepsize/#Manopt.StepsizeState"><code>StepsizeState</code></a> with point and search direction</li><li><code>stepsize=</code><a href="../../plans/stepsize/#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a><code>()</code>: a functor inheriting from <a href="../../plans/stepsize/#Stepsize"><code>Stepsize</code></a> to determine a step size with the <a href="#Manopt.InteriorPointCentralityCondition"><code>InteriorPointCentralityCondition</code></a> as additional condition to accept a step</li></ul><p>and internally <code>_step_M</code> and <code>_step_p</code> for the manifold and point in the stepsize.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L31-L97">source</a></section></article><h2 id="Subproblem-functions"><a class="docs-heading-anchor" href="#Subproblem-functions">Subproblem functions</a><a id="Subproblem-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Subproblem-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.CondensedKKTVectorField" href="#Manopt.CondensedKKTVectorField"><code>Manopt.CondensedKKTVectorField</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CondensedKKTVectorField{O&lt;:ConstrainedManifoldObjective,T,R} &lt;: AbstractConstrainedSlackFunctor{T,R}</code></pre><p>Given the constrained optimization problem</p><p class="math-container">\[\begin{aligned}
\min_{p ‚àà\mathcal{M}} &amp;f(p)\\
\text{subject to } &amp;g_i(p)\leq 0 \quad \text{ for } i= 1, ‚Ä¶, m,\\
\quad &amp;h_j(p)=0 \quad \text{ for } j=1,‚Ä¶,n,
\end{aligned}\]</p><p>Then reformulating the KKT conditions of the Lagrangian from the optimality conditions of the Lagrangian</p><p class="math-container">\[\mathcal L(p, Œº, Œª) = f(p) + \sum_{j=1}^n Œª_jh_j(p) + \sum_{i=1}^m Œº_ig_i(p)\]</p><p>in a perturbed / barrier method in a condensed form using a slack variable <span>$s ‚àà ‚Ñù^m$</span> and a barrier parameter <span>$Œ≤$</span> and the Riemannian gradient of the Lagrangian with respect to the first parameter <span>$\operatorname{grad}_p L(p, Œº, Œª)$</span>.</p><p>Let <span>$\mathcal N = \mathcal M √ó ‚Ñù^n$</span>. We obtain the linear system</p><p class="math-container">\[\mathcal A(p,Œª)[X,Y] = -b(p,Œª),\qquad \text{where } (X,Y) ‚àà T_{(p,Œª)}\mathcal N\]</p><p>where <span>$\mathcal A: T_{(p,Œª)}\mathcal N ‚Üí T_{(p,Œª)}\mathcal N$</span> is a linear operator and this struct models the right hand side <span>$b(p,Œª) ‚àà T_{(p,Œª)}\mathcal M$</span> given by</p><p class="math-container">\[b(p,Œª) = \begin{pmatrix}
\operatorname{grad} f(p)
+ \displaystyle\sum_{j=1}^n Œª_j \operatorname{grad} h_j(p)
+ \displaystyle\sum_{i=1}^m Œº_i \operatorname{grad} g_i(p)
+ \displaystyle\sum_{i=1}^m \frac{Œº_i}{s_i}\bigl(
  Œº_i(g_i(p)+s_i) + Œ≤ - Œº_is_i
\bigr)\operatorname{grad} g_i(p)\\
h(p)
\end{pmatrix}\]</p><p><strong>Fields</strong></p><ul><li><code>cmo</code> the <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a></li><li><code>Œº::T</code> the vector in <span>$‚Ñù^m$</span> of coefficients for the inequality constraints</li><li><code>s::T</code> the vector in <span>$‚Ñù^m$</span> of sclack variables</li><li><code>Œ≤::R</code> the barrier parameter <span>$Œ≤‚àà‚Ñù$</span></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">CondensedKKTVectorField(cmo, Œº, s, Œ≤)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L252-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.CondensedKKTVectorFieldJacobian" href="#Manopt.CondensedKKTVectorFieldJacobian"><code>Manopt.CondensedKKTVectorFieldJacobian</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CondensedKKTVectorFieldJacobian{O&lt;:ConstrainedManifoldObjective,T,R}  &lt;: AbstractConstrainedSlackFunctor{T,R}</code></pre><p>Given the constrained optimization problem</p><p class="math-container">\[\begin{aligned}
\min_{p ‚àà\mathcal{M}} &amp;f(p)\\
\text{subject to } &amp;g_i(p)\leq 0 \quad \text{ for } i= 1, ‚Ä¶, m,\\
\quad &amp;h_j(p)=0 \quad \text{ for } j=1,‚Ä¶,n,
\end{aligned}\]</p><p>we reformulate the KKT conditions of the Lagrangian from the optimality conditions of the Lagrangian</p><p class="math-container">\[\mathcal L(p, Œº, Œª) = f(p) + \sum_{j=1}^n Œª_jh_j(p) + \sum_{i=1}^m Œº_ig_i(p)\]</p><p>in a perturbed / barrier method enhanced as well as condensed form as using <span>$\operatorname{grad}_o L(p, Œº, Œª)$</span> the Riemannian gradient of the Lagrangian with respect to the first parameter.</p><p>Let <span>$\mathcal N = \mathcal M √ó ‚Ñù^n$</span>. We obtain the linear system</p><p class="math-container">\[\mathcal A(p,Œª)[X,Y] = -b(p,Œª),\qquad \text{where } X ‚àà T_p\mathcal M, Y ‚àà ‚Ñù^n\]</p><p>where <span>$\mathcal A: T_{(p,Œª)}\mathcal N ‚Üí T_{(p,Œª)}\mathcal N$</span> is a linear operator on <span>$T_{(p,Œª)}\mathcal N = T_p\mathcal M √ó ‚Ñù^n$</span> given by</p><p class="math-container">\[\mathcal A(p,Œª)[X,Y] = \begin{pmatrix}
\operatorname{Hess}_p\mathcal L(p, Œº, Œª)[X]
+ \displaystyle\sum_{i=1}^m \frac{Œº_i}{s_i}‚ü®\operatorname{grad} g_i(p), X‚ü©\operatorname{grad} g_i(p)
+ \displaystyle\sum_{j=1}^n Y_j \operatorname{grad} h_j(p)
\\
\Bigl( ‚ü®\operatorname{grad} h_j(p), X‚ü© \Bigr)_{j=1}^n
\end{pmatrix}\]</p><p><strong>Fields</strong></p><ul><li><code>cmo</code> the <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a></li><li><code>Œº::V</code> the vector in <span>$‚Ñù^m$</span> of coefficients for the inequality constraints</li><li><code>s::V</code> the vector in <span>$‚Ñù^m$</span> of slack variables</li><li><code>Œ≤::R</code> the barrier parameter <span>$Œ≤‚àà‚Ñù$</span></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">CondensedKKTVectorFieldJacobian(cmo, Œº, s, Œ≤)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L354-L405">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.KKTVectorField" href="#Manopt.KKTVectorField"><code>Manopt.KKTVectorField</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KKTVectorField{O&lt;:ConstrainedManifoldObjective}</code></pre><p>Implement the vectorfield <span>$F$</span> KKT-conditions, inlcuding a slack variable for the inequality constraints.</p><p>Given the <a href="../../plans/objective/#Manopt.LagrangianCost"><code>LagrangianCost</code></a></p><p class="math-container">\[\mathcal L(p; Œº, Œª) = f(p) + \sum_{i=1}^m Œº_ig_i(p) + \sum_{j=1}^n Œª_jh_j(p)\]</p><p>the <a href="../../plans/objective/#Manopt.LagrangianGradient"><code>LagrangianGradient</code></a></p><p class="math-container">\[\operatorname{grad}\mathcal L(p, Œº, Œª) = \operatorname{grad}f(p) + \sum_{j=1}^n Œª_j \operatorname{grad} h_j(p) + \sum_{i=1}^m Œº_i \operatorname{grad} g_i(p),\]</p><p>and introducing the slack variables <span>$s=-g(p) ‚àà ‚Ñù^m$</span> the vector field is given by</p><p class="math-container">\[F(p, Œº, Œª, s) = \begin{pmatrix}
\operatorname{grad}_p \mathcal L(p, Œº, Œª)\\
g(p) + s\\
h(p)\\
Œº ‚äô s
\end{pmatrix}, \text{ where } p \in \mathcal M, Œº, s \in ‚Ñù^m\text{ and } Œª \in ‚Ñù^n,\]</p><p>where <span>$‚äô$</span> denotes the Hadamard (or elementwise) product</p><p><strong>Fields</strong></p><ul><li><code>cmo</code> the <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a></li></ul><p>While the point <code>p</code> is arbitrary and usually not needed, it serves as internal memory in the computations. Furthermore Both fields together also calrify the product manifold structure to use.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">KKTVectorField(cmo::ConstrainedManifoldObjective)</code></pre><p><strong>Example</strong></p><p>Define <code>F = KKTVectorField(cmo)</code> for some <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code> and let <code>N</code> be the product manifold of <span>$\mathcal M√ó‚Ñù^m√ó‚Ñù^n√ó‚Ñù^m$</span>. Then, you can call this cost as <code>F(N, q)</code> or as the in-place variant <code>F(N, Y, q)</code>, where <code>q</code> is a point on <code>N</code> and <code>Y</code> is a tangent vector at <code>q</code> for the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L456-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.KKTVectorFieldJacobian" href="#Manopt.KKTVectorFieldJacobian"><code>Manopt.KKTVectorFieldJacobian</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KKTVectorFieldJacobian{O&lt;:ConstrainedManifoldObjective}</code></pre><p>Implement the Jacobian of the vector field <span>$F$</span> of the KKT-conditions, inlcuding a slack variable for the inequality constraints, see <a href="#Manopt.KKTVectorField"><code>KKTVectorField</code></a> and <a href="#Manopt.KKTVectorFieldAdjointJacobian"><code>KKTVectorFieldAdjointJacobian</code></a>..</p><p class="math-container">\[\operatorname{J} F(p, Œº, Œª, s)[X, Y, Z, W] = \begin{pmatrix}
    \operatorname{Hess}_p \mathcal L(p, Œº, Œª)[X] + \displaystyle\sum_{i=1}^m Y_i \operatorname{grad} g_i(p) + \displaystyle\sum_{j=1}^n Z_j \operatorname{grad} h_j(p)\\
    \Bigl( ‚ü®\operatorname{grad} g_i(p), X‚ü© + W_i\Bigr)_{i=1}^m\\
    \Bigl( ‚ü®\operatorname{grad} h_j(p), X‚ü© \Bigr)_{j=1}^n\\
    Œº ‚äô W + s ‚äô Y
\end{pmatrix},\]</p><p>where <span>$‚äô$</span> denotes the Hadamard (or elementwise) product</p><p>See also the <a href="../../plans/objective/#Manopt.LagrangianHessian"><code>LagrangianHessian</code></a> <span>$\operatorname{Hess}_p \mathcal L(p, Œº, Œª)[X]$</span>.</p><p><strong>Fields</strong></p><ul><li><code>cmo</code> the <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">KKTVectorFieldJacobian(cmo::ConstrainedManifoldObjective)</code></pre><p>Generate the Jacobian of the KKT vector field related to some <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code>.</p><p><strong>Example</strong></p><p>Define <code>JF = KKTVectorFieldJacobian(cmo)</code> for some <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code> and let <code>N</code> be the product manifold of <span>$\mathcal M√ó‚Ñù^m√ó‚Ñù^n√ó‚Ñù^m$</span>. Then, you can call this cost as <code>JF(N, q, Y)</code> or as the in-place variant <code>JF(N, Z, q, Y)</code>, where <code>q</code> is a point on <code>N</code> and <code>Y</code> and <code>Z</code> are a tangent vector at <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L529-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.KKTVectorFieldAdjointJacobian" href="#Manopt.KKTVectorFieldAdjointJacobian"><code>Manopt.KKTVectorFieldAdjointJacobian</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KKTVectorFieldAdjointJacobian{O&lt;:ConstrainedManifoldObjective}</code></pre><p>Implement the Adjoint of the Jacobian of the vector field <span>$F$</span> of the KKT-conditions, inlcuding a slack variable for the inequality constraints, see <a href="#Manopt.KKTVectorField"><code>KKTVectorField</code></a> and <a href="#Manopt.KKTVectorFieldJacobian"><code>KKTVectorFieldJacobian</code></a>.</p><p class="math-container">\[\operatorname{J}^* F(p, Œº, Œª, s)[X, Y, Z, W] = \begin{pmatrix}
    \operatorname{Hess}_p \mathcal L(p, Œº, Œª)[X] + \displaystyle\sum_{i=1}^m Y_i \operatorname{grad} g_i(p) + \displaystyle\sum_{j=1}^n Z_j \operatorname{grad} h_j(p)\\
    \Bigl( ‚ü®\operatorname{grad} g_i(p), X‚ü© + s_iW_i\Bigr)_{i=1}^m\\
    \Bigl( ‚ü®\operatorname{grad} h_j(p), X‚ü© \Bigr)_{j=1}^n\\
    Œº ‚äô W + Y
\end{pmatrix},\]</p><p>where <span>$‚äô$</span> denotes the Hadamard (or elementwise) product</p><p>See also the <a href="../../plans/objective/#Manopt.LagrangianHessian"><code>LagrangianHessian</code></a> <span>$\operatorname{Hess}_p \mathcal L(p, Œº, Œª)[X]$</span>.</p><p><strong>Fields</strong></p><ul><li><code>cmo</code> the <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">KKTVectorFieldAdjointJacobian(cmo::ConstrainedManifoldObjective)</code></pre><p>Generate the Adjoint Jacobian of the KKT vector field related to some <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code>.</p><p><strong>Example</strong></p><p>Define <code>AdJF = KKTVectorFieldAdjointJacobian(cmo)</code> for some <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code> and let <code>N</code> be the product manifold of <span>$\mathcal M√ó‚Ñù^m√ó‚Ñù^n√ó‚Ñù^m$</span>. Then, you can call this cost as <code>AdJF(N, q, Y)</code> or as the in-place variant <code>AdJF(N, Z, q, Y)</code>, where <code>q</code> is a point on <code>N</code> and <code>Y</code> and <code>Z</code> are a tangent vector at <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L603-L637">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.KKTVectorFieldNormSq" href="#Manopt.KKTVectorFieldNormSq"><code>Manopt.KKTVectorFieldNormSq</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KKTVectorFieldNormSq{O&lt;:ConstrainedManifoldObjective}</code></pre><p>Implement the square of the norm of the vectorfield <span>$F$</span> of the KKT-conditions, inlcuding a slack variable for the inequality constraints, see <a href="#Manopt.KKTVectorField"><code>KKTVectorField</code></a>, where this functor applies the norm to. In [<a href="../../references/#LaiYoshise:2024">LY24</a>] this is called the merit function.</p><p><strong>Fields</strong></p><ul><li><code>cmo</code> the <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">KKTVectorFieldNormSq(cmo::ConstrainedManifoldObjective)</code></pre><p><strong>Example</strong></p><p>Define <code>f = KKTVectorFieldNormSq(cmo)</code> for some <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code> and let <code>N</code> be the product manifold of <span>$\mathcal M√ó‚Ñù^m√ó‚Ñù^n√ó‚Ñù^m$</span>. Then, you can call this cost as <code>f(N, q)</code>, where <code>q</code> is a point on <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L676-L696">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.KKTVectorFieldNormSqGradient" href="#Manopt.KKTVectorFieldNormSqGradient"><code>Manopt.KKTVectorFieldNormSqGradient</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KKTVectorFieldNormSqGradient{O&lt;:ConstrainedManifoldObjective}</code></pre><p>Compute the gradient of the <a href="#Manopt.KKTVectorFieldNormSq"><code>KKTVectorFieldNormSq</code></a> <span>$œÜ(p,Œº,Œª,s) = \lVert F(p,Œº,Œª,s)\rVert^2$</span>, that is of the norm squared of the <a href="#Manopt.KKTVectorField"><code>KKTVectorField</code></a> <span>$F$</span>.</p><p>This is given in [<a href="../../references/#LaiYoshise:2024">LY24</a>] as the gradient of their merit function, which we can write with the adjoint <span>$J^*$</span> of the Jacobian</p><p class="math-container">\[\operatorname{grad} œÜ = 2\operatorname{J}^* F(p, Œº, Œª, s)[F(p, Œº, Œª, s)],\]</p><p>and hence is computed with <a href="#Manopt.KKTVectorFieldAdjointJacobian"><code>KKTVectorFieldAdjointJacobian</code></a> and <a href="#Manopt.KKTVectorField"><code>KKTVectorField</code></a>.</p><p>For completeness, the gradient reads, using the <a href="../../plans/objective/#Manopt.LagrangianGradient"><code>LagrangianGradient</code></a> <span>$L = \operatorname{grad}_p \mathcal L(p,Œº,Œª) ‚àà T_p\mathcal M$</span>, for a shorthand of the first component of <span>$F$</span>, as</p><p class="math-container">\[\operatorname{grad} œÜ
=
2 \begin{pmatrix}
\operatorname{grad}_p \mathcal L(p,Œº,Œª)[L] + (g_i(p) + s_i)\operatorname{grad} g_i(p) + h_j(p)\operatorname{grad} h_j(p)\\
  \Bigl( ‚ü®\operatorname{grad} g_i(p), L‚ü© + s_i\Bigr)_{i=1}^m + Œº ‚äô s ‚äô s\\
  \Bigl( ‚ü®\operatorname{grad} h_j(p), L‚ü© \Bigr)_{j=1}^n\\
  g + s + Œº ‚äô Œº ‚äô s
\end{pmatrix},\]</p><p>where <span>$‚äô$</span> denotes the Hadamard (or elementwise) product.</p><p><strong>Fields</strong></p><ul><li><code>cmo</code> the <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">KKTVectorFieldNormSqGradient(cmo::ConstrainedManifoldObjective)</code></pre><p><strong>Example</strong></p><p>Define <code>grad_f = KKTVectorFieldNormSqGradient(cmo)</code> for some <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code> and let <code>N</code> be the product manifold of <span>$\mathcal M√ó‚Ñù^m√ó‚Ñù^n√ó‚Ñù^m$</span>. Then, you can call this cost as <code>grad_f(N, q)</code> or as the in-place variant <code>grad_f(N, Y, q)</code>, where <code>q</code> is a point on <code>N</code> and <code>Y</code> is a tangent vector at <code>q</code> returning the resulting gradient at.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L709-L753">source</a></section></article><h2 id="Helpers"><a class="docs-heading-anchor" href="#Helpers">Helpers</a><a id="Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Helpers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InteriorPointCentralityCondition" href="#Manopt.InteriorPointCentralityCondition"><code>Manopt.InteriorPointCentralityCondition</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InteriorPointCentralityCondition{CO,R}</code></pre><p>A functor to check the centrality condition.</p><p>In order to obtain a step in the linesearch performed within the <a href="#Manopt.interior_point_Newton"><code>interior_point_Newton</code></a>, Section 6 of [<a href="../../references/#LaiYoshise:2024">LY24</a>] propose the following additional conditions to hold inspired by the Euclidean case described in Section 6 [<a href="../../references/#El-BakryTapiaTsuchiyaZhang:1996">ETTZ96</a>]:</p><p>For a given <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> assume consider the <a href="#Manopt.KKTVectorField"><code>KKTVectorField</code></a> <span>$F$</span>, that is we are at a point <span>$q = (p, Œª, Œº, s)$</span>  on <span>$\mathcal M √ó ‚Ñù^m √ó ‚Ñù^n √ó ‚Ñù^m$</span>and a search direction <span>$V = (X, Y, Z, W)$</span>.</p><p>Then, let</p><p class="math-container">\[œÑ_1 = \frac{m‚ãÖ\min\{ Œº ‚äô s\}}{Œº^{\mathrm{T}}s}
\quad\text{ and }\quad
œÑ_2 = \frac{Œº^{\mathrm{T}}s}{\lVert F(q) \rVert}\]</p><p>where <span>$‚äô$</span> denotes the Hadamard (or elementwise) product.</p><p>For a new candidate <span>$q(Œ±) = \bigl(p(Œ±), Œª(Œ±), Œº(Œ±), s(Œ±)\bigr) := (\operatorname{retr}_p(Œ±X), Œª+Œ±Y, Œº+Œ±Z, s+Œ±W)$</span>, we then define two functions</p><p class="math-container">\[c_1(Œ±) = \min\{ Œº(Œ±) ‚äô s(Œ±) \} - \frac{Œ≥œÑ_1 Œº(Œ±)^{\mathrm{T}}s(Œ±)}{m}
\quad\text{ and }\quad
c_2(Œ±) = Œº(Œ±)^{\mathrm{T}}s(Œ±) ‚Äì Œ≥œÑ_2 \lVert F(q(Œ±)) \rVert.\]</p><p>While the paper now states that the (Armijo) linesearch starts at a point <span>$\tilde Œ±$</span>, it is easier to include the condition that <span>$c_1(Œ±) ‚â• 0$</span> and <span>$c_2(Œ±) ‚â• 0$</span> into the linesearch as well.</p><p>The functor <code>InteriorPointCentralityCondition(cmo, Œ≥, Œº, s, normKKT)(N,qŒ±)</code> defined here evaluates this condition and returns true if both <span>$c_1$</span> and <span>$c_2$</span> are nonnegative.</p><p><strong>Fields</strong></p><ul><li><code>cmo</code>: a <a href="../../plans/objective/#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a></li><li><code>Œ≥</code>: a constant</li><li><code>œÑ1</code>, <code>œÑ2</code>: the constants given in the formula.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">InteriorPointCentralityCondition(cmo, Œ≥)
InteriorPointCentralityCondition(cmo, Œ≥, œÑ1, œÑ2)</code></pre><p>Initialise the centrality conditions. The parameters <code>œÑ1</code>, <code>œÑ2</code> are initialise to zero if not provided.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Besides <a href="../../plans/#Manopt.get_parameter"><code>get_parameter</code></a> for all three constants, and <a href="../../plans/#Manopt.set_parameter!"><code>set_parameter!</code></a> for <span>$Œ≥$</span>, to update <span>$œÑ_1$</span> and <span>$œÑ_2$</span>, call <code>set_parameter(ipcc, :œÑ, N, q)</code> to update both <span>$œÑ_1$</span> and <span>$œÑ_2$</span> according to the formulae above.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L788-L845">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.calculate_œÉ" href="#Manopt.calculate_œÉ"><code>Manopt.calculate_œÉ</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_œÉ(M, cmo, p, Œº, Œª, s; kwargs...)</code></pre><p>Compute the new <span>$œÉ$</span> factor for the barrier parameter in <a href="#Manopt.interior_point_Newton"><code>interior_point_Newton</code></a> as</p><p class="math-container">\[\min\{\frac{1}{2}, \lVert F(p; Œº, Œª, s)\rVert^{\frac{1}{2}} \},\]</p><p>where <span>$F$</span> is the KKT vector field, hence the <a href="#Manopt.KKTVectorFieldNormSq"><code>KKTVectorFieldNormSq</code></a> is used.</p><p><strong>Keyword arguments</strong></p><ul><li><code>vector_space=</code><a href="../../extensions/#Manopt.Rn"><code>Rn</code></a> a function that, given an integer, returns the manifold to be used for the vector space components <span>$‚Ñù^m,‚Ñù^n$</span></li><li><code>N</code> the manifold <span>$\mathcal M √ó ‚Ñù^m √ó ‚Ñù^n √ó ‚Ñù^m$</span> the vector field lives on (generated using <code>vector_space</code>)</li><li><code>q</code> provide memory on <code>N</code> for interims evaluation of the vector field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L965-L980">source</a></section></article><h2 id="Additional-stopping-criteria"><a class="docs-heading-anchor" href="#Additional-stopping-criteria">Additional stopping criteria</a><a id="Additional-stopping-criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-stopping-criteria" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.StopWhenKKTResidualLess" href="#Manopt.StopWhenKKTResidualLess"><code>Manopt.StopWhenKKTResidualLess</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StopWhenKKTResidualLess &lt;: StoppingCriterion</code></pre><p>Stop when the KKT residual</p><pre><code class="nohighlight hljs">r^2
= \lVert \operatorname{grad}_p \mathcal L(p, Œº, Œª) \rVert^2
+ \sum_{i=1}^m [Œº_i]_{-}^2 + [g_i(p)]_+^2 + \lvert \mu_ig_i(p)^2
+ \sum_{j=1}^n \lvert h_i(p)\rvert^2.</code></pre><p>is less than a given threshold <span>$r &lt; Œµ$</span>. We use <span>$[v]_+ = \max\{0,v\}$</span> and <span>$[v]_- = \min\{0,t\}$</span> for the positive and negative part of <span>$v$</span>, respectively</p><p><strong>Fields</strong></p><ul><li><code>Œµ</code>: a threshold</li><li><code>residual</code>: store the last residual if the stopping criterion is hit.</li><li><code>at_iteration</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6430b319ba0cc04af2dc26cc8acc594cac2041c2/src/plans/interior_point_Newton_plan.jl#L889-L910">source</a></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[ETTZ96]</dt><dd><div>A.¬†S.¬†El-Bakry, R.¬†A.¬†Tapia, T.¬†Tsuchiya and Y.¬†Zhang. <em>On the formulation and theory of the Newton interior-point method for nonlinear programming</em>. <a href="https://doi.org/10.1007/bf02275347">Journal¬†of¬†Optimization¬†Theory¬†and¬†Applications <strong>89</strong>, 507‚Äì541</a> (1996).</div></dd><dt>[LY24]</dt><dd><div>Z.¬†Lai and A.¬†Yoshise. <em>Riemannian Interior Point Methods for Constrained Optimization on Manifolds</em>. <a href="https://doi.org/10.1007/s10957-024-02403-8">Journal¬†of¬†Optimization¬†Theory¬†and¬†Applications <strong>201</strong>, 433‚Äì469</a> (2024), <a href="https://arxiv.org/abs/2203.09762">arXiv:2203.09762</a>.</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gradient_descent/">¬´ Gradient Descent</a><a class="docs-footer-nextpage" href="../LevenbergMarquardt/">Levenberg‚ÄìMarquardt ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Sunday 13 April 2025 10:16">Sunday 13 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
