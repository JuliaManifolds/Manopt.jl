#
# Fork of Hager-Zhang from LineSearches.jl

# NOTE:
#   [1] The type `T` in the `HagerZhang{T}` need not be the same `T` as in
#       `hagerzhang!{T}`; in the latter, `T` comes from the input vector `x`.
#   [2] the only method parameter that is not included in the
#       type is `iterfinitemax` since this value needs to be
#       inferred from the input vector `x` and not from the type information
#       on the parameters

mutable struct HagerZhangLinesearch{
    T,TRM<:AbstractRetractionMethod,VTM<:AbstractVectorTransportMethod,P
} <: Linesearch
    delta::T # c_1 Wolfe sufficient decrease condition
    sigma::T # c_2 Wolfe curvature condition (Recommend 0.1 for GradientDescent)
    alphamax::T
    rho::T
    epsilon::T
    gamma::T
    linesearchmax::Int
    psi3::T
    retraction_method::TRM
    vector_transport_method::VTM
    mayterminate::Bool
    candidate_point::P
end

function HagerZhangLinesearch(
    M::AbstractManifold=DefaultManifold();
    candidate_point::P=allocate_result(M, rand),
    retraction_method::TRM=default_retraction_method(M),
    vector_transport_method::VTM=default_vector_transport_method(M),
    delta::T=0.1, # c_1 Wolfe sufficient decrease condition
    sigma::T=0.9, # c_2 Wolfe curvature condition (Recommend 0.1 for GradientDescent)
    alphamax::T=max_stepsize(M),
    rho::T=5.0,
    epsilon::T=1e-6,
    gamma::T=0.66,
    linesearchmax::Int=50,
    psi3::T=0.1,
) where {P,TRM<:AbstractRetractionMethod,VTM<:AbstractVectorTransportMethod,T}
    return HagerZhangLinesearch{T,TRM,VTM,P}(
        delta,
        sigma,
        alphamax,
        rho,
        epsilon,
        gamma,
        linesearchmax,
        psi3,
        retraction_method,
        vector_transport_method,
        false,
        candidate_point,
    )
end

function (cs::HagerZhangLinesearch)(
    mp::AbstractManoptProblem,
    s::AbstractManoptSolverState,
    i::Int,
    η=-get_gradient(s);
    fp=get_cost(mp, get_iterate(s)),
    kwargs...,
)
    M = get_manifold(mp)
    p = get_iterate(s)
    X = get_gradient(s)
    X_tmp = copy(M, p, X)
    Y_tmp = copy(M, p, X)
    f = Manopt.get_cost_function(get_objective(mp))
    dphi_0 = real(inner(M, p, X, η))

    # guess initial alpha
    α0 = 1.0

    # perform actual linesearch

    function ϕ(α)
        retract!(M, cs.candidate_point, p, η, α, cs.retraction_method)
        return f(M, cs.candidate_point)
    end
    function dϕ(α)
        retract!(M, cs.candidate_point, p, η, α, cs.retraction_method)
        get_gradient!(mp, X_tmp, cs.candidate_point)
        vector_transport_to!(M, Y_tmp, p, η, cs.candidate_point, cs.vector_transport_method)
        return real(inner(M, cs.candidate_point, X_tmp, Y_tmp))
    end
    function ϕdϕ(α)
        # TODO: optimize?
        retract!(M, cs.candidate_point, p, η, α, cs.retraction_method)
        get_gradient!(mp, X_tmp, cs.candidate_point)
        vector_transport_to!(M, Y_tmp, p, η, cs.candidate_point, cs.vector_transport_method)
        phi = f(M, cs.candidate_point)
        dphi = real(inner(M, cs.candidate_point, X_tmp, Y_tmp))
        return (phi, dphi)
    end

    α, fp = cs(ϕ, ϕdϕ, α0, fp, dphi_0)
    return α
end

function (ls::HagerZhangLinesearch)(ϕ, ϕdϕ, c::T, phi_0::Real, dphi_0::Real) where {T}
    alphamax = ls.alphamax
    linesearchmax = ls.linesearchmax

    zeroT = convert(T, 0)
    if !(isfinite(phi_0) && isfinite(dphi_0))
        throw(
            LineSearchException("Value and slope at step length = 0 must be finite.", T(0))
        )
    end
    if dphi_0 >= eps(T) * abs(phi_0)
        throw(LineSearchException("Search direction is not a direction of descent.", T(0)))
    elseif dphi_0 >= 0
        return zeroT, phi_0
    end

    # Prevent values of x_new = x+αs that are likely to make
    # ϕ(x_new) infinite
    iterfinitemax::Int = ceil(Int, -log2(eps(T)))
    alphas = [zeroT] # for bisection
    values = [phi_0]
    slopes = [dphi_0]

    phi_lim = phi_0 + ls.epsilon * abs(phi_0)
    @assert c >= 0
    c <= eps(T) && return zeroT, phi_0
    @assert isfinite(c) && c <= alphamax
    phi_c, dphi_c = ϕdϕ(c)
    iterfinite = 1
    while !(isfinite(phi_c) && isfinite(dphi_c)) && iterfinite < iterfinitemax
        ls.mayterminate = false
        iterfinite += 1
        c *= psi3
        phi_c, dphi_c = ϕdϕ(c)
    end
    if !(isfinite(phi_c) && isfinite(dphi_c))
        @warn("Failed to achieve finite new evaluation point, using alpha=0")
        ls.mayterminate = false # reset in case another initial guess is used next
        return zeroT, phi_0
    end
    push!(alphas, c)
    push!(values, phi_c)
    push!(slopes, dphi_c)

    # If c was generated by quadratic interpolation, check whether it
    # satisfies the Wolfe conditions
    if ls.mayterminate &&
        satisfies_wolfe(c, phi_c, dphi_c, phi_0, dphi_0, phi_lim, ls.delta, ls.sigma)
        ls.mayterminate = false # reset in case another initial guess is used next
        return c, phi_c # phi_c
    end
    # Initial bracketing step (HZ, stages B0-B3)
    isbracketed = false
    ia = 1
    ib = 2
    @assert length(alphas) == 2
    iter = 1
    cold = -one(T)
    while !isbracketed && iter < linesearchmax
        if dphi_c >= zeroT
            # We've reached the upward slope, so we have b; examine
            # previous values to find a
            ib = length(alphas)
            for i in (ib - 1):-1:1
                if values[i] <= phi_lim
                    ia = i
                    break
                end
            end
            isbracketed = true
        elseif values[end] > phi_lim
            # The value is higher, but the slope is downward, so we must
            # have crested over the peak. Use bisection.
            ib = length(alphas)
            ia = 1
            if c ≉ alphas[ib] || slopes[ib] >= zeroT
                error("c = ", c)
            end
            # ia, ib = bisect(phi, lsr, ia, ib, phi_lim) # TODO: Pass options
            ia, ib = bisect!(ϕdϕ, alphas, values, slopes, ia, ib, phi_lim)
            isbracketed = true
        else
            # We'll still going downhill, expand the interval and try again.
            # Reaching this branch means that dphi_c < 0 and phi_c <= phi_0 + ϵ_k
            # So cold = c has a lower objective than phi_0 up to epsilon. 
            # This makes it a viable step to return if bracketing fails.

            # Bracketing can fail if no cold < c <= alphamax can be found with finite phi_c and dphi_c. 
            # Going back to the loop with c = cold will only result in infinite cycling.
            # So returning (cold, phi_cold) and exiting the line search is the best move.
            cold = c
            phi_cold = phi_c
            if nextfloat(cold) >= alphamax
                ls.mayterminate = false # reset in case another initial guess is used next
                return cold, phi_cold
            end
            c *= ls.rho
            if c > alphamax
                c = alphamax
            end
            phi_c, dphi_c = ϕdϕ(c)
            iterfinite = 1
            while !(isfinite(phi_c) && isfinite(dphi_c)) &&
                      c > nextfloat(cold) &&
                      iterfinite < iterfinitemax
                alphamax = c # shrinks alphamax, assumes that steps >= c can never have finite phi_c and dphi_c
                iterfinite += 1
                c = (cold + c) / 2
                phi_c, dphi_c = ϕdϕ(c)
            end
            if !(isfinite(phi_c) && isfinite(dphi_c))
                return cold, phi_cold
            end
            push!(alphas, c)
            push!(values, phi_c)
            push!(slopes, dphi_c)
        end
        iter += 1
    end
    while iter < linesearchmax
        a = alphas[ia]
        b = alphas[ib]
        @assert b > a
        if b - a <= eps(b)
            ls.mayterminate = false # reset in case another initial guess is used next
            return a, values[ia] # lsr.value[ia]
        end
        iswolfe, iA, iB = secant2!(
            ϕdϕ, alphas, values, slopes, ia, ib, phi_lim, ls.delta, ls.sigma
        )
        if iswolfe
            ls.mayterminate = false # reset in case another initial guess is used next
            return alphas[iA], values[iA] # lsr.value[iA]
        end
        A = alphas[iA]
        B = alphas[iB]
        @assert B > A
        if B - A < gamma * (b - a)
            if nextfloat(values[ia]) >= values[ib] && nextfloat(values[iA]) >= values[iB]
                # It's so flat, secant didn't do anything useful, time to quit
                ls.mayterminate = false # reset in case another initial guess is used next
                return A, values[iA]
            end
            ia = iA
            ib = iB
        else
            # Secant is converging too slowly, use bisection
            c = (A + B) / convert(T, 2)

            phi_c, dphi_c = ϕdϕ(c)
            @assert isfinite(phi_c) && isfinite(dphi_c)
            push!(alphas, c)
            push!(values, phi_c)
            push!(slopes, dphi_c)

            ia, ib = update!(ϕdϕ, alphas, values, slopes, iA, iB, length(alphas), phi_lim)
        end
        iter += 1
    end

    throw(
        LineSearchException(
            "Linesearch failed to converge, reached maximum iterations $(linesearchmax).",
            alphas[ia],
        ),
    )
end

# Check Wolfe & approximate Wolfe
function satisfies_wolfe(
    c::T,
    phi_c::Real,
    dphi_c::Real,
    phi_0::Real,
    dphi_0::Real,
    phi_lim::Real,
    delta::Real,
    sigma::Real,
) where {T<:Number}
    wolfe1 = delta * dphi_0 >= (phi_c - phi_0) / c && dphi_c >= sigma * dphi_0
    wolfe2 = (2 * delta - 1) * dphi_0 >= dphi_c >= sigma * dphi_0 && phi_c <= phi_lim
    return wolfe1 || wolfe2
end

# HZ, stages S1-S4
function secant(a::Real, b::Real, dphi_a::Real, dphi_b::Real)
    return (a * dphi_b - b * dphi_a) / (dphi_b - dphi_a)
end
function secant(alphas, values, slopes, ia::Integer, ib::Integer)
    return secant(alphas[ia], alphas[ib], slopes[ia], slopes[ib])
end
# phi
function secant2!(
    ϕdϕ,
    alphas,
    values,
    slopes,
    ia::Integer,
    ib::Integer,
    phi_lim::Real,
    delta::Real,
    sigma::Real,
)
    phi_0 = values[1]
    dphi_0 = slopes[1]
    a = alphas[ia]
    b = alphas[ib]
    dphi_a = slopes[ia]
    dphi_b = slopes[ib]
    T = eltype(slopes)
    zeroT = convert(T, 0)
    if !(dphi_a < zeroT && dphi_b >= zeroT)
        error(
            string(
                "Search direction is not a direction of descent; ",
                "this error may indicate that user-provided derivatives are inaccurate. ",
                @sprintf "(dphi_a = %f; dphi_b = %f)" dphi_a dphi_b
            ),
        )
    end
    c = secant(a, b, dphi_a, dphi_b)
    @assert isfinite(c)
    # phi_c = phi(tmpc, c) # Replace
    phi_c, dphi_c = ϕdϕ(c)
    @assert isfinite(phi_c) && isfinite(dphi_c)

    push!(alphas, c)
    push!(values, phi_c)
    push!(slopes, dphi_c)

    ic = length(alphas)
    if satisfies_wolfe(c, phi_c, dphi_c, phi_0, dphi_0, phi_lim, delta, sigma)
        return true, ic, ic
    end

    iA, iB = update!(ϕdϕ, alphas, values, slopes, ia, ib, ic, phi_lim)
    a = alphas[iA]
    b = alphas[iB]
    doupdate = false
    if iB == ic
        # we updated b, make sure we also update a
        c = secant(alphas, values, slopes, ib, iB)
    elseif iA == ic
        # we updated a, do it for b too
        c = secant(alphas, values, slopes, ia, iA)
    end
    if (iA == ic || iB == ic) && a <= c <= b
        # phi_c = phi(tmpc, c) # TODO: Replace
        phi_c, dphi_c = ϕdϕ(c)
        @assert isfinite(phi_c) && isfinite(dphi_c)

        push!(alphas, c)
        push!(values, phi_c)
        push!(slopes, dphi_c)

        ic = length(alphas)
        # Check arguments here
        if satisfies_wolfe(c, phi_c, dphi_c, phi_0, dphi_0, phi_lim, delta, sigma)
            return true, ic, ic
        end
        iA, iB = update!(ϕdϕ, alphas, values, slopes, iA, iB, ic, phi_lim)
    end
    return false, iA, iB
end

# HZ, stages U0-U3
# Given a third point, pick the best two that retain the bracket
# around the minimum (as defined by HZ, eq. 29)
# b will be the upper bound, and a the lower bound
function update!(
    ϕdϕ, alphas, values, slopes, ia::Integer, ib::Integer, ic::Integer, phi_lim::Real
)
    a = alphas[ia]
    b = alphas[ib]
    T = eltype(slopes)
    zeroT = convert(T, 0)
    # Debugging (HZ, eq. 4.4):
    @assert slopes[ia] < zeroT
    @assert values[ia] <= phi_lim
    @assert slopes[ib] >= zeroT
    @assert b > a
    c = alphas[ic]
    phi_c = values[ic]
    dphi_c = slopes[ic]
    if c < a || c > b
        return ia, ib #, 0, 0  # it's out of the bracketing interval
    end
    if dphi_c >= zeroT
        return ia, ic #, 0, 0  # replace b with a closer point
    end
    # We know dphi_c < 0. However, phi may not be monotonic between a
    # and c, so check that the value is also smaller than phi_0.  (It's
    # more dangerous to replace a than b, since we're leaving the
    # secure environment of alpha=0; that's why we didn't check this
    # above.)
    if phi_c <= phi_lim
        return ic, ib#, 0, 0  # replace a
    end
    # phi_c is bigger than phi_0, which implies that the minimum
    # lies between a and c. Find it via bisection.
    return bisect!(ϕdϕ, alphas, values, slopes, ia, ic, phi_lim)
end

# HZ, stage U3 (with theta=0.5)
function bisect!(
    ϕdϕ, alphas::AbstractArray{T}, values, slopes, ia::Integer, ib::Integer, phi_lim::Real
) where {T}
    gphi = convert(T, NaN)
    a = alphas[ia]
    b = alphas[ib]
    # Debugging (HZ, conditions shown following U3)
    zeroT = convert(T, 0)
    @assert slopes[ia] < zeroT
    @assert values[ia] <= phi_lim
    @assert slopes[ib] < zeroT       # otherwise we wouldn't be here
    @assert values[ib] > phi_lim
    @assert b > a
    while b - a > eps(b)
        d = (a + b) / convert(T, 2)
        phi_d, gphi = ϕdϕ(d)
        @assert isfinite(phi_d) && isfinite(gphi)

        push!(alphas, d)
        push!(values, phi_d)
        push!(slopes, gphi)

        id = length(alphas)
        if gphi >= zeroT
            return ia, id # replace b, return
        end
        if phi_d <= phi_lim
            a = d # replace a, but keep bisecting until dphi_b > 0
            ia = id
        else
            b = d
            ib = id
        end
    end
    return ia, ib
end
