<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Trust-Regions Solver · Manopt.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../pluto/Optimize!/">Get started: Optimize!</a></li><li><a class="tocitem" href="../../pluto/AutomaticDifferentiation/">Use AD in Manopt</a></li><li><a class="tocitem" href="../../pluto/HowToRecord/">How to record values</a></li><li><a class="tocitem" href="../../pluto/GeodesicRegression/">Do Geodesic regression</a></li><li><a class="tocitem" href="../../pluto/Bezier/">Use Bezier Curves</a></li><li><a class="tocitem" href="../../pluto/SecondOrderDifference/">Compute a second order difference</a></li><li><a class="tocitem" href="../../pluto/StochasticGradientDescent/">Do stochastic gradient descent</a></li><li><a class="tocitem" href="../../pluto/Benchmark/">speed up! using <code>gradF!</code></a></li><li><a class="tocitem" href="../../pluto/JacobiFields/">Illustrate Jacobi Fields</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../../plans/problem/">Problem</a></li><li><a class="tocitem" href="../../plans/options/">Options</a></li><li><a class="tocitem" href="../../plans/stepsize/">Stepsize</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../DouglasRachford/">Douglas–Rachford</a></li><li><a class="tocitem" href="../gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../NelderMead/">Nelder–Mead</a></li><li><a class="tocitem" href="../particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li class="is-active"><a class="tocitem" href>Trust-Regions Solver</a><ul class="internal"><li><a class="tocitem" href="#Initialization"><span>Initialization</span></a></li><li><a class="tocitem" href="#Iteration"><span>Iteration</span></a></li><li><a class="tocitem" href="#Result"><span>Result</span></a></li><li><a class="tocitem" href="#Remarks"><span>Remarks</span></a></li><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Options"><span>Options</span></a></li><li><a class="tocitem" href="#Approximation-of-the-Hessian"><span>Approximation of the Hessian</span></a></li></ul></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../functions/">Introduction</a></li><li><a class="tocitem" href="../../functions/bezier/">Bézier curves</a></li><li><a class="tocitem" href="../../functions/costs/">Cost functions</a></li><li><a class="tocitem" href="../../functions/differentials/">Differentials</a></li><li><a class="tocitem" href="../../functions/adjointdifferentials/">Adjoint Differentials</a></li><li><a class="tocitem" href="../../functions/gradients/">Gradients</a></li><li><a class="tocitem" href="../../functions/Jacobi_fields/">Jacobi Fields</a></li><li><a class="tocitem" href="../../functions/proximal_maps/">Proximal Maps</a></li><li><a class="tocitem" href="../../functions/manifold/">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/data/">Data</a></li><li><a class="tocitem" href="../../helpers/errorMeasures/">Error Measures</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../list/">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>Trust-Regions Solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Trust-Regions Solver</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/solvers/trust_regions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="trust_regions"><a class="docs-heading-anchor" href="#trust_regions">The Riemannian Trust-Regions Solver</a><a id="trust_regions-1"></a><a class="docs-heading-anchor-permalink" href="#trust_regions" title="Permalink"></a></h1><p>The aim is to solve an optimization problem on a manifold</p><p class="math-container">\[\operatorname*{min}_{x  ∈  \mathcal{M}} F(x)\]</p><p>by using the Riemannian trust-regions solver. It is number one choice for smooth optimization. This trust-region method uses the Steihaug-Toint truncated conjugate-gradient method <a href="../truncated_conjugate_gradient_descent/#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a> to solve the inner minimization problem called the trust-regions subproblem. This inner solve can be preconditioned by providing a preconditioner (symmetric and positive deﬁnite, an approximation of the inverse of the Hessian of <span>$F$</span>). If no Hessian of the cost function <span>$F$</span> is provided, a standard approximation of the Hessian based on the gradient <span>$\operatorname{grad}F$</span> with <a href="#Manopt.ApproxHessianFiniteDifference"><code>ApproxHessianFiniteDifference</code></a> will be computed.</p><h2 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h2><p>Initialize <span>$x_0 = x$</span> with an initial point <span>$x$</span> on the manifold. It can be given by the caller or set randomly. Set the initial trust-region radius <span>$\Delta =\frac{1}{8} \bar{\Delta}$</span> where <span>$\bar{\Delta}$</span> is the maximum radius the trust-region can have. Usually one uses the root of the manifold dimension <span>$\operatorname{dim}(\mathcal{M})$</span>. For accepting the next iterate and evaluating the new trust-region radius one needs an accept/reject threshold <span>$\rho&#39;  ∈  [0,\frac{1}{4})$</span>, which is <span>$\rho&#39; = 0.1$</span> on default. Set <span>$k=0$</span>.</p><h2 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h2><p>Repeat until a convergence criterion is reached</p><ol><li>Set <span>$η$</span> as a random tangent vector if using randomized approach. Else  set <span>$η$</span> as the zero vector in the tangential space <span>$T_{x_k}\mathcal{M}$</span>.</li><li>Set <span>$η^*$</span> as the solution of the trust-region subproblem, computed by  the tcg-method with <span>$η$</span> as initial vector.</li><li>If using randomized approach compare <span>$η^*$</span> with the Cauchy point  <span>$η_{c}^* = -\tau_{c} \frac{\Delta}{\lVert \operatorname{Grad}[F] (x_k) \rVert_{x_k}} \operatorname{Grad}[F] (x_k)$</span> by the model function <span>$m_{x_k}(⋅)$</span>. If the  model decrease is larger by using the Cauchy point, set  <span>$η^* = η_{c}^*$</span>.</li><li>Set <span>${x}^* = \operatorname{retr}_{x_k}(η^*)$</span>.</li><li>Set <span>$\rho = \frac{F(x_k)-F({x}^*)}{m_{x_k}(η)-m_{x_k}(η^*)}$</span>, where  <span>$m_{x_k}(⋅)$</span> describes the quadratic model function.</li><li>Update the trust-region radius:<span>$\Delta = \begin{cases}\frac{1}{4} \Delta &amp;\text{ if } \rho &lt; \frac{1}{4} \, \text{or} \, m_{x_k}(η)-m_{x_k}(η^*) \leq 0 \, \text{or}  \, \rho = \pm  ∈ fty , \\\operatorname{min}(2 \Delta, \bar{\Delta}) &amp;\text{ if } \rho &gt; \frac{3}{4} \, \text{and the tcg-method stopped because of negative curvature or exceeding the trust-region},\\\Delta &amp; \, \text{otherwise.}\end{cases}$</span></li><li>If <span>$m_{x_k}(η)-m_{x_k}(η^*) \geq 0$</span> and <span>$\rho &gt; \rho&#39;$</span> set  <span>$x_k = {x}^*$</span>.</li><li>Set <span>$k = k+1$</span>.</li></ol><h2 id="Result"><a class="docs-heading-anchor" href="#Result">Result</a><a id="Result-1"></a><a class="docs-heading-anchor-permalink" href="#Result" title="Permalink"></a></h2><p>The result is given by the last computed <span>$x_k$</span>.</p><h2 id="Remarks"><a class="docs-heading-anchor" href="#Remarks">Remarks</a><a id="Remarks-1"></a><a class="docs-heading-anchor-permalink" href="#Remarks" title="Permalink"></a></h2><p>To the Initialization: A random point on the manifold.</p><p>To step number 1: Using randomized approach means using a random tangent vector as initial vector for the approximal solve of the trust-regions subproblem. If this is the case, keep in mind that the vector must be in the trust-region radius. This is achieved by multiplying <code>η</code> by <code>sqrt(4,eps(Float64))</code> as long as its norm is greater than the current trust-region radius <span>$\Delta$</span>. For not using randomized approach, one can get the zero tangent vector.</p><p>To step number 2: Obtain <span>$η^*$</span> by (approximately) solving the trust-regions subproblem</p><p class="math-container">\[\operatorname*{arg\,min}_{η  ∈  T_{x_k}\mathcal{M}} m_{x_k}(η) = F(x_k) +
\langle \operatorname{grad}F(x_k), η \rangle_{x_k} + \frac{1}{2} \langle
\operatorname{Hess}[F](η)_ {x_k}, η \rangle_{x_k}\]</p><p class="math-container">\[\text{s.t.} \; \langle η, η \rangle_{x_k} \leq {\Delta}^2\]</p><p>with the Steihaug-Toint truncated conjugate-gradient (tcg) method. The problem as well as the solution method is described in the <a href="../truncated_conjugate_gradient_descent/#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a>.</p><p>To step number 3: If using a random tangent vector as an initial vector, compare the result of the tcg-method with the Cauchy point. Convergence proofs assume that one achieves at least (a fraction of) the reduction of the Cauchy point. The idea is to go in the direction of the gradient to an optimal point. This can be on the edge, but also before. The parameter <span>$\tau_{c}$</span> for the optimal length is defined by</p><p class="math-container">\[\tau_{c} = \begin{cases} 1 &amp; \langle \operatorname{Grad}[F] (x_k), \,
\operatorname{Hess}[F] (η_k)_ {x_k}\rangle_{x_k} \leq 0 , \\
\operatorname{min}(\frac{{\operatorname{norm}(\operatorname{Grad}[F] (x_k))}^3}
{\Delta \langle \operatorname{Grad}[F] (x_k), \,
\operatorname{Hess}[F] (η_k)_ {x_k}\rangle_{x_k}}, 1) &amp; \, \text{otherwise.}
\end{cases}\]</p><p>To check the model decrease one compares</p><p class="math-container">\[m_{x_k}(η_{c}^*) = F(x_k) + \langle η_{c}^*,
\operatorname{Grad}[F] (x_k)\rangle_{x_k} + \frac{1}{2}\langle η_{c}^*,
\operatorname{Hess}[F] (η_{c}^*)_ {x_k}\rangle_{x_k}\]</p><p>with</p><p class="math-container">\[m_{x_k}(η^*) = F(x_k) + \langle η^*,
\operatorname{Grad}[F] (x_k)\rangle_{x_k} + \frac{1}{2}\langle η^*,
\operatorname{Hess}[F] (η^*)_ {x_k}\rangle_{x_k}.\]</p><p>If <span>$m_{x_k}(η_{c}^*) &lt; m_{x_k}(η^*)$</span> then <span>$m_{x_k}(η_{c}^*)$</span> is the better choice.</p><p>To step number 4: <span>$\operatorname{retr}_{x_k}(⋅)$</span> denotes the retraction, a mapping <span>$\operatorname{retr}_{x_k}:T_{x_k}\mathcal{M} \rightarrow \mathcal{M}$</span> wich approximates the exponential map. In some cases it is cheaper to use this instead of the exponential.</p><p>To step number 6: One knows that the <a href="../truncated_conjugate_gradient_descent/#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a> algorithm stopped for these reasons when the stopping criteria <a href="../truncated_conjugate_gradient_descent/#Manopt.StopWhenCurvatureIsNegative"><code>StopWhenCurvatureIsNegative</code></a>, <a href="../truncated_conjugate_gradient_descent/#Manopt.StopWhenTrustRegionIsExceeded"><code>StopWhenTrustRegionIsExceeded</code></a> are activated.</p><p>To step number 7: The last step is to decide if the new point <span>${x}^*$</span> is accepted.</p><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.trust_regions" href="#Manopt.trust_regions"><code>Manopt.trust_regions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trust_regions(M, F, gradF, hessF, x)</code></pre><p>evaluate the Riemannian trust-regions solver for optimization on manifolds. It will attempt to minimize the cost function F on the Manifold M. If no Hessian H is provided, a standard approximation of the Hessian based on the gradient <code>gradF</code> will be computed. For solving the the inner trust-region subproblem of finding an update-vector, it uses the Steihaug-Toint truncated conjugate-gradient method. For a description of the algorithm and more details see</p><ul><li>P.-A. Absil, C.G. Baker, K.A. Gallivan,   Trust-region methods on Riemannian manifolds, FoCM, 2007.   doi: <a href="https://doi.org/10.1007/s10208-005-0179-9">10.1007/s10208-005-0179-9</a></li><li>A. R. Conn, N. I. M. Gould, P. L. Toint, Trust-region methods, SIAM,   MPS, 2000. doi: <a href="https://doi.org/10.1137/1.9780898719857">10.1137/1.9780898719857</a></li></ul><p><strong>Input</strong></p><ul><li><code>M</code> – a manifold <span>$\mathcal M$</span></li><li><code>F</code> – a cost function <span>$F : \mathcal M → ℝ$</span> to minimize</li><li><code>gradF</code>- the gradient <span>$\operatorname{grad}F : \mathcal M → T \mathcal M$</span> of <span>$F$</span></li><li><code>x</code> – an initial value <span>$x  ∈  \mathcal M$</span></li><li><code>HessF</code> – the hessian <span>$\operatorname{Hess}F(x): T_x\mathcal M → T_x\mathcal M$</span>, <span>$X ↦ \operatoname{Hess}F(x)[X] = ∇_ξ\operatorname{grad}f(x)$</span></li></ul><p><strong>Optional</strong></p><ul><li><code>evaluation</code> – (<a href="../../plans/problem/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) specify whether the gradient and hessian work by  allocation (default) or <a href="../../plans/problem/#Manopt.MutatingEvaluation"><code>MutatingEvaluation</code></a> in place</li><li><code>max_trust_region_radius</code> – the maximum trust-region radius</li><li><code>preconditioner</code> – a preconditioner (a symmetric, positive definite operator that should approximate the inverse of the Hessian)</li><li><code>randomize</code> – set to true if the trust-region solve is to be initiated with a random tangent vector. If set to true, no preconditioner will be used. This option is set to true in some scenarios to escape saddle points, but is otherwise seldom activated.</li><li><code>project_vector!</code> : (<code>copyto!</code>) specify a projection operation for tangent vectors within the TCG   for numerical stability. A function <code>(M, Y, p, X) -&gt; ...</code> working in place of <code>Y</code>.   per default, no projection is perfomed, set it to <code>project!</code> to activate projection.</li><li><code>retraction</code> – (<code>default_retraction_method(M)</code>) approximation of the exponential map</li><li><code>stopping_criterion</code> – (<a href="../#Manopt.StopWhenAny"><code>StopWhenAny</code></a>(<a href="../#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(1000)</code>, <a href="../#Manopt.StopWhenGradientNormLess"><code>StopWhenGradientNormLess</code></a><code>(10^(-6))</code>) a functor inheriting from <a href="../#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> indicating when to stop.</li><li><code>trust_region_radius</code> - the initial trust-region radius</li><li><code>ρ_prime</code> – Accept/reject threshold: if ρ (the performance ratio for the iterate) is at least ρ&#39;, the outer iteration is accepted. Otherwise, it is rejected. In case it is rejected, the trust-region radius will have been decreased. To ensure this, ρ&#39; &gt;= 0 must be strictly smaller than 1/4. If ρ_prime is negative, the algorithm is not guaranteed to produce monotonically decreasing cost values. It is strongly recommended to set ρ&#39; &gt; 0, to aid convergence.</li><li><code>ρ_regularization</code> – Close to convergence, evaluating the performance ratio ρ is numerically challenging. Meanwhile, close to convergence, the quadratic model should be a good fit and the steps should be accepted. Regularization lets ρ go to 1 as the model decrease and the actual decrease go to zero. Set this option to zero to disable regularization (not recommended). When this is not zero, it may happen that the iterates produced are not monotonically improving the cost when very close to convergence. This is because the corrected cost improvement could change sign if it is negative but very small.</li><li><code>return_options</code> – (<code>false</code>) – if activated, the extended result, i.e. the complete <a href="../../plans/options/#Manopt.Options"><code>Options</code></a> are returned. This can be used to access recorded values. If set to false (default) just the optimal value <code>x_opt</code> is returned</li></ul><p><strong>Output</strong></p><ul><li><code>x</code> – the last reached point on the manifold</li></ul><p><strong>see also</strong></p><p><a href="../truncated_conjugate_gradient_descent/#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/f75bc67f5be4e24dc8ec4f219eeae6b6d8d55dfe/src/solvers/trust_regions.jl#L1-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.trust_regions!" href="#Manopt.trust_regions!"><code>Manopt.trust_regions!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trust_regions!(M, F, gradF, hessF, x; kwargs...)</code></pre><p>evaluate the Riemannian trust-regions solver for optimization on manifolds in place of <code>x</code>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – a manifold <span>$\mathcal M$</span></li><li><code>F</code> – a cost function <span>$F: \mathcal M → ℝ$</span> to minimize</li><li><code>gradF</code>- the gradient <span>$\operatorname{grad}F: \mathcal M → T \mathcal M$</span> of <span>$F$</span></li><li><code>x</code> – an initial value <span>$x  ∈  \mathcal M$</span></li><li><code>H</code> – the hessian <span>$H( \mathcal M, x, ξ)$</span> of <span>$F$</span></li></ul><p>for more details and all options, see <a href="#Manopt.trust_regions"><code>trust_regions</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/f75bc67f5be4e24dc8ec4f219eeae6b6d8d55dfe/src/solvers/trust_regions.jl#L75-L88">source</a></section></article><h2 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractHessianOptions" href="#Manopt.AbstractHessianOptions"><code>Manopt.AbstractHessianOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHessianOptions &lt;: Options</code></pre><p>An <a href="../../plans/options/#Manopt.Options"><code>Options</code></a> type to represent algorithms that employ the Hessian. These options are assumed to have a field (<code>gradient</code>) to store the current gradient <span>$\operatorname{grad}f(x)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/f75bc67f5be4e24dc8ec4f219eeae6b6d8d55dfe/src/plans/hessian_plan.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.TrustRegionsOptions" href="#Manopt.TrustRegionsOptions"><code>Manopt.TrustRegionsOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrustRegionsOptions &lt;: AbstractHessianOptions</code></pre><p>describe the trust-regions solver, with</p><p><strong>Fields</strong></p><p>a default value is given in brackets if a parameter can be left out in initialization.</p><ul><li><code>x</code> : a point as starting point</li><li><code>stop</code> : a function s,r = @(o,iter) returning a stop   indicator and a reason based on an iteration number and the gradient</li><li><code>trust_region_radius</code> : the (initial) trust-region radius</li><li><code>max_trust_region_radius</code> : the maximum trust-region radius</li><li><code>randomize</code> : indicates if the trust-region solve is to be initiated with a       random tangent vector. If set to true, no preconditioner will be       used. This option is set to true in some scenarios to escape saddle       points, but is otherwise seldom activated.</li><li><code>project_vector!</code> : (<code>copyto!</code>) specify a projection operation for tangent vectors   for numerical stability. A function <code>(M, Y, p, X) -&gt; ...</code> working in place of <code>Y</code>.   per default, no projection is perfomed, set it to <code>project!</code> to activate projection.</li><li><code>ρ_prime</code> : a lower bound of the performance ratio for the iterate that       decides if the iteration will be accepted or not. If not, the       trust-region radius will have been decreased. To ensure this,       ρ&#39;&gt;= 0 must be strictly smaller than 1/4. If ρ&#39; is negative,       the algorithm is not guaranteed to produce monotonically decreasing       cost values. It is strongly recommended to set ρ&#39; &gt; 0, to aid       convergence.</li><li><code>ρ_regularization</code> : Close to convergence, evaluating the performance ratio ρ       is numerically challenging. Meanwhile, close to convergence, the       quadratic model should be a good fit and the steps should be       accepted. Regularization lets ρ go to 1 as the model decrease and       the actual decrease go to zero. Set this option to zero to disable       regularization (not recommended). When this is not zero, it may happen       that the iterates produced are not monotonically improving the cost       when very close to convergence. This is because the corrected cost       improvement could change sign if it is negative but very small.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">TrustRegionsOptions(x, stop, delta, delta_bar, uR, rho_prime, rho_reg)</code></pre><p>construct a trust-regions Option with the fields as above.</p><p><strong>See also</strong></p><p><a href="#Manopt.trust_regions"><code>trust_regions</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/f75bc67f5be4e24dc8ec4f219eeae6b6d8d55dfe/src/plans/hessian_plan.jl#L143-L188">source</a></section></article><h2 id="Approximation-of-the-Hessian"><a class="docs-heading-anchor" href="#Approximation-of-the-Hessian">Approximation of the Hessian</a><a id="Approximation-of-the-Hessian-1"></a><a class="docs-heading-anchor-permalink" href="#Approximation-of-the-Hessian" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.ApproxHessianFiniteDifference" href="#Manopt.ApproxHessianFiniteDifference"><code>Manopt.ApproxHessianFiniteDifference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ApproxHessianFiniteDifference{T, mT, P, G}</code></pre><p>A functor to approximate the Hessian by a finite difference of gradient evaluations</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ApproxHessianFiniteDifference(M, x, gradF)</code></pre><p>Initialize the approximate hessian to combute <span>$\operatorname{Hess}F$</span> based on the gradient <code>gradF</code> of a function <span>$F$</span> on <span>$\mathcal M$</span>. The value <code>x</code> is used to initialize a few internal fields.</p><p><strong>Optional Keyword arguments</strong></p><ul><li><code>steplength</code> - (<code>2^-14</code>) default step size for the approximation</li><li><code>evaluation</code> - (<a href="../../plans/problem/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>) specify whether the gradient is allocating or mutating.</li><li><code>retraction_method</code> – (<code>default_retraction_method(M)</code>) a <code>retraction(M, p, X)</code> to use in the approximation.</li><li><code>vector_transport_method</code> - (<code>default_vector_transport_method(M)</code>) a vector transport to use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/f75bc67f5be4e24dc8ec4f219eeae6b6d8d55dfe/src/plans/hessian_plan.jl#L303-L322">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../truncated_conjugate_gradient_descent/">« Steihaug-Toint TCG Method</a><a class="docs-footer-nextpage" href="../../functions/">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Sunday 24 April 2022 20:30">Sunday 24 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
