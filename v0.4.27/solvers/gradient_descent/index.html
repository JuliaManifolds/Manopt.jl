<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gradient Descent · Manopt.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/Optimize!/">Get started: Optimize!</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using Inplace computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use Automatic Differentiation</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a Cache</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a Solver</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do Contrained Optimization</a></li><li><a class="tocitem" href="../../tutorials/GeodesicRegression/">Do Geodesic Regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../DouglasRachford/">Douglas–Rachford</a></li><li><a class="tocitem" href="../exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../FrankWolfe/">Frank-Wolfe</a></li><li class="is-active"><a class="tocitem" href>Gradient Descent</a><ul class="internal"><li><a class="tocitem" href="#State"><span>State</span></a></li><li><a class="tocitem" href="#Direction-Update-Rules"><span>Direction Update Rules</span></a></li><li><a class="tocitem" href="#Debug-Actions"><span>Debug Actions</span></a></li><li><a class="tocitem" href="#Record-Actions"><span>Record Actions</span></a></li></ul></li><li><a class="tocitem" href="../LevenbergMarquardt/">Levenberg–Marquardt</a></li><li><a class="tocitem" href="../NelderMead/">Nelder–Mead</a></li><li><a class="tocitem" href="../particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../../plans/problem/">Problem</a></li><li><a class="tocitem" href="../../plans/objective/">Objective</a></li><li><a class="tocitem" href="../../plans/state/">Solver State</a></li><li><a class="tocitem" href="../../plans/stepsize/">Stepsize</a></li><li><a class="tocitem" href="../../plans/stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../../plans/debug/">Debug Output</a></li><li><a class="tocitem" href="../../plans/record/">Recording values</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../functions/">Introduction</a></li><li><a class="tocitem" href="../../functions/bezier/">Bézier curves</a></li><li><a class="tocitem" href="../../functions/costs/">Cost functions</a></li><li><a class="tocitem" href="../../functions/differentials/">Differentials</a></li><li><a class="tocitem" href="../../functions/adjointdifferentials/">Adjoint Differentials</a></li><li><a class="tocitem" href="../../functions/gradients/">Gradients</a></li><li><a class="tocitem" href="../../functions/proximal_maps/">Proximal Maps</a></li><li><a class="tocitem" href="../../functions/manifold/">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/data/">Data</a></li><li><a class="tocitem" href="../../helpers/errorMeasures/">Error Measures</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../list/">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>Gradient Descent</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gradient Descent</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/solvers/gradient_descent.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GradientDescentSolver"><a class="docs-heading-anchor" href="#GradientDescentSolver">Gradient Descent</a><a id="GradientDescentSolver-1"></a><a class="docs-heading-anchor-permalink" href="#GradientDescentSolver" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Manopt.gradient_descent" href="#Manopt.gradient_descent"><code>Manopt.gradient_descent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gradient_descent(M, f, grad_f, p=rand(M); kwargs...)
gradient_descent(M, gradient_objective, p=rand(M); kwargs...)</code></pre><p>perform a gradient descent</p><p class="math-container">\[p_{k+1} = \operatorname{retr}_{p_k}\bigl( s_k\operatorname{grad}f(p_k) \bigr),
\qquad k=0,1,…\]</p><p>with different choices of the stepsize <span>$s_k$</span> available (see <code>stepsize</code> option below).</p><p><strong>Input</strong></p><ul><li><code>M</code> – a manifold <span>$\mathcal M$</span></li><li><code>f</code> – a cost function <span>$f: \mathcal M→ℝ$</span> to find a minimizer <span>$p^*$</span> for</li><li><code>grad_f</code> – the gradient <span>$\operatorname{grad}f: \mathcal M → T\mathcal M$</span> of f<ul><li>as a function <code>(M, p) -&gt; X</code> or a function <code>(M, X, p) -&gt; X</code></li></ul></li><li><code>p</code> – an initial value <code>p</code> <span>$= p_0 ∈ \mathcal M$</span></li></ul><p>Alternatively to <code>f</code> and <code>grad_f</code> you can prodive the <a href="../../plans/objective/#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective</code></a> <code>gradient_objective</code> directly.</p><p><strong>Optional</strong></p><ul><li><code>direction</code> – (<a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a>) perform a processing of the direction, e.g.</li><li><code>evaluation</code> – (<a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) specify whether the gradient works by allocation (default) form <code>grad_f(M, p)</code> or <a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> in place, i.e. is of the form <code>grad_f!(M, X, p)</code>.</li><li><code>retraction_method</code> – (<code>default_retraction_method(M, typeof(p))</code>) a retraction to use</li><li><code>stepsize</code> – (<a href="../../plans/stepsize/#Manopt.ConstantStepsize"><code>ConstantStepsize</code></a><code>(1.)</code>) specify a <a href="../../plans/stepsize/#Manopt.Stepsize"><code>Stepsize</code></a> functor.</li><li><code>stopping_criterion</code> – (<a href="../../plans/stopping_criteria/#Manopt.StopWhenAny"><code>StopWhenAny</code></a><code>(</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(200),</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenGradientNormLess"><code>StopWhenGradientNormLess</code></a><code>(10.0^-8))</code>) a functor inheriting from <a href="../../plans/stopping_criteria/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> indicating when to stop.</li></ul><p>If you provide the <a href="../../plans/objective/#Manopt.ManifoldGradientObjective"><code>ManifoldGradientObjective</code></a> directly, <code>evaluation</code> is ignored.</p><p>All other keyword arguments are passed to <a href="../../plans/state/#Manopt.decorate_state!"><code>decorate_state!</code></a> for state decorators or <a href="../../plans/objective/#Manopt.decorate_objective!"><code>decorate_objective!</code></a> for objective, respectively. If you provide the <a href="../../plans/objective/#Manopt.ManifoldGradientObjective"><code>ManifoldGradientObjective</code></a> directly, these decorations can still be specified</p><p><strong>Output</strong></p><p>the obtained (approximate) minimizer <span>$p^*$</span>. To obtain the whole final state of the solver, see <a href="../#Manopt.get_solver_return"><code>get_solver_return</code></a> for details</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/solvers/gradient_descent.jl#L113-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.gradient_descent!" href="#Manopt.gradient_descent!"><code>Manopt.gradient_descent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gradient_descent!(M, f, grad_f, p; kwargs...)
gradient_descent!(M, gradient_objective, p; kwargs...)</code></pre><p>perform a gradient_descent</p><p class="math-container">\[p_{k+1} = \operatorname{retr}_{p_k}\bigl( s_k\operatorname{grad}f(p_k) \bigr)\]</p><p>in place of <code>p</code> with different choices of <span>$s_k$</span> available.</p><p><strong>Input</strong></p><ul><li><code>M</code> – a manifold <span>$\mathcal M$</span></li><li><code>f</code> – a cost function <span>$F:\mathcal M→ℝ$</span> to minimize</li><li><code>grad_f</code> – the gradient <span>$\operatorname{grad}F:\mathcal M→ T\mathcal M$</span> of F</li><li><code>p</code> – an initial value <span>$p ∈ \mathcal M$</span></li></ul><p>Alternatively to <code>f</code> and <code>grad_f</code> you can prodive the <a href="../../plans/objective/#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective</code></a> <code>gradient_objective</code> directly.</p><p>For more options, especially <a href="../../plans/stepsize/#Manopt.Stepsize"><code>Stepsize</code></a>s for <span>$s_k$</span>, see <a href="#Manopt.gradient_descent"><code>gradient_descent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/solvers/gradient_descent.jl#L196-L218">source</a></section></article><h2 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.GradientDescentState" href="#Manopt.GradientDescentState"><code>Manopt.GradientDescentState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GradientDescentState{P,T} &lt;: AbstractGradientSolverState</code></pre><p>Describes a Gradient based descent algorithm, with</p><p><strong>Fields</strong></p><p>a default value is given in brackets if a parameter can be left out in initialization.</p><ul><li><code>p – (</code>rand(M)` the current iterate</li><li><code>X</code> – (<code>zero_vector(M,p)</code>) the current gradient <span>$\operatorname{grad}f(p)$</span>, initialised to zero vector.</li><li><code>stopping_criterion</code> – (<a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(100)</code>) a <a href="../../plans/stopping_criteria/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a></li><li><code>stepsize</code> – (<a href="../../plans/stepsize/#Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}"><code>default_stepsize</code></a><code>(M, GradientDescentState)</code>) a <a href="../../plans/stepsize/#Manopt.Stepsize"><code>Stepsize</code></a></li><li><code>direction</code> - (<a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a>) a processor to compute the gradient</li><li><code>retraction_method</code> – (<code>default_retraction_method(M, typeof(p))</code>) the retraction to use, defaults to the default set for your manifold.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">GradientDescentState(M, p=rand(M); X=zero_vector(M, p), kwargs...)</code></pre><p>Generate gradient descent options, where <code>X</code> can be used to set the tangent vector to store the gradient in a certain type; it will be initialised accordingly at a later stage. All following fields are keyword arguments.</p><p><strong>See also</strong></p><p><a href="#Manopt.gradient_descent"><code>gradient_descent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/solvers/gradient_descent.jl#L2-L29">source</a></section></article><h2 id="Direction-Update-Rules"><a class="docs-heading-anchor" href="#Direction-Update-Rules">Direction Update Rules</a><a id="Direction-Update-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Direction-Update-Rules" title="Permalink"></a></h2><p>A field of the options is the <code>direction</code>, a <a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a>, which by default <a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a> just evaluates the gradient but can be enhanced for example to</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.DirectionUpdateRule" href="#Manopt.DirectionUpdateRule"><code>Manopt.DirectionUpdateRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DirectionUpdateRule</code></pre><p>A general functor, that handles direction update rules. It&#39;s field(s) is usually only a <a href="../../plans/state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a> by default initialized to the fields required for the specific coefficient, but can also be replaced by a (common, global) individual one that provides these values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/plans/gradient_plan.jl#L244-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.IdentityUpdateRule" href="#Manopt.IdentityUpdateRule"><code>Manopt.IdentityUpdateRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdentityUpdateRule &lt;: DirectionUpdateRule</code></pre><p>The default gradient direction update is the identity, i.e. it just evaluates the gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/plans/gradient_plan.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.MomentumGradient" href="#Manopt.MomentumGradient"><code>Manopt.MomentumGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MomentumGradient &lt;: DirectionUpdateRule</code></pre><p>Append a momentum to a gradient processor, where the last direction and last iterate are stored and the new is composed as <span>$η_i = m*η_{i-1}&#39; - s d_i$</span>, where <span>$sd_i$</span> is the current (inner) direction and <span>$η_{i-1}&#39;$</span> is the vector transported last direction multiplied by momentum <span>$m$</span>.</p><p><strong>Fields</strong></p><ul><li><code>p_old</code> - (<code>rand(M)</code>) remember the last iterate for parallel transporting the last direction</li><li><code>momentum</code> – (<code>0.2</code>) factor for momentum</li><li><code>direction</code> – internal <a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a> to determine directions to add the momentum to.</li><li><code>vector_transport_method</code> – <code>default_vector_transport_method(M, typeof(p))</code> vector transport method to use</li><li><code>X_old</code> – (<code>zero_vector(M,x0)</code>) the last gradient/direction update added as momentum</li></ul><p><strong>Constructors</strong></p><p>Add momentum to a gradient problem, where by default just a gradient evaluation is used</p><pre><code class="nohighlight hljs">MomentumGradient(
    M::AbstractManifold;
    p=rand(M),
    s::DirectionUpdateRule=IdentityUpdateRule();
    X=zero_vector(p.M, x0), momentum=0.2
    vector_transport_method=default_vector_transport_method(M, typeof(p)),
)</code></pre><p>Initialize a momentum gradient rule to <code>s</code>. Note that the keyword agruments <code>p</code> and <code>X</code> will be overriden often, so their initialisation is meant to set the to certain types of points or tangent vectors, if you do not use the default types with respect to <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/plans/gradient_plan.jl#L261-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.AverageGradient" href="#Manopt.AverageGradient"><code>Manopt.AverageGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AverageGradient &lt;: DirectionUpdateRule</code></pre><p>Add an average of gradients to a gradient processor. A set of previous directions (from the inner processor) and the last iterate are stored, average is taken after vector transporting them to the current iterates tangent space.</p><p><strong>Fields</strong></p><ul><li><code>gradients</code> – (fill(<code>zero_vector(M,x0),n)</code>) the last <code>n</code> gradient/direction updates</li><li><code>last_iterate</code> – last iterate (needed to transport the gradients)</li><li><code>direction</code> – internal <a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a> to determine directions to apply the averaging to</li><li><code>vector_transport_method</code> - vector transport method to use</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">AverageGradient(
    M::AbstractManifold,
    p::P=rand(M);
    n::Int=10
    s::DirectionUpdateRule=IdentityUpdateRule();
    gradients = fill(zero_vector(p.M, o.x),n),
    last_iterate = deepcopy(x0),
    vector_transport_method = default_vector_transport_method(M, typeof(p))
)</code></pre><p>Add average to a gradient problem, where</p><ul><li><code>n</code> determines the size of averaging</li><li><code>s</code> is the internal <a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a> to determine the gradients to store</li><li><code>gradients</code> can be prefilled with some history</li><li><code>last_iterate</code> stores the last iterate</li><li><code>vector_transport_method</code> determines how to transport all gradients to the current iterates tangent space before averaging</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/plans/gradient_plan.jl#L327-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.Nesterov" href="#Manopt.Nesterov"><code>Manopt.Nesterov</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Nesterov &lt;: DirectionUpdateRule</code></pre><p><strong>Fields</strong></p><ul><li><code>γ</code></li><li><code>μ</code> the strong convexity coefficient</li><li><code>v</code> (=<span>$=v_k$</span>, <span>$v_0=x_0$</span>) an interims point to compute the next gradient evaluation point <code>y_k</code></li><li><code>shrinkage</code> (<code>= i -&gt; 0.8</code>) a function to compute the shrinkage <span>$β_k$</span> per iterate.</li></ul><p>Let&#39;s assume <span>$f$</span> is <span>$L$</span>-Lipschitz and <span>$μ$</span>-strongly convex. Given</p><ul><li>a step size <span>$h_k&lt;\frac{1}{L}$</span> (from the <a href="#Manopt.GradientDescentState"><code>GradientDescentState</code></a></li><li>a <code>shrinkage</code> parameter <span>$β_k$</span></li><li>and a current iterate <span>$x_k$</span></li><li>as well as the interims values <span>$γ_k$</span> and <span>$v_k$</span> from the previous iterate.</li></ul><p>This compute a Nesterov type update using the following steps, see <sup class="footnote-reference"><a id="citeref-ZhangSra2018" href="#footnote-ZhangSra2018">[ZhangSra2018]</a></sup></p><ol><li>Copute the positive root, i.e. <span>$α_k∈(0,1)$</span> of <span>$α^2 = h_k\bigl((1-α_k)γ_k+α_k μ\bigr)$</span>.</li><li>Set <span>$\bar γ_k+1 = (1-α_k)γ_k + α_kμ$</span></li><li><span>$y_k = \operatorname{retr}_{x_k}\Bigl(\frac{α_kγ_k}{γ_k + α_kμ}\operatorname{retr}^{-1}_{x_k}v_k \Bigr)$</span></li><li><span>$x_{k+1} = \operatorname{retr}_{y_k}(-h_k \operatorname{grad}f(y_k))$</span></li><li><span>$v_{k+1} = `\operatorname{retr}_{y_k}\Bigl(\frac{(1-α_k)γ_k}{\barγ_k}\operatorname{retr}_{y_k}^{-1}(v_k) - \frac{α_k}{\bar γ_{k+1}}\operatorname{grad}f(y_k) \Bigr)$</span></li><li><span>$γ_{k+1} = \frac{1}{1+β_k}\bar γ_{k+1}$</span></li></ol><p>Then the direction from <span>$x_k$</span> to <span>$x_k+1$</span>, i.e. <span>$d = \operatorname{retr}^{-1}_{x_k}x_{k+1}$</span> is returned.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">Nesterov(M::AbstractManifold, p::P; γ=0.001, μ=0.9, schrinkage = k -&gt; 0.8;
    inverse_retraction_method=LogarithmicInverseRetraction())</code></pre><p>Initialize the Nesterov acceleration, where <code>x0</code> initializes <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/plans/gradient_plan.jl#L399-L435">source</a></section></article><h2 id="Debug-Actions"><a class="docs-heading-anchor" href="#Debug-Actions">Debug Actions</a><a id="Debug-Actions-1"></a><a class="docs-heading-anchor-permalink" href="#Debug-Actions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugGradient" href="#Manopt.DebugGradient"><code>Manopt.DebugGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DebugGradient &lt;: DebugAction</code></pre><p>debug for the gradient evaluated at the current iterate</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">DebugGradient(; long=false, prefix= , format= &quot;$prefix%s&quot;, io=stdout)</code></pre><p>display the short (<code>false</code>) or long (<code>true</code>) default text for the gradient, or set the <code>prefix</code> manually. Alternatively the complete format can be set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/plans/gradient_plan.jl#L478-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugGradientNorm" href="#Manopt.DebugGradientNorm"><code>Manopt.DebugGradientNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DebugGradientNorm &lt;: DebugAction</code></pre><p>debug for gradient evaluated at the current iterate.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">DebugGradientNorm([long=false,p=print])</code></pre><p>display the short (<code>false</code>) or long (<code>true</code>) default text for the gradient norm.</p><pre><code class="nohighlight hljs">DebugGradientNorm(prefix[, p=print])</code></pre><p>display the a <code>prefix</code> in front of the gradientnorm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/plans/gradient_plan.jl#L511-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugStepsize" href="#Manopt.DebugStepsize"><code>Manopt.DebugStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DebugStepsize &lt;: DebugAction</code></pre><p>debug for the current step size.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">DebugStepsize(;long=false,prefix=&quot;step size:&quot;, format=&quot;$prefix%s&quot;, io=stdout)</code></pre><p>display the a <code>prefix</code> in front of the step size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/plans/gradient_plan.jl#L553-L562">source</a></section></article><h2 id="Record-Actions"><a class="docs-heading-anchor" href="#Record-Actions">Record Actions</a><a id="Record-Actions-1"></a><a class="docs-heading-anchor-permalink" href="#Record-Actions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.RecordGradient" href="#Manopt.RecordGradient"><code>Manopt.RecordGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RecordGradient &lt;: RecordAction</code></pre><p>record the gradient evaluated at the current iterate</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">RecordGradient(ξ)</code></pre><p>initialize the <a href="../../plans/record/#Manopt.RecordAction"><code>RecordAction</code></a> to the corresponding type of the tangent vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/plans/gradient_plan.jl#L589-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.RecordGradientNorm" href="#Manopt.RecordGradientNorm"><code>Manopt.RecordGradientNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RecordGradientNorm &lt;: RecordAction</code></pre><p>record the norm of the current gradient</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/plans/gradient_plan.jl#L611-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.RecordStepsize" href="#Manopt.RecordStepsize"><code>Manopt.RecordStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RecordStepsize &lt;: RecordAction</code></pre><p>record the step size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/a1134787bdc19017839b7772c6fcc357053b3e18/src/plans/gradient_plan.jl#L628-L632">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-ZhangSra2018"><a class="tag is-link" href="#citeref-ZhangSra2018">ZhangSra2018</a><blockquote><p>H. Zhang, S. Sra: <em>Towards Riemannian Accelerated Gradient Methods</em>, Preprint, 2018, arXiv: <a href="https://arxiv.org/abs/1806.02812">1806.02812</a></p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../FrankWolfe/">« Frank-Wolfe</a><a class="docs-footer-nextpage" href="../LevenbergMarquardt/">Levenberg–Marquardt »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 15 June 2023 15:31">Thursday 15 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
