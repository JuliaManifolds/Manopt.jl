<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Objective · Manopt.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/Optimize!/">Get started: Optimize!</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using Inplace computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use Automatic Differentiation</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a Cache</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a Solver</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do Contrained Optimization</a></li><li><a class="tocitem" href="../../tutorials/GeodesicRegression/">Do Geodesic Regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">Introduction</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas–Rachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg–Marquardt</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder–Mead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../">Specify a Solver</a></li><li><a class="tocitem" href="../problem/">Problem</a></li><li class="is-active"><a class="tocitem" href>Objective</a><ul class="internal"><li><a class="tocitem" href="#Cost-Objective"><span>Cost Objective</span></a></li><li><a class="tocitem" href="#Gradient-Objectives"><span>Gradient Objectives</span></a></li><li><a class="tocitem" href="#Subgradient-Objective"><span>Subgradient Objective</span></a></li><li><a class="tocitem" href="#Proximal-Map-Objective"><span>Proximal Map Objective</span></a></li><li><a class="tocitem" href="#Hessian-Objective"><span>Hessian Objective</span></a></li><li><a class="tocitem" href="#Primal-Dual-based-Objetives"><span>Primal-Dual based Objetives</span></a></li><li><a class="tocitem" href="#Constrained-Objective"><span>Constrained Objective</span></a></li><li><a class="tocitem" href="#Decorators-for-AbstractManoptSolverState"><span>Decorators for AbstractManoptSolverState</span></a></li></ul></li><li><a class="tocitem" href="../state/">Solver State</a></li><li><a class="tocitem" href="../stepsize/">Stepsize</a></li><li><a class="tocitem" href="../stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../debug/">Debug Output</a></li><li><a class="tocitem" href="../record/">Recording values</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../functions/">Introduction</a></li><li><a class="tocitem" href="../../functions/bezier/">Bézier curves</a></li><li><a class="tocitem" href="../../functions/costs/">Cost functions</a></li><li><a class="tocitem" href="../../functions/differentials/">Differentials</a></li><li><a class="tocitem" href="../../functions/adjointdifferentials/">Adjoint Differentials</a></li><li><a class="tocitem" href="../../functions/gradients/">Gradients</a></li><li><a class="tocitem" href="../../functions/proximal_maps/">Proximal Maps</a></li><li><a class="tocitem" href="../../functions/manifold/">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/data/">Data</a></li><li><a class="tocitem" href="../../helpers/errorMeasures/">Error Measures</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../list/">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plans</a></li><li class="is-active"><a href>Objective</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Objective</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/plans/objective.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ObjectiveSection"><a class="docs-heading-anchor" href="#ObjectiveSection">A Manifold Objective</a><a id="ObjectiveSection-1"></a><a class="docs-heading-anchor-permalink" href="#ObjectiveSection" title="Permalink"></a></h1><p>The Objective describes that actual cost function and all its properties.</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractManifoldObjective" href="#Manopt.AbstractManifoldObjective"><code>Manopt.AbstractManifoldObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldObjective{E&lt;:AbstractEvaluationType}</code></pre><p>Describe the collection of the optimization function `<code>f\colon \mathcal M → \bbR</code> (or even a vectorial range) and its corresponding elements, which might for example be a gradient or (one or more) prxomial maps.</p><p>All these elements should usually be implemented as functions <code>(M, p) -&gt; ...</code>, or <code>(M, X, p) -&gt; ...</code> that is</p><ul><li>the first argument of these functions should be the manifold <code>M</code> they are defined on</li><li>the argument <code>X</code> is present, if the computation is performed inplace of <code>X</code> (see <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>)</li><li>the argument <code>p</code> is the place the function (<span>$f$</span> or one of its elements) is evaluated <strong>at</strong>.</li></ul><p>the type <code>T</code> indicates the global <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/objective.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractDecoratedManifoldObjective" href="#Manopt.AbstractDecoratedManifoldObjective"><code>Manopt.AbstractDecoratedManifoldObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDecoratedManifoldObjective{E&lt;:AbstractEvaluationType,O&lt;:AbstractManifoldObjective}</code></pre><p>A common supertype for all decorators of <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a>s to simplify dispatch.     The second parameter should refer to the undecorated objective (i.e. the most inner one).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/objective.jl#L25-L30">source</a></section></article><p>Which has two main different possibilities for its containing functions concerning the evaluation mode – not necessarily the cost, but for example gradient in an <a href="#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractEvaluationType" href="#Manopt.AbstractEvaluationType"><code>Manopt.AbstractEvaluationType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractEvaluationType</code></pre><p>An abstract type to specify the kind of evaluation a <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> supports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/objective.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.AllocatingEvaluation" href="#Manopt.AllocatingEvaluation"><code>Manopt.AllocatingEvaluation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AllocatingEvaluation &lt;: AbstractEvaluationType</code></pre><p>A parameter for a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> indicating that the problem uses functions that allocate memory for their result, i.e. they work out of place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/objective.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.InplaceEvaluation" href="#Manopt.InplaceEvaluation"><code>Manopt.InplaceEvaluation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InplaceEvaluation &lt;: AbstractEvaluationType</code></pre><p>A parameter for a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> indicating that the problem uses functions that do not allocate memory but work on their input, i.e. in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/objective.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.evaluation_type" href="#Manopt.evaluation_type"><code>Manopt.evaluation_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluation_type(mp::AbstractManoptProblem)</code></pre><p>Get the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> of the objective in <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>mp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/problem.jl#L32-L37">source</a></section><section><div><pre><code class="nohighlight hljs">evaluation_type(::AbstractManifoldObjective{Teval})</code></pre><p>Get the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> of the objective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/problem.jl#L39-L43">source</a></section></article><p>It sometimes might be nice to set certain parameters within</p><h2 id="Cost-Objective"><a class="docs-heading-anchor" href="#Cost-Objective">Cost Objective</a><a id="Cost-Objective-1"></a><a class="docs-heading-anchor-permalink" href="#Cost-Objective" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractManifoldCostObjective" href="#Manopt.AbstractManifoldCostObjective"><code>Manopt.AbstractManifoldCostObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldCostObjective{T&lt;:AbstractEvaluationType} &lt;: AbstractManifoldObjective{T}</code></pre><p>Representing objectives on manifolds with a cost function implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/cost_plan.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.ManifoldCostObjective" href="#Manopt.ManifoldCostObjective"><code>Manopt.ManifoldCostObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldCostObjective{T, TC} &lt;: AbstractManifoldCostObjective{T, TC}</code></pre><p>speficy an <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> that does only have information about the cost function <span>$f\colon \mathbb M → ℝ$</span> implemented as a function <code>(M, p) -&gt; c</code> to compute the cost value <code>c</code> at <code>p</code> on the manifold <code>M</code>.</p><ul><li><code>cost</code> – a function <span>$f: \mathcal M → ℝ$</span> to minimize</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldCostObjective(f)</code></pre><p>Generate a problem. While this Problem does not have any allocating functions, the type <code>T</code> can be set for consistency reasons with other problems.</p><p><strong>Used with</strong></p><p><a href="../../solvers/NelderMead/#Manopt.NelderMead"><code>NelderMead</code></a>, <a href="../../solvers/particle_swarm/#Manopt.particle_swarm"><code>particle_swarm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/cost_plan.jl#L9-L27">source</a></section></article><h3 id="Access-functions"><a class="docs-heading-anchor" href="#Access-functions">Access functions</a><a id="Access-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Access-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_cost" href="#Manopt.get_cost"><code>Manopt.get_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_cost(amp::AbstractManoptProblem, p)</code></pre><p>evaluate the cost function <code>f</code> stored within the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at the point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/problem.jl#L67-L72">source</a></section><section><div><pre><code class="nohighlight hljs">get_cost(M::AbstractManifold, obj::AbstractManifoldObjective, p)</code></pre><p>evaluate the cost function <code>f</code> defined on <code>M</code> stored within the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> at the point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/problem.jl#L77-L81">source</a></section><section><div><pre><code class="nohighlight hljs">get_cost(M::AbstractManifold, mco::AbstractManifoldCostObjective, p)</code></pre><p>Evaluate the cost function from within the <a href="#Manopt.AbstractManifoldCostObjective"><code>AbstractManifoldCostObjective</code></a> on <code>M</code> at <code>p</code>.</p><p>By default this implementation assumed that the cost is stored within <code>mco.cost</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/cost_plan.jl#L35-L42">source</a></section><section><div><pre><code class="nohighlight hljs">get_cost(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p, i)</code></pre><p>Evaluate the <code>i</code>th summand of the cost.</p><p>If you use a single function for the stochastic cost, then only the index <code>ì=1</code>` is available to evaluate the whole cost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stochastic_gradient_plan.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_cost_function" href="#Manopt.get_cost_function"><code>Manopt.get_cost_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_cost_function(amco::AbstractManifoldCostObjective)</code></pre><p>return the function to evaluate (just) the cost <span>$f(p)=c$</span> as a function <code>(M,p) -&gt; c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/cost_plan.jl#L50-L54">source</a></section></article><h2 id="Gradient-Objectives"><a class="docs-heading-anchor" href="#Gradient-Objectives">Gradient Objectives</a><a id="Gradient-Objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-Objectives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractManifoldGradientObjective" href="#Manopt.AbstractManifoldGradientObjective"><code>Manopt.AbstractManifoldGradientObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldGradientObjective{E&lt;:AbstractEvaluationType, TC, TG} &lt;: AbstractManifoldCostObjective{E, TC}</code></pre><p>An abstract type for all functions that provide a (full) gradient, where <code>T</code> is a <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> for the gradient function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/gradient_plan.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.ManifoldGradientObjective" href="#Manopt.ManifoldGradientObjective"><code>Manopt.ManifoldGradientObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldGradientObjective{T&lt;:AbstractEvaluationType} &lt;: AbstractManifoldGradientObjective{T}</code></pre><p>specify an objetive containing a cost and its gradient</p><p><strong>Fields</strong></p><ul><li><code>cost</code>       – a function <span>$f\colon\mathcal M → ℝ$</span></li><li><code>gradient!!</code> – the gradient <span>$\operatorname{grad}f\colon\mathcal M → \mathcal T\mathcal M$</span> of the cost function <span>$f$</span>.</li></ul><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>T</code> the gradient can have to forms</p><ul><li>as a function <code>(M, p) -&gt; X</code> that allocates memory for <code>X</code>, i.e. an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a></li><li>as a function <code>(M, X, p) -&gt; X</code> that work in place of <code>X</code>, i.e. an <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a></li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldGradientObjective(cost, gradient; evaluation=AllocatingEvaluation())</code></pre><p><strong>Used with</strong></p><p><a href="../../solvers/gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a>, <a href="../../solvers/conjugate_gradient_descent/#Manopt.conjugate_gradient_descent"><code>conjugate_gradient_descent</code></a>, <a href="../../solvers/quasi_Newton/#Manopt.quasi_Newton"><code>quasi_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/gradient_plan.jl#L24-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.ManifoldAlternatingGradientObjective" href="#Manopt.ManifoldAlternatingGradientObjective"><code>Manopt.ManifoldAlternatingGradientObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldAlternatingGradientObjective{E&lt;:AbstractEvaluationType,TCost,TGradient} &lt;: AbstractManifoldGradientObjective{E}</code></pre><p>An alternating gradient objective consists of</p><ul><li>a cost function <span>$F(x)$</span></li><li>a gradient <span>$\operatorname{grad}F$</span> that is either<ul><li>given as one function <span>$\operatorname{grad}F$</span> returning a tangent vector <code>X</code> on <code>M</code> or</li><li>an array of gradient functions <span>$\operatorname{grad}F_i$</span>, <code>ì=1,…,n</code> s each returning a component of the gradient</li></ul>which might be allocating or mutating variants, but not a mix of both.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This Objective is usually defined using the <code>ProductManifold</code> from <code>Manifolds.jl</code>, so <code>Manifolds.jl</code> to be loaded.</p></div></div><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldAlternatingGradientObjective(F, gradF::Function;
    evaluation=AllocatingEvaluation()
)
ManifoldAlternatingGradientObjective(F, gradF::AbstractVector{&lt;:Function};
    evaluation=AllocatingEvaluation()
)</code></pre><p>Create a alternating gradient problem with an optional <code>cost</code> and the gradient either as one function (returning an array) or a vector of functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/alternating_gradient_plan.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.ManifoldStochasticGradientObjective" href="#Manopt.ManifoldStochasticGradientObjective"><code>Manopt.ManifoldStochasticGradientObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldStochasticGradientObjective{T&lt;:AbstractEvaluationType} &lt;: AbstractManifoldGradientObjective{T}</code></pre><p>A stochastic gradient objective consists of</p><ul><li>a(n optional) cost function ``f(p) = \displaystyle\sum<em>{i=1}^n f</em>i(p)</li><li>an array of gradients, <span>$\operatorname{grad}f_i(p), i=1,\ldots,n$</span> which can be given in two forms<ul><li>as one single function <span>$(\mathcal M, p) ↦ (X_1,…,X_n) \in (T_p\mathcal M)^n$</span></li><li>as a vector of functions <span>$\bigl( (\mathcal M, p) ↦ X_1, …, (\mathcal M, p) ↦ X_n\bigr)$</span>.</li></ul></li></ul><p>Where both variants can also be provided as <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> functions, i.e. <code>(M, X, p) -&gt; X</code>, where <code>X</code> is the vector of <code>X1,...Xn</code> and <code>(M, X1, p) -&gt; X1, ..., (M, Xn, p) -&gt; Xn</code>, respectively.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldStochasticGradientObjective(
    grad_f::Function;
    cost=Missing(),
    evaluation=AllocatingEvaluation()
)
ManifoldStochasticGradientObjective(
    grad_f::AbstractVector{&lt;:Function};
    cost=Missing(), evaluation=AllocatingEvaluation()
)</code></pre><p>Create a Stochastic gradient problem with the gradient either as one function (returning an array of tangent vectors) or a vector of functions (each returning one tangent vector).</p><p>The optional cost can also be given as either a single function (returning a number) pr a vector of functions, each returning a value.</p><p><strong>Used with</strong></p><p><a href="../../solvers/stochastic_gradient_descent/#Manopt.stochastic_gradient_descent"><code>stochastic_gradient_descent</code></a></p><p>Note that this can also be used with a <a href="../../solvers/gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a>, since the (complete) gradient is just the sums of the single gradients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stochastic_gradient_plan.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.NonlinearLeastSquaresObjective" href="#Manopt.NonlinearLeastSquaresObjective"><code>Manopt.NonlinearLeastSquaresObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonlinearLeastSquaresObjective{T&lt;:AbstractEvaluationType} &lt;: AbstractManifoldObjective{T}</code></pre><p>A type for nonlinear least squares problems. <code>T</code> is a <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> for the <code>F</code> and Jacobian functions.</p><p>Specify a nonlinear least squares problem</p><p><strong>Fields</strong></p><ul><li><code>f</code>        – a function <span>$f: \mathcal M → ℝ^d$</span> to minimize</li><li><code>jacobian!!</code>   – Jacobian of the function <span>$f$</span></li><li><code>jacobian_tangent_basis</code>     – the basis of tangent space used for computing the Jacobian.</li><li><code>num_components</code> – number of values returned by <code>f</code> (equal to <code>d</code>).</li></ul><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>T</code> the function <span>$F$</span> has to be provided:</p><ul><li>as a functions <code>(M::AbstractManifold, p) -&gt; v</code> that allocates memory for <code>v</code> itself for an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>,</li><li>as a function <code>(M::AbstractManifold, v, p) -&gt; v</code> that works in place of <code>v</code> for a <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>.</li></ul><p>Also the Jacobian <span>$jacF!!$</span> is required:</p><ul><li>as a functions <code>(M::AbstractManifold, p; basis_domain::AbstractBasis) -&gt; v</code> that allocates memory for <code>v</code> itself for an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>,</li><li>as a function <code>(M::AbstractManifold, v, p; basis_domain::AbstractBasis) -&gt; v</code> that works in place of <code>v</code> for an <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">NonlinearLeastSquaresProblem(M, F, jacF, num_components; evaluation=AllocatingEvaluation(), jacobian_tangent_basis=DefaultOrthonormalBasis())</code></pre><p><strong>See also</strong></p><p><a href="../../solvers/LevenbergMarquardt/#Manopt.LevenbergMarquardt"><code>LevenbergMarquardt</code></a>, <a href="../../solvers/LevenbergMarquardt/#Manopt.LevenbergMarquardtState"><code>LevenbergMarquardtState</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/nonlinear_least_squares_plan.jl#L2-L37">source</a></section></article><p>There is also a second variant, if just one function is responsible for computing the cost <em>and</em> the gradient</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.ManifoldCostGradientObjective" href="#Manopt.ManifoldCostGradientObjective"><code>Manopt.ManifoldCostGradientObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldCostGradientObjective{T} &lt;: AbstractManifoldObjective{T}</code></pre><p>specify an objetive containing one function to perform a combined computation of cost and its gradient</p><p><strong>Fields</strong></p><ul><li><code>costgrad!!</code> – a function that computes both the cost <span>$f\colon\mathcal M → ℝ$</span> and its gradient <span>$\operatorname{grad}f\colon\mathcal M → \mathcal T\mathcal M$</span></li></ul><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>T</code> the gradient can have to forms</p><ul><li>as a function <code>(M, p) -&gt; (c, X)</code> that allocates memory for the gradient <code>X</code>, i.e. an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a></li><li>as a function <code>(M, X, p) -&gt; (c, X)</code> that work in place of <code>X</code>, i.e. an <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a></li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldCostGradientObjective(costgrad; evaluation=AllocatingEvaluation())</code></pre><p><strong>Used with</strong></p><p><a href="../../solvers/gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a>, <a href="../../solvers/conjugate_gradient_descent/#Manopt.conjugate_gradient_descent"><code>conjugate_gradient_descent</code></a>, <a href="../../solvers/quasi_Newton/#Manopt.quasi_Newton"><code>quasi_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/gradient_plan.jl#L57-L78">source</a></section></article><h3 id="Access-functions-2"><a class="docs-heading-anchor" href="#Access-functions-2">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_gradient" href="#Manopt.get_gradient"><code>Manopt.get_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_gradient(s::AbstractManoptSolverState)</code></pre><p>return the (last stored) gradient within <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a><code></code>s`. By default also undecorates the state beforehand</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/solver_state.jl#L159-L164">source</a></section><section><div><pre><code class="nohighlight hljs">get_gradient(amp::AbstractManoptProblem, p)
get_gradient!(amp::AbstractManoptProblem, X, p)</code></pre><p>evaluate the gradient of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at the point <code>p</code>.</p><p>The evaluation is done in place of <code>X</code> for the <code>!</code>-variant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/gradient_plan.jl#L126-L133">source</a></section><section><div><pre><code class="nohighlight hljs">get_gradient(M::AbstractManifold, mgo::AbstractManifoldGradientObjective{T}, p)
get_gradient!(M::AbstractManifold, X, mgo::AbstractManifoldGradientObjective{T}, p)</code></pre><p>evaluate the gradient of a <a href="#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective{T}</code></a> <code>mgo</code> at <code>p</code>.</p><p>The evaluation is done in place of <code>X</code> for the <code>!</code>-variant. The <code>T=</code><a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a> problem might still allocate memory within. When the non-mutating variant is called with a <code>T=</code><a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> memory for the result is allocated.</p><p>Note that the order of parameters follows the philisophy of <code>Manifolds.jl</code>, namely that even for the mutating variant, the manifold is the first parameter and the (inplace) tangent vector <code>X</code> comes second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/gradient_plan.jl#L141-L155">source</a></section><section><div><pre><code class="nohighlight hljs">get_gradient(agst::AbstractGradientSolverState)</code></pre><p>return the gradient stored within gradient options. THe default resturns <code>agst.X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/gradient_plan.jl#L206-L211">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p, k)
get_gradient!(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, Y, p, k)</code></pre><p>Evaluate one of the summands gradients <span>$\operatorname{grad}f_k$</span>, <span>$k∈\{1,…,n\}$</span>, at <code>x</code> (in place of <code>Y</code>).</p><p>If you use a single function for the stochastic gradient, that works inplace, then <code>get_gradient</code> is not available, since the length (or number of elements of the gradient required for allocation) can not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stochastic_gradient_plan.jl#L177-L185">source</a></section><section><div><pre><code class="nohighlight hljs">get_gradient(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p)
get_gradient!(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, X, p)</code></pre><p>Evaluate the complete gradient <span>$\operatorname{grad} f = \displaystyle\sum_{i=1}^n \operatorname{grad} f_i(p)$</span> at <code>p</code> (in place of <code>X</code>).</p><p>If you use a single function for the stochastic gradient, that works inplace, then <code>get_gradient</code> is not available, since the length (or number of elements of the gradient required for allocation) can not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stochastic_gradient_plan.jl#L269-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_gradients" href="#Manopt.get_gradients"><code>Manopt.get_gradients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_gradients(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p)
get_gradients!(M::AbstractManifold, X, sgo::ManifoldStochasticGradientObjective, p)</code></pre><p>Evaluate all summands gradients <span>$\{\operatorname{grad}f_i\}_{i=1}^n$</span> at <code>p</code> (in place of <code>X</code>).</p><p>If you use a single function for the stochastic gradient, that works inplace, then <code>get_gradient</code> is not available, since the length (or number of elements of the gradient) can not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stochastic_gradient_plan.jl#L82-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_gradient_function" href="#Manopt.get_gradient_function"><code>Manopt.get_gradient_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_gradient_function(amgo::AbstractManifoldGradientObjective{E&lt;:AbstractEvaluationType})</code></pre><p>return the function to evaluate (just) the gradient <span>$\operatorname{grad} f(p)$</span>. Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code> this is a function</p><ul><li><code>(M, p) -&gt; X</code> for the <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a> case</li><li><code>(M, X, p) -&gt; X</code> for the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>, i.e. working inplace of <code>X</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/gradient_plan.jl#L10-L18">source</a></section></article><h2 id="Subgradient-Objective"><a class="docs-heading-anchor" href="#Subgradient-Objective">Subgradient Objective</a><a id="Subgradient-Objective-1"></a><a class="docs-heading-anchor-permalink" href="#Subgradient-Objective" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.ManifoldSubgradientObjective" href="#Manopt.ManifoldSubgradientObjective"><code>Manopt.ManifoldSubgradientObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldSubgradientObjective{T&lt;:AbstractEvaluationType,C,S} &lt;:AbstractManifoldCostObjective{T, C}</code></pre><p>A structure to store information about a objective for a subgradient based optimization problem</p><p><strong>Fields</strong></p><ul><li><code>cost</code> – the function <span>$F$</span> to be minimized</li><li><code>subgradient</code> – a function returning a subgradient <span>$\partial F$</span> of <span>$F$</span></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldSubgradientObjective(f, ∂f)</code></pre><p>Generate the <a href="#Manopt.ManifoldSubgradientObjective"><code>ManifoldSubgradientObjective</code></a> for a subgradient objective, i.e. a (cost) function <code>f(M, p)</code> and a function <code>∂f(M, p)</code> that returns a not necessarily deterministic element from the subdifferential at <code>p</code> on a manifold <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/subgradient_plan.jl#L1-L17">source</a></section></article><h3 id="Access-Functions"><a class="docs-heading-anchor" href="#Access-Functions">Access Functions</a><a id="Access-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Access-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_subgradient" href="#Manopt.get_subgradient"><code>Manopt.get_subgradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_subgradient(amp::AbstractManoptProblem, p)
get_subgradient!(amp::AbstractManoptProblem, X, p)</code></pre><p>evaluate the subgradient of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at point <code>p</code>.</p><p>The evaluation is done in place of <code>X</code> for the <code>!</code>-variant. The result might not be deterministic, <em>one</em> element of the subdifferential is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/subgradient_plan.jl#L29-L37">source</a></section><section><div><pre><code class="nohighlight hljs">X = get_subgradient(M;;AbstractManifold, sgo::ManifoldSubgradientObjective, p)
get_subgradient!(M;;AbstractManifold, X, sgo::ManifoldSubgradientObjective, p)</code></pre><p>Evaluate the (sub)gradient of a <a href="#Manopt.ManifoldSubgradientObjective"><code>ManifoldSubgradientObjective</code></a> <code>sgo</code> at the point <code>p</code>.</p><p>The evaluation is done in place of <code>X</code> for the <code>!</code>-variant. The result might not be deterministic, <em>one</em> element of the subdifferential is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/subgradient_plan.jl#L45-L54">source</a></section></article><h2 id="Proximal-Map-Objective"><a class="docs-heading-anchor" href="#Proximal-Map-Objective">Proximal Map Objective</a><a id="Proximal-Map-Objective-1"></a><a class="docs-heading-anchor-permalink" href="#Proximal-Map-Objective" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.ManifoldProximalMapObjective" href="#Manopt.ManifoldProximalMapObjective"><code>Manopt.ManifoldProximalMapObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldProximalMapObjective{E&lt;:AbstractEvaluationType, TC, TP, V &lt;: Vector{&lt;:Integer}} &lt;: AbstractManifoldCostObjective{E, TC}</code></pre><p>specify a problem for solvers based on the evaluation of proximal map(s).</p><p><strong>Fields</strong></p><ul><li><code>cost</code> - a function <span>$F:\mathcal M→ℝ$</span> to minimize</li><li><code>proxes</code> - proximal maps <span>$\operatorname{prox}_{λ\varphi}:\mathcal M→\mathcal M$</span> as functions <code>(M, λ, p) -&gt; q</code>.</li><li><code>number_of_proxes</code> - (<code>ones(length(proxes))</code>` number of proximal Maps per function, e.g. if one of the maps is a combined one such that the proximal Maps functions return more than one entry per function, you have to adapt this value. if not speciifed, it is set to one prox per function.</li></ul><p><strong>See also</strong></p><p><a href="../../solvers/cyclic_proximal_point/#Manopt.cyclic_proximal_point"><code>cyclic_proximal_point</code></a>, <a href="#Manopt.get_cost"><code>get_cost</code></a>, <a href="#Manopt.get_proximal_map"><code>get_proximal_map</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/proximal_plan.jl#L6-L23">source</a></section></article><h3 id="Access-Functions-2"><a class="docs-heading-anchor" href="#Access-Functions-2">Access Functions</a><a class="docs-heading-anchor-permalink" href="#Access-Functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_proximal_map" href="#Manopt.get_proximal_map"><code>Manopt.get_proximal_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = get_proximal_map(M::AbstractManifold, mpo::ManifoldProximalMapObjective, λ, p)
get_proximal_map!(M::AbstractManifold, q, mpo::ManifoldProximalMapObjective, λ, p)
q = get_proximal_map(M::AbstractManifold, mpo::ManifoldProximalMapObjective, λ, p, i)
get_proximal_map!(M::AbstractManifold, q, mpo::ManifoldProximalMapObjective, λ, p, i)</code></pre><p>evaluate the (<code>i</code>th) proximal map of <code>ManifoldProximalMapObjective p</code> at the point <code>p</code> of <code>p.M</code> with parameter <span>$λ&gt;0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/proximal_plan.jl#L60-L67">source</a></section></article><h2 id="Hessian-Objective"><a class="docs-heading-anchor" href="#Hessian-Objective">Hessian Objective</a><a id="Hessian-Objective-1"></a><a class="docs-heading-anchor-permalink" href="#Hessian-Objective" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.ManifoldHessianObjective" href="#Manopt.ManifoldHessianObjective"><code>Manopt.ManifoldHessianObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldHessianObjective{T&lt;:AbstractEvaluationType,C,G,H,Pre} &lt;: AbstractManifoldGradientObjective{T}</code></pre><p>specify a problem for hessian based algorithms.</p><p><strong>Fields</strong></p><ul><li><code>cost</code> : a function <span>$F:\mathcal M→ℝ$</span> to minimize</li><li><code>gradient</code>     : the gradient <span>$\operatorname{grad}F:\mathcal M → \mathcal T\mathcal M$</span> of the cost function <span>$F$</span></li><li><code>hessian</code>      : the hessian <span>$\operatorname{Hess}F(x)[⋅]: \mathcal T_{x} \mathcal M → \mathcal T_{x} \mathcal M$</span> of the cost function <span>$F$</span></li><li><code>preconditioner</code>       : the symmetric, positive definite preconditioner   as an approximation of the inverse of the Hessian of <span>$f$</span>, i.e. as a map with the same   input variables as the <code>hessian</code>.</li></ul><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>T</code> the gradient and can have to forms</p><ul><li>as a function <code>(M, p) -&gt; X</code>  and <code>(M, p, X) -&gt; Y</code>, resp. i.e. an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a></li><li>as a function <code>(M, X, p) -&gt; X</code> and (M, Y, p, X), resp., i.e. an <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldHessianObjective(f, grad_f, Hess_f, preconditioner = (M, p, X) -&gt; X;
    evaluation=AllocatingEvaluation())</code></pre><p><strong>See also</strong></p><p><a href="../../solvers/truncated_conjugate_gradient_descent/#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a>, <a href="../../solvers/trust_regions/#Manopt.trust_regions"><code>trust_regions</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/hessian_plan.jl#L9-L37">source</a></section></article><h3 id="Access-functions-3"><a class="docs-heading-anchor" href="#Access-functions-3">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_hessian" href="#Manopt.get_hessian"><code>Manopt.get_hessian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Y = get_hessian(amp::AbstractManoptProblem{T}, p, X)
get_hessian!(amp::AbstractManoptProblem{T}, Y, p, X)</code></pre><p>evaluate the Hessian of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at <code>p</code> applied to a tangent vector <code>X</code>, i.e. compute <span>$\operatorname{Hess}f(q)[X]$</span>, which can also happen in-place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/hessian_plan.jl#L62-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_preconditioner" href="#Manopt.get_preconditioner"><code>Manopt.get_preconditioner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_preconditioner(amp::AbstractManoptProblem, p, X)</code></pre><p>evaluate the symmetric, positive definite preconditioner (approximation of the inverse of the Hessian of the cost function <code>f</code>) of a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>s objective at the point <code>p</code> applied to a tangent vector <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/hessian_plan.jl#L110-L117">source</a></section><section><div><pre><code class="nohighlight hljs">get_preconditioner(M::AbstractManifold, mho::ManifoldHessianObjective, p, X)</code></pre><p>evaluate the symmetric, positive definite preconditioner (approximation of the inverse of the Hessian of the cost function <code>F</code>) of a <a href="#Manopt.ManifoldHessianObjective"><code>ManifoldHessianObjective</code></a> <code>mho</code> at the point <code>p</code> applied to a tangent vector <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/hessian_plan.jl#L125-L132">source</a></section></article><h2 id="Primal-Dual-based-Objetives"><a class="docs-heading-anchor" href="#Primal-Dual-based-Objetives">Primal-Dual based Objetives</a><a id="Primal-Dual-based-Objetives-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-Dual-based-Objetives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.AbstractPrimalDualManifoldObjective" href="#Manopt.AbstractPrimalDualManifoldObjective"><code>Manopt.AbstractPrimalDualManifoldObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractPrimalDualManifoldObjective{E&lt;:AbstractEvaluationType,C,P} &lt;: AbstractManifoldCostObjective{E,C}</p><p>A common abstract super type for objectives that consider primal-dual problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/primal_dual_plan.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.PrimalDualManifoldObjective" href="#Manopt.PrimalDualManifoldObjective"><code>Manopt.PrimalDualManifoldObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrimalDualManifoldObjective{E&lt;:AbstractEvaluationType} &lt;: AbstractPrimalDualManifoldObjective{E}</code></pre><p>Describes an Objective linearized or exact Chambolle-Pock algorithm.<sup class="footnote-reference"><a id="citeref-BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020" href="#footnote-BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020">[BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020]</a></sup><sup class="footnote-reference"><a id="citeref-ChambollePock2011" href="#footnote-ChambollePock2011">[ChambollePock2011]</a></sup></p><p><strong>Fields</strong></p><p>All fields with !! can either be mutating or nonmutating functions, which should be set depenting on the parameter <code>T &lt;: AbstractEvaluationType</code>.</p><ul><li><code>cost</code> <span>$F + G(Λ(⋅))$</span> to evaluate interims cost function values</li><li><code>linearized_forward_operator!!</code> linearized operator for the forward operation in the algorithm <span>$DΛ$</span></li><li><code>linearized_adjoint_operator!!</code> The adjoint differential <span>$(DΛ)^* : \mathcal N → T\mathcal M$</span></li><li><code>prox_f!!</code> the proximal map belonging to <span>$f$</span></li><li><code>prox_G_dual!!</code> the proximal map belonging to <span>$g_n^*$</span></li><li><code>Λ!!</code> – (<code>fordward_operator</code>) the  forward operator (if given) <span>$Λ: \mathcal M → \mathcal N$</span></li></ul><p>Either the linearized operator <span>$DΛ$</span> or <span>$Λ$</span> are required usually.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PrimalDualManifoldObjective(cost, prox_f, prox_G_dual, adjoint_linearized_operator;
    linearized_forward_operator::Union{Function,Missing}=missing,
    Λ::Union{Function,Missing}=missing,
    evaluation::AbstractEvaluationType=AllocatingEvaluation()
)</code></pre><p>The last optional argument can be used to provide the 4 or 5 functions as allocating or mutating (in place computation) ones. Note that the first argument is always the manifold under consideration, the mutated one is the second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/primal_dual_plan.jl#L30-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.PrimalDualManifoldSemismoothNewtonObjective" href="#Manopt.PrimalDualManifoldSemismoothNewtonObjective"><code>Manopt.PrimalDualManifoldSemismoothNewtonObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrimalDualManifoldSemismoothNewtonObjective{E&lt;:AbstractEvaluationType, TC, LO, ALO, PF, DPF, PG, DPG, L} &lt;: AbstractPrimalDualManifoldObjective{E, TC, PF}</code></pre><p>Describes a Problem for the Primal-dual Riemannian semismooth Newton algorithm. <sup class="footnote-reference"><a id="citeref-DiepeveenLellmann2021" href="#footnote-DiepeveenLellmann2021">[DiepeveenLellmann2021]</a></sup></p><p><strong>Fields</strong></p><ul><li><code>cost</code> <span>$F + G(Λ(⋅))$</span> to evaluate interims cost function values</li><li><code>linearized_operator</code> the linearization <span>$DΛ(⋅)[⋅]$</span> of the operator <span>$Λ(⋅)$</span>.</li><li><code>linearized_adjoint_operator</code> The adjoint differential <span>$(DΛ)^* \colon \mathcal N \to T\mathcal M$</span></li><li><code>prox_F</code> the proximal map belonging to <span>$f$</span></li><li><code>diff_prox_F</code> the (Clarke Generalized) differential of the proximal maps of <span>$F$</span></li><li><code>prox_G_dual</code> the proximal map belonging to <span>$g_n^*$</span></li><li><code>diff_prox_dual_G</code> the (Clarke Generalized) differential of the proximal maps of <span>$G^\ast_n$</span></li><li><code>Λ</code> – the exact forward operator. This operator is required if <code>Λ(m)=n</code> does not hold.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PrimalDualManifoldSemismoothNewtonObjective(cost, prox_F, prox_G_dual, forward_operator, adjoint_linearized_operator,Λ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/higher_order_primal_dual_plan.jl#L1-L27">source</a></section></article><h3 id="Access-functions-4"><a class="docs-heading-anchor" href="#Access-functions-4">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Manopt.adjoint_linearized_operator" href="#Manopt.adjoint_linearized_operator"><code>Manopt.adjoint_linearized_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">X = adjoint_linearized_operator(N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, m, n, Y)
adjoint_linearized_operator(N::AbstractManifold, X, apdmo::AbstractPrimalDualManifoldObjective, m, n, Y)</code></pre><p>Evaluate the adjoint of the linearized forward operator of <span>$(DΛ(m))^*[Y]$</span> stored within the <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a> (in place of <code>X</code>). Since <span>$Y∈T_n\mathcal N$</span>, both <span>$m$</span> and <span>$n=Λ(m)$</span> are necessary arguments, mainly because the forward operator <span>$Λ$</span> might be <code>missing</code> in <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/primal_dual_plan.jl#L417-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.forward_operator" href="#Manopt.forward_operator"><code>Manopt.forward_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = forward_operator(M::AbstractManifold, N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, p)
forward_operator!(M::AbstractManifold, N::AbstractManifold, q, apdmo::AbstractPrimalDualManifoldObjective, p)</code></pre><p>Evaluate the forward operator of <span>$Λ(x)$</span> stored within the <a href="../problem/#Manopt.TwoManifoldProblem"><code>TwoManifoldProblem</code></a> (in place of <code>q</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/primal_dual_plan.jl#L347-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_differential_dual_prox" href="#Manopt.get_differential_dual_prox"><code>Manopt.get_differential_dual_prox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">η = get_differential_dual_prox(N::AbstractManifold, pdsno::PrimalDualManifoldSemismoothNewtonObjective, n, τ, X, ξ)
get_differential_dual_prox!(N::AbstractManifold, pdsno::PrimalDualManifoldSemismoothNewtonObjective, η, n, τ, X, ξ)</code></pre><p>Evaluate the differential proximal map of <span>$G_n^*$</span> stored within <a href="#Manopt.PrimalDualManifoldSemismoothNewtonObjective"><code>PrimalDualManifoldSemismoothNewtonObjective</code></a></p><p class="math-container">\[D\operatorname{prox}_{τG_n^*}(X)[ξ]\]</p><p>which can also be computed in place of <code>η</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/higher_order_primal_dual_plan.jl#L274-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_differential_primal_prox" href="#Manopt.get_differential_primal_prox"><code>Manopt.get_differential_primal_prox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = get_differential_primal_prox(M::AbstractManifold, pdsno::PrimalDualManifoldSemismoothNewtonObjective σ, x)
get_differential_primal_prox!(p::TwoManifoldProblem, y, σ, x)</code></pre><p>Evaluate the differential proximal map of <span>$F$</span> stored within <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a></p><p class="math-container">\[D\operatorname{prox}_{σF}(x)[X]\]</p><p>which can also be computed in place of <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/higher_order_primal_dual_plan.jl#L193-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_dual_prox" href="#Manopt.get_dual_prox"><code>Manopt.get_dual_prox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Y = get_dual_prox(N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, n, τ, X)
get_dual_prox!(N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, Y, n, τ, X)</code></pre><p>Evaluate the proximal map of <span>$g_n^*$</span> stored within <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a></p><p class="math-container">\[  Y = \operatorname{prox}_{τG_n^*}(X)\]</p><p>which can also be computed in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/primal_dual_plan.jl#L179-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_primal_prox" href="#Manopt.get_primal_prox"><code>Manopt.get_primal_prox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = get_primal_prox(M::AbstractManifold, p::AbstractPrimalDualManifoldObjective, σ, p)
get_primal_prox!(M::AbstractManifold, p::AbstractPrimalDualManifoldObjective, q, σ, p)</code></pre><p>Evaluate the proximal map of <span>$F$</span> stored within <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a></p><p class="math-container">\[\operatorname{prox}_{σF}(x)\]</p><p>which can also be computed in place of <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/primal_dual_plan.jl#L111-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.linearized_forward_operator" href="#Manopt.linearized_forward_operator"><code>Manopt.linearized_forward_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Y = linearized_forward_operator(M::AbstractManifold, N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, m, X, n)
linearized_forward_operator!(M::AbstractManifold, N::AbstractManifold, Y, apdmo::AbstractPrimalDualManifoldObjective, m, X, n)</code></pre><p>Evaluate the linearized operator (differential) <span>$DΛ(m)[X]$</span> stored within the <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a> (in place of <code>Y</code>), where <code>n = Λ(m)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/primal_dual_plan.jl#L255-L261">source</a></section></article><h2 id="Constrained-Objective"><a class="docs-heading-anchor" href="#Constrained-Objective">Constrained Objective</a><a id="Constrained-Objective-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-Objective" title="Permalink"></a></h2><p>Besides the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> there is one further property to distinguish among constraint functions, especially the gradients of the constraints.</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.ConstraintType" href="#Manopt.ConstraintType"><code>Manopt.ConstraintType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstraintType</code></pre><p>An abstract type to represent different forms of representing constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.FunctionConstraint" href="#Manopt.FunctionConstraint"><code>Manopt.FunctionConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FunctionConstraint &lt;: ConstraintType</code></pre><p>A type to indicate that constraints are implemented one whole functions, e.g. <span>$g(p) ∈ \mathbb R^m$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.VectorConstraint" href="#Manopt.VectorConstraint"><code>Manopt.VectorConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorConstraint &lt;: ConstraintType</code></pre><p>A type to indicate that constraints are implemented a  vector of functions, e.g. <span>$g_i(p) ∈ \mathbb R, i=1,…,m$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L16-L21">source</a></section></article><p>The <a href="#Manopt.ConstraintType"><code>ConstraintType</code></a> is a parameter of the corresponding Objective.</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.ConstrainedManifoldObjective" href="#Manopt.ConstrainedManifoldObjective"><code>Manopt.ConstrainedManifoldObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstrainedManifoldObjective{T&lt;:AbstractEvaluationType, C &lt;: ConstraintType Manifold} &lt;: AbstractManifoldObjective{T}</code></pre><p>Describes the constrained objective</p><p class="math-container">\[\begin{aligned}
 \operatorname*{arg\,min}_{p ∈\mathcal{M}} &amp; f(p)\\
 \text{subject to } &amp;g_i(p)\leq0 \quad \text{ for all } i=1,…,m,\\
 \quad &amp;h_j(p)=0 \quad \text{ for all } j=1,…,n.
\end{aligned}\]</p><p>It consists of</p><ul><li>an cost function <span>$f(p)$</span></li><li>the gradient of <span>$f$</span>, <span>$\operatorname{grad}f(p)$</span> <a href="#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective</code></a></li><li>inequality constraints <span>$g(p)$</span>, either a function <code>g</code> returning a vector or a vector <code>[g1, g2,...,gm]</code> of functions.</li><li>equality constraints <span>$h(p)$</span>, either a function <code>h</code> returning a vector or a vector <code>[h1, h2,...,hn]</code> of functions.</li><li>gradient(s) of the inequality constraints <span>$\operatorname{grad}g(p) ∈ (T_p\mathcal M)^m$</span>, either a function or a vector of functions.</li><li>gradient(s) of the equality constraints <span>$\operatorname{grad}h(p) ∈ (T_p\mathcal M)^n$</span>, either a function or a vector of functions.</li></ul><p>There are two ways to specify the constraints <span>$g$</span> and <span>$h$</span>.</p><ol><li>as one <code>Function</code> returning a vector in <span>$\mathbb R^m$</span> and <span>$\mathbb R^n$</span> respecively. This might be easier to implement but requires evaluating <em>all</em> constraints even if only one is needed.</li><li>as a <code>AbstractVector{&lt;:Function}</code> where each function returns a real number. This requires each constrant to be implemented as a single function, but it is possible to evaluate also only a single constraint.</li></ol><p>The gradients <span>$\operatorname{grad}g$</span>, <span>$\operatorname{grad}h$</span> have to follow the same form. Additionally they can be implemented as in-place functions or as allocating ones. The gradient <span>$\operatorname{grad}F$</span> has to be the same kind. This difference is indicated by the <code>evaluation</code> keyword.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConstrainedManifoldObjective(f, grad_f, g, grad_g, h, grad_h;
    evaluation=AllocatingEvaluation()
)</code></pre><p>Where <code>f, g, h</code> describe the cost, inequality and equality constraints, respecitvely, as described above and <code>grad_f, grad_g, grad_h</code> are the corresponding gradient functions in one of the 4 formats. If the objective does not have inequality constraints, you can set <code>G</code> and <code>gradG</code> no <code>nothing</code>. If the problem does not have equality constraints, you can set <code>H</code> and <code>gradH</code> no <code>nothing</code> or leave them out.</p><pre><code class="nohighlight hljs">ConstrainedManifoldObjective(M::AbstractManifold, F, gradF;
    G=nothing, gradG=nothing, H=nothing, gradH=nothing;
    evaluation=AllocatingEvaluation()
)</code></pre><p>A keyword argument variant of the constructor above, where you can leave out either <code>G</code> and <code>gradG</code> <em>or</em> <code>H</code> and <code>gradH</code> but not both.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L24-L74">source</a></section></article><h3 id="Access-functions-5"><a class="docs-heading-anchor" href="#Access-functions-5">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-5" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_constraints" href="#Manopt.get_constraints"><code>Manopt.get_constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_constraints(M::AbstractManifold, co::ConstrainedManifoldObjective, p)</code></pre><p>Return the vector <span>$(g_1(p),...g_m(p),h_1(p),...,h_n(p))$</span> from the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>P</code> containing the values of all constraints at <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L265-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_equality_constraint" href="#Manopt.get_equality_constraint"><code>Manopt.get_equality_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_equality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, j)</code></pre><p>evaluate the <code>j</code>th equality constraint <span>$(h(p))_j$</span> or <span>$h_j(p)$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> representation this still evaluates all constraints.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L307-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_equality_constraints" href="#Manopt.get_equality_constraints"><code>Manopt.get_equality_constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_equality_constraints(M::AbstractManifold, co::ConstrainedManifoldObjective, p)</code></pre><p>evaluate all equality constraints <span>$h(p)$</span> of <span>$\bigl(h_1(p), h_2(p),\ldots,h_p(p)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <span>$P$</span> at <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L281-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_inequality_constraint" href="#Manopt.get_inequality_constraint"><code>Manopt.get_inequality_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_inequality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, i)</code></pre><p>evaluate one equality constraint <span>$(g(p))_i$</span> or <span>$g_i(p)$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> representation this still evaluates all constraints.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L363-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_inequality_constraints" href="#Manopt.get_inequality_constraints"><code>Manopt.get_inequality_constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_inequality_constraints(M::AbstractManifold, co::ConstrainedManifoldObjective, p)</code></pre><p>Evaluate all inequality constraints <span>$g(p)$</span> or <span>$\bigl(g_1(p), g_2(p),\ldots,g_m(p)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <span>$P$</span> at <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L335-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_grad_equality_constraint" href="#Manopt.get_grad_equality_constraint"><code>Manopt.get_grad_equality_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_equality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, j)</code></pre><p>evaluate the gradient of the <code>j</code> th equality constraint <span>$(\operatorname{grad} h(p))_j$</span> or <span>$\operatorname{grad} h_j(x)$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem, this function still evaluates the full gradient. For the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> and <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> of the problem, this function currently also calls <a href="#Manopt.get_equality_constraints"><code>get_equality_constraints</code></a>, since this is the only way to determine the number of cconstraints. It also allocates a full tangent vector.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L391-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_grad_equality_constraints" href="#Manopt.get_grad_equality_constraints"><code>Manopt.get_grad_equality_constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_equality_constraints(M::AbstractManifold, co::ConstrainedManifoldObjective, p)</code></pre><p>eevaluate all gradients of the equality constraints <span>$\operatorname{grad} h(x)$</span> or <span>$\bigl(\operatorname{grad} h_1(x), \operatorname{grad} h_2(x),\ldots, \operatorname{grad}h_n(x)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>P</code> at <code>p</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>for the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> and <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem,    this function currently also calls <a href="#Manopt.get_equality_constraints"><code>get_equality_constraints</code></a>,    since this is the only way to determine the number of cconstraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L511-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_grad_equality_constraints!" href="#Manopt.get_grad_equality_constraints!"><code>Manopt.get_grad_equality_constraints!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_equality_constraints!(M::AbstractManifold, X, co::ConstrainedManifoldObjective, p)</code></pre><p>evaluate all gradients of the equality constraints <span>$\operatorname{grad} h(p)$</span> or <span>$\bigl(\operatorname{grad} h_1(p), \operatorname{grad} h_2(p),\ldots,\operatorname{grad} h_n(p)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <span>$P$</span> at <span>$p$</span> in place of <code>X</code><code>, which is a vector of</code><code>n</code>` tangent vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L564-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_grad_equality_constraint!" href="#Manopt.get_grad_equality_constraint!"><code>Manopt.get_grad_equality_constraint!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_equality_constraint!(M::AbstractManifold, X, co::ConstrainedManifoldObjective, p, j)</code></pre><p>Evaluate the gradient of the <code>j</code>th equality constraint <span>$(\operatorname{grad} h(x))_j$</span> or <span>$\operatorname{grad} h_j(x)$</span> in place of <span>$X$</span></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem, this function still evaluates the full gradient. For the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> of the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> of the problem, this function currently also calls <a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a>, since this is the only way to determine the number of cconstraints and allocates a full vector of tangent vectors</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L447-L456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_grad_inequality_constraint" href="#Manopt.get_grad_inequality_constraint"><code>Manopt.get_grad_inequality_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_inequality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, i)</code></pre><p>Evaluate the gradient of the <code>i</code> th inequality constraints <span>$(\operatorname{grad} g(x))_i$</span> or <span>$\operatorname{grad} g_i(x)$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem, this function still evaluates the full gradient. For the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> and <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> of the problem, this function currently also calls <a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a>, since this is the only way to determine the number of cconstraints.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L619-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_grad_inequality_constraint!" href="#Manopt.get_grad_inequality_constraint!"><code>Manopt.get_grad_inequality_constraint!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_inequality_constraint!(P, X, p, i)</code></pre><p>Evaluate the gradient of the <code>i</code>th inequality constraints <span>$(\operatorname{grad} g(x))_i$</span> or <span>$\operatorname{grad} g_i(x)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>P</code> in place of <span>$X$</span></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem, this function still evaluates the full gradient. For the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> and <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> of the problem, this function currently also calls <a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a>,</p></div></div><p>since this is the only way to determine the number of cconstraints. evaluate all gradients of the inequality constraints <span>$\operatorname{grad} h(x)$</span> or <span>$\bigl(g_1(x), g_2(x),\ldots,g_m(x)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <span>$p$</span> at <span>$x$</span> in place of <code>X</code><code>, which is a vector of</code><code>m</code>` tangent vectors .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L675-L687">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_grad_inequality_constraints" href="#Manopt.get_grad_inequality_constraints"><code>Manopt.get_grad_inequality_constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_inequality_constraints(M::AbstractManifold, co::ConstrainedManifoldObjective, p)</code></pre><p>evaluate all gradients of the inequality constraints <span>$\operatorname{grad} g(p)$</span> or <span>$\bigl(\operatorname{grad} g_1(p), \operatorname{grad} g_2(p),…,\operatorname{grad} g_m(p)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <span>$P$</span> at <span>$p$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>for the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> and <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem,    this function currently also calls <a href="#Manopt.get_equality_constraints"><code>get_equality_constraints</code></a>,    since this is the only way to determine the number of cconstraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L739-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_grad_inequality_constraints!" href="#Manopt.get_grad_inequality_constraints!"><code>Manopt.get_grad_inequality_constraints!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_inequality_constraints!(M::AbstractManifold, X, co::ConstrainedManifoldObjective, p)</code></pre><p>evaluate all gradients of the inequality constraints <span>$\operatorname{grad} g(x)$</span> or <span>$\bigl(\operatorname{grad} g_1(x), \operatorname{grad} g_2(x),\ldots,\operatorname{grad} g_m(x)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>P</code> at <code>p</code> in place of <code>X</code>, which is a vector of <span>$m$</span> tangent vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/constrained_plan.jl#L792-L797">source</a></section></article><h2 id="Decorators-for-AbstractManoptSolverState"><a class="docs-heading-anchor" href="#Decorators-for-AbstractManoptSolverState">Decorators for AbstractManoptSolverState</a><a id="Decorators-for-AbstractManoptSolverState-1"></a><a class="docs-heading-anchor-permalink" href="#Decorators-for-AbstractManoptSolverState" title="Permalink"></a></h2><p>An objective can be decorated using the following trait and function to initialize</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.dispatch_objective_decorator" href="#Manopt.dispatch_objective_decorator"><code>Manopt.dispatch_objective_decorator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dispatch_objective_decorator(o::AbstractManoptSolverState)</code></pre><p>Indicate internally, whether an <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>o</code> to be of decorating type, i.e. it stores (encapsulates) an object in itself, by default in the field <code>o.objective</code>.</p><p>Decorators indicate this by returning <code>Val{true}</code> for further dispatch.</p><p>The default is <code>Val{false}</code>, i.e. by default an state is not decorated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/objective.jl#L69-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.is_objective_decorator" href="#Manopt.is_objective_decorator"><code>Manopt.is_objective_decorator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_object_decorator(s::AbstractManifoldObjective)</code></pre><p>Indicate, whether <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>s</code> are of decorator type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/objective.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.decorate_objective!" href="#Manopt.decorate_objective!"><code>Manopt.decorate_objective!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decorate_objective!(M, o::AbstractManifoldObjective)</code></pre><p>decorate the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a><code>o</code> with specific decorators.</p><p><strong>Optional Arguments</strong></p><p>optional arguments provide necessary details on the decorators. A specific one is used to activate certain decorators.</p><ul><li><code>cache</code> – (<code>missing</code>) specify a cache. Currenlty <code>:Simple</code> is supported and <code>:LRU</code> if you load <code>LRUCache.jl</code>. For this case a tuple specifying what to cache and how many can be provided, i.e. <code>(:LRU, [:Cost, :Gradient], 10)</code>, where the number specifies the size of each cache. and 10 is the default if one omits the last tuple entry</li><li><code>count</code> – (<code>missing</code>) specify calls to the objective to be called, see <a href="#Manopt.ManifoldCountObjective"><code>ManifoldCountObjective</code></a> for the full list</li></ul><p>other keywords are ignored.</p><p><strong>See also</strong></p><p><a href="#Manopt.objective_cache_factory"><code>objective_cache_factory</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/solvers/solver.jl#L57-L78">source</a></section></article><h3 id="CacheSection"><a class="docs-heading-anchor" href="#CacheSection">Cache Objective</a><a id="CacheSection-1"></a><a class="docs-heading-anchor-permalink" href="#CacheSection" title="Permalink"></a></h3><p>Since single function calls, e.g. to the cost or the gradient, might be expensive, a simple cache objective exists as a decorator, that caches one cost value or gradient.</p><p>It can be activated/used with the <code>cache=</code> keyword argument available for every solver.</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.reset_counters!" href="#Manopt.reset_counters!"><code>Manopt.reset_counters!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_counters(co::ManifoldCountObjective, value::Integer=0)</code></pre><p>Reset all values in the count objective to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/count.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.objective_cache_factory" href="#Manopt.objective_cache_factory"><code>Manopt.objective_cache_factory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">objective_cache_factory(M::AbstractManifold, o::AbstractManifoldObjective, cache::Symbol)</code></pre><p>Generate a cached variant of the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>o</code> on the <code>AbstractManifold M</code> based on the symbol <code>cache</code>.</p><p>The following caches are available</p><ul><li><code>:Simple</code> generates a <a href="#Manopt.SimpleManifoldCachedObjective"><code>SimpleManifoldCachedObjective</code></a></li><li><code>:LRU</code> generates a <a href="#Manopt.ManifoldCachedObjective"><code>ManifoldCachedObjective</code></a> where you should use the form <code>(:LRU, [:Cost, :Gradient])</code> to specify what should be cached or <code>(:LRU, [:Cost, :Gradient], 100)</code> to specify the cache size. Here this variant defaults to <code>(:LRU, [:Cost, :Gradient], 100)</code>, i.e. to cache up to 100 cost and gradient values.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/cache.jl#L736-L753">source</a></section><section><div><pre><code class="nohighlight hljs">objective_cache_factory(M::AbstractManifold, o::AbstractManifoldObjective, cache::Tuple{Symbol, Array, Array})
objective_cache_factory(M::AbstractManifold, o::AbstractManifoldObjective, cache::Tuple{Symbol, Array})</code></pre><p>Generate a cached variant of the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>o</code> on the <code>AbstractManifold M</code> based on the symbol <code>cache[1]</code>, where the second element <code>cache[2]</code> are further arguments to the cache and the optional third is passed down as keyword arguments.</p><p>For all available caches see the simpler variant with symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/cache.jl#L761-L771">source</a></section></article><h4 id="A-simple-cache"><a class="docs-heading-anchor" href="#A-simple-cache">A simple cache</a><a id="A-simple-cache-1"></a><a class="docs-heading-anchor-permalink" href="#A-simple-cache" title="Permalink"></a></h4><p>A first generic cache is always available, but it only caches one gradient and one cost function evaluation (for the same point).</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.SimpleManifoldCachedObjective" href="#Manopt.SimpleManifoldCachedObjective"><code>Manopt.SimpleManifoldCachedObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> SimpleManifoldCachedObjective{O&lt;:AbstractManifoldGradientObjective{E,TC,TG}, P, T,C} &lt;: AbstractManifoldGradientObjective{E,TC,TG}</code></pre><p>Provide a simple cache for an <a href="#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective</code></a> that is for a given point <code>p</code> this cache stores a point <code>p</code> and a gradient <span>$\operatorname{grad} f(p)$</span> in <code>X</code> as well as a cost value <span>$f(p)$</span> in <code>c</code>.</p><p>Both <code>X</code> and <code>c</code> are accompanied by booleans to keep track of their validity.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SimpleManifoldCachedObjective(M::AbstractManifold, obj::AbstractManifoldGradientObjective; kwargs...)</code></pre><p><strong>Keyword</strong></p><ul><li><code>p</code> (<code>rand(M)</code>) – a point on the manifold to initialize the cache with</li><li><code>X</code> (<code>get_gradient(M, obj, p)</code> or <code>zero_vector(M,p)</code>) – a tangent vector to store the gradient in, see also <code>initialize</code></li><li><code>c</code> (<code>get_cost(M, obj, p)</code> or <code>0.0</code>) – a value to store the cost function in <code>initialize</code></li><li><code>initialized</code> (<code>true</code>) – whether to initialize the cached <code>X</code> and <code>c</code> or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/cache.jl#L4-L21">source</a></section></article><h4 id="A-Generic-Cache"><a class="docs-heading-anchor" href="#A-Generic-Cache">A Generic Cache</a><a id="A-Generic-Cache-1"></a><a class="docs-heading-anchor-permalink" href="#A-Generic-Cache" title="Permalink"></a></h4><p>For the more advanced cache, you need to implement some type of cache yourself, that provides a <code>get!</code> and implement <a href="#Manopt.init_caches"><code>init_caches</code></a>. This is for example provided if you load <a href="https://github.com/JuliaCollections/LRUCache.jl"><code>LRUCache.jl</code></a>. Then you obtain</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.ManifoldCachedObjective" href="#Manopt.ManifoldCachedObjective"><code>Manopt.ManifoldCachedObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldCachedObjective{E,P,O&lt;:AbstractManifoldObjective{&lt;:E},C&lt;:NamedTuple{}} &lt;: AbstractDecoratedManifoldObjective{E,P}</code></pre><p>Create a cache for an objective, based on a <code>NamedTuple</code> that stores some kind of cache.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldCachedObjective(M, o::AbstractManifoldObjective, caches::Vector{Symbol}; kwargs...)</code></pre><p>Create a cache for the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> where the Symbols in <code>caches</code> indicate, which function evaluations to cache.</p><p><strong>Supported Symbols</strong></p><table><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Caches calls to (incl. <code>!</code> variants)</th><th style="text-align: left">Comment</th></tr><tr><td style="text-align: left"><code>:Constraints</code></td><td style="text-align: left"><a href="#Manopt.get_constraints"><code>get_constraints</code></a></td><td style="text-align: left">vector of numbers</td></tr><tr><td style="text-align: left"><code>:Cost</code></td><td style="text-align: left"><a href="#Manopt.get_cost"><code>get_cost</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:EqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraint"><code>get_equality_constraint</code></a></td><td style="text-align: left">numbers per (p,i)</td></tr><tr><td style="text-align: left"><code>:EqualityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraints"><code>get_equality_constraints</code></a></td><td style="text-align: left">vector of numbers</td></tr><tr><td style="text-align: left"><code>:GradEqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_grad_equality_constraint"><code>get_grad_equality_constraint</code></a></td><td style="text-align: left">tangent vector per (p,i)</td></tr><tr><td style="text-align: left"><code>:GradEqualityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_grad_equality_constraints"><code>get_grad_equality_constraints</code></a></td><td style="text-align: left">vector of tangent vectors</td></tr><tr><td style="text-align: left"><code>:GradInequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">tangent vector per (p,i)</td></tr><tr><td style="text-align: left"><code>:GradInequalityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a></td><td style="text-align: left">vector of tangent vectors</td></tr><tr><td style="text-align: left"><code>:Gradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M,p)</code></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:Hessian</code></td><td style="text-align: left"><a href="#Manopt.get_hessian"><code>get_hessian</code></a></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:InequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">numbers per (p,j)</td></tr><tr><td style="text-align: left"><code>:InequalityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a></td><td style="text-align: left">vector of numbers</td></tr><tr><td style="text-align: left"><code>:Preconditioner</code></td><td style="text-align: left"><a href="#Manopt.get_preconditioner"><code>get_preconditioner</code></a></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:ProximalMap</code></td><td style="text-align: left"><a href="#Manopt.get_proximal_map"><code>get_proximal_map</code></a></td><td style="text-align: left">point per <code>(p,λ,i)</code></td></tr><tr><td style="text-align: left"><code>:StochasticGradients</code></td><td style="text-align: left"><a href="#Manopt.get_gradients"><code>get_gradients</code></a></td><td style="text-align: left">vector of tangent vectors</td></tr><tr><td style="text-align: left"><code>:StochasticGradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M, p, i)</code></td><td style="text-align: left">tangent vector per (p,i)</td></tr><tr><td style="text-align: left"><code>:SubGradient</code></td><td style="text-align: left"><a href="#Manopt.get_subgradient"><code>get_subgradient</code></a></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:SubtrahendGradient</code></td><td style="text-align: left"><a href="../../solvers/difference_of_convex/#Manopt.get_subtrahend_gradient"><code>get_subtrahend_gradient</code></a></td><td style="text-align: left">tangent vectors</td></tr></table><p><strong>Keyword Arguments</strong></p><ul><li><code>p</code>           - (<code>rand(M)</code>) the type of the keys to be used in the caches. Defaults to the default representation on <code>M</code>.</li><li><code>value</code>       - (<code>get_cost(M, objective, p)</code>) the type of values for numeric values in the cache, e.g. the cost</li><li><code>X</code>           - (<code>zero_vector(M,p)</code>) the type of values to be cached for gradient and Hessian calls.</li><li><code>cache</code>       - (<code>[:Cost]</code>) a vector of symbols indicating which function calls should be cached.</li><li><code>cache_size</code>  - (<code>10</code>) number of (least recently used) calls to cache</li><li><code>cache_sizes</code> – (<code>Dict{Symbol,Int}()</code>) a named tuple or dictionary specifying the sizes individually for each cache.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/cache.jl#L192-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.init_caches" href="#Manopt.init_caches"><code>Manopt.init_caches</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_caches(M::AbstractManifold, caches, T; kwargs...)</code></pre><p>Given a vector of symbols <code>caches</code>, this function sets up the <code>NamedTuple</code> of caches for points/vectors on <code>M</code>, where <code>T</code> is the type of cache to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/cache.jl#L274-L280">source</a></section></article><h3 id="ManifoldCountObjective"><a class="docs-heading-anchor" href="#ManifoldCountObjective">Count Objective</a><a id="ManifoldCountObjective-1"></a><a class="docs-heading-anchor-permalink" href="#ManifoldCountObjective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Manopt.ManifoldCountObjective" href="#Manopt.ManifoldCountObjective"><code>Manopt.ManifoldCountObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldCountObjective{E,P,O&lt;:AbstractManifoldObjective,I&lt;:Integer} &lt;: AbstractDecoratedManifoldObjective{E,P}</code></pre><p>A wrapper for any <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> of type <code>O</code> to count different calls to parts of the objective.</p><p><strong>Fields</strong></p><ul><li><code>counts</code> a dictionary of symbols mapping to integers keeping the counted values</li><li><code>objective</code> the wrapped objective</li></ul><p><strong>Supported Symbols</strong></p><table><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Counts calls to (incl. <code>!</code> variants)</th><th style="text-align: left">Comment</th></tr><tr><td style="text-align: left"><code>:Constraints</code></td><td style="text-align: left"><a href="#Manopt.get_constraints"><code>get_constraints</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:Cost</code></td><td style="text-align: left"><a href="#Manopt.get_cost"><code>get_cost</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:EqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraint"><code>get_equality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:EqualityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraints"><code>get_equality_constraints</code></a></td><td style="text-align: left">does not count single access</td></tr><tr><td style="text-align: left"><code>:GradEqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_grad_equality_constraint"><code>get_grad_equality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:GradEqualityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_grad_equality_constraints"><code>get_grad_equality_constraints</code></a></td><td style="text-align: left">does not count single access</td></tr><tr><td style="text-align: left"><code>:GradInequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:GradInequalityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a></td><td style="text-align: left">does not count single access</td></tr><tr><td style="text-align: left"><code>:Gradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M,p)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:Hessian</code></td><td style="text-align: left"><a href="#Manopt.get_hessian"><code>get_hessian</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:InequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:InequalityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a></td><td style="text-align: left">does not count single access</td></tr><tr><td style="text-align: left"><code>:Preconditioner</code></td><td style="text-align: left"><a href="#Manopt.get_preconditioner"><code>get_preconditioner</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:ProximalMap</code></td><td style="text-align: left"><a href="#Manopt.get_proximal_map"><code>get_proximal_map</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:StochasticGradients</code></td><td style="text-align: left"><a href="#Manopt.get_gradients"><code>get_gradients</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:StochasticGradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M, p, i)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:SubGradient</code></td><td style="text-align: left"><a href="#Manopt.get_subgradient"><code>get_subgradient</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:SubtrahendGradient</code></td><td style="text-align: left"><a href="../../solvers/difference_of_convex/#Manopt.get_subtrahend_gradient"><code>get_subtrahend_gradient</code></a></td><td style="text-align: left"></td></tr></table><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldCountObjective(objective::AbstractManifoldObjective, counts::Dict{Symbol, &lt;:Integer})</code></pre><p>Initialise the <code>ManifoldCountObjective</code> to wrap <code>objective</code> initializing the set of counts</p><pre><code class="nohighlight hljs">ManifoldCountObjective(M::AbtractManifold, objective::AbstractManifoldObjective, count::AbstractVecor{Symbol}, init=0)</code></pre><p>Count function calls on <code>objective</code> using the symbols in <code>count</code> initialising all entries to <code>init</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/count.jl#L1-L44">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020"><a class="tag is-link" href="#citeref-BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020">BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020</a><blockquote><p>R. Bergmann, R. Herzog, M. Silva Louzeiro, D. Tenbrinck, J. Vidal-Núñez: <em>Fenchel Duality Theory and a Primal-Dual Algorithm on Riemannian Manifolds</em>, Foundations of Computational Mathematics, 2021. doi: <a href="http://dx.doi.org/10.1007/s10208-020-09486-5">10.1007/s10208-020-09486-5</a> arXiv: <a href="http://arxiv.org/abs/1908.02022">1908.02022</a></p></blockquote></li><li class="footnote" id="footnote-ChambollePock2011"><a class="tag is-link" href="#citeref-ChambollePock2011">ChambollePock2011</a><blockquote><p>A. Chambolle, T. Pock: <em>A first-order primal-dual algorithm for convex problems with applications to imaging</em>, Journal of Mathematical Imaging and Vision 40(1), 120–145, 2011. doi: <a href="https://dx.doi.org/10.1007/s10851-010-0251-1">10.1007/s10851-010-0251-1</a></p></blockquote></li><li class="footnote" id="footnote-DiepeveenLellmann2021"><a class="tag is-link" href="#citeref-DiepeveenLellmann2021">DiepeveenLellmann2021</a><blockquote><p>W. Diepeveen, J. Lellmann: <em>An Inexact Semismooth Newton Method on Riemannian Manifolds with Application to Duality-Based Total Variation Denoising</em>, SIAM Journal on Imaging Sciences, 2021. doi: <a href="https://doi.org/10.1137/21M1398513">10.1137/21M1398513</a></p></blockquote></li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>This cache requires <a href="https://github.com/JuliaCollections/LRUCache.jl"><code>LRUCache.jl</code></a> to be loaded as well.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problem/">« Problem</a><a class="docs-footer-nextpage" href="../state/">Solver State »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 12 July 2023 12:25">Wednesday 12 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
