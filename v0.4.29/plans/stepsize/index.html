<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stepsize · Manopt.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/Optimize!/">Get started: Optimize!</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using Inplace computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use Automatic Differentiation</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a Cache</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a Solver</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do Contrained Optimization</a></li><li><a class="tocitem" href="../../tutorials/GeodesicRegression/">Do Geodesic Regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">Introduction</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas–Rachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg–Marquardt</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder–Mead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../">Specify a Solver</a></li><li><a class="tocitem" href="../problem/">Problem</a></li><li><a class="tocitem" href="../objective/">Objective</a></li><li><a class="tocitem" href="../state/">Solver State</a></li><li class="is-active"><a class="tocitem" href>Stepsize</a></li><li><a class="tocitem" href="../stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../debug/">Debug Output</a></li><li><a class="tocitem" href="../record/">Recording values</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../functions/">Introduction</a></li><li><a class="tocitem" href="../../functions/bezier/">Bézier curves</a></li><li><a class="tocitem" href="../../functions/costs/">Cost functions</a></li><li><a class="tocitem" href="../../functions/differentials/">Differentials</a></li><li><a class="tocitem" href="../../functions/adjointdifferentials/">Adjoint Differentials</a></li><li><a class="tocitem" href="../../functions/gradients/">Gradients</a></li><li><a class="tocitem" href="../../functions/proximal_maps/">Proximal Maps</a></li><li><a class="tocitem" href="../../functions/manifold/">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/data/">Data</a></li><li><a class="tocitem" href="../../helpers/errorMeasures/">Error Measures</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../list/">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plans</a></li><li class="is-active"><a href>Stepsize</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stepsize</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/plans/stepsize.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Stepsize"><a class="docs-heading-anchor" href="#Stepsize">Stepsize and Linesearch</a><a id="Stepsize-1"></a><a class="docs-heading-anchor-permalink" href="#Stepsize" title="Permalink"></a></h1><p>Most iterative algorithms determine a direction along which the algorithm will proceed and determine a step size to find the next iterate. How advanced the step size computation can be implemented depends (among others) on the properties the corresponding problem provides.</p><p>Within <code>Manopt.jl</code>, the step size determination is implemented as a <code>functor</code> which is a subtype of [<code>Stepsize</code>](@refbased on</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.Stepsize" href="#Manopt.Stepsize"><code>Manopt.Stepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Stepsize</code></pre><p>An abstract type for the functors representing step sizes, i.e. they are callable structures. The naming scheme is <code>TypeOfStepSize</code>, e.g. <code>ConstantStepsize</code>.</p><p>Every Stepsize has to provide a constructor and its function has to have the interface <code>(p,o,i)</code> where a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> as well as <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> and the current number of iterations are the arguments and returns a number, namely the stepsize to use.</p><p><strong>See also</strong></p><p><a href="#Manopt.Linesearch"><code>Linesearch</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L1-L15">source</a></section></article><p>Usually, a constructor should take the manifold <code>M</code> as its first argument, for consistency, to allow general step size functors to be set up based on default values that might depend on the manifold currently under consideration.</p><p>Currently, the following step sizes are available</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.AdaptiveWNGradient" href="#Manopt.AdaptiveWNGradient"><code>Manopt.AdaptiveWNGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdaptiveWNGradient &lt;: DirectionUpdateRule</code></pre><p>Represent an adaptive gradient method introduced by <sup class="footnote-reference"><a id="citeref-GrapigliaStella2023" href="#footnote-GrapigliaStella2023">[GrapigliaStella2023]</a></sup>.</p><p>Given a positive threshold <span>$\hat c \mathbb N$</span>, an minimal bound <span>$b_{\mathrm{min}} &gt; 0$</span>, an initial <span>$b_0 ≥ b_{\mathrm{min}}$</span>, and a gradient reduction factor threshold ``\alpha \in [0,1).</p><p>Set <span>$c_0=0$</span> and use <span>$\omega_0 = \lVert \operatorname{grad} f(p_0) \rvert_{p_0}$</span>.</p><p>For the first iterate we use the initial step size <span>$s_0 = \frac{1}{b_0}$</span></p><p>Then, given the last gradient <span>$X_{k-1} = \operatorname{grad} f(x_{k-1})$</span>, and a previous <span>$\omega_{k-1}$</span>, the values <span>$(b_k, \omega_k, c_k)$</span> are computed using <span>$X_k = \operatorname{grad} f(p_k)$</span> and the following cases</p><p>If <span>$\lVert X_k \rVert_{p_k} \leq \alpha\omega_{k-1}$</span>, then let <span>$\hat b_{k-1} \in [b_\mathrm{min},b_{k-1}]$</span> and set</p><p class="math-container">\[(b_k, \omega_k, c_k) = \begin{cases}
\bigl(\hat b_{k-1}, \lVert X_k\rVert_{p_k}, 0 \bigr) &amp; \text{ if } c_{k-1}+1 = \hat c\\
\Bigl(b_{k-1} + \frac{\lVert X_k\rVert_{p_k}^2}{b_{k-1}}, \omega_{k-1}, c_{k-1}+1 \Bigr) &amp; \text{ if } c_{k-1}+1&lt;\hat c
\end{cases}\]</p><p>If <span>$\lVert X_k \rVert_{p_k} &gt; \alpha\omega_{k-1}$</span>, the set</p><p class="math-container">\[(b_k, \omega_k, c_k) =
\Bigl( b_{k-1} + \frac{\lVert X_k\rVert_{p_k}^2}{b_{k-1}}, \omega_{k-1}, 0)\]</p><p>and return the step size <span>$s_k = \frac{1}{b_k}$</span>.</p><p>Note that for <span>$α=0$</span> this is the Riemannian variant of WNGRad</p><p><strong>Fields</strong></p><ul><li><code>count_threshold::Int</code> (<code>4</code>) an <code>Integer</code> for <span>$\hat c$</span></li><li><code>minimal_bound::Float64</code> (<code>1e-4</code>) for <span>$b_{\mathrm{min}}$</span></li><li><code>alternate_bound::Function</code> (<code>(bk, hat_c) -&gt; min(gradient_bound, max(gradient_bound, bk/(3*hat_c)</code>) how to determine <span>$\hat b_k$</span> as a function of <code>(bmin, bk, hat_c) -&gt; hat_bk</code></li><li><code>gradient_reduction::Float64</code> (<code>0.9</code>)</li><li><code>gradient_bound</code> <code>norm(M, p0, grad_f(M,p0))</code> the bound <span>$b_k$</span>.</li></ul><p>as well as the internal fields</p><ul><li><code>weight</code> for <span>$ω_k$</span> initialised to <span>$ω_0 =$</span><code>norm(M, p0, grad_f(M,p0))</code> if this is not zero, <code>1.0</code> otherwise.</li><li><code>count</code> for the <span>$c_k$</span>, initialised to <span>$c_0 = 0$</span>.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">AdaptiveWNGrad(M=DefaultManifold, grad_f=(M,p) -&gt; zero_vector(M,rand(M)), p=rand(M); kwargs...)</code></pre><p>Where all above fields with defaults are keyword arguments. An additional keyword arguments</p><ul><li><code>adaptive</code> (<code>true</code>) switches the <code>gradient_reduction</code><code>α</code><code>to</code>0`.</li><li><code>evaluation</code> (<code>AllocatingEvaluation()</code>) specifies whether the gradient (that is used for initialisation only) is mutating or allocating</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L961-L1029">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.ArmijoLinesearch" href="#Manopt.ArmijoLinesearch"><code>Manopt.ArmijoLinesearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArmijoLinesearch &lt;: Linesearch</code></pre><p>A functor representing Armijo line search including the last runs state, i.e. a last step size.</p><p><strong>Fields</strong></p><ul><li><code>initial_stepsize</code>    – (<code>1.0</code>) and initial step size</li><li><code>retraction_method</code>   – (<code>default_retraction_method(M)</code>) the rectraction to use</li><li><code>contraction_factor</code>  – (<code>0.95</code>) exponent for line search reduction</li><li><code>sufficient_decrease</code> – (<code>0.1</code>) gain within Armijo&#39;s rule</li><li><code>last_stepsize</code>       – (<code>initialstepsize</code>) the last step size we start the search with</li><li><code>initial_guess</code>       - (<code>(p,s,i,l) -&gt; l</code>)  based on a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>p</code>, <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>s</code> and a current iterate <code>i</code> and a last step size <code>l</code>, this returns an initial guess. The default uses the last obtained stepsize</li></ul><p>Furthermore the following fields act as safeguards</p><ul><li><code>stop_when_stepsize_less    - (</code>0.0`) smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_when_stepsize_exceeds - ([</code>max_stepsize<code>](@ref)</code>(M, p)`) – largest stepsize when to stop.</li><li><code>stop_increasing_at_step</code>   - (^100`) last step to increase the stepsize (phase 1),</li><li><code>stop_decreasing_at_step</code>   - (<code>1000</code>) last step size to decrese the stepsize (phase 2),</li></ul><p>Pass <code>:Messages</code> to a <code>debug=</code> to see <code>@info</code>s when these happen.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ArmijoLinesearch(M=DefaultManifold())</code></pre><p>with the Fields above as keyword arguments and the retraction is set to the default retraction on <code>M</code>.</p><p>The constructors return the functor to perform Armijo line search, where two interfaces are available:</p><ul><li>based on a tuple <code>(amp, ams, i)</code> of a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>, <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> and a current iterate <code>i</code>.</li><li>with <code>(M, x, F, gradFx[,η=-gradFx]) -&gt; s</code> where <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/interface.html#Manifold">Manifold</a> <code>M</code>, a current point <code>x</code> a function <code>F</code>, that maps from the manifold to the reals, its gradient (a tangent vector) <code>gradFx</code><span>$=\operatorname{grad}F(x)$</span> at  <code>x</code> and an optional search direction tangent vector <code>η=-gradFx</code> are the arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L169-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.ConstantStepsize" href="#Manopt.ConstantStepsize"><code>Manopt.ConstantStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantStepsize &lt;: Stepsize</code></pre><p>A functor that always returns a fixed step size.</p><p><strong>Fields</strong></p><ul><li><code>length</code> – constant value for the step size.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConstantStepsize(s::Real)</code></pre><p>initialize the stepsize to a constant <code>s</code>.</p><pre><code class="nohighlight hljs">ConstantStepsize(M::AbstractManifold=DefaultManifold(2); stepsize=injectivity_radius(M)/2)</code></pre><p>initialize the stepsize to a constant <code>stepsize</code>, which by default is half the injectivity radius, unless the radius is infinity, then the default step size is <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L42-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DecreasingStepsize" href="#Manopt.DecreasingStepsize"><code>Manopt.DecreasingStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DecreasingStepsize()</code></pre><p>A functor that represents several decreasing step sizes</p><p><strong>Fields</strong></p><ul><li><code>length</code> – (<code>1</code>) the initial step size <span>$l$</span>.</li><li><code>factor</code> – (<code>1</code>) a value <span>$f$</span> to multiply the initial step size with every iteration</li><li><code>subtrahend</code> – (<code>0</code>) a value <span>$a$</span> that is subtracted every iteration</li><li><code>exponent</code> – (<code>1</code>) a value <span>$e$</span> the current iteration numbers <span>$e$</span>th exponential is taken of</li><li><code>shift</code> – (<code>0</code>) shift the denominator iterator <span>$i$</span> by <span>$s$</span>`.</li></ul><p>In total the complete formulae reads for the <span>$i$</span>th iterate as</p><p class="math-container">\[s_i = \frac{(l - i a)f^i}{(i+s)^e}\]</p><p>and hence the default simplifies to just <span>$s_i = \frac{l}{i}$</span></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DecreasingStepsize(l=1,f=1,a=0,e=1,s=0)</code></pre><p>Alternatively one can also use the following keyword.</p><pre><code class="nohighlight hljs">DecreasingStepsize(
    M::AbstractManifold=DefaultManifold(3);
    length=injectivity_radius(M)/2, multiplier=1.0, subtrahend=0.0, exponent=1.0, shift=0)</code></pre><p>initialiszes all fields above, where none of them is mandatory and the length is set to half and to <span>$1$</span> if the injectivity radius is infinite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L78-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.Linesearch" href="#Manopt.Linesearch"><code>Manopt.Linesearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Linesearch &lt;: Stepsize</code></pre><p>An abstract functor to represent line search type step size deteminations, see <a href="#Manopt.Stepsize"><code>Stepsize</code></a> for details. One example is the <a href="#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a> functor.</p><p>Compared to simple step sizes, the linesearch functors provide an interface of the form <code>(p,o,i,η) -&gt; s</code> with an additional (but optional) fourth parameter to provide a search direction; this should default to something reasonable, e.g. the negative gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L144-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.NonmonotoneLinesearch" href="#Manopt.NonmonotoneLinesearch"><code>Manopt.NonmonotoneLinesearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonmonotoneLinesearch &lt;: Linesearch</code></pre><p>A functor representing a nonmonotone line search using the Barzilai-Borwein step size<sup class="footnote-reference"><a id="citeref-Iannazzo2018" href="#footnote-Iannazzo2018">[Iannazzo2018]</a></sup>. Together with a gradient descent algorithm this line search represents the Riemannian Barzilai-Borwein with nonmonotone line-search (RBBNMLS) algorithm. We shifted the order of the algorithm steps from the paper by Iannazzo and Porcelli so that in each iteration we first find</p><p class="math-container">\[y_{k} = \operatorname{grad}F(x_{k}) - \operatorname{T}_{x_{k-1} → x_k}(\operatorname{grad}F(x_{k-1}))\]</p><p>and</p><p class="math-container">\[s_{k} = - α_{k-1} * \operatorname{T}_{x_{k-1} → x_k}(\operatorname{grad}F(x_{k-1})),\]</p><p>where <span>$α_{k-1}$</span> is the step size computed in the last iteration and <span>$\operatorname{T}$</span> is a vector transport. We then find the Barzilai–Borwein step size</p><p class="math-container">\[α_k^{\text{BB}} = \begin{cases}
\min(α_{\text{max}}, \max(α_{\text{min}}, τ_{k})),  &amp; \text{if } ⟨s_{k}, y_{k}⟩_{x_k} &gt; 0,\\
α_{\text{max}}, &amp; \text{else,}
\end{cases}\]</p><p>where</p><p class="math-container">\[τ_{k} = \frac{⟨s_{k}, s_{k}⟩_{x_k}}{⟨s_{k}, y_{k}⟩_{x_k}},\]</p><p>if the direct strategy is chosen,</p><p class="math-container">\[τ_{k} = \frac{⟨s_{k}, y_{k}⟩_{x_k}}{⟨y_{k}, y_{k}⟩_{x_k}},\]</p><p>in case of the inverse strategy and an alternation between the two in case of the alternating strategy. Then we find the smallest <span>$h = 0, 1, 2, …$</span> such that</p><p class="math-container">\[F(\operatorname{retr}_{x_k}(- σ^h α_k^{\text{BB}} \operatorname{grad}F(x_k)))
\leq
\max_{1 ≤ j ≤ \min(k+1,m)} F(x_{k+1-j}) - γ σ^h α_k^{\text{BB}} ⟨\operatorname{grad}F(x_k), \operatorname{grad}F(x_k)⟩_{x_k},\]</p><p>where <span>$σ$</span> is a step length reduction factor <span>$∈ (0,1)$</span>, <span>$m$</span> is the number of iterations after which the function value has to be lower than the current one and <span>$γ$</span> is the sufficient decrease parameter <span>$∈(0,1)$</span>. We can then find the new stepsize by</p><p class="math-container">\[α_k = σ^h α_k^{\text{BB}}.\]</p><p><strong>Fields</strong></p><ul><li><code>initial_stepsize</code> – (<code>1.0</code>) the step size we start the search with</li><li><code>memory_size</code> – (<code>10</code>) number of iterations after which the cost value needs to be lower than the current one</li><li><code>bb_min_stepsize</code> – (<code>1e-3</code>) lower bound for the Barzilai-Borwein step size greater than zero</li><li><code>bb_max_stepsize</code> – (<code>1e3</code>) upper bound for the Barzilai-Borwein step size greater than min_stepsize</li><li><code>retraction_method</code> – (<code>ExponentialRetraction()</code>) the rectraction to use</li><li><code>strategy</code> – (<code>direct</code>) defines if the new step size is computed using the direct, indirect or alternating strategy</li><li><code>storage</code> – (for <code>:Iterate</code> and <code>:Gradient</code>) a <a href="../state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a></li><li><code>stepsize_reduction</code> – (<code>0.5</code>) step size reduction factor contained in the interval (0,1)</li><li><code>sufficient_decrease</code> – (<code>1e-4</code>) sufficient decrease parameter contained in the interval (0,1)</li><li><code>vector_transport_method</code> – (<code>ParallelTransport()</code>) the vector transport method to use</li></ul><p>Furthermore the following fields act as safeguards</p><ul><li><code>stop_when_stepsize_less    - (</code>0.0`) smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_when_stepsize_exceeds - ([</code>max_stepsize<code>](@ref)</code>(M, p)`) – largest stepsize when to stop.</li><li><code>stop_increasing_at_step</code>   - (^100`) last step to increase the stepsize (phase 1),</li><li><code>stop_decreasing_at_step</code>   - (<code>1000</code>) last step size to decrese the stepsize (phase 2),</li></ul><p>Pass <code>:Messages</code> to a <code>debug=</code> to see <code>@info</code>s when these happen.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">NonmonotoneLinesearch()</code></pre><p>with the Fields above in their order as optional arguments (deprecated).</p><pre><code class="nohighlight hljs">NonmonotoneLinesearch(M)</code></pre><p>with the Fields above in their order as keyword arguments and where the retraction and vector transport are set to the default ones on <code>M</code>, repsectively.</p><p>The constructors return the functor to perform nonmonotone line search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L382-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.WolfePowellBinaryLinesearch" href="#Manopt.WolfePowellBinaryLinesearch"><code>Manopt.WolfePowellBinaryLinesearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WolfePowellBinaryLinesearch &lt;: Linesearch</code></pre><p>A <a href="#Manopt.Linesearch"><code>Linesearch</code></a> method that determines a step size <code>t</code> fulfilling the Wolfe conditions</p><p>based on a binary chop. Let <span>$η$</span> be a search direction and <span>$c1,c_2&gt;0$</span> be two constants. Then with</p><p class="math-container">\[A(t) = f(x_+) ≤ c1 t ⟨\operatorname{grad}f(x), η⟩_{x}
\quad\text{and}\quad
W(t) = ⟨\operatorname{grad}f(x_+), \text{V}_{x_+\gets x}η⟩_{x_+} ≥ c_2 ⟨η, \operatorname{grad}f(x)⟩_x,\]</p><p>where <span>$x_+ = \operatorname{retr}_x(tη)$</span> is the current trial point, and <span>$\text{V}$</span> is a vector transport, we perform the following Algorithm similar to Algorithm 7 from <sup class="footnote-reference"><a id="citeref-Huang2014" href="#footnote-Huang2014">[Huang2014]</a></sup></p><ol><li>set <span>$α=0$</span>, <span>$β=∞$</span> and <span>$t=1$</span>.</li><li>While either <span>$A(t)$</span> does not hold or <span>$W(t)$</span> does not hold do steps 3-5.</li><li>If <span>$A(t)$</span> fails, set <span>$β=t$</span>.</li><li>If <span>$A(t)$</span> holds but <span>$W(t)$</span> fails, set <span>$α=t$</span>.</li><li>If <span>$β&lt;∞$</span> set <span>$t=\frac{α+β}{2}$</span>, otherwise set <span>$t=2α$</span>.</li></ol><p><strong>Constructors</strong></p><p>There exist two constructors, where, when prodivind the manifold <code>M</code> as a first (optional) parameter, its default retraction and vector transport are the default. In this case the retraction and the vector transport are also keyword arguments for ease of use. The other constructor is kept for backward compatibility.</p><pre><code class="nohighlight hljs">WolfePowellLinesearch(
    M=DefaultManifold(),
    c1::Float64=10^(-4),
    c2::Float64=0.999;
    retraction_method = default_retraction_method(M),
    vector_transport_method = default_vector_transport(M),
    linesearch_stopsize = 0.0
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L836-L878">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.WolfePowellLinesearch" href="#Manopt.WolfePowellLinesearch"><code>Manopt.WolfePowellLinesearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WolfePowellLinesearch &lt;: Linesearch</code></pre><p>Do a backtracking linesearch to find a step size <span>$α$</span> that fulfils the Wolfe conditions along a search direction <span>$η$</span> starting from <span>$x$</span>, i.e.</p><p class="math-container">\[f\bigl( \operatorname{retr}_x(αη) \bigr) ≤ f(x_k) + c_1 α_k ⟨\operatorname{grad}f(x), η⟩_x
\quad\text{and}\quad
\frac{\mathrm{d}}{\mathrm{d}t} f\bigr(\operatorname{retr}_x(tη)\bigr)
\Big\vert_{t=α}
≥ c_2 \frac{\mathrm{d}}{\mathrm{d}t} f\bigl(\operatorname{retr}_x(tη)\bigr)\Big\vert_{t=0}.\]</p><p><strong>Constructors</strong></p><p>There exist two constructors, where, when prodivind the manifold <code>M</code> as a first (optional) parameter, its default retraction and vector transport are the default. In this case the retraction and the vector transport are also keyword arguments for ease of use. The other constructor is kept for backward compatibility. Note that the <code>linesearch_stopsize</code> to stop for too small stepsizes is only available in the new signature including <code>M</code>.</p><pre><code class="nohighlight hljs">WolfePowellLinesearch(
    M,
    c1::Float64=10^(-4),
    c2::Float64=0.999;
    retraction_method = default_retraction_method(M),
    vector_transport_method = default_vector_transport(M),
    linesearch_stopsize = 0.0
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L694-L725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}" href="#Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}"><code>Manopt.default_stepsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_stepsize(M::AbstractManifold, ams::AbstractManoptSolverState)</code></pre><p>Returns the default <a href="#Manopt.Stepsize"><code>Stepsize</code></a> functor used when running the solver specified by the <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> running with an objective on the <code>AbstractManifold M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}" href="#Manopt.get_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}"><code>Manopt.get_stepsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_stepsize(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, vars...)</code></pre><p>return the stepsize stored within <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> when solving the <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>. This method also works for decorated options and the <a href="#Manopt.Stepsize"><code>Stepsize</code></a> function within the options, by default stored in <code>o.stepsize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L1126-L1133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T, Any}} where {TF, T}" href="#Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T, Any}} where {TF, T}"><code>Manopt.linesearch_backtrack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(s, msg) = linesearch_backtrack(
    M, F, x, gradFx, s, decrease, contract, retr, η = -gradFx, f0 = F(x);
    stop_when_stepsize_less=0.0,
    stop_when_stepsize_exceeds=max_stepsize(M, p),
    stop_increasing_at_step = 100,
    stop_decreasing_at_step = 1000,
)</code></pre><p>perform a linesearch for</p><ul><li>a manifold <code>M</code></li><li>a cost function <code>f</code>,</li><li>an iterate <code>p</code></li><li>the gradient <span>$\operatorname{grad}F(x)$</span></li><li>an initial stepsize <code>s</code> usually called <span>$γ$</span></li><li>a sufficient <code>decrease</code></li><li>a <code>contract</code>ion factor <span>$σ$</span></li><li>a <code>retr</code>action, which defaults to the <code>default_retraction_method(M)</code></li><li>a search direction <span>$η = -\operatorname{grad}F(x)$</span></li><li>an offset, <span>$f_0 = F(x)$</span></li></ul><p>And use the 4 keywords to limit the maximal increase and decrease steps as well as a maximal stepsize (especially on non-Hadamard manifolds) and a minimal one.</p><p><strong>Return value</strong></p><p>A stepsize <code>s</code> and a message <code>msg</code> (in case any of the 4 criteria hit)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L292-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.max_stepsize-Tuple{AbstractManifold, Any}" href="#Manopt.max_stepsize-Tuple{AbstractManifold, Any}"><code>Manopt.max_stepsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_stepsize(M::AbstractManifold, p)
max_stepsize(M::AbstractManifold)</code></pre><p>Get the maximum stepsize (at point <code>p</code>) on manifold <code>M</code>. It should be used to limit the distance an algorithm is trying to move in a single step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/6482858d7b540d6174dc0bea60122ec6f94f1b85/src/plans/stepsize.jl#L28-L34">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-GrapigliaStella2023"><a class="tag is-link" href="#citeref-GrapigliaStella2023">GrapigliaStella2023</a><blockquote><p>Grapiglia, G. N., Stella, G. F. D.: An Adaptive Riemannian Gradient Method Without Function Evaluations Journal of Optimization Theory and Applications (197), pp. 1140–1160, 2023. doi: <a href="https://doi.org/10.1007/s10957-023-02227-y">10.1007/s10957-023-02227-y</a>, preprint: <a href="https://optimization-online.org/wp-content/uploads/2022/04/8864.pdf">optimization-online.org/wp-content/uploads/2022/04/8864.pdf</a></p></blockquote></li><li class="footnote" id="footnote-Iannazzo2018"><a class="tag is-link" href="#citeref-Iannazzo2018">Iannazzo2018</a><blockquote><p>B. Iannazzo, M. Porcelli, <strong>The Riemannian Barzilai–Borwein Method with Nonmonotone Line Search and the Matrix Geometric Mean Computation</strong>, In: IMA Journal of Numerical Analysis. Volume 38, Issue 1, January 2018, Pages 495–517, doi <a href="https://doi.org/10.1093/imanum/drx015">10.1093/imanum/drx015</a></p></blockquote></li><li class="footnote" id="footnote-Huang2014"><a class="tag is-link" href="#citeref-Huang2014">Huang2014</a><blockquote><p>Huang, W.: <em>Optimization algorithms on Riemannian manifolds with applications</em>, Dissertation, Flordia State University, 2014. <a href="https://www.math.fsu.edu/~whuang2/pdf/Huang_W_Dissertation_2013.pdf">pdf</a></p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../state/">« Solver State</a><a class="docs-footer-nextpage" href="../stopping_criteria/">Stopping Criteria »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 12 July 2023 12:25">Wednesday 12 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
