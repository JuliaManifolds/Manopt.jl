<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stepsize ¬∑ Manopt.jl</title><meta name="title" content="Stepsize ¬∑ Manopt.jl"/><meta property="og:title" content="Stepsize ¬∑ Manopt.jl"/><meta property="twitter:title" content="Stepsize ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/Optimize/">üèîÔ∏è Get started: optimize.</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../../tutorials/EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../../tutorials/HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../../tutorials/ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do constrained optimization</a></li><li><a class="tocitem" href="../../tutorials/GeodesicRegression/">Do geodesic regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">Introduction</a></li><li><a class="tocitem" href="../../solvers/adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../">Specify a Solver</a></li><li><a class="tocitem" href="../problem/">Problem</a></li><li><a class="tocitem" href="../objective/">Objective</a></li><li><a class="tocitem" href="../state/">Solver State</a></li><li class="is-active"><a class="tocitem" href>Stepsize</a><ul class="internal"><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../debug/">Debug Output</a></li><li><a class="tocitem" href="../record/">Recording values</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../functions/">Introduction</a></li><li><a class="tocitem" href="../../functions/bezier/">B√©zier curves</a></li><li><a class="tocitem" href="../../functions/costs/">Cost functions</a></li><li><a class="tocitem" href="../../functions/differentials/">Differentials</a></li><li><a class="tocitem" href="../../functions/adjoint_differentials/">Adjoint Differentials</a></li><li><a class="tocitem" href="../../functions/gradients/">Gradients</a></li><li><a class="tocitem" href="../../functions/proximal_maps/">Proximal Maps</a></li><li><a class="tocitem" href="../../functions/manifold/">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/data/">Data</a></li><li><a class="tocitem" href="../../helpers/errorMeasures/">Error Measures</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plans</a></li><li class="is-active"><a href>Stepsize</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stepsize</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/plans/stepsize.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Stepsize"><a class="docs-heading-anchor" href="#Stepsize">Stepsize and line search</a><a id="Stepsize-1"></a><a class="docs-heading-anchor-permalink" href="#Stepsize" title="Permalink"></a></h1><p>Most iterative algorithms determine a direction along which the algorithm shall proceed and determine a step size to find the next iterate. How advanced the step size computation can be implemented depends (among others) on the properties the corresponding problem provides.</p><p>Within <code>Manopt.jl</code>, the step size determination is implemented as a <code>functor</code> which is a subtype of <a href="#Manopt.Stepsize"><code>Stepsize</code></a> based on</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.Stepsize" href="#Manopt.Stepsize"><code>Manopt.Stepsize</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Stepsize</code></pre><p>An abstract type for the functors representing step sizes, i.e. they are callable structures. The naming scheme is <code>TypeOfStepSize</code>, e.g. <code>ConstantStepsize</code>.</p><p>Every Stepsize has to provide a constructor and its function has to have the interface <code>(p,o,i)</code> where a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> as well as <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> and the current number of iterations are the arguments and returns a number, namely the stepsize to use.</p><p><strong>See also</strong></p><p><a href="#Manopt.Linesearch"><code>Linesearch</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L1-L15">source</a></section></article><p>Usually, a constructor should take the manifold <code>M</code> as its first argument, for consistency, to allow general step size functors to be set up based on default values that might depend on the manifold currently under consideration.</p><p>Currently, the following step sizes are available</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AdaptiveWNGradient" href="#Manopt.AdaptiveWNGradient"><code>Manopt.AdaptiveWNGradient</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdaptiveWNGradient &lt;: DirectionUpdateRule</code></pre><p>Represent an adaptive gradient method introduced by <a href="../../references/#GrapigliaStella:2023">Grapiglia,Stella, J. Optim. Theory Appl., 2023</a>.</p><p>Given a positive threshold <span>$\hat c \mathbb N$</span>, an minimal bound <span>$b_{\mathrm{min}} &gt; 0$</span>, an initial <span>$b_0 ‚â• b_{\mathrm{min}}$</span>, and a gradient reduction factor threshold <span>$\alpha \in [0,1)$</span>.</p><p>Set <span>$c_0=0$</span> and use <span>$\omega_0 = \lVert \operatorname{grad} f(p_0) \rvert_{p_0}$</span>.</p><p>For the first iterate we use the initial step size <span>$s_0 = \frac{1}{b_0}$</span></p><p>Then, given the last gradient <span>$X_{k-1} = \operatorname{grad} f(x_{k-1})$</span>, and a previous <span>$\omega_{k-1}$</span>, the values <span>$(b_k, \omega_k, c_k)$</span> are computed using <span>$X_k = \operatorname{grad} f(p_k)$</span> and the following cases</p><p>If <span>$\lVert X_k \rVert_{p_k} \leq \alpha\omega_{k-1}$</span>, then let <span>$\hat b_{k-1} \in [b_\mathrm{min},b_{k-1}]$</span> and set</p><p class="math-container">\[(b_k, \omega_k, c_k) = \begin{cases}
\bigl(\hat b_{k-1}, \lVert X_k\rVert_{p_k}, 0 \bigr) &amp; \text{ if } c_{k-1}+1 = \hat c\\
\Bigl(b_{k-1} + \frac{\lVert X_k\rVert_{p_k}^2}{b_{k-1}}, \omega_{k-1}, c_{k-1}+1 \Bigr) &amp; \text{ if } c_{k-1}+1&lt;\hat c
\end{cases}\]</p><p>If <span>$\lVert X_k \rVert_{p_k} &gt; \alpha\omega_{k-1}$</span>, the set</p><p class="math-container">\[(b_k, \omega_k, c_k) =
\Bigl( b_{k-1} + \frac{\lVert X_k\rVert_{p_k}^2}{b_{k-1}}, \omega_{k-1}, 0)\]</p><p>and return the step size <span>$s_k = \frac{1}{b_k}$</span>.</p><p>Note that for <span>$Œ±=0$</span> this is the Riemannian variant of WNGRad</p><p><strong>Fields</strong></p><ul><li><code>count_threshold::Int</code> (<code>4</code>) an <code>Integer</code> for <span>$\hat c$</span></li><li><code>minimal_bound::Float64</code> (<code>1e-4</code>) for <span>$b_{\mathrm{min}}$</span></li><li><code>alternate_bound::Function</code> (<code>(bk, hat_c) -&gt; min(gradient_bound, max(gradient_bound, bk/(3*hat_c)</code>) how to determine <span>$\hat b_k$</span> as a function of <code>(bmin, bk, hat_c) -&gt; hat_bk</code></li><li><code>gradient_reduction::Float64</code> (<code>0.9</code>)</li><li><code>gradient_bound</code> <code>norm(M, p0, grad_f(M,p0))</code> the bound <span>$b_k$</span>.</li></ul><p>as well as the internal fields</p><ul><li><code>weight</code> for <span>$œâ_k$</span> initialised to <span>$œâ_0 =$</span><code>norm(M, p0, grad_f(M,p0))</code> if this is not zero, <code>1.0</code> otherwise.</li><li><code>count</code> for the <span>$c_k$</span>, initialised to <span>$c_0 = 0$</span>.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">AdaptiveWNGrad(M=DefaultManifold, grad_f=(M,p) -&gt; zero_vector(M,rand(M)), p=rand(M); kwargs...)</code></pre><p>Where all above fields with defaults are keyword arguments. An additional keyword arguments</p><ul><li><code>adaptive</code> (<code>true</code>) switches the <code>gradient_reduction</code><code>Œ±</code><code>to</code>0`.</li><li><code>evaluation</code> (<code>AllocatingEvaluation()</code>) specifies whether the gradient (that is used for initialisation only) is mutating or allocating</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L983-L1044">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ArmijoLinesearch" href="#Manopt.ArmijoLinesearch"><code>Manopt.ArmijoLinesearch</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArmijoLinesearch &lt;: Linesearch</code></pre><p>A functor representing Armijo line search including the last runs state, i.e. a last step size.</p><p><strong>Fields</strong></p><ul><li><code>initial_stepsize</code>    ‚Äì (<code>1.0</code>) and initial step size</li><li><code>retraction_method</code>   ‚Äì (<code>default_retraction_method(M)</code>) the retraction to use</li><li><code>contraction_factor</code>  ‚Äì (<code>0.95</code>) exponent for line search reduction</li><li><code>sufficient_decrease</code> ‚Äì (<code>0.1</code>) gain within Armijo&#39;s rule</li><li><code>last_stepsize</code>       ‚Äì (<code>initialstepsize</code>) the last step size we start the search with</li><li><code>initial_guess</code>       - (<code>(p,s,i,l) -&gt; l</code>)  based on a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>p</code>, <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>s</code> and a current iterate <code>i</code> and a last step size <code>l</code>, this returns an initial guess. The default uses the last obtained stepsize</li></ul><p>Furthermore the following fields act as safeguards</p><ul><li><code>stop_when_stepsize_less</code>    - (<code>0.0</code>) smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_when_stepsize_exceeds - ([</code>max_stepsize<code>](@ref)</code>(M, p)`) ‚Äì largest stepsize when to stop.</li><li><code>stop_increasing_at_step</code>   - (<code>100</code>) last step to increase the stepsize (phase 1),</li><li><code>stop_decreasing_at_step</code>   - (<code>1000</code>) last step size to decrease the stepsize (phase 2),</li></ul><p>Pass <code>:Messages</code> to a <code>debug=</code> to see <code>@info</code>s when these happen.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ArmijoLinesearch(M=DefaultManifold())</code></pre><p>with the Fields above as keyword arguments and the retraction is set to the default retraction on <code>M</code>.</p><p>The constructors return the functor to perform Armijo line search, where two interfaces are available:</p><ul><li>based on a tuple <code>(amp, ams, i)</code> of a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>, <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> and a current iterate <code>i</code>.</li><li>with <code>(M, x, F, gradFx[,Œ∑=-gradFx]) -&gt; s</code> where  <code>M</code>, a current point <code>x</code> a function <code>F</code>, that maps from the manifold to the reals, its gradient (a tangent vector) <code>gradFx</code><span>$=\operatorname{grad}F(x)$</span> at  <code>x</code> and an optional search direction tangent vector <code>Œ∑=-gradFx</code> are the arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L200-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ConstantStepsize" href="#Manopt.ConstantStepsize"><code>Manopt.ConstantStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantStepsize &lt;: Stepsize</code></pre><p>A functor that always returns a fixed step size.</p><p><strong>Fields</strong></p><ul><li><code>length</code> ‚Äì constant value for the step size</li><li><code>type</code> - a symbol that indicates whether the stepsize is relatively (:relative),   with respect to the gradient norm, or absolutely (:absolute) constant.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConstantStepsize(s::Real, t::Symbol=:relative)</code></pre><p>initialize the stepsize to a constant <code>s</code> of type <code>t</code>.</p><pre><code class="nohighlight hljs">ConstantStepsize(M::AbstractManifold=DefaultManifold(2);
    stepsize=injectivity_radius(M)/2, type::Symbol=:relative
)</code></pre><p>initialize the stepsize to a constant <code>stepsize</code>, which by default is half the injectivity radius, unless the radius is infinity, then the default step size is <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L42-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.DecreasingStepsize" href="#Manopt.DecreasingStepsize"><code>Manopt.DecreasingStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DecreasingStepsize()</code></pre><p>A functor that represents several decreasing step sizes</p><p><strong>Fields</strong></p><ul><li><code>length</code> ‚Äì (<code>1</code>) the initial step size <span>$l$</span>.</li><li><code>factor</code> ‚Äì (<code>1</code>) a value <span>$f$</span> to multiply the initial step size with every iteration</li><li><code>subtrahend</code> ‚Äì (<code>0</code>) a value <span>$a$</span> that is subtracted every iteration</li><li><code>exponent</code> ‚Äì (<code>1</code>) a value <span>$e$</span> the current iteration numbers <span>$e$</span>th exponential is taken of</li><li><code>shift</code> ‚Äì (<code>0</code>) shift the denominator iterator <span>$i$</span> by <span>$s$</span>`.</li><li><code>type</code> - a symbol that indicates whether the stepsize is relatively (:relative),   with respect to the gradient norm, or absolutely (:absolute) constant.</li></ul><p>In total the complete formulae reads for the <span>$i$</span>th iterate as</p><p class="math-container">\[s_i = \frac{(l - i a)f^i}{(i+s)^e}\]</p><p>and hence the default simplifies to just <span>$s_i = \frac{l}{i}$</span></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DecreasingStepsize(l=1,f=1,a=0,e=1,s=0,type=:relative)</code></pre><p>Alternatively one can also use the following keyword.</p><pre><code class="nohighlight hljs">DecreasingStepsize(
    M::AbstractManifold=DefaultManifold(3);
    length=injectivity_radius(M)/2, multiplier=1.0, subtrahend=0.0,
    exponent=1.0, shift=0, type=:relative
)</code></pre><p>initializes all fields above, where none of them is mandatory and the length is set to half and to <span>$1$</span> if the injectivity radius is infinite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L94-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.Linesearch" href="#Manopt.Linesearch"><code>Manopt.Linesearch</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Linesearch &lt;: Stepsize</code></pre><p>An abstract functor to represent line search type step size determinations, see <a href="#Manopt.Stepsize"><code>Stepsize</code></a> for details. One example is the <a href="#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a> functor.</p><p>Compared to simple step sizes, the linesearch functors provide an interface of the form <code>(p,o,i,Œ∑) -&gt; s</code> with an additional (but optional) fourth parameter to provide a search direction; this should default to something reasonable, e.g. the negative gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L175-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.NonmonotoneLinesearch" href="#Manopt.NonmonotoneLinesearch"><code>Manopt.NonmonotoneLinesearch</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonmonotoneLinesearch &lt;: Linesearch</code></pre><p>A functor representing a nonmonotone line search using the Barzilai-Borwein step size <a href="../../references/#IannazzoPorcelli:2017">Iannazzo, Porcelli, IMA J. Numer. Anal., 2017</a>. Together with a gradient descent algorithm this line search represents the Riemannian Barzilai-Borwein with nonmonotone line-search (RBBNMLS) algorithm. We shifted the order of the algorithm steps from the paper by Iannazzo and Porcelli so that in each iteration we first find</p><p class="math-container">\[y_{k} = \operatorname{grad}F(x_{k}) - \operatorname{T}_{x_{k-1} ‚Üí x_k}(\operatorname{grad}F(x_{k-1}))\]</p><p>and</p><p class="math-container">\[s_{k} = - Œ±_{k-1} * \operatorname{T}_{x_{k-1} ‚Üí x_k}(\operatorname{grad}F(x_{k-1})),\]</p><p>where <span>$Œ±_{k-1}$</span> is the step size computed in the last iteration and <span>$\operatorname{T}$</span> is a vector transport. We then find the Barzilai‚ÄìBorwein step size</p><p class="math-container">\[Œ±_k^{\text{BB}} = \begin{cases}
\min(Œ±_{\text{max}}, \max(Œ±_{\text{min}}, œÑ_{k})),  &amp; \text{if } ‚ü®s_{k}, y_{k}‚ü©_{x_k} &gt; 0,\\
Œ±_{\text{max}}, &amp; \text{else,}
\end{cases}\]</p><p>where</p><p class="math-container">\[œÑ_{k} = \frac{‚ü®s_{k}, s_{k}‚ü©_{x_k}}{‚ü®s_{k}, y_{k}‚ü©_{x_k}},\]</p><p>if the direct strategy is chosen,</p><p class="math-container">\[œÑ_{k} = \frac{‚ü®s_{k}, y_{k}‚ü©_{x_k}}{‚ü®y_{k}, y_{k}‚ü©_{x_k}},\]</p><p>in case of the inverse strategy and an alternation between the two in case of the alternating strategy. Then we find the smallest <span>$h = 0, 1, 2, ‚Ä¶$</span> such that</p><p class="math-container">\[F(\operatorname{retr}_{x_k}(- œÉ^h Œ±_k^{\text{BB}} \operatorname{grad}F(x_k)))
\leq
\max_{1 ‚â§ j ‚â§ \min(k+1,m)} F(x_{k+1-j}) - Œ≥ œÉ^h Œ±_k^{\text{BB}} ‚ü®\operatorname{grad}F(x_k), \operatorname{grad}F(x_k)‚ü©_{x_k},\]</p><p>where <span>$œÉ$</span> is a step length reduction factor <span>$‚àà (0,1)$</span>, <span>$m$</span> is the number of iterations after which the function value has to be lower than the current one and <span>$Œ≥$</span> is the sufficient decrease parameter <span>$‚àà(0,1)$</span>. We can then find the new stepsize by</p><p class="math-container">\[Œ±_k = œÉ^h Œ±_k^{\text{BB}}.\]</p><p><strong>Fields</strong></p><ul><li><code>initial_stepsize</code>          ‚Äì (<code>1.0</code>) the step size we start the search with</li><li><code>memory_size</code>               ‚Äì (<code>10</code>) number of iterations after which the cost value needs to be lower than the current one</li><li><code>bb_min_stepsize</code>           ‚Äì (<code>1e-3</code>) lower bound for the Barzilai-Borwein step size greater than zero</li><li><code>bb_max_stepsize</code>           ‚Äì (<code>1e3</code>) upper bound for the Barzilai-Borwein step size greater than min_stepsize</li><li><code>retraction_method</code>         ‚Äì (<code>ExponentialRetraction()</code>) the retraction to use</li><li><code>strategy</code>                  ‚Äì (<code>direct</code>) defines if the new step size is computed using the direct, indirect or alternating strategy</li><li><code>storage</code>                   ‚Äì (for <code>:Iterate</code> and <code>:Gradient</code>) a <a href="../state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a></li><li><code>stepsize_reduction</code>        ‚Äì (<code>0.5</code>) step size reduction factor contained in the interval (0,1)</li><li><code>sufficient_decrease</code>       ‚Äì (<code>1e-4</code>) sufficient decrease parameter contained in the interval (0,1)</li><li><code>vector_transport_method</code>   ‚Äì (<code>ParallelTransport()</code>) the vector transport method to use</li></ul><p>Furthermore the following fields act as safeguards</p><ul><li><code>stop_when_stepsize_less    - (</code>0.0`) smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_when_stepsize_exceeds - ([</code>max_stepsize<code>](@ref)</code>(M, p)`) ‚Äì largest stepsize when to stop.</li><li><code>stop_increasing_at_step</code>   - (^100`) last step to increase the stepsize (phase 1),</li><li><code>stop_decreasing_at_step</code>   - (<code>1000</code>) last step size to decrease the stepsize (phase 2),</li></ul><p>Pass <code>:Messages</code> to a <code>debug=</code> to see <code>@info</code>s when these happen.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">NonmonotoneLinesearch()</code></pre><p>with the Fields above in their order as optional arguments (deprecated).</p><pre><code class="nohighlight hljs">NonmonotoneLinesearch(M)</code></pre><p>with the Fields above in their order as keyword arguments and where the retraction and vector transport are set to the default ones on <code>M</code>, respectively.</p><p>The constructors return the functor to perform nonmonotone line search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L413-L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.WolfePowellBinaryLinesearch" href="#Manopt.WolfePowellBinaryLinesearch"><code>Manopt.WolfePowellBinaryLinesearch</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WolfePowellBinaryLinesearch &lt;: Linesearch</code></pre><p>A <a href="#Manopt.Linesearch"><code>Linesearch</code></a> method that determines a step size <code>t</code> fulfilling the Wolfe conditions</p><p>based on a binary chop. Let <span>$Œ∑$</span> be a search direction and <span>$c1,c_2&gt;0$</span> be two constants. Then with</p><p class="math-container">\[A(t) = f(x_+) ‚â§ c1 t ‚ü®\operatorname{grad}f(x), Œ∑‚ü©_{x}
\quad\text{and}\quad
W(t) = ‚ü®\operatorname{grad}f(x_+), \text{V}_{x_+\gets x}Œ∑‚ü©_{x_+} ‚â• c_2 ‚ü®Œ∑, \operatorname{grad}f(x)‚ü©_x,\]</p><p>where <span>$x_+ = \operatorname{retr}_x(tŒ∑)$</span> is the current trial point, and <span>$\text{V}$</span> is a vector transport, we perform the following Algorithm similar to Algorithm 7 from <a href="../../references/#Huang:2014">Huang, Thesis, 2014</a></p><ol><li>set <span>$Œ±=0$</span>, <span>$Œ≤=‚àû$</span> and <span>$t=1$</span>.</li><li>While either <span>$A(t)$</span> does not hold or <span>$W(t)$</span> does not hold do steps 3-5.</li><li>If <span>$A(t)$</span> fails, set <span>$Œ≤=t$</span>.</li><li>If <span>$A(t)$</span> holds but <span>$W(t)$</span> fails, set <span>$Œ±=t$</span>.</li><li>If <span>$Œ≤&lt;‚àû$</span> set <span>$t=\frac{Œ±+Œ≤}{2}$</span>, otherwise set <span>$t=2Œ±$</span>.</li></ol><p><strong>Constructors</strong></p><p>There exist two constructors, where, when prodivind the manifold <code>M</code> as a first (optional) parameter, its default retraction and vector transport are the default. In this case the retraction and the vector transport are also keyword arguments for ease of use. The other constructor is kept for backward compatibility.</p><pre><code class="nohighlight hljs">WolfePowellLinesearch(
    M=DefaultManifold(),
    c1::Float64=10^(-4),
    c2::Float64=0.999;
    retraction_method = default_retraction_method(M),
    vector_transport_method = default_vector_transport(M),
    linesearch_stopsize = 0.0
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L862-L900">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.WolfePowellLinesearch" href="#Manopt.WolfePowellLinesearch"><code>Manopt.WolfePowellLinesearch</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WolfePowellLinesearch &lt;: Linesearch</code></pre><p>Do a backtracking linesearch to find a step size <span>$Œ±$</span> that fulfils the Wolfe conditions along a search direction <span>$Œ∑$</span> starting from <span>$x$</span>, i.e.</p><p class="math-container">\[f\bigl( \operatorname{retr}_x(Œ±Œ∑) \bigr) ‚â§ f(x_k) + c_1 Œ±_k ‚ü®\operatorname{grad}f(x), Œ∑‚ü©_x
\quad\text{and}\quad
\frac{\mathrm{d}}{\mathrm{d}t} f\bigr(\operatorname{retr}_x(tŒ∑)\bigr)
\Big\vert_{t=Œ±}
‚â• c_2 \frac{\mathrm{d}}{\mathrm{d}t} f\bigl(\operatorname{retr}_x(tŒ∑)\bigr)\Big\vert_{t=0}.\]</p><p><strong>Constructors</strong></p><p>There exist two constructors, where, when prodivind the manifold <code>M</code> as a first (optional) parameter, its default retraction and vector transport are the default. In this case the retraction and the vector transport are also keyword arguments for ease of use. The other constructor is kept for backward compatibility. Note that the <code>linesearch_stopsize</code> to stop for too small stepsizes is only available in the new signature including <code>M</code>.</p><pre><code class="nohighlight hljs">WolfePowellLinesearch(
    M,
    c1::Float64=10^(-4),
    c2::Float64=0.999;
    retraction_method = default_retraction_method(M),
    vector_transport_method = default_vector_transport(M),
    linesearch_stopsize = 0.0
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L720-L751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}" href="#Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}"><code>Manopt.default_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_stepsize(M::AbstractManifold, ams::AbstractManoptSolverState)</code></pre><p>Returns the default <a href="#Manopt.Stepsize"><code>Stepsize</code></a> functor used when running the solver specified by the <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> running with an objective on the <code>AbstractManifold M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}" href="#Manopt.get_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}"><code>Manopt.get_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_stepsize(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, vars...)</code></pre><p>return the stepsize stored within <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> when solving the <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>. This method also works for decorated options and the <a href="#Manopt.Stepsize"><code>Stepsize</code></a> function within the options, by default stored in <code>o.stepsize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L1141-L1148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T, Any}} where {TF, T}" href="#Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T, Any}} where {TF, T}"><code>Manopt.linesearch_backtrack</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(s, msg) = linesearch_backtrack(
    M, F, x, gradFx, s, decrease, contract, retr, Œ∑ = -gradFx, f0 = F(x);
    stop_when_stepsize_less=0.0,
    stop_when_stepsize_exceeds=max_stepsize(M, p),
    stop_increasing_at_step = 100,
    stop_decreasing_at_step = 1000,
)</code></pre><p>perform a linesearch for</p><ul><li>a manifold <code>M</code></li><li>a cost function <code>f</code>,</li><li>an iterate <code>p</code></li><li>the gradient <span>$\operatorname{grad}F(x)$</span></li><li>an initial stepsize <code>s</code> usually called <span>$Œ≥$</span></li><li>a sufficient <code>decrease</code></li><li>a <code>contract</code>ion factor <span>$œÉ$</span></li><li>a <code>retr</code>action, which defaults to the <code>default_retraction_method(M)</code></li><li>a search direction <span>$Œ∑ = -\operatorname{grad}F(x)$</span></li><li>an offset, <span>$f_0 = F(x)$</span></li></ul><p>And use the 4 keywords to limit the maximal increase and decrease steps as well as a maximal stepsize (especially on non-Hadamard manifolds) and a minimal one.</p><p><strong>Return value</strong></p><p>A stepsize <code>s</code> and a message <code>msg</code> (in case any of the 4 criteria hit)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L323-L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.max_stepsize-Tuple{AbstractManifold, Any}" href="#Manopt.max_stepsize-Tuple{AbstractManifold, Any}"><code>Manopt.max_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_stepsize(M::AbstractManifold, p)
max_stepsize(M::AbstractManifold)</code></pre><p>Get the maximum stepsize (at point <code>p</code>) on manifold <code>M</code>. It should be used to limit the distance an algorithm is trying to move in a single step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/c8e9079e49133026ff8b153456c00b67d6c0b1fb/src/plans/stepsize.jl#L28-L34">source</a></section></article><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[GS23]</dt><dd><div>G.¬†N.¬†Grapiglia and G.¬†F.¬†Stella. <em>An Adaptive Riemannian Gradient Method Without Function Evaluations</em>. <a href="https://doi.org/10.1007/s10957-023-02227-y">Journal¬†of¬†Optimization¬†Theory¬†and¬†Applications <strong>197</strong>, 1140‚Äì1160</a> (2023), preprint: <a href="https://optimization-online.org/wp-content/uploads/2022/04/8864.pdf">optimization-online.org/wp-content/uploads/2022/04/8864.pdf</a>.</div></dd><dt>[Hua14]</dt><dd><div>W.¬†Huang. <a href="https://www.math.fsu.edu/~whuang2/pdf/Huang_W_Dissertation_2013.pdf"><em>Optimization algorithms on Riemannian manifolds with applications</em></a>. Ph.D. Thesis, Flordia State University (2014).</div></dd><dt>[IP17]</dt><dd><div>B.¬†Iannazzo and M.¬†Porcelli. <em>The Riemannian Barzilai‚ÄìBorwein method with nonmonotone line search and the matrix geometric mean computation</em>. <a href="https://doi.org/10.1093/imanum/drx015">IMA¬†Journal¬†of¬†Numerical¬†Analysis <strong>38</strong>, 495‚Äì517</a> (2017).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../state/">¬´ Solver State</a><a class="docs-footer-nextpage" href="../stopping_criteria/">Stopping Criteria ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Monday 20 November 2023 18:02">Monday 20 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
