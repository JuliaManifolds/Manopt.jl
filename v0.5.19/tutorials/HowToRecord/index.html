<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Record values ¬∑ Manopt.jl</title><meta name="title" content="Record values ¬∑ Manopt.jl"/><meta property="og:title" content="Record values ¬∑ Manopt.jl"/><meta property="twitter:title" content="Record values ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../getstarted/">üèîÔ∏è Get started with Manopt.jl</a></li><li><a class="tocitem" href="../InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../HowToDebug/">Print debug output</a></li><li class="is-active"><a class="tocitem" href>Record values</a><ul class="internal"><li><a class="tocitem" href="#The-objective"><span>The objective</span></a></li><li><a class="tocitem" href="#First-examples"><span>First examples</span></a></li><li><a class="tocitem" href="#A-more-complex-example"><span>A more complex example</span></a></li><li><a class="tocitem" href="#Recording-from-a-Subsolver"><span>Recording from a Subsolver</span></a></li><li><a class="tocitem" href="#Writing-an-own-[RecordAction](https://manoptjl.org/stable/plans/record/#Manopt.RecordAction)s"><span>Writing an own <code>RecordAction</code>s</span></a></li><li><a class="tocitem" href="#Technical-details"><span>Technical details</span></a></li></ul></li><li><a class="tocitem" href="../ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../ConstrainedOptimization/">Do constrained optimization</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">List of Solvers</a></li><li><a class="tocitem" href="../../solvers/adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/cma_es/">CMA-ES</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/conjugate_residual/">Conjugate Residual</a></li><li><a class="tocitem" href="../../solvers/convex_bundle_method/">Convex bundle method</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/interior_point_Newton/">Interior Point Newton</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="../../solvers/mesh_adaptive_direct_search/">Mesh Adaptive Direct Search</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/projected_gradient_method/">Projected Gradient Method</a></li><li><a class="tocitem" href="../../solvers/proximal_bundle_method/">Proximal bundle method</a></li><li><a class="tocitem" href="../../solvers/proximal_gradient_method/">Proximal Gradient Method</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../../plans/problem/">Problem</a></li><li><a class="tocitem" href="../../plans/objective/">Objective</a></li><li><a class="tocitem" href="../../plans/state/">Solver State</a></li><li><a class="tocitem" href="../../plans/stepsize/">Stepsize</a></li><li><a class="tocitem" href="../../plans/stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../../plans/debug/">Debug Output</a></li><li><a class="tocitem" href="../../plans/record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to...</a></li><li class="is-active"><a href>Record values</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Record values</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/tutorials/HowToRecord.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="How-to-record-data-during-the-iterations"><a class="docs-heading-anchor" href="#How-to-record-data-during-the-iterations">How to record data during the iterations</a><a id="How-to-record-data-during-the-iterations-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-record-data-during-the-iterations" title="Permalink"></a></h1><p>Ronny Bergmann</p><p>The recording and debugging features make it possible to record nearly any data during the iterations. This tutorial illustrates how to:</p><ul><li>record one value during the iterations;</li><li>record multiple values during the iterations and access them afterwards;</li><li>record within a subsolver</li><li>define an own <code>RecordAction</code> to perform individual recordings.</li></ul><p>Several predefined recordings exist, for example <a href="../../plans/record/#Manopt.RecordCost"><code>RecordCost</code></a> or <a href="https://manoptjl.org/stable/solvers/gradient_descent/#Manopt.RecordGradient"><code>RecordGradient</code></a>, if the problem the solver uses provides a gradient. For fields of the <code>State</code> the recording can also be done <a href="../../plans/record/#Manopt.RecordEntry"><code>RecordEntry</code></a>. For other recordings, for example more advanced computations before storing a value, an own <code>RecordAction</code> can be defined.</p><p>We illustrate these using the gradient descent from the <a href="../getstarted/">Get started: optimize</a> tutorial.</p><p>Here the focus is put on ways to investigate the behaviour during iterations by using Recording techniques.</p><p>Let‚Äôs first load the necessary packages.</p><pre><code class="language-julia hljs">using Manopt, Manifolds, Random, ManifoldDiff, LinearAlgebra
using ManifoldDiff: grad_distance
Random.seed!(42);</code></pre><h2 id="The-objective"><a class="docs-heading-anchor" href="#The-objective">The objective</a><a id="The-objective-1"></a><a class="docs-heading-anchor-permalink" href="#The-objective" title="Permalink"></a></h2><p>We generate data and define our cost and gradient:</p><pre><code class="language-julia hljs">Random.seed!(42)
m = 30
M = Sphere(m)
n = 800
œÉ = œÄ / 8
x = zeros(Float64, m + 1)
x[2] = 1.0
data = [exp(M, x, œÉ * rand(M; vector_at=x)) for i in 1:n]
f(M, p) = sum(1 / (2 * n) * distance.(Ref(M), Ref(p), data) .^ 2)
grad_f(M, p) = sum(1 / n * grad_distance.(Ref(M), data, Ref(p)))</code></pre><pre><code class="nohighlight hljs">grad_f (generic function with 1 method)</code></pre><h2 id="First-examples"><a class="docs-heading-anchor" href="#First-examples">First examples</a><a id="First-examples-1"></a><a class="docs-heading-anchor-permalink" href="#First-examples" title="Permalink"></a></h2><p>For the high level interfaces of the solvers, like <a href="https://manoptjl.org/stable/solvers/gradient_descent.html"><code>gradient_descent</code></a> we have to set <code>return_state</code> to <code>true</code> to obtain the whole <a href="https://manoptjl.org/stable/plans/state/">solver state</a> and not only the resulting minimizer.</p><p>Then we can easily use the <code>record=</code> option to add recorded values. This keyword accepts <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordAction"><code>RecordAction</code></a>s as well as several symbols as shortcuts, for example <code>:Cost</code> to record the cost, or if your options have a field <code>f</code>, <code>:f</code> would record that entry. An overview of the symbols that can be used is given <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordActionFactory-Tuple%7BAbstractManoptSolverState,%20RecordAction%7D">here</a>.</p><p>We first just record the cost after every iteration</p><pre><code class="language-julia hljs">R = gradient_descent(M, f, grad_f, data[1]; record=:Cost, return_state=true)</code></pre><pre><code class="nohighlight hljs"># Solver state for `Manopt.jl`s Gradient Descent
After 58 iterations

## Parameters
* retraction method: ManifoldsBase.ExponentialRetraction()

## Stepsize
ArmijoLinesearch(;
    initial_stepsize=1.0
    retraction_method=ManifoldsBase.ExponentialRetraction()
    contraction_factor=0.95
    sufficient_decrease=0.1
)

## Stopping criterion

Stop When _one_ of the following are fulfilled:
  * Max Iteration 200:  not reached
  * |grad f| &lt; 1.0e-8: reached
Overall: reached
This indicates convergence: Yes

## Record
(Iteration = RecordCost(),)</code></pre><p>From the returned state, we see that the <a href="https://manoptjl.org/stable/solvers/gradient_descent/#Manopt.GradientDescentState"><code>GradientDescentState</code></a> are encapsulated (decorated) within a <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordSolverState"><code>RecordSolverState</code></a>.</p><p>For such a state, one can attach different recorders to some operations, currently to <code>:Start</code>. <code>:Stop</code>, and <code>:Iteration</code>, where <code>:Iteration</code> is the default when using the <code>record=</code> keyword with a <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordAction"><code>RecordAction</code></a> or a <code>Symbol</code> as we just did. We can access all values recorded during the iterations by calling <code>get_record(R, :Iteation)</code> or since this is the default even shorter</p><pre><code class="language-julia hljs">get_record(R)</code></pre><pre><code class="nohighlight hljs">58-element Vector{Float64}:
 0.6870172325261714
 0.6239221496686211
 0.5900244338953802
 0.569312079535616
 0.551804825865545
 0.5429045359832491
 0.5383847696671529
 0.5360322830268692
 0.5348144739486789
 0.5341773307679919
 ‚ãÆ
 0.5334801024530125
 0.5334801024530096
 0.5334801024530081
 0.5334801024530073
 0.5334801024530066
 0.5334801024530061
 0.5334801024530059
 0.5334801024530059
 0.5334801024530059</code></pre><p>To record more than one value, you can pass an array of a mix of symbols and <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordAction"><code>RecordAction</code></a>s which formally introduces <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordGroup"><code>RecordGroup</code></a>. Such a group records a tuple of values in every iteration:</p><pre><code class="language-julia hljs">R2 = gradient_descent(M, f, grad_f, data[1]; record=[:Iteration, :Cost], return_state=true)</code></pre><pre><code class="nohighlight hljs"># Solver state for `Manopt.jl`s Gradient Descent
After 58 iterations

## Parameters
* retraction method: ManifoldsBase.ExponentialRetraction()

## Stepsize
ArmijoLinesearch(;
    initial_stepsize=1.0
    retraction_method=ManifoldsBase.ExponentialRetraction()
    contraction_factor=0.95
    sufficient_decrease=0.1
)

## Stopping criterion

Stop When _one_ of the following are fulfilled:
  * Max Iteration 200:  not reached
  * |grad f| &lt; 1.0e-8: reached
Overall: reached
This indicates convergence: Yes

## Record
(Iteration = RecordGroup([RecordIteration(), RecordCost()]),)</code></pre><p>Here, the symbol <code>:Cost</code> is mapped to using the <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordCost"><code>RecordCost</code></a> action. The same holds for <code>:Iteration</code> obviously records the current iteration number <code>i</code>. To access these you can first extract the group of records (that is where the <code>:Iteration</code>s are recorded; note the plural) and then access the <code>:Cost</code> ‚Äú‚Äú‚Äù</p><pre><code class="language-julia hljs">get_record_action(R2, :Iteration)</code></pre><pre><code class="nohighlight hljs">RecordGroup([RecordIteration(), RecordCost()])</code></pre><p>Since <code>iteration</code> is the default, we can also omit it here again. To access single recorded values, one can use</p><pre><code class="language-julia hljs">get_record_action(R2)[:Cost]</code></pre><pre><code class="nohighlight hljs">58-element Vector{Float64}:
 0.6870172325261714
 0.6239221496686211
 0.5900244338953802
 0.569312079535616
 0.551804825865545
 0.5429045359832491
 0.5383847696671529
 0.5360322830268692
 0.5348144739486789
 0.5341773307679919
 ‚ãÆ
 0.5334801024530125
 0.5334801024530096
 0.5334801024530081
 0.5334801024530073
 0.5334801024530066
 0.5334801024530061
 0.5334801024530059
 0.5334801024530059
 0.5334801024530059</code></pre><p>This can be also done by using a the high level interface <a href="https://manoptjl.org/stable/plans/record/#Manopt.get_record"><code>get_record</code></a></p><pre><code class="language-julia hljs">get_record(R2, :Iteration, :Cost)</code></pre><pre><code class="nohighlight hljs">58-element Vector{Float64}:
 0.6870172325261714
 0.6239221496686211
 0.5900244338953802
 0.569312079535616
 0.551804825865545
 0.5429045359832491
 0.5383847696671529
 0.5360322830268692
 0.5348144739486789
 0.5341773307679919
 ‚ãÆ
 0.5334801024530125
 0.5334801024530096
 0.5334801024530081
 0.5334801024530073
 0.5334801024530066
 0.5334801024530061
 0.5334801024530059
 0.5334801024530059
 0.5334801024530059</code></pre><p>Note that the first symbol again refers to the point where we record (not to the thing we record). We can also pass a tuple as second argument to have our own order within the tuples returned. Switching the order of recorded cost and Iteration can be done using ‚Äú‚Äú‚Äù</p><pre><code class="language-julia hljs">get_record(R2, :Iteration, (:Iteration, :Cost))</code></pre><pre><code class="nohighlight hljs">58-element Vector{Tuple{Int64, Float64}}:
 (1, 0.6870172325261714)
 (2, 0.6239221496686211)
 (3, 0.5900244338953802)
 (4, 0.569312079535616)
 (5, 0.551804825865545)
 (6, 0.5429045359832491)
 (7, 0.5383847696671529)
 (8, 0.5360322830268692)
 (9, 0.5348144739486789)
 (10, 0.5341773307679919)
 ‚ãÆ
 (50, 0.5334801024530125)
 (51, 0.5334801024530096)
 (52, 0.5334801024530081)
 (53, 0.5334801024530073)
 (54, 0.5334801024530066)
 (55, 0.5334801024530061)
 (56, 0.5334801024530059)
 (57, 0.5334801024530059)
 (58, 0.5334801024530059)</code></pre><h2 id="A-more-complex-example"><a class="docs-heading-anchor" href="#A-more-complex-example">A more complex example</a><a id="A-more-complex-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-more-complex-example" title="Permalink"></a></h2><p>To illustrate a complicated example let‚Äôs record:</p><ul><li>the iteration number, cost and gradient field, but only every sixth iteration;</li><li>the iteration at which we stop.</li></ul><p>We first generate the problem and the state, to also illustrate the low-level works when not using the high-level interface <a href="https://manoptjl.org/stable/solvers/gradient_descent.html"><code>gradient_descent</code></a>.</p><pre><code class="language-julia hljs">p = DefaultManoptProblem(M, ManifoldGradientObjective(f, grad_f))
s = GradientDescentState(
    M;
    p=copy(data[1]),
    stopping_criterion=StopAfterIteration(200) | StopWhenGradientNormLess(10.0^-9),
)</code></pre><pre><code class="nohighlight hljs"># Solver state for `Manopt.jl`s Gradient Descent

## Parameters
* retraction method: ManifoldsBase.ExponentialRetraction()

## Stepsize
ArmijoLinesearch(;
    initial_stepsize=1.0
    retraction_method=ManifoldsBase.ExponentialRetraction()
    contraction_factor=0.95
    sufficient_decrease=0.1
)

## Stopping criterion

Stop When _one_ of the following are fulfilled:
  * Max Iteration 200:  not reached
  * |grad f| &lt; 1.0e-9: not reached
Overall: not reached
This indicates convergence: No</code></pre><p>We now first build a <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordGroup"><code>RecordGroup</code></a> to group the three entries we want to record per iteration. We then put this into a <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordEvery"><code>RecordEvery</code></a> to only record this every sixth iteration</p><pre><code class="language-julia hljs">rI = RecordEvery(
    RecordGroup([
        RecordIteration() =&gt; :Iteration,
        RecordCost() =&gt; :Cost,
        RecordEntry(similar(data[1]), :X) =&gt; :Gradient,
    ]),
    6,
)</code></pre><pre><code class="nohighlight hljs">RecordEvery(RecordGroup([RecordIteration(), RecordCost(), RecordEntry(:X)]), 6, true)</code></pre><p>where the notation as a pair with the symbol can be read as ‚ÄúIs accessible by‚Äù. The <code>record=</code> keyword with the symbol <code>:Iteration</code> is actually the same as we specified here for the first group entry. For recording the final iteration number</p><pre><code class="language-julia hljs">sI = RecordIteration()</code></pre><pre><code class="nohighlight hljs">RecordIteration()</code></pre><p>We now combine both into the <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordSolverState"><code>RecordSolverState</code></a> decorator. It acts completely the same as any <a href="https://manoptjl.org/stable/plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> but records something in every iteration additionally. This is stored in a dictionary of <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordAction"><code>RecordAction</code></a>s, where <code>:Iteration</code> is the action (here the only every sixth iteration group) and the <code>sI</code> which is executed at stop.</p><p>Note that the keyword <code>record=</code> in the high level interface <code>gradient_descent</code> only would fill the <code>:Iteration</code> symbol of said dictionary, but we could also pass pairs like in the following, that is in the form <code>Symbol =&gt; RecordAction</code> into that keyword to obtain the same as in</p><pre><code class="language-julia hljs">r = RecordSolverState(s, Dict(:Iteration =&gt; rI, :Stop =&gt; sI))</code></pre><pre><code class="nohighlight hljs"># Solver state for `Manopt.jl`s Gradient Descent

## Parameters
* retraction method: ManifoldsBase.ExponentialRetraction()

## Stepsize
ArmijoLinesearch(;
    initial_stepsize=1.0
    retraction_method=ManifoldsBase.ExponentialRetraction()
    contraction_factor=0.95
    sufficient_decrease=0.1
)

## Stopping criterion

Stop When _one_ of the following are fulfilled:
  * Max Iteration 200:  not reached
  * |grad f| &lt; 1.0e-9: not reached
Overall: not reached
This indicates convergence: No

## Record
(Iteration = RecordEvery(RecordGroup([RecordIteration(), RecordCost(), RecordEntry(:X)]), 6, true), Stop = RecordIteration())</code></pre><p>We now call the solver</p><pre><code class="language-julia hljs">res = solve!(p, r)</code></pre><pre><code class="nohighlight hljs"># Solver state for `Manopt.jl`s Gradient Descent
After 63 iterations

## Parameters
* retraction method: ManifoldsBase.ExponentialRetraction()

## Stepsize
ArmijoLinesearch(;
    initial_stepsize=1.0
    retraction_method=ManifoldsBase.ExponentialRetraction()
    contraction_factor=0.95
    sufficient_decrease=0.1
)

## Stopping criterion

Stop When _one_ of the following are fulfilled:
  * Max Iteration 200:  not reached
  * |grad f| &lt; 1.0e-9: reached
Overall: reached
This indicates convergence: Yes

## Record
(Iteration = RecordEvery(RecordGroup([RecordIteration(), RecordCost(), RecordEntry(:X)]), 6, true), Stop = RecordIteration())</code></pre><p>And we can look at the recorded value at <code>:Stop</code> to see how many iterations were performed</p><pre><code class="language-julia hljs">get_record(res, :Stop)</code></pre><pre><code class="nohighlight hljs">1-element Vector{Int64}:
 63</code></pre><p>and the other values during the iterations are</p><pre><code class="language-julia hljs">get_record(res, :Iteration, (:Iteration, :Cost))</code></pre><pre><code class="nohighlight hljs">10-element Vector{Tuple{Int64, Float64}}:
 (6, 0.5429045359832491)
 (12, 0.5336712822308554)
 (18, 0.5334840986243338)
 (24, 0.5334801877032023)
 (30, 0.5334801043129838)
 (36, 0.5334801024945817)
 (42, 0.5334801024539585)
 (48, 0.5334801024530282)
 (54, 0.5334801024530066)
 (60, 0.5334801024530057)</code></pre><p>where the last tuple contains the names from the pairs when we generated the record group. So similarly we can use <code>:Gradient</code> as specified before to access the recorded gradient.</p><h2 id="Recording-from-a-Subsolver"><a class="docs-heading-anchor" href="#Recording-from-a-Subsolver">Recording from a Subsolver</a><a id="Recording-from-a-Subsolver-1"></a><a class="docs-heading-anchor-permalink" href="#Recording-from-a-Subsolver" title="Permalink"></a></h2><p>One can also record from a subsolver. For that we need a problem that actually requires a subsolver. We take the constraint example from the <a href="../HowToDebug/">How to print debug</a> tutorial. Maybe read that part for more details on the problem</p><pre><code class="language-julia hljs">d = 4
M2 = Sphere(d - 1)
v0 = project(M2, [ones(2)..., zeros(d - 2)...])
Z = v0 * v0&#39;
#Cost and gradient
f2(M, p) = -tr(transpose(p) * Z * p) / 2
grad_f2(M, p) = project(M, p, -transpose.(Z) * p / 2 - Z * p / 2)
# Constraints
g(M, p) = -p # now p ‚â• 0
mI = -Matrix{Float64}(I, d, d)
# Vector of gradients of the constraint components
grad_g(M, p) = [project(M, p, mI[:, i]) for i in 1:d]
p0 = project(M2, [ones(2)..., zeros(d - 3)..., 0.1])</code></pre><p>We directly start with recording the sub solvers Iteration. We can specify what to record in the subsolver using the <code>sub_kwargs</code> keyword argument with a <code>Symbol =&gt; value</code> pair. Here we specify to record the iteration and the cost in every sub solvers step.</p><p>Furthermore, we have to ‚Äúcollect‚Äù this recording after every sub solver run. This is done with the <code>:Subsolver</code> keyword in the main <code>record=</code> keyword.</p><pre><code class="language-julia hljs">s1 = exact_penalty_method(
    M2,
    f2,
    grad_f2,
    p0;
    g = g,
    grad_g = grad_g,
    record = [:Iteration, :Cost, :Subsolver],
    sub_kwargs = [:record =&gt; [:Iteration, :Cost]],
    return_state=true,
);</code></pre><p>Then the first entry of the record contains the iterate, the (main solvers) cost, and the third entry is the recording of the subsolver.</p><pre><code class="language-julia hljs">get_record(s1)[1]</code></pre><pre><code class="nohighlight hljs">(1, -0.4733019623455375, [(1, -0.4288382393589549), (2, -0.43669534259556914), (3, -0.4374036673499917), (4, -0.43744087180862923)])</code></pre><p>When adding a number to not record on every iteration, the <code>:Subsolver</code> keyword of course still also only ‚Äúcopies over‚Äù the subsolver recordings when active. But one could avoid allocations on the other runs. This is done, by specifying the sub solver as <code>:WhenActive</code></p><pre><code class="language-julia hljs">s2 = exact_penalty_method(
    M2,
    f2,
    grad_f2,
    p0;
    g = g,
    grad_g = grad_g,
    record = [:Iteration, :Cost, :Subsolver, 25],
    sub_kwargs = [:record =&gt; [:Iteration, :Cost, :WhenActive]],
    return_state=true,
);</code></pre><p>Then</p><pre><code class="language-julia hljs">get_record(s2)</code></pre><pre><code class="nohighlight hljs">4-element Vector{Tuple{Int64, Float64, Vector{Tuple{Int64, Float64}}}}:
 (25, -0.4994494108530985, [(1, -0.4991469152295235)])
 (50, -0.49999564261147317, [(1, -0.49999366842932896)])
 (75, -0.49999997420136083, [(1, -0.4999999614701454)])
 (100, -0.4999999998337046, [(1, -0.49999999981081666)])</code></pre><p>Finally, instead of recording iterations, we can also specify to record the stopping criterion and final cost by adding that to <code>:Stop</code> of the sub solvers record. Then we can specify, as usual in a tuple, that the <code>:Subsolver</code> should record <code>:Stop</code> (by default it takes over <code>:Iteration</code>)</p><pre><code class="language-julia hljs">s3 = exact_penalty_method(
    M2,
    f2,
    grad_f2,
    p0;
    g = g,
    grad_g = grad_g,
    record = [:Iteration, :Cost, (:Subsolver, :Stop), 25],
    sub_kwargs = [:record =&gt; [:Stop =&gt; [:Stop, :Cost]]],
    return_state=true,
);</code></pre><p>Then the following displays also the reasons why each of the recorded sub solvers stopped and the corresponding cost</p><pre><code class="language-julia hljs">get_record(s3)</code></pre><pre><code class="nohighlight hljs">4-element Vector{Tuple{Int64, Float64, Vector{Tuple{String, Float64}}}}:
 (25, -0.4994494108530985, [(&quot;The algorithm reached approximately critical point after 1 iterations; the gradient norm (0.00031307624887101047) is less than 0.001.\n&quot;, -0.4991469152295235)])
 (50, -0.49999564261147317, [(&quot;The algorithm reached approximately critical point after 1 iterations; the gradient norm (0.0009767910400237622) is less than 0.001.\n&quot;, -0.49999366842932896)])
 (75, -0.49999997420136083, [(&quot;The algorithm reached approximately critical point after 1 iterations; the gradient norm (0.0002239629119661262) is less than 0.001.\n&quot;, -0.4999999614701454)])
 (100, -0.4999999998337046, [(&quot;The algorithm reached approximately critical point after 1 iterations; the gradient norm (3.8129640908105967e-6) is less than 0.001.\n&quot;, -0.49999999981081666)])</code></pre><h2 id="Writing-an-own-[RecordAction](https://manoptjl.org/stable/plans/record/#Manopt.RecordAction)s"><a class="docs-heading-anchor" href="#Writing-an-own-[RecordAction](https://manoptjl.org/stable/plans/record/#Manopt.RecordAction)s">Writing an own <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordAction"><code>RecordAction</code></a>s</a><a id="Writing-an-own-[RecordAction](https://manoptjl.org/stable/plans/record/#Manopt.RecordAction)s-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-an-own-[RecordAction](https://manoptjl.org/stable/plans/record/#Manopt.RecordAction)s" title="Permalink"></a></h2><p>Let‚Äôs investigate where we want to count the number of function evaluations, again just to illustrate, since for the gradient this is just one evaluation per iteration. We first define a cost, that counts its own calls.</p><pre><code class="language-julia hljs">mutable struct MyCost{T}
    data::T
    count::Int
end
MyCost(data::T) where {T} = MyCost{T}(data, 0)
function (c::MyCost)(M, x)
    c.count += 1
    return sum(1 / (2 * length(c.data)) * distance.(Ref(M), Ref(x), c.data) .^ 2)
end</code></pre><p>and we define an own, new <a href="https://manoptjl.org/stable/plans/record/#Manopt.RecordAction"><code>RecordAction</code></a>, which is a functor, that is a struct that is also a function. The function we have to implement is similar to a single solver step in signature, since it might get called every iteration:</p><pre><code class="language-julia hljs">mutable struct RecordCount &lt;: RecordAction
    recorded_values::Vector{Int}
    RecordCount() = new(Vector{Int}())
end
function (r::RecordCount)(p::AbstractManoptProblem, ::AbstractManoptSolverState, i)
    if i &gt; 0
        push!(r.recorded_values, Manopt.get_cost_function(get_objective(p)).count)
    elseif i &lt; 0 # reset if negative
        r.recorded_values = Vector{Int}()
    end
end</code></pre><p>Now we can initialize the new cost and call the gradient descent. Note that this illustrates also the last use case since you can pass symbol-action pairs into the <code>record=</code>array.</p><pre><code class="language-julia hljs">f3 = MyCost(data)</code></pre><p>Now for the plain gradient descent, we have to modify the step (to a constant stepsize) and remove the default debug verification whether the cost increases (setting <code>debug</code> to <code>[]</code>). We also only look at the first 20 iterations to keep this example small in recorded values. We call</p><pre><code class="language-julia hljs">R3 = gradient_descent(
    M,
    f3,
    grad_f,
    data[1];
    record=[:Iteration =&gt; [
        :Iteration,
        RecordCount() =&gt; :Count,
        :Cost],
    ],
    stepsize = ConstantLength(1.0),
    stopping_criterion=StopAfterIteration(20),
    debug=[],
    return_state=true,
)</code></pre><pre><code class="nohighlight hljs"># Solver state for `Manopt.jl`s Gradient Descent
After 20 iterations

## Parameters
* retraction method: ManifoldsBase.ExponentialRetraction()

## Stepsize
ConstantLength(1.0; type=:relative)

## Stopping criterion

Max Iteration 20:   reached
This indicates convergence: No

## Record
(Iteration = RecordGroup([RecordIteration(), Main.Notebook.RecordCount([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), RecordCost()]),)</code></pre><p>For <code>:Cost</code> we already learned how to access them, the <code>=&gt; :Count</code> introduces an action to obtain the <code>:Count</code> symbol as its access. We can again access the whole sets of records</p><pre><code class="language-julia hljs">get_record(R3)</code></pre><pre><code class="nohighlight hljs">20-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 1, 0.5823814423113639)
 (2, 2, 0.540804980234004)
 (3, 3, 0.5345550944722898)
 (4, 4, 0.5336375289938887)
 (5, 5, 0.5335031591890169)
 (6, 6, 0.5334834802310252)
 (7, 7, 0.5334805973984544)
 (8, 8, 0.5334801749902928)
 (9, 9, 0.5334801130855078)
 (10, 10, 0.5334801040117543)
 (11, 11, 0.5334801026815558)
 (12, 12, 0.5334801024865219)
 (13, 13, 0.5334801024579218)
 (14, 14, 0.5334801024537273)
 (15, 15, 0.5334801024531121)
 (16, 16, 0.5334801024530218)
 (17, 17, 0.5334801024530087)
 (18, 18, 0.5334801024530067)
 (19, 19, 0.5334801024530065)
 (20, 20, 0.5334801024530064)</code></pre><p>this is equivalent to calling <code>R[:Iteration]</code>. Note that since we introduced <code>:Count</code> we can also access a single recorded value using</p><pre><code class="language-julia hljs">R3[:Iteration, :Count]</code></pre><pre><code class="nohighlight hljs">20-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20</code></pre><p>and we see that the cost function is called once per iteration.</p><p>If we use this counting cost and run the default gradient descent with Armijo line search, we can infer how many Armijo line search backtracks are preformed:</p><pre><code class="language-julia hljs">f4 = MyCost(data)</code></pre><pre><code class="nohighlight hljs">MyCost{Vector{Vector{Float64}}}([[-0.054658825167894595, -0.5592077846510423, -0.04738273828111257, -0.04682080720921302, 0.12279468849667038, 0.07171438895366239, -0.12930045409417057, -0.22102081626380404, -0.31805333254577767, 0.0065859500152017645  ‚Ä¶  -0.21999168261518043, 0.19570142227077295, 0.340909965798364, -0.0310802190082894, -0.04674431076254687, -0.006088297671169996, 0.01576037011323387, -0.14523596850249543, 0.14526158060820338, 0.1972125856685378], [-0.08192376929745249, -0.5097715132187676, -0.008339904915541005, 0.07289741328038676, 0.11422036270613797, -0.11546739299835748, 0.2296996932628472, 0.1490467170835958, -0.11124820565850364, -0.11790721606521781  ‚Ä¶  -0.16421249630470344, -0.2450575844467715, -0.07570080850379841, -0.07426218324072491, -0.026520181327346338, 0.11555341205250205, -0.0292955762365121, -0.09012096853677576, -0.23470556634911574, -0.026214242996704013], [-0.22951484264859257, -0.6083825348640186, 0.14273766477054015, -0.11947823367023377, 0.05984293499234536, 0.058820835498203126, 0.07577331705863266, 0.1632847202946857, 0.20244385489915745, 0.04389826920203656  ‚Ä¶  0.3222365119325929, 0.009728730325524067, -0.12094785371632395, -0.36322323926212824, -0.0689253407939657, 0.23356953371702974, 0.23489531397909744, 0.078303336494718, -0.14272984135578806, 0.07844539956202407], [-0.0012588500237817606, -0.29958740415089763, 0.036738459489123514, 0.20567651907595125, -0.1131046432541904, -0.06032435985370224, 0.3366633723165895, -0.1694687746143405, -0.001987171245125281, 0.04933779858684409  ‚Ä¶  -0.2399584473006256, 0.19889267065775063, 0.22468755918787048, 0.1780090580180643, 0.023703860700539356, -0.10212737517121755, 0.03807004103115319, -0.20569120952458983, -0.03257704254233959, 0.06925473452536687], [-0.035534309946938375, -0.06645560787329002, 0.14823972268208874, -0.23913346587232426, 0.038347027875883496, 0.10453333143286662, 0.050933995140290705, -0.12319549375687473, 0.12956684644537844, -0.23540367869989412  ‚Ä¶  -0.41471772859912864, -0.1418984610380257, 0.0038321446836859334, 0.23655566917750157, -0.17500681300994742, -0.039189751036839374, -0.08687860620942896, -0.11509948162959047, 0.11378233994840942, 0.38739450723013735], [-0.3122539912469438, -0.3101935557860296, 0.1733113629107006, 0.08968593616209351, -0.1836344261367962, -0.06480023695256802, 0.18165070013886545, 0.19618275767992124, -0.07956460275570058, 0.0325997354656551  ‚Ä¶  0.2845492418767769, 0.17406455870721682, -0.053101230371568706, -0.1382082812981627, 0.005830071475508364, 0.16739264037923055, 0.034365814374995335, 0.09107702398753297, -0.1877250428700409, 0.05116494897806923], [-0.04159442361185588, -0.7768029783272633, 0.06303616666722486, 0.08070518925253539, -0.07396265237309446, -0.06008109299719321, 0.07977141629715745, 0.019511027129056415, 0.08629917589924847, -0.11156298867318722  ‚Ä¶  0.0792587504128044, -0.016444383900170008, -0.181746064577005, -0.01888129512990984, -0.13523922089388968, 0.11358102175659832, 0.07929049608459493, 0.1689565359083833, 0.07673657951723721, -0.1128480905648813], [-0.21221814304651335, -0.5031823821503253, 0.010326342133992458, -0.12438192100961257, 0.04004758695231872, 0.2280527500843805, -0.2096243232022162, -0.16564828762420294, -0.28325749481138984, 0.17033534605245823  ‚Ä¶  -0.13599096505924074, 0.28437770540525625, 0.08424426798544583, -0.1266207606984139, 0.04917635557603396, -0.00012608938533809706, -0.04283220254770056, -0.08771365647566572, 0.14750169103093985, 0.11601120086036351], [0.10683290707435536, -0.17680836277740156, 0.23767458301899405, 0.12011180867097299, -0.029404774462600154, 0.11522028383799933, -0.3318174480974519, -0.17859266746938374, 0.04352373642537759, 0.2530382802667988  ‚Ä¶  0.08879861736692073, -0.004412506987801729, 0.19786810509925895, -0.1397104682727044, 0.09482328498485094, 0.05108149065160893, -0.14578343506951633, 0.3167479772660438, 0.10422673169182732, 0.21573150015891313], [-0.024895624707466164, -0.7473912016432697, -0.1392537238944721, -0.14948896791465557, -0.09765393283580377, 0.04413059403279867, -0.13865379004720355, -0.071032040283992, 0.15604054722246585, -0.10744260463413555  ‚Ä¶  -0.14748067081342833, -0.14743635071251024, 0.0643591937981352, 0.16138827697852615, -0.12656652133603935, -0.06463635704869083, 0.14329582429103488, -0.01113113793821713, 0.29295387893749997, 0.06774523575259782]  ‚Ä¶  [0.011874845316569967, -0.6910596618389588, 0.21275741439477827, -0.014042545524367437, -0.07883613103495014, -0.0021900966696246776, -0.033836430464220496, 0.2925813113264835, -0.04718187201980008, 0.03949680289730036  ‚Ä¶  0.0867736586603294, 0.0404682510051544, -0.24779813848587257, -0.28631514602877145, -0.07211767532456789, -0.15072898498180473, 0.017855923621826746, -0.09795357710255254, -0.14755229203084924, 0.1305005778855436], [0.013457629515450426, -0.3750353654626534, 0.12349883726772073, 0.3521803555005319, 0.2475921439420274, 0.006088649842999206, 0.31203183112392907, -0.036869203979483754, -0.07475746464056504, -0.029297797064479717  ‚Ä¶  0.16867368684091563, -0.09450564983271922, -0.0587273302122711, -0.1326667940553803, -0.25530237980444614, 0.37556905374043376, 0.04922612067677609, 0.2605362549983866, -0.21871556587505667, -0.22915883767386164], [0.03295085436260177, -0.971861604433394, 0.034748713521512035, -0.0494065013245799, -0.01767479281403355, 0.0465459739459587, 0.007470494722096038, 0.003227960072276129, 0.0058328596338402365, -0.037591237446692356  ‚Ä¶  0.03205152122876297, 0.11331109854742015, 0.03044900529526686, 0.017971704993311105, -0.009329252062960229, -0.02939354719650879, 0.022088835776251863, -0.02546111553658854, -0.0026257225461427582, 0.005702111697172774], [0.06968243992532257, -0.7119502191435176, -0.18136614593117445, -0.1695926215673451, 0.01725015359973796, -0.00694164951158388, -0.34621134287344574, 0.024709256792651912, -0.1632255805999673, -0.2158226433583082  ‚Ä¶  -0.14153772108081458, -0.11256850346909901, 0.045109821764180706, -0.1162754336222613, -0.13221711766357983, 0.005365354776191061, 0.012750671705879105, -0.018208207549835407, 0.12458753932455452, -0.31843587960340897], [-0.19830349374441875, -0.6086693423968884, 0.08552341811170468, 0.35781519334042255, 0.15790663648524367, 0.02712571268324985, 0.09855601327331667, -0.05840653973421127, -0.09546429767790429, -0.13414717696055448  ‚Ä¶  -0.0430935804718714, 0.2678584478951765, 0.08780994289014614, 0.01613469379498457, 0.0516187906322884, -0.07383067566731401, -0.1481272738354552, -0.010532317187265649, 0.06555344745952187, -0.1506167863762911], [-0.04347524125197773, -0.6327981074196994, -0.221116680035191, 0.0282207467940456, -0.0855024881522933, 0.12821801740178346, 0.1779499563280024, -0.10247384887512365, 0.0396432464100116, -0.0582580338112627  ‚Ä¶  0.1253893207083573, 0.09628202269764763, 0.3165295473947355, -0.14915034201394833, -0.1376727867817772, -0.004153096613530293, 0.09277957650773738, 0.05917264554031624, -0.12230262590034507, -0.19655728521529914], [-0.10173946348675116, -0.6475660153977272, 0.1260284619729566, -0.11933160462857616, -0.04774310633937567, 0.09093928358804217, 0.041662676324043114, -0.1264739543938265, 0.09605293126911392, -0.16790474428001648  ‚Ä¶  -0.04056684573478108, 0.09351665120940456, 0.15259195558799882, 0.0009949298312580497, 0.09461980828206303, 0.3067004514287283, 0.16129258773733715, -0.18893664085007542, -0.1806865244492513, 0.029319680436405825], [-0.251780954320053, -0.39147463259941456, -0.24359579328578626, 0.30179309757665723, 0.21658893985206484, 0.12304585275893232, 0.28281133086451704, 0.029187615341955325, 0.03616243507191924, 0.029375588909979152  ‚Ä¶  -0.08071746662465404, -0.2176101928258658, 0.20944684921170825, 0.043033273425352715, -0.040505542460853576, 0.17935596149079197, -0.08454569418519972, 0.0545941597033932, 0.12471741052450099, -0.24314124407858329], [0.28156471341150974, -0.6708572780452595, -0.1410302363738465, -0.08322589397277698, -0.022772599832907418, -0.04447265789199677, -0.016448068022011157, -0.07490911512503738, 0.2778432295769144, -0.10191899088372378  ‚Ä¶  -0.057272155080983836, 0.12817478092201395, 0.04623814480781884, -0.12184190164369117, 0.1987855635987229, -0.14533603246124993, -0.16334072868597016, -0.052369977381939437, 0.014904286931394959, -0.2440882678882144], [0.12108727495744157, -0.714787344982596, 0.01632521838262752, 0.04437570556908449, -0.041199280304144284, 0.052984488452616, 0.03796520200156107, 0.2791785910964288, 0.11530429924056099, 0.12178223160398421  ‚Ä¶  -0.07621847481721669, 0.18353870423743013, -0.19066653731436745, -0.09423224997242206, 0.14596847781388494, -0.09747986927777111, 0.16041150122587072, -0.02296513951256738, 0.06786878373578588, 0.15296635978447756]], 0)</code></pre><p>To not get too many entries let‚Äôs just look at the first 20 iterations again</p><pre><code class="language-julia hljs">R4 = gradient_descent(
    M,
    f4,
    grad_f,
    data[1];
    record=[RecordCount(),],
    return_state=true,
)</code></pre><pre><code class="nohighlight hljs"># Solver state for `Manopt.jl`s Gradient Descent
After 58 iterations

## Parameters
* retraction method: ManifoldsBase.ExponentialRetraction()

## Stepsize
ArmijoLinesearch(;
    initial_stepsize=1.0
    retraction_method=ManifoldsBase.ExponentialRetraction()
    contraction_factor=0.95
    sufficient_decrease=0.1
)

## Stopping criterion

Stop When _one_ of the following are fulfilled:
  * Max Iteration 200:  not reached
  * |grad f| &lt; 1.0e-8: reached
Overall: reached
This indicates convergence: Yes

## Record
(Iteration = Main.Notebook.RecordCount([25, 29, 33, 37, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188, 192, 196, 200, 204, 208, 212, 216, 220, 224, 229, 232, 237, 241, 245, 247, 249]),)</code></pre><pre><code class="language-julia hljs">get_record(R4)</code></pre><pre><code class="nohighlight hljs">58-element Vector{Int64}:
  25
  29
  33
  37
  40
  44
  48
  52
  56
  60
   ‚ãÆ
 220
 224
 229
 232
 237
 241
 245
 247
 249</code></pre><p>We can see that the number of cost function calls varies, depending on how many line search backtrack steps were required to obtain a good stepsize.</p><h2 id="Technical-details"><a class="docs-heading-anchor" href="#Technical-details">Technical details</a><a id="Technical-details-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-details" title="Permalink"></a></h2><p>This tutorial is cached. It was last run on the following package versions.</p><pre><code class="nohighlight hljs">Status `~/work/Manopt.jl/Manopt.jl/tutorials/Project.toml`
  [47edcb42] ADTypes v1.15.0
  [6e4b80f9] BenchmarkTools v1.6.0
  [5ae59095] Colors v0.13.1
  [31c24e10] Distributions v0.25.120
  [26cc04aa] FiniteDifferences v0.12.32
  [7073ff75] IJulia v1.29.0
  [8ac3fa9e] LRUCache v1.6.2
  [af67fdf4] ManifoldDiff v0.4.4
  [1cead3c2] Manifolds v0.10.22
  [3362f125] ManifoldsBase v1.2.0
  [0fc0a36d] Manopt v0.5.18 `~/work/Manopt.jl/Manopt.jl`
  [91a5bcdd] Plots v1.40.16
  [731186ca] RecursiveArrayTools v3.34.1
  [37e2e46d] LinearAlgebra v1.11.0
  [9a3f8284] Random v1.11.0</code></pre><p>This tutorial was last rendered July 4, 2025, 16:40:53.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../HowToDebug/">¬´ Print debug output</a><a class="docs-footer-nextpage" href="../ImplementASolver/">Implement a solver ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Friday 4 July 2025 17:44">Friday 4 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
