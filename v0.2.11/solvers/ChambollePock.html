<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Chambolle-Pock · Manopt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Manopt.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../about.html">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../tutorials/MeanAndMedian.html">get Started: Optimize!</a></li><li><a class="tocitem" href="../tutorials/BezierCurves.html">work with Bézier curves</a></li><li><a class="tocitem" href="../tutorials/GradientOfSecondOrderDifference.html">see the gradient of <span>$d_2$</span></a></li><li><a class="tocitem" href="../tutorials/JacobiFields.html">use Jacobi Fields</a></li></ul></li><li><a class="tocitem" href="../plans/index.html">Plans</a></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="ChambollePock.html">Chambolle-Pock</a><ul class="internal"><li><a class="tocitem" href="#Problem-and-Options-1"><span>Problem &amp; Options</span></a></li><li><a class="tocitem" href="#Useful-Terms-1"><span>Useful Terms</span></a></li><li><a class="tocitem" href="#Debug-1"><span>Debug</span></a></li><li><a class="tocitem" href="#Record-1"><span>Record</span></a></li><li><a class="tocitem" href="#Internals-1"><span>Internals</span></a></li></ul></li><li><a class="tocitem" href="conjugate_gradient_descent.html">Conjugate gradient descent</a></li><li><a class="tocitem" href="cyclic_proximal_point.html">Cyclic Proximal Point</a></li><li><a class="tocitem" href="DouglasRachford.html">Douglas–Rachford</a></li><li><a class="tocitem" href="gradient_descent.html">Gradient Descent</a></li><li><a class="tocitem" href="NelderMead.html">Nelder–Mead</a></li><li><a class="tocitem" href="particle_swarm.html">Particle Swarm Optimization</a></li><li><a class="tocitem" href="subgradient.html">Subgradient method</a></li><li><a class="tocitem" href="truncated_conjugate_gradient_descent.html">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="trust_regions.html">Riemannian Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../functions/index.html">Introduction</a></li><li><a class="tocitem" href="../functions/bezier.html">Bézier curves</a></li><li><a class="tocitem" href="../functions/costs.html">Cost functions</a></li><li><a class="tocitem" href="../functions/differentials.html">Differentials</a></li><li><a class="tocitem" href="../functions/adjoint_differentials.html">Adjoint Differentials</a></li><li><a class="tocitem" href="../functions/gradients.html">Gradients</a></li><li><a class="tocitem" href="../functions/Jacobi_fields.html">Jacobi Fields</a></li><li><a class="tocitem" href="../functions/proximal_maps.html">Proximal Maps</a></li><li><a class="tocitem" href="../functions/manifold.html">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../helpers/data.html">Data</a></li><li><a class="tocitem" href="../helpers/errorMeasures.html">Error Measures</a></li><li><a class="tocitem" href="../helpers/exports.html">Exports</a></li></ul></li><li><a class="tocitem" href="../list.html">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href="ChambollePock.html">Chambolle-Pock</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ChambollePock.html">Chambolle-Pock</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/solvers/ChambollePock.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ChambollePockSolver-1"><a class="docs-heading-anchor" href="#ChambollePockSolver-1">The Riemannian Chambolle-Pock Algorithm</a><a class="docs-heading-anchor-permalink" href="#ChambollePockSolver-1" title="Permalink"></a></h1><p>The Riemannian Chambolle–Pock is a generalization of the Chambolle–Pock algorithm<sup class="footnote-reference"><a id="citeref-ChambollePock2011" href="#footnote-ChambollePock2011">[ChambollePock2011]</a></sup>. It is also known as primal dual hybrig gradient (PDHG) or primal dual proximal splitting (PDPS) algorithm.</p><p>In order to minimize over p\in\mathcal M§ the cost function consisting of</p><div>\[F(p) + G(\Lambda(p)),\]</div><p>where <span>$F:\mathcal M \to \overline{\mathbb R}$</span>, <span>$G:\mathcal N \to \overline{\mathbb R}$</span>, and <span>$\Lambda:\mathcal M \to\mathcal N$</span>. If the manifolds <span>$\mathcal M$</span> or <span>$\mathcal N$</span> are not Hadamard, it has to be considered locally, i.e. on geodesically convex sets <span>$\mathcal C \subset \mathcal M$</span> and <span>$\mathcal D \subset\mathcal N$</span> such that <span>$\Lambda(\mathcal C) \subset \mathcal D$</span>.</p><p>The algorithm is available in four variants: exact versus linearized (see <code>variant</code>) as well as with primal versus dual relaxation (see <code>relax</code>). For more details, see <sup class="footnote-reference"><a id="citeref-BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020" href="#footnote-BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020">[BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020]</a></sup>. In the following we note the case of the exact, primal relaxed Riemannian Chambolle–Pock algorithm.</p><p>Given base points <span>$m\in\mathcal C$</span>, <span>$n=\Lambda(m)\in\mathcal D$</span>, initial primal and dual values <span>$p^{(0)} \in \mathcal C$</span>, <span>$\xi_n^{(0)} \in T_n^*\mathcal N$</span>, and primal and dual step sizes <span>$\sigma_0$</span>, <span>$\tau_0$</span>, relaxation <span>$\theta_0$</span>, as well as acceleration <span>$\gamma$</span>.</p><p>As an initialization, perform <span>$\bar p^{(0)} \gets p^{(0)}$</span>.</p><p>The algorithms performs the steps <span>$k=1,\ldots,$</span> (until a <a href="index.html#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> is fulfilled with)</p><ol><li><div>\[\xi^{(k+1)}_n = \operatorname{prox}_{\tau_k G_n^*}\Bigl(\xi_n^{(k)} + \tau_k \bigl(\log_n \Lambda (\bar p^{(k)})\bigr)^\flat\Bigr)\]</div></li><li><div>\[p^{(k+1)} = \operatorname{prox}_{\sigma_k F}\biggl(\exp_{p^{(k)}}\Bigl( \operatorname{PT}_{p^{(k)}\gets m}\bigl(-\sigma_k D\Lambda(m)^*[\xi_n^{(k+1)}]\bigr)^\sharp\Bigr)\biggr)\]</div></li><li>Update<ul><li><span>$\theta_k = (1+2\gamma\sigma_k)^{-\frac{1}{2}}$</span></li><li><span>$\sigma_{k+1} = \sigma_k\theta_k$</span></li><li><span>$\tau_{k+1} =  \frac{\tau_k}{\theta_k}$</span></li></ul></li><li><div>\[\bar p^{(k+1)}  = \exp_{p^{(k+1)}}\bigl(-\theta_k \log_{p^{(k+1)}} p^{(k)}\bigr)\]</div></li></ol><p>Furthermore you can exchange the exponential map, the logarithmic map, and the parallel transport by a retraction, an in verse retraction and a vector transport.</p><p>Finally you can also update the base points <span>$m$</span> and <span>$n$</span> during the iterations. This introduces a few additional vector transports. The same holds for the case that <span>$\Lambda(m^{(k)})\neq n^{(k)}$</span> at some point. All these cases are covered in the algorithm.</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.ChambollePock" href="#Manopt.ChambollePock"><code>Manopt.ChambollePock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ChambollePock(M, N, cost, x0, ξ0, m, n, prox_F, prox_G_dual, forward_operator, adjoint_DΛ)</code></pre><p>Perform the Riemannian Chambolle–Pock algorithm.</p><p>Given a <code>cost</code> function <span>$\mathcal E\colon\mathcal M \to ℝ$</span> of the form</p><div>\[\mathcal E(x) = F(x) + G( Λ(x) ),\]</div><p>where <span>$F\colon\mathcal M \to ℝ$</span>, <span>$G\colon\mathcal N \to ℝ$</span>, and <span>$\Lambda\colon\mathcal M \to \mathcal N$</span>. The remaining input parameters are</p><ul><li><code>x,ξ</code> primal and dual start points <span>$x\in\mathcal M$</span> and <span>$\xi\in T_n\mathcal N$</span></li><li><code>m,n</code> base points on <span>$\mathcal M$</span> and <span>$\mathcal N$</span>, respectively.</li><li><code>forward_operator</code> the operator <span>$Λ(⋅)$</span> or its linearization <span>$DΛ(⋅)[⋅]$</span>, depending on whether <code>:exact</code> or <code>:linearized</code> is chosen.</li><li><code>adjoint_linearized_operator</code> the adjoint <span>$DΛ^*$</span> of the linearized operator <span>$DΛ(m)\colon T_{m}\mathcal M \to T_{Λ(m)}\mathcal N$</span></li><li><code>prox_F, prox_G_Dual</code> the proximal maps of <span>$F$</span> and <span>$G^\ast_n$</span></li></ul><p>By default, this performs the exact Riemannian Chambolle Pock algorithm, see the opional parameter <code>DΛ</code> for ther linearized variant.</p><p>For more details on the algorithm, see<sup class="footnote-reference"><a id="citeref-BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020" href="#footnote-BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020">[BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020]</a></sup>.</p><p><strong>Optional Parameters</strong></p><ul><li><code>acceleration</code> – (<code>0.05</code>)</li><li><code>dual_stepsize</code> – (<code>1/sqrt(8)</code>) proximnal parameter of the primal prox</li><li><code>Λ</code> (<code>missing</code>) the exact operator, that is required if the forward operator is linearized; <code>missing</code> indicates, that the forward operator is exact.</li><li><code>primal_stepsize</code> – (<code>1/sqrt(8)</code>) proximnal parameter of the dual prox</li><li><code>relaxation</code> – (<code>1.</code>)</li><li><code>relax</code> – (<code>:primal</code>) whether to relax the primal or dual</li><li><code>variant</code> - (<code>:exact</code> if <code>Λ</code> is missing, otherwise <code>:linearized</code>) variant to use. Note that this changes the arguments the <code>forward_operator</code> will be called.</li><li><code>stopping_criterion</code> – (<code>stopAtIteration(100)</code>) a <a href="index.html#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a></li><li><code>update_primal_base</code> – (<code>missing</code>) function to update <code>m</code> (identity by default/missing)</li><li><code>update_dual_base</code> – (<code>missing</code>) function to update <code>n</code> (identity by default/missing)</li><li><code>retraction_method</code> – (<code>ExponentialRetraction()</code>) the rectraction to use</li><li><code>inverse_retraction_method</code> - (<code>LogarithmicInverseRetraction()</code>) an inverse retraction to use.</li><li><code>vector_transport_method</code> - (<code>ParallelTransport()</code>) a vector transport to use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/solvers/ChambollePock.jl#L1-L47">source</a></section></article><h2 id="Problem-and-Options-1"><a class="docs-heading-anchor" href="#Problem-and-Options-1">Problem &amp; Options</a><a class="docs-heading-anchor-permalink" href="#Problem-and-Options-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.PrimalDualProblem" href="#Manopt.PrimalDualProblem"><code>Manopt.PrimalDualProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrimalDualProblem {mT &lt;: Manifold, nT &lt;: Manifold} &lt;: PrimalDualProblem} &lt;: Problem</code></pre><p>Describes a Problem for the linearized Chambolle-Pock algorithm.</p><p><strong>Fields</strong></p><ul><li><code>M</code>, <code>N</code> – two manifolds <span>$\mathcal M$</span>, <span>$\mathcal N$</span></li><li><code>cost</code> <span>$F + G(Λ(⋅))$</span> to evaluate interims cost function values</li><li><code>forward_oprator</code> the operator for the forward operation in the algorthm, either <span>$Λ$</span> (exact) or <span>$DΛ$</span> (linearized).</li><li><code>linearized_adjoint_operator</code> The adjoint differential <span>$(DΛ)^* \colon \mathcal N \to T\mathcal M$</span></li><li><code>prox_F</code> the proximal map belonging to <span>$f$</span></li><li><code>prox_G_dual</code> the proximal map belonging to <span>$g_n^*$</span></li><li><code>Λ</code> – (<code>fordward_operator</code>) for the linearized variant, this has to be set to the exact forward operator. This operator is required in several variants of the linearized algorithm. Since the exact variant is the default, <code>Λ</code> is by default set to <code>forward_operator</code>.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">LinearizedPrimalDualProblem(M, N, cost, prox_F, prox_G_dual, forward_operator, adjoint_linearized_operator,Λ=forward_operator)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.PrimalDualOptions" href="#Manopt.PrimalDualOptions"><code>Manopt.PrimalDualOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrimalDualOptions</code></pre><p>A general type for all primal dual based options to be used within primal dual based algorithms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.ChambollePockOptions" href="#Manopt.ChambollePockOptions"><code>Manopt.ChambollePockOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ChambollePockOptions &lt;: PrimalDualOptions</code></pre><p>stores all options and variables within a linearized or exact Chambolle Pock. The following list provides the order for the constructor, where the previous iterates are initialized automatically and values with a default may be left out.</p><ul><li><code>m</code> - base point on $ \mathcal M $</li><li><code>n</code> - base point on $ \mathcal N $</li><li><code>x</code> - an initial point on <span>$x^{(0)} \in \mathcal M$</span> (and its previous iterate)</li><li><code>ξ</code> - an initial tangent vector <span>$\xi^{(0)}\in T^*\mathcal N$</span> (and its previous iterate)</li><li><code>xbar</code> - the relaxed iterate used in the next dual update step (when using <code>:primal</code> relaxation)</li><li><code>ξbar</code> - the relaxed iterate used in the next primal update step (when using <code>:dual</code> relaxation)</li><li><code>Θ</code> – factor to damp the helping <span>$\tilde x$</span></li><li><code>primal_stepsize</code> – (<code>1/sqrt(8)</code>) proximal parameter of the primal prox</li><li><code>dual_stepsize</code> – (<code>1/sqrt(8)</code>) proximnal parameter of the dual prox</li><li><code>acceleration</code> – (<code>0.</code>) acceleration factor due to Chambolle &amp; Pock</li><li><code>relaxation</code> – (<code>1.</code>) relaxation in the primal relaxation step (to compute <code>xbar</code>)</li><li><code>relax</code> – (<code>_primal</code>) which variable to relax (<code>:primal</code> or <code>:dual</code>)</li><li><code>stop</code> - a <a href="index.html#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a></li><li><code>type</code> – (<code>exact</code>) whether to perform an <code>:exact</code> or <code>:linearized</code> Chambolle-Pock</li><li><code>update_primal_base</code> (<code>(p,o,i) -&gt; o.m</code>) function to update the primal base</li><li><code>update_dual_base</code> (<code>(p,o,i) -&gt; o.n</code>) function to update the dual base</li><li><code>retraction_method</code> – (<code>ExponentialRetraction()</code>) the rectraction to use</li><li><code>inverse_retraction_method</code> - (<code>LogarithmicInverseRetraction()</code>) an inverse retraction to use.</li><li><code>vector_transport_method</code> - (<code>ParallelTransport()</code>) a vector transport to use</li></ul><p>where for the last two the functions a <a href="../plans/index.html#Manopt.Problem"><code>Problem</code></a><code>p</code>, <a href="../plans/index.html#Manopt.Options"><code>Options</code></a><code>o</code> and the current iterate <code>i</code> are the arguments. If you activate these to be different from the default identity, you have to provide <code>p.Λ</code> for the algorithm to work (which might be <code>missing</code> in the linearized case).</p><p><strong>Constructor</strong></p><pre><code class="language-none">ChambollePockOptions(m::P, n::Q, x::P, ξ::T, primal_stepsize::Float64, dual_stepsize::Float64;
    acceleration::Float64 = 0.0,
    relaxation::Float64 = 1.0,
    relax::Symbol = :primal,
    stopping_criterion::StoppingCriterion = StopAfterIteration(300),
    variant::Symbol = :exact,
    update_primal_base::Union{Function,Missing} = missing,
    update_dual_base::Union{Function,Missing} = missing,
    retraction_method = ExponentialRetraction(),
    inverse_retraction_method = LogarithmicInverseRetraction(),
    vector_transport_method = ParallelTransport(),
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L56-L101">source</a></section></article><h2 id="Useful-Terms-1"><a class="docs-heading-anchor" href="#Useful-Terms-1">Useful Terms</a><a class="docs-heading-anchor-permalink" href="#Useful-Terms-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.primal_residual" href="#Manopt.primal_residual"><code>Manopt.primal_residual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">primal_residual(p, o, x_old, ξ_old, n_old)</code></pre><p>Compute the primal residual at current iterate <span>$k$</span> given the necessary values <span>$x_{k-1}, ξ_{k-1}, and $n_{k-1}$</span> from the previous iterate.</p><div>\[\Bigl\lVert
\frac{1}{σ}\operatorname{retr}^{-1}_{x_{k}}x_{k-1} -
V_{x_k\gets m_k}\bigl(DΛ^*(m_k)\bigl[V_{n_k\gets n_{k-1}}ξ_{k-1} - ξ_k \bigr]
\Bigr\rVert\]</div><p>where <span>$V_{\cdot\gets\cdot}$</span> is the vector transport used in the <a href="ChambollePock.html#Manopt.ChambollePockOptions"><code>ChambollePockOptions</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L177-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.dual_residual" href="#Manopt.dual_residual"><code>Manopt.dual_residual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dual_residual(p, o, x_old, ξ_old, n_old)</code></pre><p>Compute the dual residual at current iterate <span>$k$</span> given the necessary values <span>$x_{k-1}, ξ_{k-1}, and $n_{k-1}$</span> from the previous iterate. The formula is slightly different depending on the <code>o.variant</code> used:</p><p>For the <code>:lineaized</code> it reads</p><div>\[\Bigl\lVert
\frac{1}{τ}\bigl(
V_{n_{k}\gets n_{k-1}}(ξ_{k-1})
- ξ_k
\bigr)
-
DΛ(m_k)\bigl[
V_{m_k\gets x_k}\operatorname{retr}^{-1}_{x_{k}}x_{k-1}
\bigr]
\Bigr\rVert\]</div><p>and for the <code>:exact</code> variant</p><div>\[\Bigl\lVert
\frac{1}{τ} V_{n_{k}\gets n_{k-1}}(ξ_{k-1})
-
\operatorname{retr}^{-1}_{n_{k}}\bigl(
Λ(\operatorname{retr}_{m_{k}}(V_{m_k\gets x_k}\operatorname{retr}^{-1}_{x_{k}}x_{k-1}))
\bigr)
\Bigr\rVert\]</div><p>where in both cases <span>$V_{\cdot\gets\cdot}$</span> is the vector transport used in the <a href="ChambollePock.html#Manopt.ChambollePockOptions"><code>ChambollePockOptions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L209-L243">source</a></section></article><h2 id="Debug-1"><a class="docs-heading-anchor" href="#Debug-1">Debug</a><a class="docs-heading-anchor-permalink" href="#Debug-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugDualBaseIterate" href="#Manopt.DebugDualBaseIterate"><code>Manopt.DebugDualBaseIterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DebugDualBaseIterate(io::IO=stdout)</code></pre><p>Print the dual base variable by using <a href="../plans/index.html#Manopt.DebugEntry"><code>DebugEntry</code></a>, see their constructors for detail. This method is further set display <code>o.n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L476-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugDualBaseChange" href="#Manopt.DebugDualBaseChange"><code>Manopt.DebugDualBaseChange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DebugDualChange(a=StoreOptionsAction((:ξ)),io::IO=stdout)</code></pre><p>Print the change of the dual base variable by using <a href="../plans/index.html#Manopt.DebugEntryChange"><code>DebugEntryChange</code></a>, see their constructors for detail, on <code>o.n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L484-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugPrimalBaseIterate" href="#Manopt.DebugPrimalBaseIterate"><code>Manopt.DebugPrimalBaseIterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DebugPrimalBaseIterate(io::IO=stdout)</code></pre><p>Print the primal base variable by using <a href="../plans/index.html#Manopt.DebugEntry"><code>DebugEntry</code></a>, see their constructors for detail. This method is further set display <code>o.m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L496-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugPrimalBaseChange" href="#Manopt.DebugPrimalBaseChange"><code>Manopt.DebugPrimalBaseChange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DebugPrimalBaseChange(a::StoreOptionsAction=StoreOptionsAction((:m)),io::IO=stdout)</code></pre><p>Print the change of the primal base variable by using <a href="../plans/index.html#Manopt.DebugEntryChange"><code>DebugEntryChange</code></a>, see their constructors for detail, on <code>o.n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L505-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugDualChange" href="#Manopt.DebugDualChange"><code>Manopt.DebugDualChange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DebugDualChange(opts...)</code></pre><p>Print the change of the dual variable, similar to <a href="../plans/index.html#Manopt.DebugChange"><code>DebugChange</code></a>, see their constructors for detail, but with a different calculation of the change, since the dual variable lives in (possibly different) tangent spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L434-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugDualIterate" href="#Manopt.DebugDualIterate"><code>Manopt.DebugDualIterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DebugDualIterate(e)</code></pre><p>Print the dual variable by using <a href="../plans/index.html#Manopt.DebugEntry"><code>DebugEntry</code></a>, see their constructors for detail. This method is further set display <code>o.ξ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L425-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugDualResidual" href="#Manopt.DebugDualResidual"><code>Manopt.DebugDualResidual</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DebugDualResidual &lt;: DebugAction</code></pre><p>A Debug action to print the dual residual. The constructor accepts a printing function and some (shared) storage, which should at least record <code>:x</code>, <code>:ξ</code> and <code>:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L296-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugPrimalChange" href="#Manopt.DebugPrimalChange"><code>Manopt.DebugPrimalChange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DebugPrimalChange(opts...)</code></pre><p>Print the change of the primal variable by using <a href="../plans/index.html#Manopt.DebugChange"><code>DebugChange</code></a>, see their constructors for detail.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L409-L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugPrimalIterate" href="#Manopt.DebugPrimalIterate"><code>Manopt.DebugPrimalIterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DebugPrimalIterate(opts...)</code></pre><p>Print the change of the primal variable by using <a href="../plans/index.html#Manopt.DebugIterate"><code>DebugIterate</code></a>, see their constructors for detail.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L417-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugPrimalResidual" href="#Manopt.DebugPrimalResidual"><code>Manopt.DebugPrimalResidual</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DebugPrimalResidual &lt;: DebugAction</code></pre><p>A Debug action to print the primal residual. The constructor accepts a printing function and some (shared) storage, which should at least record <code>:x</code>, <code>:ξ</code> and <code>:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L329-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DebugPrimalDualResidual" href="#Manopt.DebugPrimalDualResidual"><code>Manopt.DebugPrimalDualResidual</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DebugPrimalDualResidual &lt;: DebugAction</code></pre><p>A Debug action to print the primaldual residual. The constructor accepts a printing function and some (shared) storage, which should at least record <code>:x</code>, <code>:ξ</code> and <code>:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L363-L369">source</a></section></article><h2 id="Record-1"><a class="docs-heading-anchor" href="#Record-1">Record</a><a class="docs-heading-anchor-permalink" href="#Record-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.RecordDualBaseIterate" href="#Manopt.RecordDualBaseIterate"><code>Manopt.RecordDualBaseIterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RecordDualBaseIterate(n)</code></pre><p>Create an <a href="../plans/index.html#Manopt.RecordAction"><code>RecordAction</code></a> that records the dual base point, i.e. <a href="../plans/index.html#Manopt.RecordEntry"><code>RecordEntry</code></a> of <code>o.n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L556-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.RecordDualBaseChange" href="#Manopt.RecordDualBaseChange"><code>Manopt.RecordDualBaseChange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RecordDualBaseChange(e)</code></pre><p>Create an <a href="../plans/index.html#Manopt.RecordAction"><code>RecordAction</code></a> that records the dual base point change, i.e. <a href="../plans/index.html#Manopt.RecordEntryChange"><code>RecordEntryChange</code></a> of <code>o.n</code> with distance to the last value to store a value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L564-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.RecordDualChange" href="#Manopt.RecordDualChange"><code>Manopt.RecordDualChange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RecordDualChange()</code></pre><p>Create the action either with a given (shared) Storage, which can be set to the <code>values</code> Tuple, if that is provided).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L548-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.RecordDualIterate" href="#Manopt.RecordDualIterate"><code>Manopt.RecordDualIterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RecordDualIterate(ξ)</code></pre><p>Create an <a href="../plans/index.html#Manopt.RecordAction"><code>RecordAction</code></a> that records the dual base point, i.e. <a href="../plans/index.html#Manopt.RecordEntry"><code>RecordEntry</code></a> of <code>o.ξ</code>, so .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L540-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.RecordPrimalBaseIterate" href="#Manopt.RecordPrimalBaseIterate"><code>Manopt.RecordPrimalBaseIterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RecordPrimalBaseIterate(x)</code></pre><p>Create an <a href="../plans/index.html#Manopt.RecordAction"><code>RecordAction</code></a> that records the primal base point, i.e. <a href="../plans/index.html#Manopt.RecordEntry"><code>RecordEntry</code></a> of <code>o.m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L572-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.RecordPrimalBaseChange" href="#Manopt.RecordPrimalBaseChange"><code>Manopt.RecordPrimalBaseChange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RecordPrimalBaseChange()</code></pre><p>Create an <a href="../plans/index.html#Manopt.RecordAction"><code>RecordAction</code></a> that records the primal base point change, i.e. <a href="../plans/index.html#Manopt.RecordEntryChange"><code>RecordEntryChange</code></a> of <code>o.m</code> with distance to the last value to store a value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L579-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.RecordPrimalChange" href="#Manopt.RecordPrimalChange"><code>Manopt.RecordPrimalChange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RecordPrimalChange(a)</code></pre><p>Create an <a href="../plans/index.html#Manopt.RecordAction"><code>RecordAction</code></a> that records the primal value change, i.e. <a href="../plans/index.html#Manopt.RecordChange"><code>RecordChange</code></a>, since we just redord the change of <code>o.x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L524-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.RecordPrimalIterate" href="#Manopt.RecordPrimalIterate"><code>Manopt.RecordPrimalIterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RecordDualBaseIterate(x)</code></pre><p>Create an <a href="../plans/index.html#Manopt.RecordAction"><code>RecordAction</code></a> that records the dual base point, i.e. <a href="../plans/index.html#Manopt.RecordIterate"><code>RecordIterate</code></a>, i.e. <code>o.x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/plans/primal_dual_plan.jl#L532-L537">source</a></section></article><h2 id="Internals-1"><a class="docs-heading-anchor" href="#Internals-1">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Manopt.update_prox_parameters!" href="#Manopt.update_prox_parameters!"><code>Manopt.update_prox_parameters!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_prox_parameters!(o)</code></pre><p>update the prox parameters as described in Algorithm 2 of Chambolle, Pock, 2010, i.e.</p><ol><li><span>$\theta_{n} = \frac{1}{\sqrt{1+2\gamma\tau_n}}$</span></li><li><span>$\tau_{n+1} = \theta_n\tau_n$</span></li><li><span>$\sigma_{n+1} = \frac{\sigma_n}{\theta_n}$</span></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/940068f79cb1fd82141f0706cfe6c7525aca12b9/src/solvers/ChambollePock.jl#L233-L240">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020"><a class="tag is-link" href="#citeref-BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020">BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez2020</a><blockquote><p>R. Bergmann, R. Herzog, M. Silva Louzeiro, D. Tenbrinck, J. Vidal-Núñez: <em>Fenchel Duality Theory and a Primal-Dual Algorithm on Riemannian Manifolds</em>, arXiv: <a href="http://arxiv.org/abs/1908.02022">1908.02022</a> accepted for publication in Foundations of Computational Mathematics</p></blockquote></li><li class="footnote" id="footnote-ChambollePock2011"><a class="tag is-link" href="#citeref-ChambollePock2011">ChambollePock2011</a><blockquote><p>A. Chambolle, T. Pock: <em>A first-order primal-dual algorithm for convex problems with applications to imaging</em>, Journal of Mathematical Imaging and Vision 40(1), 120–145, 2011. doi: <a href="https://dx.doi.org/10.1007/s10851-010-0251-1">10.1007/s10851-010-0251-1</a></p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><a class="docs-footer-nextpage" href="conjugate_gradient_descent.html">Conjugate gradient descent »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 21 November 2020 16:18">Saturday 21 November 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
