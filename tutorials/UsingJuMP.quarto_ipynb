{  "cells": [    {      "cell_type": "markdown",      "metadata": {},      "source": [        "---\n",        "title: \"Using Manopt.jl from within JuMP\"\n",        "author: Ronny Bergmann\n",        "---\n",        "\n",        "\n",        "In this tutorial we aim to illustrate how to use manifolds and the algorithms from [`Manopt.jl`](https://manoptjl.org) within the [JuMP](https://jump.dev) framework by implementing the [get started](getstarted.md) tutorial again using JuMP combining it with for example their [get started](https://jump.dev/JuMP.jl/stable/tutorials/getting_started/getting_started_with_JuMP/#Getting-started-with-JuMP) tutorial.\n"      ],      "id": "7daa8c18"    },    {      "cell_type": "code",      "metadata": {},      "source": [        "#| echo: false\n",        "#| code-fold: true\n",        "#| output: false\n",        "using Pkg;\n",        "cd(@__DIR__)\n",        "Pkg.activate(\".\"); # for reproducibility use the local tutorial environment."      ],      "id": "28e3fafc",      "execution_count": null,      "outputs": []    },    {      "cell_type": "code",      "metadata": {},      "source": [        "using JuMP, Manopt, Manifolds"      ],      "id": "d5f83337",      "execution_count": null,      "outputs": []    },    {      "cell_type": "markdown",      "metadata": {},      "source": [        "First we generate the same data for the [Riemannian center of mass]() as before\n"      ],      "id": "ff977638"    },    {      "cell_type": "code",      "metadata": {},      "source": [        "n = 100\n",        "σ = π / 8\n",        "M = Sphere(2)\n",        "p = 1 / sqrt(2) * [1.0, 0.0, 1.0]\n",        "data = [exp(M, p,  σ * rand(M; vector_at=p)) for i in 1:n];"      ],      "id": "7547c31e",      "execution_count": null,      "outputs": []    },    {      "cell_type": "markdown",      "metadata": {},      "source": [        "and we start by stating that our [JuMP model](https://jump.dev/JuMP.jl/stable/manual/models/) is\n"      ],      "id": "7fda01e4"    },    {      "cell_type": "code",      "metadata": {},      "source": [        "model = Model(Manopt.JuMP_Optimizer)"      ],      "id": "c9e77141",      "execution_count": null,      "outputs": []    },    {      "cell_type": "markdown",      "metadata": {},      "source": [        "Next we add a [JuMP variable](https://jump.dev/JuMP.jl/stable/manual/variables/),\n",        "where we specify the manifold using the `in` keyword, `start=` cares for the initialisation\n"      ],      "id": "9a0df6fe"    },    {      "cell_type": "code",      "metadata": {},      "source": [        "@variable(model, p[i=1:3] in M, start=p[i])"      ],      "id": "2d66433b",      "execution_count": null,      "outputs": []    },    {      "cell_type": "markdown",      "metadata": {},      "source": [        "For now this is restricted to array-type-representations of points and tangent vectors.\n",        "\n",        "## Variant I: Specify the\n",        "\n",        "One can specify a cost in the embedding and get an approximate gradient in the embedding that is “converted” into a Riemannian one, see [AD](AutomaticDifferentiation.md).\n"      ],      "id": "325693e6"    },    {      "cell_type": "code",      "metadata": {},      "source": [        "f(p) = sum(1 / (2 * n) * norm.(Ref(p) - data) .^ 2)\n",        "grad_f(p) = sum(1 / n * grad_distance.(Ref(M), data, Ref(p)));\n",        "# TODO: how to set the objective to an implemented function ?\n",        "# TODO 100% unsure how to set a gradient since that seems to be nowhere documented ?!\n",        "@objective(model, f)"      ],      "id": "1aa0d737",      "execution_count": null,      "outputs": []    },    {      "cell_type": "markdown",      "metadata": {},      "source": [        "We set the solver to use to be [gradient descent](gradient_descent.md)\n"      ],      "id": "041135a4"    },    {      "cell_type": "code",      "metadata": {},      "source": [        "set_attribute(\"descent_state_type\", GradientDescentState)"      ],      "id": "9f145642",      "execution_count": null,      "outputs": []    },    {      "cell_type": "markdown",      "metadata": {},      "source": [        "Then we can call the solver\n"      ],      "id": "d5cd37c7"    },    {      "cell_type": "code",      "metadata": {},      "source": [        "optimize!(model)"      ],      "id": "825df2a2",      "execution_count": null,      "outputs": []    },    {      "cell_type": "markdown",      "metadata": {},      "source": [        "and look at the solution\n"      ],      "id": "278085c2"    },    {      "cell_type": "code",      "metadata": {},      "source": [        "solution_summary(model)"      ],      "id": "ab4e7dc7",      "execution_count": null,      "outputs": []    },    {      "cell_type": "markdown",      "metadata": {},      "source": [        "## Vriant II: Specify the objective directly\n",        "\n",        "The [objective](https://jump.dev/JuMP.jl/stable/manual/objective/) is set for example using our [Objectives](objective.md).\n"      ],      "id": "12300491"    },    {      "cell_type": "code",      "metadata": {},      "source": [        "model2 = Model(Manopt.JuMP_Optimizer)\n",        "@variable(model2, p[i=1:3] in M, start = p[i])\n",        "f(M, p) = sum(1 / (2 * n) * distance.(Ref(M), Ref(p), data) .^ 2)\n",        "grad_f(M, p) = sum(1 / n * grad_distance.(Ref(M), data, Ref(p)));\n",        "# ToDo: Does not yet work, but I thought it should by now?\n",        "@objective(model2, Min, Manopt.ManifoldGradientObjective(f, grad_f))\n",        "set_attribute(\"descent_state_type\", GradientDescentState)"      ],      "id": "e080cfce",      "execution_count": null,      "outputs": []    },    {      "cell_type": "markdown",      "metadata": {},      "source": [        "And we issue again the optimization\n"      ],      "id": "d54ebdd5"    },    {      "cell_type": "code",      "metadata": {},      "source": [        "optimize!(model2)"      ],      "id": "2e5e703d",      "execution_count": null,      "outputs": []    },    {      "cell_type": "markdown",      "metadata": {},      "source": [        "and look at the solution\n"      ],      "id": "d38a3f9e"    },    {      "cell_type": "code",      "metadata": {},      "source": [        "solution_summary(model2)"      ],      "id": "02a9da93",      "execution_count": null,      "outputs": []    }  ],  "metadata": {    "kernelspec": {      "name": "julia-1.11",      "language": "julia",      "display_name": "Julia 1.11.5",      "path": "/Users/ronnber/Library/Jupyter/kernels/julia-1.11"    }  },  "nbformat": 4,  "nbformat_minor": 5}