<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gradient Descent ¬∑ Manopt.jl</title><meta name="title" content="Gradient Descent ¬∑ Manopt.jl"/><meta property="og:title" content="Gradient Descent ¬∑ Manopt.jl"/><meta property="twitter:title" content="Gradient Descent ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/getstarted/">üèîÔ∏è Get started with Manopt.jl</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../../tutorials/EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../../tutorials/HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../../tutorials/ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do constrained optimization</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../">List of Solvers</a></li><li><a class="tocitem" href="../adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../cma_es/">CMA-ES</a></li><li><a class="tocitem" href="../conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../conjugate_residual/">Conjugate Residual</a></li><li><a class="tocitem" href="../convex_bundle_method/">Convex bundle method</a></li><li><a class="tocitem" href="../cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="../exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../FrankWolfe/">Frank-Wolfe</a></li><li class="is-active"><a class="tocitem" href>Gradient Descent</a><ul class="internal"><li><a class="tocitem" href="#State"><span>State</span></a></li><li><a class="tocitem" href="#Direction-update-rules"><span>Direction update rules</span></a></li><li><a class="tocitem" href="#Debug-actions"><span>Debug actions</span></a></li><li><a class="tocitem" href="#Record-actions"><span>Record actions</span></a></li><li><a class="tocitem" href="#sec-gradient-descent-technical-details"><span>Technical details</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../interior_point_Newton/">Interior Point Newton</a></li><li><a class="tocitem" href="../LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="../mesh_adaptive_direct_search/">MADS</a></li><li><a class="tocitem" href="../NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="../particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../projected_gradient_method/">Projected Gradient Method</a></li><li><a class="tocitem" href="../proximal_bundle_method/">Proximal bundle method</a></li><li><a class="tocitem" href="../quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../../plans/problem/">Problem</a></li><li><a class="tocitem" href="../../plans/objective/">Objective</a></li><li><a class="tocitem" href="../../plans/state/">Solver State</a></li><li><a class="tocitem" href="../../plans/stepsize/">Stepsize</a></li><li><a class="tocitem" href="../../plans/stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../../plans/debug/">Debug Output</a></li><li><a class="tocitem" href="../../plans/record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>Gradient Descent</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gradient Descent</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/solvers/gradient_descent.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Gradient-descent"><a class="docs-heading-anchor" href="#Gradient-descent">Gradient descent</a><a id="Gradient-descent-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-descent" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.gradient_descent" href="#Manopt.gradient_descent"><code>Manopt.gradient_descent</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient_descent(M, f, grad_f, p=rand(M); kwargs...)
gradient_descent(M, gradient_objective, p=rand(M); kwargs...)
gradient_descent!(M, f, grad_f, p; kwargs...)
gradient_descent!(M, gradient_objective, p; kwargs...)</code></pre><p>perform the gradient descent algorithm</p><p class="math-container">\[p_{k+1} = \operatorname{retr}_{p_k}\bigl( s_k\operatorname{grad}f(p_k) \bigr),
\qquad k=0,1,‚Ä¶\]</p><p>where <span>$s_k &gt; 0$</span> denotes a step size.</p><p>The algorithm can be performed in-place of <code>p</code>.</p><p><strong>Input</strong></p><ul><li><code>M::</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code></code>: a Riemannian manifold <span>$\mathcal M$</span></li><li><code>f</code>: a cost function <span>$f: \mathcal M‚Üí ‚Ñù$</span> implemented as <code>(M, p) -&gt; v</code></li><li><code>grad_f</code>: the (Riemannian) gradient <span>$\operatorname{grad}f: \mathcal M ‚Üí T_{p}\mathcal M$</span> of f as a function <code>(M, p) -&gt; X</code> or a function <code>(M, X, p) -&gt; X</code> computing <code>X</code> in-place</li><li><code>p</code>: a point on the manifold <span>$\mathcal M$</span></li></ul><p>Alternatively to <code>f</code> and <code>grad_f</code> you can provide the corresponding <a href="../../plans/objective/#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective</code></a> <code>gradient_objective</code> directly.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>direction=</code><a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a><code>()</code>: specify to perform a certain processing of the direction, for example <a href="#Manopt.Nesterov"><code>Nesterov</code></a>, <a href="#Manopt.MomentumGradient"><code>MomentumGradient</code></a> or <a href="#Manopt.AverageGradient"><code>AverageGradient</code></a>.</p></li><li><p><code>evaluation=</code><a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.For example <code>grad_f(M,p)</code> allocates, but <code>grad_f!(M, X, p)</code> computes the result in-place of <code>X</code>.</p></li><li><p><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></p></li><li><p><code>stepsize=</code><a href="../../plans/stepsize/#Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}"><code>default_stepsize</code></a><code>(M, GradientDescentState)</code>: a functor inheriting from <a href="../../plans/stepsize/#Stepsize"><code>Stepsize</code></a> to determine a step size</p></li><li><p><code>stopping_criterion=</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(200)</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenAny"><code>|</code></a><a href="../../plans/stopping_criteria/#Manopt.StopWhenGradientNormLess"><code>StopWhenGradientNormLess</code></a><code>(1e-8)</code>: a functor indicating that the stopping criterion is fulfilled</p></li><li><p><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>storing the gradient at the current iterate</p></li></ul><p>All other keyword arguments are passed to <a href="../../plans/state/#Manopt.decorate_state!"><code>decorate_state!</code></a> for state decorators or <a href="../../plans/objective/#Manopt.decorate_objective!"><code>decorate_objective!</code></a> for objective decorators, respectively.</p><p>If you provide the <a href="../../plans/objective/#Manopt.ManifoldGradientObjective"><code>ManifoldGradientObjective</code></a> directly, the <code>evaluation=</code> keyword is ignored. The decorations are still applied to the objective.</p><p>If you activate tutorial mode (cf. <a href="../../plans/#Manopt.is_tutorial_mode"><code>is_tutorial_mode</code></a>), this solver provides additional debug warnings.</p><p><strong>Output</strong></p><p>The obtained approximate minimizer <span>$p^*$</span>. To obtain the whole final state of the solver, see <a href="../#Manopt.get_solver_return"><code>get_solver_return</code></a> for details, especially the <code>return_state=</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/solvers/gradient_descent.jl#L165-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.gradient_descent!" href="#Manopt.gradient_descent!"><code>Manopt.gradient_descent!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient_descent(M, f, grad_f, p=rand(M); kwargs...)
gradient_descent(M, gradient_objective, p=rand(M); kwargs...)
gradient_descent!(M, f, grad_f, p; kwargs...)
gradient_descent!(M, gradient_objective, p; kwargs...)</code></pre><p>perform the gradient descent algorithm</p><p class="math-container">\[p_{k+1} = \operatorname{retr}_{p_k}\bigl( s_k\operatorname{grad}f(p_k) \bigr),
\qquad k=0,1,‚Ä¶\]</p><p>where <span>$s_k &gt; 0$</span> denotes a step size.</p><p>The algorithm can be performed in-place of <code>p</code>.</p><p><strong>Input</strong></p><ul><li><code>M::</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code></code>: a Riemannian manifold <span>$\mathcal M$</span></li><li><code>f</code>: a cost function <span>$f: \mathcal M‚Üí ‚Ñù$</span> implemented as <code>(M, p) -&gt; v</code></li><li><code>grad_f</code>: the (Riemannian) gradient <span>$\operatorname{grad}f: \mathcal M ‚Üí T_{p}\mathcal M$</span> of f as a function <code>(M, p) -&gt; X</code> or a function <code>(M, X, p) -&gt; X</code> computing <code>X</code> in-place</li><li><code>p</code>: a point on the manifold <span>$\mathcal M$</span></li></ul><p>Alternatively to <code>f</code> and <code>grad_f</code> you can provide the corresponding <a href="../../plans/objective/#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective</code></a> <code>gradient_objective</code> directly.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>direction=</code><a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a><code>()</code>: specify to perform a certain processing of the direction, for example <a href="#Manopt.Nesterov"><code>Nesterov</code></a>, <a href="#Manopt.MomentumGradient"><code>MomentumGradient</code></a> or <a href="#Manopt.AverageGradient"><code>AverageGradient</code></a>.</p></li><li><p><code>evaluation=</code><a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.For example <code>grad_f(M,p)</code> allocates, but <code>grad_f!(M, X, p)</code> computes the result in-place of <code>X</code>.</p></li><li><p><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></p></li><li><p><code>stepsize=</code><a href="../../plans/stepsize/#Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}"><code>default_stepsize</code></a><code>(M, GradientDescentState)</code>: a functor inheriting from <a href="../../plans/stepsize/#Stepsize"><code>Stepsize</code></a> to determine a step size</p></li><li><p><code>stopping_criterion=</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(200)</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenAny"><code>|</code></a><a href="../../plans/stopping_criteria/#Manopt.StopWhenGradientNormLess"><code>StopWhenGradientNormLess</code></a><code>(1e-8)</code>: a functor indicating that the stopping criterion is fulfilled</p></li><li><p><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>storing the gradient at the current iterate</p></li></ul><p>All other keyword arguments are passed to <a href="../../plans/state/#Manopt.decorate_state!"><code>decorate_state!</code></a> for state decorators or <a href="../../plans/objective/#Manopt.decorate_objective!"><code>decorate_objective!</code></a> for objective decorators, respectively.</p><p>If you provide the <a href="../../plans/objective/#Manopt.ManifoldGradientObjective"><code>ManifoldGradientObjective</code></a> directly, the <code>evaluation=</code> keyword is ignored. The decorations are still applied to the objective.</p><p>If you activate tutorial mode (cf. <a href="../../plans/#Manopt.is_tutorial_mode"><code>is_tutorial_mode</code></a>), this solver provides additional debug warnings.</p><p><strong>Output</strong></p><p>The obtained approximate minimizer <span>$p^*$</span>. To obtain the whole final state of the solver, see <a href="../#Manopt.get_solver_return"><code>get_solver_return</code></a> for details, especially the <code>return_state=</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/solvers/gradient_descent.jl#L190-L241">source</a></section></article><h2 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.GradientDescentState" href="#Manopt.GradientDescentState"><code>Manopt.GradientDescentState</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GradientDescentState{P,T} &lt;: AbstractGradientSolverState</code></pre><p>Describes the state of a gradient based descent algorithm.</p><p><strong>Fields</strong></p><ul><li><code>p::P</code>: a point on the manifold <span>$\mathcal M$</span>storing the current iterate</li><li><code>X::T</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>storing the gradient at the current iterate</li><li><code>stop::StoppingCriterion</code>: a functor indicating that the stopping criterion is fulfilled</li><li><code>stepsize::Stepsize</code>: a functor inheriting from <a href="../../plans/stepsize/#Stepsize"><code>Stepsize</code></a> to determine a step size</li><li><code>direction::</code><a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a> : a processor to handle the obtained gradient and compute a direction to ‚Äúwalk into‚Äù.</li><li><code>retraction_method::AbstractRetractionMethod</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">GradientDescentState(M::AbstractManifold; kwargs...)</code></pre><p>Initialize the gradient descent solver state, where</p><p><strong>Input</strong></p><ul><li><code>M::</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code></code>: a Riemannian manifold <span>$\mathcal M$</span></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>direction=</code><a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a><code>()</code></li><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>to specify the initial value</li><li><code>stopping_criterion=</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(100)</code>: a functor indicating that the stopping criterion is fulfilled</li><li><code>stepsize=</code><a href="../../plans/stepsize/#Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}"><code>default_stepsize</code></a><code>(M, GradientDescentState; retraction_method=retraction_method)</code>: a functor inheriting from <a href="../../plans/stepsize/#Stepsize"><code>Stepsize</code></a> to determine a step size</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>to specify the representation of a tangent vector</li></ul><p><strong>See also</strong></p><p><a href="#Manopt.gradient_descent"><code>gradient_descent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/solvers/gradient_descent.jl#L2-L39">source</a></section></article><h2 id="Direction-update-rules"><a class="docs-heading-anchor" href="#Direction-update-rules">Direction update rules</a><a id="Direction-update-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Direction-update-rules" title="Permalink"></a></h2><p>A field of the options is the <code>direction</code>, a <a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a>, which by default <a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a> just evaluates the gradient but can be enhanced for example to</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AverageGradient" href="#Manopt.AverageGradient"><code>Manopt.AverageGradient</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AverageGradient(; kwargs...)
AverageGradient(M::AbstractManifold; kwargs...)</code></pre><p>Add an average of gradients to a gradient processor. A set of previous directions (from the inner processor) and the last iterate are stored, average is taken after vector transporting them to the current iterates tangent space.</p><p><strong>Input</strong></p><ul><li><code>M::</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code></code>: a Riemannian manifold <span>$\mathcal M$</span> (optional)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>to specify the initial value</li><li><code>direction=</code><a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a> preprocess the actual gradient before adding momentum</li><li><code>gradients=[zero_vector(M, p) for _ in 1:n]</code> how to initialise the internal storage</li><li><code>n=10</code> number of gradient evaluations to take the mean over</li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span></li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function generates a <a href="../../plans/#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.AverageGradientRule"><code>AverageGradientRule</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L452-L474">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.DirectionUpdateRule" href="#Manopt.DirectionUpdateRule"><code>Manopt.DirectionUpdateRule</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DirectionUpdateRule</code></pre><p>A general functor, that handles direction update rules. It&#39;s fields are usually only a <a href="../../plans/state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a> by default initialized to the fields required for the specific coefficient, but can also be replaced by a (common, global) individual one that provides these values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L264-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.IdentityUpdateRule" href="#Manopt.IdentityUpdateRule"><code>Manopt.IdentityUpdateRule</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IdentityUpdateRule &lt;: DirectionUpdateRule</code></pre><p>The default gradient direction update is the identity, usually it just evaluates the gradient.</p><p>You can also use <code>Gradient()</code> to create the corresponding factory, though this only delays this parameter-free instantiation to later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L274-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.MomentumGradient" href="#Manopt.MomentumGradient"><code>Manopt.MomentumGradient</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MomentumGradient()</code></pre><p>Append a momentum to a gradient processor, where the last direction and last iterate are stored and the new is composed as <span>$Œ∑_i = m*Œ∑_{i-1}&#39; - s d_i$</span>, where <span>$sd_i$</span> is the current (inner) direction and <span>$Œ∑_{i-1}&#39;$</span> is the vector transported last direction multiplied by momentum <span>$m$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> (optional)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span></li><li><code>direction=</code><a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a> preprocess the actual gradient before adding momentum</li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span></li><li><code>momentum=0.2</code> amount of momentum to use</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function generates a <a href="../../plans/#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.MomentumGradientRule"><code>MomentumGradientRule</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L355-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.Nesterov" href="#Manopt.Nesterov"><code>Manopt.Nesterov</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Nesterov(; kwargs...)
Nesterov(M::AbstractManifold; kwargs...)</code></pre><p>Assume <span>$f$</span> is <span>$L$</span>-Lipschitz and <span>$Œº$</span>-strongly convex. Given</p><ul><li>a step size <span>$h_k&lt;\frac{1}{L}$</span> (from the <a href="#Manopt.GradientDescentState"><code>GradientDescentState</code></a></li><li>a <code>shrinkage</code> parameter <span>$Œ≤_k$</span></li><li>and a current iterate <span>$p_k$</span></li><li>as well as the interim values <span>$Œ≥_k$</span> and <span>$v_k$</span> from the previous iterate.</li></ul><p>This compute a Nesterov type update using the following steps, see [<a href="../../references/#ZhangSra:2018">ZS18</a>]</p><ol><li>Compute the positive root <span>$Œ±_k‚àà(0,1)$</span> of <span>$Œ±^2 = h_k\bigl((1-Œ±_k)Œ≥_k+Œ±_k Œº\bigr)$</span>.</li><li>Set <span>$\barŒ≥_k+1 = (1-Œ±_k)Œ≥_k + Œ±_kŒº$</span></li><li><span>$y_k = \operatorname{retr}_{p_k}\Bigl(\frac{Œ±_kŒ≥_k}{Œ≥_k + Œ±_kŒº}\operatorname{retr}^{-1}_{p_k}v_k \Bigr)$</span></li><li><span>$x_{k+1} = \operatorname{retr}_{y_k}(-h_k \operatorname{grad}f(y_k))$</span></li><li><span>$v_{k+1} = \operatorname{retr}_{y_k}\Bigl(\frac{(1-Œ±_k)Œ≥_k}{\barŒ≥_k}\operatorname{retr}_{y_k}^{-1}(v_k) - \frac{Œ±_k}{\barŒ≥_{k+1}}\operatorname{grad}f(y_k) \Bigr)$</span></li><li><span>$Œ≥_{k+1} = \frac{1}{1+Œ≤_k}\barŒ≥_{k+1}$</span></li></ol><p>Then the direction from <span>$p_k$</span> to <span>$p_k+1$</span> by <span>$d = \operatorname{retr}^{-1}_{p_k}p_{k+1}$</span> is returned.</p><p><strong>Input</strong></p><ul><li><code>M::</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code></code>: a Riemannian manifold <span>$\mathcal M$</span> (optional)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>to specify the initial value</li><li><code>Œ≥=0.001</code></li><li><code>Œº=0.9</code></li><li><code>shrinkage = k -&gt; 0.8</code></li><li><code>inverse_retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_inverse_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_inverse_retraction_method</code></a><code>(M, typeof(p))</code>: an inverse retraction <span>$\operatorname{retr}^{-1}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions and their inverses</a></li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function generates a <a href="../../plans/#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.NesterovRule"><code>NesterovRule</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L551-L586">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.PreconditionedDirection" href="#Manopt.PreconditionedDirection"><code>Manopt.PreconditionedDirection</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PreconditionedDirection(preconditioner; kwargs...)
PreconditionedDirection(M::AbstractManifold, preconditioner; kwargs...)</code></pre><p>Add a preconditioner to a gradient processor following the <a href="https://en.wikipedia.org/wiki/Preconditioner#Preconditioning_in_optimization">motivation for optimization</a>, as a linear invertible map <span>$P: T_{p}\mathcal M ‚Üí T_{p}\mathcal M$</span> that usually should be</p><ul><li>symmetric: <span>$‚ü®X, P(Y)‚ü© = ‚ü®P(X), Y‚ü©$</span></li><li>positive definite <span>$‚ü®X, P(X)‚ü© &gt; 0$</span> for <span>$X$</span> not the zero-vector</li></ul><p>The gradient is then preconditioned as <span>$P(X)$</span>, where <span>$X$</span> is either the gradient of the objective or the result of a previous (internally stored) gradient processor.</p><p>For example if you provide as the preconditioner the inverse of the Hessian <span>$\operatorname{Hess}^{-1} f$</span>, you turn a gradient descent into a Newton method.</p><p><strong>Arguments</strong></p><ul><li><code>M::</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code></code>: a Riemannian manifold <span>$\mathcal M$</span> (optional)</li><li><code>preconditioner</code>:   preconditioner function, either as a <code>(M, p, X) -&gt; Y</code> allocating or <code>(M, Y, p, X) -&gt; Y</code> mutating function</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>direction=</code><a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a> internal <a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a> to determine the gradients to store or a <a href="../../plans/#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> generating one</li><li><code>evaluation=</code><a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.</li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function generates a <a href="../../plans/#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.PreconditionedDirectionRule"><code>PreconditionedDirectionRule</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L659-L686">source</a></section></article><p>which internally use the <a href="../../plans/#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> and produce the internal elements</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AverageGradientRule" href="#Manopt.AverageGradientRule"><code>Manopt.AverageGradientRule</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AverageGradientRule &lt;: DirectionUpdateRule</code></pre><p>Add an average of gradients to a gradient processor. A set of previous directions (from the inner processor) and the last iterate are stored. The average is taken after vector transporting them to the current iterates tangent space.</p><p><strong>Fields</strong></p><ul><li><code>gradients</code>:               the last <code>n</code> gradient/direction updates</li><li><code>last_iterate</code>:            last iterate (needed to transport the gradients)</li><li><code>direction</code>:               internal <a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a> to determine directions to apply the averaging to</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">AverageGradientRule(
    M::AbstractManifold;
    p::P=rand(M);
    n::Int=10
    direction::Union{&lt;:DirectionUpdateRule,ManifoldDefaultsFactory}=IdentityUpdateRule(),
    gradients = fill(zero_vector(p.M, o.x),n),
    last_iterate = deepcopy(x0),
    vector_transport_method = default_vector_transport_method(M, typeof(p))
)</code></pre><p>Add average to a gradient problem, where</p><ul><li><code>n</code>:                       determines the size of averaging</li><li><code>direction</code>:               is the internal <a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a> to determine the gradients to store</li><li><code>gradients</code>:               can be pre-filled with some history</li><li><code>last_iterate</code>:            stores the last iterate</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L380-L414">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ConjugateDescentCoefficientRule" href="#Manopt.ConjugateDescentCoefficientRule"><code>Manopt.ConjugateDescentCoefficientRule</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConjugateDescentCoefficientRule &lt;: DirectionUpdateRule</code></pre><p>A functor <code>(problem, state, k) -&gt; Œ≤_k</code> to compute the conjugate gradient update coefficient adapted to manifolds</p><p>See also <a href="../conjugate_gradient_descent/#Manopt.conjugate_gradient_descent"><code>conjugate_gradient_descent</code></a></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ConjugateDescentCoefficientRule()</code></pre><p>Construct the conjugate descent coefficient update rule, a new storage is created by default.</p><p><strong>See also</strong></p><p><a href="../conjugate_gradient_descent/#Manopt.ConjugateDescentCoefficient"><code>ConjugateDescentCoefficient</code></a>, <a href="../conjugate_gradient_descent/#Manopt.conjugate_gradient_descent"><code>conjugate_gradient_descent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/conjugate_gradient_plan.jl#L147-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.MomentumGradientRule" href="#Manopt.MomentumGradientRule"><code>Manopt.MomentumGradientRule</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MomentumGradientRule &lt;: DirectionUpdateRule</code></pre><p>Store the necessary information to compute the <a href="#Manopt.MomentumGradient"><code>MomentumGradient</code></a> direction update.</p><p><strong>Fields</strong></p><ul><li><code>p_old::P</code>: a point on the manifold <span>$\mathcal M$</span></li><li><code>momentum::Real</code>: factor for the momentum</li><li><code>direction</code>: internal <a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a> to determine directions to add the momentum to.</li><li><code>vector_transport_method::AbstractVectorTransportMethodP</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li><li><code>X_old::T</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span></li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">MomentumGradientRule(M::AbstractManifold; kwargs...)</code></pre><p>Initialize a momentum gradient rule to <code>s</code>, where <code>p</code> and <code>X</code> are memory for interim values.</p><p><strong>Keyword arguments</strong></p><ul><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span></li><li><code>s=</code><a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a><code>()</code></li><li><code>momentum=0.2</code></li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span></li></ul><p><strong>See also</strong></p><p><a href="#Manopt.MomentumGradient"><code>MomentumGradient</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L285-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.NesterovRule" href="#Manopt.NesterovRule"><code>Manopt.NesterovRule</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NesterovRule &lt;: DirectionUpdateRule</code></pre><p>Compute a Nesterov inspired direction update rule. See <a href="#Manopt.Nesterov"><code>Nesterov</code></a> for details</p><p><strong>Fields</strong></p><ul><li><code>Œ≥::Real</code>, <code>Œº::Real</code>: coefficients from the last iterate</li><li><code>v::P</code>:      an interim point to compute the next gradient evaluation point <code>y_k</code></li><li><code>shrinkage</code>: a function <code>k -&gt; ...</code> to compute the shrinkage <span>$Œ≤_k$</span> per iterate <code>k</code>`.</li><li><code>inverse_retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_inverse_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_inverse_retraction_method</code></a><code>(M, typeof(p))</code>: an inverse retraction <span>$\operatorname{retr}^{-1}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions and their inverses</a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">NesterovRule(M::AbstractManifold; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>to specify the initial value</li><li><code>Œ≥=0.001</code>`</li><li><code>Œº=0.9</code>`</li><li><code>shrinkage = k -&gt; 0.8</code></li><li><code>inverse_retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_inverse_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_inverse_retraction_method</code></a><code>(M, typeof(p))</code>: an inverse retraction <span>$\operatorname{retr}^{-1}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions and their inverses</a></li></ul><p><strong>See also</strong></p><p><a href="#Manopt.Nesterov"><code>Nesterov</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L478-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.PreconditionedDirectionRule" href="#Manopt.PreconditionedDirectionRule"><code>Manopt.PreconditionedDirectionRule</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PreconditionedDirectionRule{E&lt;:AbstractEvaluationType} &lt;: DirectionUpdateRule</code></pre><p>Add a preconditioning as gradient processor, see <a href="#Manopt.PreconditionedDirection"><code>PreconditionedDirection</code></a> for more mathematical background.</p><p><strong>Fields</strong></p><ul><li><code>direction</code>:      internal <a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a> to determine directions to apply the preconditioning to</li><li><code>preconditioner</code>: the preconditioner function</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">PreconditionedDirectionRule(
    M::AbstractManifold,
    preconditioner;
    direction::Union{&lt;:DirectionUpdateRule,ManifoldDefaultsFactory}=IdentityUpdateRule(),
    evaluation::AbstractEvaluationType=AllocatingEvaluation()
)</code></pre><p>Add preconditioning to a gradient problem.</p><p><strong>Input</strong></p><ul><li><code>M::</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code></code>: a Riemannian manifold <span>$\mathcal M$</span></li><li><code>preconditioner</code>:   preconditioner function, either as a <code>(M, p, X)</code> -&gt; Y<code>allocating or</code>(M, Y, p, X) -&gt; Y` mutating function</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>evaluation=</code><a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.</li><li><code>direction=</code><a href="#Manopt.IdentityUpdateRule"><code>IdentityUpdateRule</code></a> internal <a href="#Manopt.DirectionUpdateRule"><code>DirectionUpdateRule</code></a> to determine the gradients to store or a <a href="../../plans/#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> generating one</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L591-L622">source</a></section></article><h2 id="Debug-actions"><a class="docs-heading-anchor" href="#Debug-actions">Debug actions</a><a id="Debug-actions-1"></a><a class="docs-heading-anchor-permalink" href="#Debug-actions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.DebugGradient" href="#Manopt.DebugGradient"><code>Manopt.DebugGradient</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DebugGradient &lt;: DebugAction</code></pre><p>debug for the gradient evaluated at the current iterate</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">DebugGradient(; long=false, prefix= , format= &quot;$prefix%s&quot;, io=stdout)</code></pre><p>display the short (<code>false</code>) or long (<code>true</code>) default text for the gradient, or set the <code>prefix</code> manually. Alternatively the complete format can be set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L690-L700">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.DebugGradientNorm" href="#Manopt.DebugGradientNorm"><code>Manopt.DebugGradientNorm</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DebugGradientNorm &lt;: DebugAction</code></pre><p>debug for gradient evaluated at the current iterate.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">DebugGradientNorm([long=false,p=print])</code></pre><p>display the short (<code>false</code>) or long (<code>true</code>) default text for the gradient norm.</p><pre><code class="nohighlight hljs">DebugGradientNorm(prefix[, p=print])</code></pre><p>display the a <code>prefix</code> in front of the gradient norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L723-L736">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.DebugStepsize" href="#Manopt.DebugStepsize"><code>Manopt.DebugStepsize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DebugStepsize &lt;: DebugAction</code></pre><p>debug for the current step size.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">DebugStepsize(;long=false,prefix=&quot;step size:&quot;, format=&quot;$prefix%s&quot;, io=stdout)</code></pre><p>display the a <code>prefix</code> in front of the step size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L765-L774">source</a></section></article><h2 id="Record-actions"><a class="docs-heading-anchor" href="#Record-actions">Record actions</a><a id="Record-actions-1"></a><a class="docs-heading-anchor-permalink" href="#Record-actions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.RecordGradient" href="#Manopt.RecordGradient"><code>Manopt.RecordGradient</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RecordGradient &lt;: RecordAction</code></pre><p>record the gradient evaluated at the current iterate</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">RecordGradient(Œæ)</code></pre><p>initialize the <a href="../../plans/record/#Manopt.RecordAction"><code>RecordAction</code></a> to the corresponding type of the tangent vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L801-L810">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.RecordGradientNorm" href="#Manopt.RecordGradientNorm"><code>Manopt.RecordGradientNorm</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RecordGradientNorm &lt;: RecordAction</code></pre><p>record the norm of the current gradient</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L823-L827">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.RecordStepsize" href="#Manopt.RecordStepsize"><code>Manopt.RecordStepsize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RecordStepsize &lt;: RecordAction</code></pre><p>record the step size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/56212e1285ed1fd180dd9380055a4b0da044086d/src/plans/gradient_plan.jl#L840-L844">source</a></section></article><h2 id="sec-gradient-descent-technical-details"><a class="docs-heading-anchor" href="#sec-gradient-descent-technical-details">Technical details</a><a id="sec-gradient-descent-technical-details-1"></a><a class="docs-heading-anchor-permalink" href="#sec-gradient-descent-technical-details" title="Permalink"></a></h2><p>The <a href="#Manopt.gradient_descent"><code>gradient_descent</code></a> solver requires the following functions of a manifold to be available</p><ul><li>A <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/"><code>retract!</code></a><code>(M, q, p, X)</code>; it is recommended to set the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a> to a favourite retraction. If this default is set, a <code>retraction_method=</code> does not have to be specified.</li><li>By default gradient descent uses <a href="../../plans/stepsize/#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a> which requires <a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M)</code> to be set and an implementation of <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.inner-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%2C%20Any%7D"><code>inner</code></a><code>(M, p, X)</code>.</li><li>By default the stopping criterion uses the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#LinearAlgebra.norm-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D"><code>norm</code></a> as well, to stop when the norm of the gradient is small, but if you implemented <code>inner</code>, the norm is provided already.</li><li>By default the tangent vector storing the gradient is initialized calling <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M,p)</code>.</li></ul><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[Lue72]</dt><dd><div>D.¬†G.¬†Luenberger. <em>The gradient projection method along geodesics</em>. Management¬†Science <strong>18</strong>, 620‚Äì631 (1972).</div></dd><dt>[ZS18]</dt><dd><div>H.¬†Zhang and S.¬†Sra. <a href="https://arxiv.org/abs/1806.02812"><em>Towards Riemannian accelerated gradient methods</em></a>, arXiv¬†Preprint,¬†1806.02812 (2018).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../FrankWolfe/">¬´ Frank-Wolfe</a><a class="docs-footer-nextpage" href="../interior_point_Newton/">Interior Point Newton ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Monday 12 May 2025 09:20">Monday 12 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
