<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · Manopt.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Manopt.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../tutorials/Optimize!/">Get started: Optimize!</a></li><li><a class="tocitem" href="../tutorials/InplaceGradient/">Speedup using Inplace computations</a></li><li><a class="tocitem" href="../tutorials/AutomaticDifferentiation/">Use Automatic Differentiation</a></li><li><a class="tocitem" href="../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../tutorials/ConstrainedOptimization/">Do Contrained Optimization</a></li><li><a class="tocitem" href="../tutorials/GeodesicRegression/">Do Geodesic Regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#List-of-Algorithms"><span>List of Algorithms</span></a></li><li><a class="tocitem" href="#Technical-Details"><span>Technical Details</span></a></li><li><a class="tocitem" href="#API-for-solvers"><span>API for solvers</span></a></li></ul></li><li><a class="tocitem" href="alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="DouglasRachford/">Douglas–Rachford</a></li><li><a class="tocitem" href="exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="LevenbergMarquardt/">Levenberg–Marquardt</a></li><li><a class="tocitem" href="NelderMead/">Nelder–Mead</a></li><li><a class="tocitem" href="particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="subgradient/">Subgradient method</a></li><li><a class="tocitem" href="truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../plans/problem/">Problem</a></li><li><a class="tocitem" href="../plans/objective/">Objective</a></li><li><a class="tocitem" href="../plans/state/">Solver State</a></li><li><a class="tocitem" href="../plans/stepsize/">Stepsize</a></li><li><a class="tocitem" href="../plans/stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../plans/debug/">Debug Output</a></li><li><a class="tocitem" href="../plans/record/">Recording values</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../functions/">Introduction</a></li><li><a class="tocitem" href="../functions/bezier/">Bézier curves</a></li><li><a class="tocitem" href="../functions/costs/">Cost functions</a></li><li><a class="tocitem" href="../functions/differentials/">Differentials</a></li><li><a class="tocitem" href="../functions/adjointdifferentials/">Adjoint Differentials</a></li><li><a class="tocitem" href="../functions/gradients/">Gradients</a></li><li><a class="tocitem" href="../functions/proximal_maps/">Proximal Maps</a></li><li><a class="tocitem" href="../functions/manifold/">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../helpers/data/">Data</a></li><li><a class="tocitem" href="../helpers/errorMeasures/">Error Measures</a></li><li><a class="tocitem" href="../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li><li><a class="tocitem" href="../list/">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/solvers/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SolversSection"><a class="docs-heading-anchor" href="#SolversSection">Solvers</a><a id="SolversSection-1"></a><a class="docs-heading-anchor-permalink" href="#SolversSection" title="Permalink"></a></h1><p>Solvers can be applied to <a href="../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a>s with solver specific <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a>.</p><h1 id="List-of-Algorithms"><a class="docs-heading-anchor" href="#List-of-Algorithms">List of Algorithms</a><a id="List-of-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-Algorithms" title="Permalink"></a></h1><p>The following algorithms are currently available</p><table><tr><th style="text-align: left">Solver</th><th style="text-align: left">Function &amp; State</th><th style="text-align: left">Objective</th></tr><tr><td style="text-align: left"><a href="alternating_gradient_descent/#AlternatingGradientDescentSolver">Alternating Gradient Descent</a></td><td style="text-align: left"><a href="alternating_gradient_descent/#Manopt.alternating_gradient_descent"><code>alternating_gradient_descent</code></a> <a href="alternating_gradient_descent/#Manopt.AlternatingGradientDescentState"><code>AlternatingGradientDescentState</code></a></td><td style="text-align: left"><span>$f=(f_1,\ldots,f_n)$</span>, <span>$\operatorname{grad} f_i$</span></td></tr><tr><td style="text-align: left"><a href="ChambollePock/#ChambollePockSolver">Chambolle-Pock</a></td><td style="text-align: left"><a href="ChambollePock/#Manopt.ChambollePock"><code>ChambollePock</code></a>, <a href="ChambollePock/#Manopt.ChambollePockState"><code>ChambollePockState</code></a> (using <a href="../plans/problem/#Manopt.TwoManifoldProblem"><code>TwoManifoldProblem</code></a>)</td><td style="text-align: left"><span>$f=F+G(Λ\cdot)$</span>, <span>$\operatorname{prox}_{σ F}$</span>, <span>$\operatorname{prox}_{τ G^*}$</span>, <span>$Λ$</span></td></tr><tr><td style="text-align: left"><a href="conjugate_gradient_descent/#CGSolver">Conjugate Gradient Descent</a></td><td style="text-align: left"><a href="conjugate_gradient_descent/#Manopt.conjugate_gradient_descent"><code>conjugate_gradient_descent</code></a>, <a href="conjugate_gradient_descent/#Manopt.ConjugateGradientDescentState"><code>ConjugateGradientDescentState</code></a></td><td style="text-align: left"><span>$f$</span>, <span>$\operatorname{grad} f$</span></td></tr><tr><td style="text-align: left"><a href="cyclic_proximal_point/#CPPSolver">Cyclic Proximal Point</a></td><td style="text-align: left"><a href="cyclic_proximal_point/#Manopt.cyclic_proximal_point"><code>cyclic_proximal_point</code></a>, <a href="cyclic_proximal_point/#Manopt.CyclicProximalPointState"><code>CyclicProximalPointState</code></a></td><td style="text-align: left"><span>$f=\sum f_i$</span>, <span>$\operatorname{prox}_{\lambda f_i}$</span></td></tr><tr><td style="text-align: left"><a href="difference_of_convex/#DCASolver">Difference of Convex Algorithm</a></td><td style="text-align: left"><a href="difference_of_convex/#Manopt.difference_of_convex_algorithm"><code>difference_of_convex_algorithm</code></a>, <a href="difference_of_convex/#Manopt.DifferenceOfConvexState"><code>DifferenceOfConvexState</code></a></td><td style="text-align: left"><span>$f=g-h$</span>, <span>$∂h$</span>, and e.g. <span>$g$</span>, <span>$\operatorname{grad} g$</span></td></tr><tr><td style="text-align: left"><a href="difference_of_convex/#DCPPASolver">Difference of Convex Proximal Point</a></td><td style="text-align: left"><a href="difference_of_convex/#Manopt.difference_of_convex_proximal_point"><code>difference_of_convex_proximal_point</code></a>, <a href="difference_of_convex/#Manopt.DifferenceOfConvexProximalState"><code>DifferenceOfConvexProximalState</code></a></td><td style="text-align: left"><span>$f=g-h$</span>, <span>$∂h$</span>, and e.g. <span>$g$</span>, <span>$\operatorname{grad} g$</span></td></tr><tr><td style="text-align: left"><a href="DouglasRachford/#DRSolver">Douglas–Rachford</a></td><td style="text-align: left"><a href="DouglasRachford/#Manopt.DouglasRachford"><code>DouglasRachford</code></a>, <a href="DouglasRachford/#Manopt.DouglasRachfordState"><code>DouglasRachfordState</code></a></td><td style="text-align: left"><span>$f=\sum f_i$</span>, <span>$\operatorname{prox}_{\lambda f_i}$</span></td></tr><tr><td style="text-align: left"><a href="exact_penalty_method/#ExactPenaltySolver">Exact Penalty Method</a></td><td style="text-align: left"><a href="exact_penalty_method/#Manopt.exact_penalty_method"><code>exact_penalty_method</code></a>, <a href="exact_penalty_method/#Manopt.ExactPenaltyMethodState"><code>ExactPenaltyMethodState</code></a></td><td style="text-align: left"><span>$f$</span>, <span>$\operatorname{grad} f$</span>, <span>$g$</span>, <span>$\operatorname{grad} g_i$</span>, <span>$h$</span>, <span>$\operatorname{grad} h_j$</span></td></tr><tr><td style="text-align: left"><a href="FrankWolfe/#FrankWolfe">Frank-Wolfe algorithm</a></td><td style="text-align: left"><a href="FrankWolfe/#Manopt.Frank_Wolfe_method"><code>Frank_Wolfe_method</code></a>, <a href="FrankWolfe/#Manopt.FrankWolfeState"><code>FrankWolfeState</code></a></td><td style="text-align: left">sub-problem solver</td></tr><tr><td style="text-align: left"><a href="gradient_descent/#GradientDescentSolver">Gradient Descent</a></td><td style="text-align: left"><a href="gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a>, <a href="gradient_descent/#Manopt.GradientDescentState"><code>GradientDescentState</code></a></td><td style="text-align: left"><span>$f$</span>, <span>$\operatorname{grad} f$</span></td></tr><tr><td style="text-align: left"><a href="LevenbergMarquardt/#Levenberg-Marquardt">Levenberg-Marquardt</a></td><td style="text-align: left"><a href="LevenbergMarquardt/#Manopt.LevenbergMarquardt"><code>LevenbergMarquardt</code></a>, <a href="LevenbergMarquardt/#Manopt.LevenbergMarquardtState"><code>LevenbergMarquardtState</code></a></td><td style="text-align: left"><span>$f = \sum_i f_i$</span> <span>$\operatorname{grad} f_i$</span> (Jacobian)</td></tr><tr><td style="text-align: left"><a href="NelderMead/#NelderMeadSolver">Nelder-Mead</a></td><td style="text-align: left"><a href="NelderMead/#Manopt.NelderMead"><code>NelderMead</code></a>, <a href="NelderMead/#Manopt.NelderMeadState"><code>NelderMeadState</code></a></td><td style="text-align: left"><span>$f$</span></td></tr><tr><td style="text-align: left"><a href="augmented_Lagrangian_method/#AugmentedLagrangianSolver">Augmented Lagrangian Method</a></td><td style="text-align: left"><a href="augmented_Lagrangian_method/#Manopt.augmented_Lagrangian_method"><code>augmented_Lagrangian_method</code></a>, <a href="augmented_Lagrangian_method/#Manopt.AugmentedLagrangianMethodState"><code>AugmentedLagrangianMethodState</code></a></td><td style="text-align: left"><span>$f$</span>, <span>$\operatorname{grad} f$</span>, <span>$g$</span>, <span>$\operatorname{grad} g_i$</span>, <span>$h$</span>, <span>$\operatorname{grad} h_j$</span></td></tr><tr><td style="text-align: left"><a href="particle_swarm/#ParticleSwarmSolver">Particle Swarm</a></td><td style="text-align: left"><a href="particle_swarm/#Manopt.particle_swarm"><code>particle_swarm</code></a>, <a href="particle_swarm/#Manopt.ParticleSwarmState"><code>ParticleSwarmState</code></a></td><td style="text-align: left"><span>$f$</span></td></tr><tr><td style="text-align: left"><a href="primal_dual_semismooth_Newton/#PDRSSNSolver">Primal-dual Riemannian semismooth Newton Algorithm</a></td><td style="text-align: left"><a href="primal_dual_semismooth_Newton/#Manopt.primal_dual_semismooth_Newton"><code>primal_dual_semismooth_Newton</code></a>,  <a href="primal_dual_semismooth_Newton/#Manopt.PrimalDualSemismoothNewtonState"><code>PrimalDualSemismoothNewtonState</code></a> (using <a href="../plans/problem/#Manopt.TwoManifoldProblem"><code>TwoManifoldProblem</code></a>)</td><td style="text-align: left"><span>$f=F+G(Λ\cdot)$</span>, <span>$\operatorname{prox}_{σ F}$</span> &amp; diff., <span>$\operatorname{prox}_{τ G^*}$</span> &amp; diff., <span>$Λ$</span></td></tr><tr><td style="text-align: left"><a href="quasi_Newton/#quasiNewton">Quasi-Newton Method</a></td><td style="text-align: left"><a href="quasi_Newton/#Manopt.quasi_Newton"><code>quasi_Newton</code></a>, <a href="quasi_Newton/#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a></td><td style="text-align: left"><span>$f$</span>, <span>$\operatorname{grad} f$</span></td></tr><tr><td style="text-align: left"><a href="truncated_conjugate_gradient_descent/#tCG">Steihaug-Toint Truncated Conjugate-Gradient Method</a></td><td style="text-align: left"><a href="truncated_conjugate_gradient_descent/#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a>, <a href="truncated_conjugate_gradient_descent/#Manopt.TruncatedConjugateGradientState"><code>TruncatedConjugateGradientState</code></a></td><td style="text-align: left"><span>$f$</span>, <span>$\operatorname{grad} f$</span>, <span>$\operatorname{Hess} f$</span></td></tr><tr><td style="text-align: left"><a href="subgradient/#SubgradientSolver">Subgradient Method</a></td><td style="text-align: left"><a href="subgradient/#Manopt.subgradient_method"><code>subgradient_method</code></a>, <a href="subgradient/#Manopt.SubGradientMethodState"><code>SubGradientMethodState</code></a></td><td style="text-align: left"><span>$f$</span>, <span>$∂ f$</span></td></tr><tr><td style="text-align: left"><a href="stochastic_gradient_descent/#StochasticGradientDescentSolver">Stochastic Gradient Descent</a></td><td style="text-align: left"><a href="stochastic_gradient_descent/#Manopt.stochastic_gradient_descent"><code>stochastic_gradient_descent</code></a>, <a href="stochastic_gradient_descent/#Manopt.StochasticGradientDescentState"><code>StochasticGradientDescentState</code></a></td><td style="text-align: left"><span>$f = \sum_i f_i$</span>, <span>$\operatorname{grad} f_i$</span></td></tr><tr><td style="text-align: left"><a href="trust_regions/#trust_regions">The Riemannian Trust-Regions Solver</a></td><td style="text-align: left"><a href="trust_regions/#Manopt.trust_regions"><code>trust_regions</code></a>, <a href="trust_regions/#Manopt.TrustRegionsState"><code>TrustRegionsState</code></a></td><td style="text-align: left"><span>$f$</span>, <span>$\operatorname{grad} f$</span>, <span>$\operatorname{Hess} f$</span></td></tr></table><p>Note that the solvers (their <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a>, to be precise) can also be decorated to enhance your algorithm by general additional properties, see <a href="../plans/debug/#DebugSection">debug output</a> and <a href="../plans/record/#RecordSection">recording values</a>. This is done using the <code>debug=</code> and <code>record=</code> keywords in the function calls. Similarly, since 0.4 we provide a (simple) <a href="../plans/objective/#CacheSection">caching of the objective function</a> using the <code>cache=</code> keyword in any of the function calls..</p><h2 id="Technical-Details"><a class="docs-heading-anchor" href="#Technical-Details">Technical Details</a><a id="Technical-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-Details" title="Permalink"></a></h2><p>The main function a solver calls is</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.solve!-Tuple{AbstractManoptProblem, AbstractManoptSolverState}" href="#Manopt.solve!-Tuple{AbstractManoptProblem, AbstractManoptSolverState}"><code>Manopt.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(p::AbstractManoptProblem, s::AbstractManoptSolverState)</code></pre><p>run the solver implemented for the <a href="../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a><code>p</code> and the <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a><code>s</code> employing <a href="#Manopt.initialize_solver!"><code>initialize_solver!</code></a>, <a href="#Manopt.step_solver!"><code>step_solver!</code></a>, as well as the <a href="../plans/debug/#Manopt.stop_solver!-Tuple{AbstractManoptProblem, DebugSolverState, Int64}"><code>stop_solver!</code></a> of the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/34d1bf4745a5af7aeaaf1f53cdd73cc4e0492931/src/solvers/solver.jl#L96-L102">source</a></section></article><p>which is a framework that you in general should not change or redefine. It uses the following methods, which also need to be implemented on your own algorithm, if you want to provide one.</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.initialize_solver!" href="#Manopt.initialize_solver!"><code>Manopt.initialize_solver!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialize_solver!(ams::AbstractManoptProblem, amp::AbstractManoptSolverState)</code></pre><p>Initialize the solver to the optimization <a href="../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> by initializing the necessary values in the <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>amp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/34d1bf4745a5af7aeaaf1f53cdd73cc4e0492931/src/solvers/solver.jl#L84-L89">source</a></section><section><div><pre><code class="language-julia hljs">initialize_solver!(amp::AbstractManoptProblem, dss::DebugSolverState)</code></pre><p>Extend the initialization of the solver by a hook to run debug that were added to the <code>:Start</code> and <code>:All</code> entries of the debug lists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/34d1bf4745a5af7aeaaf1f53cdd73cc4e0492931/src/solvers/debug_solver.jl#L1-L6">source</a></section><section><div><pre><code class="language-julia hljs">initialize_solver!(ams::AbstractManoptProblem, rss::RecordSolverState)</code></pre><p>Extend the initialization of the solver by a hook to run records that were added to the <code>:Start</code> entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/34d1bf4745a5af7aeaaf1f53cdd73cc4e0492931/src/solvers/record_solver.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.step_solver!" href="#Manopt.step_solver!"><code>Manopt.step_solver!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">step_solver!(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, i)</code></pre><p>Do one iteration step (the <code>i</code>th) for an <a href="../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a><code>p</code> by modifying the values in the <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/34d1bf4745a5af7aeaaf1f53cdd73cc4e0492931/src/solvers/solver.jl#L113-L118">source</a></section><section><div><pre><code class="language-julia hljs">step_solver!(amp::AbstractManoptProblem, dss::DebugSolverState, i)</code></pre><p>Extend the <code>i</code>th step of the solver by a hook to run debug prints, that were added to the <code>:Step</code> and <code>:All</code> entries of the debug lists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/34d1bf4745a5af7aeaaf1f53cdd73cc4e0492931/src/solvers/debug_solver.jl#L13-L18">source</a></section><section><div><pre><code class="language-julia hljs">step_solver!(amp::AbstractManoptProblem, rss::RecordSolverState, i)</code></pre><p>Extend the <code>i</code>th step of the solver by a hook to run records, that were added to the <code>:Iteration</code> entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/34d1bf4745a5af7aeaaf1f53cdd73cc4e0492931/src/solvers/record_solver.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_solver_result" href="#Manopt.get_solver_result"><code>Manopt.get_solver_result</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_solver_result(ams::AbstractManoptSolverState)</code></pre><p>Return the final result after all iterations that is stored within the <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code>, which was modified during the iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/34d1bf4745a5af7aeaaf1f53cdd73cc4e0492931/src/plans/solver_state.jl#L175-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_solver_return" href="#Manopt.get_solver_return"><code>Manopt.get_solver_return</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_solver_return(O::AbstractManoptSolverState)</code></pre><p>determine the result value of a call to a solver. By default this returns the same as <a href="#Manopt.get_solver_result"><code>get_solver_result</code></a>, i.e. the last iterate or (approximate) minimizer.</p><pre><code class="nohighlight hljs">get_solver_return(O::ReturnSolverState)</code></pre><p>return the internally stored state of the <a href="../plans/state/#Manopt.ReturnSolverState"><code>ReturnSolverState</code></a> instead of the minimizer. This means that when the state are decorated like this, the user still has to call <a href="#Manopt.get_solver_result"><code>get_solver_result</code></a> on the internal state separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/34d1bf4745a5af7aeaaf1f53cdd73cc4e0492931/src/plans/solver_state.jl#L85-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.stop_solver!-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Any}" href="#Manopt.stop_solver!-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Any}"><code>Manopt.stop_solver!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stop_solver!(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, i)</code></pre><p>depending on the current <a href="../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>, the current state of the solver stored in <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> and the current iterate <code>i</code> this function determines whether to stop the solver, which by default means to call the internal <a href="../plans/stopping_criteria/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a>. <code>ams.stop</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/34d1bf4745a5af7aeaaf1f53cdd73cc4e0492931/src/solvers/solver.jl#L124-L131">source</a></section></article><h2 id="API-for-solvers"><a class="docs-heading-anchor" href="#API-for-solvers">API for solvers</a><a id="API-for-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#API-for-solvers" title="Permalink"></a></h2><p>this is a short overview of the different types of high-level functions are usually available for a solver. Let&#39;s assume the solver is called <code>new_solver</code> and requires a cost <code>f</code> and some first order information <code>df</code> as well as a starting point <code>p</code> on <code>M</code>. <code>f</code> and <code>df</code> form the objective together called <code>obj</code>.</p><p>Then there are basically two different variants to call</p><h3 id="The-easy-to-access-call"><a class="docs-heading-anchor" href="#The-easy-to-access-call">The easy to access call</a><a id="The-easy-to-access-call-1"></a><a class="docs-heading-anchor-permalink" href="#The-easy-to-access-call" title="Permalink"></a></h3><pre><code class="nohighlight hljs">new_solver(M, f, df, p=rand(M); kwargs...)
new_solver!(M, f, df, p; kwargs...)</code></pre><p>Where the start point should be optional. Keyword arguments include the type of evaluation, decorators like <code>debug=</code> or <code>record=</code> as well as algorithm specific ones. If you provide an immutable point <code>p</code> or the <code>rand(M)</code> point is immutable, like on the <code>Circle()</code> this method should turn the point into a mutable one as well.</p><p>The third variant works in place of <code>p</code>, so it is mandatory.</p><p>This first interface would set up the objective and pass all keywords on the the objective based call.</p><h3 id="The-objective-based-call"><a class="docs-heading-anchor" href="#The-objective-based-call">The objective-based call</a><a id="The-objective-based-call-1"></a><a class="docs-heading-anchor-permalink" href="#The-objective-based-call" title="Permalink"></a></h3><pre><code class="nohighlight hljs">new_solver(M, obj, p=rand(M); kwargs...)
new_solver!(M, obj, p; kwargs...)</code></pre><p>Here the objective would be created beforehand, e.g. to compare different solvers on the same objective, and for the first variant the start point is optional. Keyword arguments include decorators like <code>debug=</code> or <code>record=</code> as well as algorithm specific ones.</p><p>this variant would generate the <code>problem</code> and the <code>state</code> and check validity of all provided keyword arguments that affect the state. Then it would call the iterate process.</p><h3 id="The-manual-call"><a class="docs-heading-anchor" href="#The-manual-call">The manual call</a><a id="The-manual-call-1"></a><a class="docs-heading-anchor-permalink" href="#The-manual-call" title="Permalink"></a></h3><p>If you generate the correctsponding <code>problem</code> and <code>state</code> as the previous step does, you can also use the third (lowest level) and just call</p><pre><code class="nohighlight hljs">solve!(problem, state)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/GeodesicRegression/">« Do Geodesic Regression</a><a class="docs-footer-nextpage" href="alternating_gradient_descent/">Alternating Gradient Descent »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 29 April 2023 17:15">Saturday 29 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
