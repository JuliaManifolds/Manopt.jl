<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>get Started: Optimize! · Manopt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Manopt.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../about.html">About</a></li><li><span class="tocitem">How to...</span><ul><li class="is-active"><a class="tocitem" href="MeanAndMedian.html">get Started: Optimize!</a><ul class="internal"><li><a class="tocitem" href="#Example-1"><span>Example</span></a></li><li><a class="tocitem" href="#The-given-Dataset-1"><span>The given Dataset</span></a></li><li><a class="tocitem" href="#Computing-the-Mean-1"><span>Computing the Mean</span></a></li><li><a class="tocitem" href="#Computing-the-Median-1"><span>Computing the Median</span></a></li><li><a class="tocitem" href="#Literature-1"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="BezierCurves.html">work with Bézier curves</a></li><li><a class="tocitem" href="GradientOfSecondOrderDifference.html">see the gradient of <span>$d_2$</span></a></li><li><a class="tocitem" href="JacobiFields.html">use Jacobi Fields</a></li></ul></li><li><a class="tocitem" href="../plans/index.html">Plans</a></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../solvers/index.html">Introduction</a></li><li><a class="tocitem" href="../solvers/conjugate_gradient_descent.html">Conjugate gradient descent</a></li><li><a class="tocitem" href="../solvers/cyclic_proximal_point.html">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../solvers/DouglasRachford.html">Douglas–Rachford</a></li><li><a class="tocitem" href="../solvers/gradientDescent.html">Gradient Descent</a></li><li><a class="tocitem" href="../solvers/NelderMead.html">Nelder–Mead</a></li><li><a class="tocitem" href="../solvers/particle_swarm.html">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../solvers/subgradient.html">Subgradient method</a></li><li><a class="tocitem" href="../solvers/truncated_conjugate_gradient_descent.html">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../solvers/trust_regions.html">Riemannian Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../functions/index.html">Introduction</a></li><li><a class="tocitem" href="../functions/bezier.html">Bézier curves</a></li><li><a class="tocitem" href="../functions/costFunctions.html">Cost functions</a></li><li><a class="tocitem" href="../functions/differentials.html">Differentials</a></li><li><a class="tocitem" href="../functions/adjointDifferentials.html">Adjoint Differentials</a></li><li><a class="tocitem" href="../functions/gradients.html">Gradients</a></li><li><a class="tocitem" href="../functions/jacobiFields.html">JacobiFields</a></li><li><a class="tocitem" href="../functions/proximalMaps.html">Proximal Maps</a></li><li><a class="tocitem" href="../functions/manifold.html">Specific manifold functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../helpers/data.html">Data</a></li><li><a class="tocitem" href="../helpers/errorMeasures.html">Error Measures</a></li><li><a class="tocitem" href="../helpers/exports.html">Exports</a></li></ul></li><li><a class="tocitem" href="../list.html">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to...</a></li><li class="is-active"><a href="MeanAndMedian.html">get Started: Optimize!</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="MeanAndMedian.html">get Started: Optimize!</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/src/tutorials/MeanAndMedian.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimize-1"><a class="docs-heading-anchor" href="#Optimize-1">Get started: Optimize!</a><a class="docs-heading-anchor-permalink" href="#Optimize-1" title="Permalink"></a></h1><p>This example illustrates how to set up and solve optimization problems and how to further get data from the algorithm using <a href="../plans/index.html#Manopt.DebugOptions"><code>DebugOptions</code></a> and <a href="../plans/index.html#Manopt.RecordOptions"><code>RecordOptions</code></a></p><p>To start from the quite general case: A <strong>Solver</strong> is an algorithm that aims to solve</p><div>\[\operatorname*{argmin}_{x∈\mathcal M} f(x)\]</div><p>where <span>$\mathcal M$</span> is a <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/interface.html#ManifoldsBase.Manifold">Manifold</a> and <span>$f\colon\mathcal M \to \mathbb R$</span> is the cost function.</p><p>In <code>Manopt.jl</code> a <strong>Solver</strong> is an algorithm that requires a <a href="../plans/index.html#Manopt.Problem"><code>Problem</code></a> <code>p</code> and <a href="../plans/index.html#Manopt.Options"><code>Options</code></a> <code>o</code>. While former contains <strong>static</strong> data, most prominently the manifold <span>$\mathcal M$</span> (usually as <code>p.M</code>) and the cost function <span>$f$</span> (usually as <code>p.cost</code>), the latter contains <strong>dynamic</strong> data, i.e. things that usually change during the algorithm, are allowed to change, or specify the details of the algorithm to use. Together they form a <code>plan</code>. A <code>plan</code> uniquely determines the algorithm to use and provide all necessary information to run the algorithm.</p><h2 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h2><p>A gradient plan consists of a <a href="../plans/index.html#Manopt.GradientProblem"><code>GradientProblem</code></a> with the fields <code>M</code>, cost function <span>$f$</span> as well as <code>gradient</code> storing the gradient function corresponding to <span>$f$</span>. Accessing both functions can be done directly but should be encapsulated using <a href="../plans/index.html#Manopt.get_cost"><code>get_cost</code></a><code>(p,x)</code> and <a href="../plans/index.html#Manopt.get_gradient"><code>get_gradient</code></a><code>(p,x)</code>, where in both cases <code>x</code> is a point on the <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/interface.html#ManifoldsBase.Manifold">Manifold</a> <code>M</code>. Second, the <a href="../solvers/gradientDescent.html#Manopt.GradientDescentOptions"><code>GradientDescentOptions</code></a> specify that the algorithm to solve the <a href="../plans/index.html#Manopt.GradientProblem"><code>GradientProblem</code></a> will be the <a href="https://en.wikipedia.org/wiki/Gradient_descent">gradient descent</a> algorithm. It requires an initial value <code>o.x0</code>, a <a href="../solvers/index.html#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> <code>o.stop</code>, a <a href="../plans/index.html#Manopt.Stepsize"><code>Stepsize</code></a> <code>o.stepsize</code> and a retraction <code>o.retraction</code> and it internally stores the last evaluation of the gradient at <code>o.∇</code> for convenience. The only mandatory parameter is the initial value <code>x0</code>, though the defaults for both the stopping criterion (<a href="../solvers/index.html#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(100)</code>) as well as the stepsize (<a href="../plans/index.html#Manopt.ConstantStepsize"><code>ConstantStepsize</code></a><code>(1.)</code> are quite conservative, but are chosen to be as simple as possible.</p><p>With these two at hand, running the algorithm just requires to call <code>xOpt = solve(p,o)</code>.</p><p>In the following two examples we will see, how to use a higher level interface that allows to more easily activate for example a debug output or record values during the iterations</p><h2 id="The-given-Dataset-1"><a class="docs-heading-anchor" href="#The-given-Dataset-1">The given Dataset</a><a class="docs-heading-anchor-permalink" href="#The-given-Dataset-1" title="Permalink"></a></h2><pre><code class="language-julia">exportFolder = joinpath(
    @__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;docs&quot;, &quot;src&quot;, &quot;assets&quot;, &quot;images&quot;, &quot;tutorials&quot;
using Manopt, Manifolds
using Random, Colors</code></pre><p>For a persistent random set we use</p><pre><code class="language-">n = 100
σ = π / 8
M = Sphere(2)
x = 1 / sqrt(2) * [1.0, 0.0, 1.0]
Random.seed!(42)
data = [exp(M, x, random_tangent(M, x, Val(:Gaussian), σ)) for i in 1:n]
nothing #hide</code></pre><p>and we define some colors from <a href="https://personal.sron.nl/~pault/">Paul Tol</a></p><pre><code class="language-">black = RGBA{Float64}(colorant&quot;#000000&quot;)
TolVibrantOrange = RGBA{Float64}(colorant&quot;#EE7733&quot;)
TolVibrantBlue = RGBA{Float64}(colorant&quot;#0077BB&quot;)
TolVibrantTeal = RGBA{Float64}(colorant&quot;#009988&quot;)
TolVibrantMagenta = RGBA{Float64}(colorant&quot;#EE3377&quot;)
nothing #hide</code></pre><p>Then our data rendered using <a href="../helpers/exports.html#Manopt.asymptote_export_S2_signals-Tuple{String}"><code>asymptote_export_S2_signals</code></a> looks like</p><pre><code class="language-julia">asymptote_export_S2_signals(&quot;startDataAndCenter.asy&quot;;
    points = [ [x], data],
    colors=Dict(:points =&gt; [TolVibrantBlue, TolVibrantTeal]),
    dotSize = 3.5, cameraPosition = (1.,.5,.5)
)
render_asymptote(&quot;startDataAndCenter.asy&quot;; render = 2)</code></pre><p><img src="../assets/images/tutorials/startDataAndCenter.png" alt="The data of noisy versions of \$x\$"/></p><h2 id="Computing-the-Mean-1"><a class="docs-heading-anchor" href="#Computing-the-Mean-1">Computing the Mean</a><a class="docs-heading-anchor-permalink" href="#Computing-the-Mean-1" title="Permalink"></a></h2><p>To compute the mean on the manifold we use the characterization, that the Euclidean mean minimizes the sum of squared distances, and end up with the following cost function. Its minimizer is called <a href="https://arxiv.org/abs/1407.2087">Riemannian Center of Mass</a>.</p><pre><code class="language-julia">F = y -&gt; sum(1 / (2 * n) * distance.(Ref(M), Ref(y), data) .^ 2)
∇F = y -&gt; sum(1 / n * ∇distance.(Ref(M), data, Ref(y)))</code></pre><p>note that the <a href="../functions/gradients.html#Manopt.∇distance"><code>∇distance</code></a> defaults to the case <code>p=2</code>, i.e. the gradient of the squared distance. For details on convergence of the gradient descent for this problem, see [<a href="#AfsariTronVidal2013">Afsari, Tron, Vidal, 2013</a>]</p><p>The easiest way to call the gradient descent is now to call <a href="../solvers/gradientDescent.html#Manopt.gradient_descent"><code>gradient_descent</code></a></p><pre><code class="language-">xMean = gradient_descent(M, F, ∇F, data[1])
nothing; #hide
nothing #hide</code></pre><p>but in order to get more details, we further add the <code>debug=</code> options, which act as a <a href="https://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a> using the <a href="../plans/index.html#Manopt.DebugOptions"><code>DebugOptions</code></a> and <a href="../plans/index.html#Manopt.DebugAction"><code>DebugAction</code></a>s. The latter store values if that&#39;s necessary, for example for the <a href="../plans/index.html#Manopt.DebugChange"><code>DebugChange</code></a> that prints the change during the last iteration. The following debug prints</p><p><code># i | x: | Last Change: | F(x):</code>`</p><p>as well as the reason why the algorithm stopped at the end. Here, the format shorthand and the [<code>DebugFactory</code>] are used, which returns a <a href="../plans/index.html#Manopt.DebugGroup"><code>DebugGroup</code></a> of <a href="../plans/index.html#Manopt.DebugAction"><code>DebugAction</code></a> performed each iteration and the stop, respectively.</p><pre><code class="language-">xMean = gradient_descent(
    M,
    F,
    ∇F,
    data[1];
    debug=[:Iteration, &quot; | &quot;, :x, &quot; | &quot;, :Change, &quot; | &quot;, :Cost, &quot;\n&quot;, :Stop],
)
nothing #hide</code></pre><pre><code class="language-julia">asymptote_export_S2_signals(&quot;startDataCenterMean.asy&quot;;
    points = [ [x], data, [xMean] ],
    colors=Dict(:points =&gt; [TolVibrantBlue, TolVibrantTeal, TolVibrantOrange]),
    dotSize = 3.5, cameraPosition = (1.,.5,.5)
)
render_asymptote(&quot;startDataCenterMean.asy&quot;; render = 2)</code></pre><p><img src="../assets/images/tutorials/startDataCenterMean.png" alt="The resulting mean (orange)"/></p><h2 id="Computing-the-Median-1"><a class="docs-heading-anchor" href="#Computing-the-Median-1">Computing the Median</a><a class="docs-heading-anchor-permalink" href="#Computing-the-Median-1" title="Permalink"></a></h2><p>Similar to the mean you can also define the median as the minimizer of the distances, see for example [<a href="#Bačák2014">Bačák, 2014</a>], but since this problem is not differentiable, we employ the Cyclic Proximal Point (CPP) algorithm, described in the same reference. We define</p><pre><code class="language-">F2 = y -&gt; sum(1 / (2 * n) * distance.(Ref(M), Ref(y), data))
proxes = Function[(λ, y) -&gt; prox_distance(M, λ / n, di, y, 1) for di in data]
nothing #hide</code></pre><p>where the <code>Function</code> is a helper for global scope to infer the correct type.</p><p>We then call the <a href="../solvers/cyclic_proximal_point.html#Manopt.cyclic_proximal_point"><code>cyclic_proximal_point</code></a> as</p><pre><code class="language-">o = cyclic_proximal_point(
    M,
    F2,
    proxes,
    data[1];
    debug=[:Iteration, &quot; | &quot;, :x, &quot; | &quot;, :Change, &quot; | &quot;, :Cost, &quot;\n&quot;, 50, :Stop],
    record=[:Iteration, :Change, :Cost],
    return_options=true,
)
xMedian = get_solver_result(o)
values = get_record(o)
nothing # hide</code></pre><p>where the differences to <a href="../solvers/gradientDescent.html#Manopt.gradient_descent"><code>gradient_descent</code></a> are as follows</p><ul><li>the third parameter is now an Array of proximal maps</li><li>debug is reduces to only every 50th iteration</li><li>we further activated a <a href="../plans/index.html#Manopt.RecordAction"><code>RecordAction</code></a> using the <code>record=</code> optional parameter. These work very similar to those in debug, but they collect their data in an array. The high level interface then returns two variables; the <code>values</code> do contain an array of recorded datum per iteration. Here a Tuple containing the iteration, last change and cost respectively; see <a href="../plans/index.html#Manopt.RecordGroup"><code>RecordGroup</code></a>, <a href="../plans/index.html#Manopt.RecordIteration"><code>RecordIteration</code></a>, <a href="../plans/index.html#Manopt.RecordChange"><code>RecordChange</code></a>, <a href="../plans/index.html#Manopt.RecordCost"><code>RecordCost</code></a> as well as the <a href="../plans/index.html#Manopt.RecordFactory-Union{Tuple{O}, Tuple{O,Array{#s12,1} where #s12}} where O&lt;:Options"><code>RecordFactory</code></a> for details. The <code>values</code> contains hence a tuple per iteration, that itself consists of (by order of specification) the iteration number, the last change and the cost function value.</li></ul><p>These recorded entries read</p><pre><code class="language-julia">values</code></pre><pre><code class="language-none">values (generic function with 9 methods)</code></pre><p>The resulting median and mean for the data hence are</p><pre><code class="language-julia">asymptote_export_S2_signals(&quot;startDataCenterMean.asy&quot;;
    points = [ [x], data, [xMean], [xMedian] ],
    colors=Dict(:points =&gt; [TolVibrantBlue, TolVibrantTeal, TolVibrantOrange, TolVibrantMagenta]),
    dotSize = 3.5, cameraPosition = (1.,.5,.5)
)
render_asymptote(&quot;startDataCenterMedianAndMean.asy&quot;; render = 2)</code></pre><p><img src="../assets/images/tutorials/startDataCenterMedianAndMean.png" alt="The resulting mean (orange) and median (magenta)"/></p><h2 id="Literature-1"><a class="docs-heading-anchor" href="#Literature-1">Literature</a><a class="docs-heading-anchor-permalink" href="#Literature-1" title="Permalink"></a></h2><ul>
<li id="Bačák2014">[<a>Bačák, 2014</a>]
  Bačák, M: <emph>Computing Medians and Means in Hadamard Spaces.</emph>,
  SIAM Journal on Optimization, Volume 24, Number 3, pp. 1542–1566,
  doi: <a href="https://doi.org/10.1137/140953393">10.1137/140953393</a>,
  arxiv: <a href="https://arxiv.org/abs/1210.2145">1210.2145</a>.</li>
  <li id="AfsariTronVidal2013">[<a>Afsari, Tron, Vidal, 2013</a>]
   Afsari, B; Tron, R.; Vidal, R.: <emph>On the Convergence of Gradient
   Descent for Finding the Riemannian Center of Mass</emph>,
   SIAM Journal on Control and Optimization, Volume 51, Issue 3,
   pp. 2230–2260.
   doi: <a href="https://doi.org/10.1137/12086282X">10.1137/12086282X</a>,
   arxiv: <a href="https://arxiv.org/abs/1201.0925">1201.0925</a></li>
</ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../about.html">« About</a><a class="docs-footer-nextpage" href="BezierCurves.html">work with Bézier curves »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 11 October 2020 09:14">Sunday 11 October 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
