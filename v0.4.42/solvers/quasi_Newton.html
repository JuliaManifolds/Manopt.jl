<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quasi-Newton · Manopt.jl</title><meta name="title" content="Quasi-Newton · Manopt.jl"/><meta property="og:title" content="Quasi-Newton · Manopt.jl"/><meta property="twitter:title" content="Quasi-Newton · Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../about.html">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../tutorials/Optimize!.html">Get started: Optimize!</a></li><li><a class="tocitem" href="../tutorials/InplaceGradient.html">Speedup using Inplace computations</a></li><li><a class="tocitem" href="../tutorials/AutomaticDifferentiation.html">Use Automatic Differentiation</a></li><li><a class="tocitem" href="../tutorials/EmbeddingObjectives.html">Define Objectives in the Embedding</a></li><li><a class="tocitem" href="../tutorials/CountAndCache.html">Count and use a Cache</a></li><li><a class="tocitem" href="../tutorials/HowToDebug.html">Print Debug Output</a></li><li><a class="tocitem" href="../tutorials/HowToRecord.html">Record values</a></li><li><a class="tocitem" href="../tutorials/ImplementASolver.html">Implement a Solver</a></li><li><a class="tocitem" href="../tutorials/ConstrainedOptimization.html">Do Constrained Optimization</a></li><li><a class="tocitem" href="../tutorials/GeodesicRegression.html">Do Geodesic Regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="adaptive-regularization-with-cubics.html">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="alternating_gradient_descent.html">Alternating Gradient Descent</a></li><li><a class="tocitem" href="augmented_Lagrangian_method.html">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="ChambollePock.html">Chambolle-Pock</a></li><li><a class="tocitem" href="conjugate_gradient_descent.html">Conjugate gradient descent</a></li><li><a class="tocitem" href="cyclic_proximal_point.html">Cyclic Proximal Point</a></li><li><a class="tocitem" href="difference_of_convex.html">Difference of Convex</a></li><li><a class="tocitem" href="DouglasRachford.html">Douglas–Rachford</a></li><li><a class="tocitem" href="exact_penalty_method.html">Exact Penalty Method</a></li><li><a class="tocitem" href="FrankWolfe.html">Frank-Wolfe</a></li><li><a class="tocitem" href="gradient_descent.html">Gradient Descent</a></li><li><a class="tocitem" href="LevenbergMarquardt.html">Levenberg–Marquardt</a></li><li><a class="tocitem" href="NelderMead.html">Nelder–Mead</a></li><li><a class="tocitem" href="particle_swarm.html">Particle Swarm Optimization</a></li><li><a class="tocitem" href="primal_dual_semismooth_Newton.html">Primal-dual Riemannian semismooth Newton</a></li><li class="is-active"><a class="tocitem" href="quasi_Newton.html">Quasi-Newton</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Direction-Updates"><span>Direction Updates</span></a></li><li><a class="tocitem" href="#Hessian-Update-Rules"><span>Hessian Update Rules</span></a></li><li><a class="tocitem" href="#State"><span>State</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="stochastic_gradient_descent.html">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="subgradient.html">Subgradient method</a></li><li><a class="tocitem" href="truncated_conjugate_gradient_descent.html">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="trust_regions.html">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../plans/index.html">Specify a Solver</a></li><li><a class="tocitem" href="../plans/problem.html">Problem</a></li><li><a class="tocitem" href="../plans/objective.html">Objective</a></li><li><a class="tocitem" href="../plans/state.html">Solver State</a></li><li><a class="tocitem" href="../plans/stepsize.html">Stepsize</a></li><li><a class="tocitem" href="../plans/stopping_criteria.html">Stopping Criteria</a></li><li><a class="tocitem" href="../plans/debug.html">Debug Output</a></li><li><a class="tocitem" href="../plans/record.html">Recording values</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../functions/index.html">Introduction</a></li><li><a class="tocitem" href="../functions/bezier.html">Bézier curves</a></li><li><a class="tocitem" href="../functions/costs.html">Cost functions</a></li><li><a class="tocitem" href="../functions/differentials.html">Differentials</a></li><li><a class="tocitem" href="../functions/adjoint_differentials.html">Adjoint Differentials</a></li><li><a class="tocitem" href="../functions/gradients.html">Gradients</a></li><li><a class="tocitem" href="../functions/proximal_maps.html">Proximal Maps</a></li><li><a class="tocitem" href="../functions/manifold.html">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../helpers/checks.html">Checks</a></li><li><a class="tocitem" href="../helpers/data.html">Data</a></li><li><a class="tocitem" href="../helpers/errorMeasures.html">Error Measures</a></li><li><a class="tocitem" href="../helpers/exports.html">Exports</a></li></ul></li><li><a class="tocitem" href="../contributing.html">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../extensions.html">Extensions</a></li><li><a class="tocitem" href="../notation.html">Notation</a></li><li><a class="tocitem" href="../changelog.html">Changelog</a></li><li><a class="tocitem" href="../references.html">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href="quasi_Newton.html">Quasi-Newton</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="quasi_Newton.html">Quasi-Newton</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/solvers/quasi_Newton.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="quasiNewton"><a class="docs-heading-anchor" href="#quasiNewton">Riemannian quasi-Newton methods</a><a id="quasiNewton-1"></a><a class="docs-heading-anchor-permalink" href="#quasiNewton" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.quasi_Newton" href="#Manopt.quasi_Newton"><code>Manopt.quasi_Newton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quasi_Newton(M, f, grad_f, p)</code></pre><p>Perform a quasi Newton iteration for <code>f</code> on the manifold <code>M</code> starting in the point <code>p</code>.</p><p>The <span>$k$</span>th iteration consists of</p><ol><li>Compute the search direction <span>$η_k = -\mathcal{B}_k [\operatorname{grad}f (p_k)]$</span> or solve <span>$\mathcal{H}_k [η_k] = -\operatorname{grad}f (p_k)]$</span>.</li><li>Determine a suitable stepsize <span>$α_k$</span> along the curve <span>$\gamma(α) = R_{p_k}(α η_k)$</span> e.g. by using <a href="../plans/stepsize.html#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a>.</li><li>Compute <code>p_{k+1} = R_{p_k}(α_k η_k)</code>`.</li><li>Define <span>$s_k = T_{p_k, α_k η_k}(α_k η_k)$</span> and <span>$y_k = \operatorname{grad}f(p_{k+1}) - T_{p_k, α_k η_k}(\operatorname{grad}f(p_k))$</span>.</li><li>Compute the new approximate Hessian <span>$H_{k+1}$</span> or its inverse <span>$B_k$</span>.</li></ol><p><strong>Input</strong></p><ul><li><code>M</code> – a manifold <span>$\mathcal{M}$</span>.</li><li><code>f</code> – a cost function <span>$F : \mathcal{M} →ℝ$</span> to minimize.</li><li><code>grad_f</code>– the gradient <span>$\operatorname{grad}F : \mathcal{M} →T_x\mathcal M$</span> of <span>$F$</span>.</li><li><code>p</code> – an initial value <span>$p ∈ \mathcal{M}$</span>.</li></ul><p><strong>Optional</strong></p><ul><li><code>basis</code> – (<code>DefaultOrthonormalBasis()</code>) basis within the tangent space(s) to represent the Hessian (inverse).</li><li><code>cautious_update</code> – (<code>false</code>) – whether or not to use a <a href="quasi_Newton.html#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>QuasiNewtonCautiousDirectionUpdate</code></a></li><li><code>cautious_function</code> – (<code>(x) -&gt; x*10^(-4)</code>) – a monotone increasing function that is zero at 0 and strictly increasing at 0 for the cautious update.</li><li><code>direction_update</code> – (<a href="quasi_Newton.html#Manopt.InverseBFGS"><code>InverseBFGS</code></a><code>()</code>) the update rule to use.</li><li><code>evaluation</code> – (<a href="../plans/objective.html#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) specify whether the gradient works by  allocation (default) form <code>gradF(M, x)</code> or <a href="../plans/objective.html#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> in place, i.e.  is of the form <code>gradF!(M, X, x)</code>.</li><li><code>initial_operator</code> – (<code>Matrix{Float64}(I,n,n)</code>) initial matrix to use die the approximation, where <code>n=manifold_dimension(M)</code>, see also <code>scale_initial_operator</code>.</li><li><code>memory_size</code> – (<code>20</code>) limited memory, number of <span>$s_k, y_k$</span> to store. Set to a negative value to use a full memory representation</li><li><code>retraction_method</code> – (<code>default_retraction_method(M, typeof(p))</code>) a retraction method to use, by default the exponential map.</li><li><code>scale_initial_operator</code> - (<code>true</code>) scale initial operator with <span>$\frac{⟨s_k,y_k⟩_{p_k}}{\lVert y_k\rVert_{p_k}}$</span> in the computation</li><li><code>stabilize</code> – (<code>true</code>) stabilize the method numerically by projecting computed (Newton-) directions to the tangent space to reduce numerical errors</li><li><code>stepsize</code> – (<a href="../plans/stepsize.html#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a><code>(retraction_method, vector_transport_method)</code>) specify a <a href="../plans/stepsize.html#Manopt.Stepsize"><code>Stepsize</code></a>.</li><li><code>stopping_criterion</code> - (<a href="../plans/stopping_criteria.html#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(max(1000, memory_size)) |</code><a href="../plans/stopping_criteria.html#Manopt.StopWhenGradientNormLess"><code>StopWhenGradientNormLess</code></a><code>(1e-6)</code>) specify a <a href="../plans/stopping_criteria.html#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a></li><li><code>vector_transport_method</code> – (<code>default_vector_transport_method(M, typeof(p))</code>) a vector transport to use.</li></ul><p><strong>Output</strong></p><p>the obtained (approximate) minimizer <span>$p^*$</span>, see <a href="index.html#Manopt.get_solver_return"><code>get_solver_return</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/solvers/quasi_Newton.jl#L146-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.quasi_Newton!" href="#Manopt.quasi_Newton!"><code>Manopt.quasi_Newton!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quasi_Newton!(M, F, gradF, x; options...)</code></pre><p>Perform a quasi Newton iteration for <code>F</code> on the manifold <code>M</code> starting in the point <code>x</code> using a retraction <span>$R$</span> and a vector transport <span>$T$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – a manifold <span>$\mathcal{M}$</span>.</li><li><code>F</code> – a cost function <span>$F: \mathcal{M} →ℝ$</span> to minimize.</li><li><code>gradF</code>– the gradient <span>$\operatorname{grad}F : \mathcal{M} → T_x\mathcal M$</span> of <span>$F$</span> implemented as <code>gradF(M,p)</code>.</li><li><code>x</code> – an initial value <span>$x ∈ \mathcal{M}$</span>.</li></ul><p>For all optional parameters, see <a href="quasi_Newton.html#Manopt.quasi_Newton"><code>quasi_Newton</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/solvers/quasi_Newton.jl#L229-L242">source</a></section></article><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>The aim is to minimize a real-valued function on a Riemannian manifold, i.e.</p><p class="math-container">\[\min f(x), \quad x ∈ \mathcal{M}.\]</p><p>Riemannian quasi-Newtonian methods are as generalizations of their Euclidean counterparts Riemannian line search methods. These methods determine a search direction <span>$η_k ∈ T_{x_k} \mathcal{M}$</span> at the current iterate <span>$x_k$</span> and a suitable stepsize <span>$α_k$</span> along <span>$\gamma(α) = R_{x_k}(α η_k)$</span>, where <span>$R: T \mathcal{M} →\mathcal{M}$</span> is a retraction. The next iterate is obtained by</p><p class="math-container">\[x_{k+1} = R_{x_k}(α_k η_k).\]</p><p>In quasi-Newton methods, the search direction is given by</p><p class="math-container">\[η_k = -{\mathcal{H}_k}^{-1}[\operatorname{grad}f (x_k)] = -\mathcal{B}_k [\operatorname{grad} (x_k)],\]</p><p>where <span>$\mathcal{H}_k : T_{x_k} \mathcal{M} →T_{x_k} \mathcal{M}$</span> is a positive definite self-adjoint operator, which approximates the action of the Hessian <span>$\operatorname{Hess} f (x_k)[⋅]$</span> and <span>$\mathcal{B}_k = {\mathcal{H}_k}^{-1}$</span>. The idea of quasi-Newton methods is instead of creating a complete new approximation of the Hessian operator <span>$\operatorname{Hess} f(x_{k+1})$</span> or its inverse at every iteration, the previous operator <span>$\mathcal{H}_k$</span> or <span>$\mathcal{B}_k$</span> is updated by a convenient formula using the obtained information about the curvature of the objective function during the iteration. The resulting operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> acts on the tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span> of the freshly computed iterate <span>$x_{k+1}$</span>. In order to get a well-defined method, the following requirements are placed on the new operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> that is created by an update. Since the Hessian <span>$\operatorname{Hess} f(x_{k+1})$</span> is a self-adjoint operator on the tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>, and <span>$\mathcal{H}_{k+1}$</span> approximates it, we require that <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> is also self-adjoint on <span>$T_{x_{k+1}} \mathcal{M}$</span>. In order to achieve a steady descent, we want <span>$η_k$</span> to be a descent direction in each iteration. Therefore we require, that <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> is a positive definite operator on <span>$T_{x_{k+1}} \mathcal{M}$</span>. In order to get information about the curvature of the objective function into the new operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span>, we require that it satisfies a form of a Riemannian quasi-Newton equation:</p><p class="math-container">\[\mathcal{H}_{k+1} [T_{x_k \rightarrow x_{k+1}}({R_{x_k}}^{-1}(x_{k+1}))] = \operatorname{grad}(x_{k+1}) - T_{x_k \rightarrow x_{k+1}}(\operatorname{grad}f(x_k))\]</p><p>or</p><p class="math-container">\[\mathcal{B}_{k+1} [\operatorname{grad}f(x_{k+1}) - T_{x_k \rightarrow x_{k+1}}(\operatorname{grad}f(x_k))] = T_{x_k \rightarrow x_{k+1}}({R_{x_k}}^{-1}(x_{k+1}))\]</p><p>where <span>$T_{x_k \rightarrow x_{k+1}} : T_{x_k} \mathcal{M} →T_{x_{k+1}} \mathcal{M}$</span> and the chosen retraction <span>$R$</span> is the associated retraction of <span>$T$</span>. We note that, of course, not all updates in all situations will meet these conditions in every iteration. For specific quasi-Newton updates, the fulfillment of the Riemannian curvature condition, which requires that</p><p class="math-container">\[g_{x_{k+1}}(s_k, y_k) &gt; 0\]</p><p>holds, is a requirement for the inheritance of the self-adjointness and positive definiteness of the <span>$\mathcal{H}_k$</span> or <span>$\mathcal{B}_k$</span> to the operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span>. Unfortunately, the fulfillment of the Riemannian curvature condition is not given by a step size <span>$\alpha_k &gt; 0$</span> that satisfies the generalized Wolfe conditions. However, in order to create a positive definite operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> in each iteration, the so-called locking condition was introduced in <a href="../references.html#HuangGallivanAbsil:2015">Huang, Gallican, Absil, SIAM J. Optim., 2015</a>, which requires that the isometric vector transport <span>$T^S$</span>, which is used in the update formula, and its associate retraction <span>$R$</span> fulfill</p><p class="math-container">\[T^{S}{x, ξ_x}(ξ_x) = β T^{R}{x, ξ_x}(ξ_x), \quad β = \frac{\lVert ξ_x \rVert_x}{\lVert T^{R}{x, ξ_x}(ξ_x) \rVert_{R_{x}(ξ_x)}},\]</p><p>where <span>$T^R$</span> is the vector transport by differentiated retraction. With the requirement that the isometric vector transport <span>$T^S$</span> and its associated retraction <span>$R$</span> satisfies the locking condition and using the tangent vector</p><p class="math-container">\[y_k = {β_k}^{-1} \operatorname{grad}f(x_{k+1}) - T^{S}{x_k, α_k η_k}(\operatorname{grad}f(x_k)),\]</p><p>where</p><p class="math-container">\[β_k = \frac{\lVert α_k η_k \rVert_{x_k}}{\lVert T^{R}{x_k, α_k η_k}(α_k η_k) \rVert_{x_{k+1}}},\]</p><p>in the update, it can be shown that choosing a stepsize <span>$α_k &gt; 0$</span> that satisfies the Riemannian Wolfe conditions leads to the fulfillment of the Riemannian curvature condition, which in turn implies that the operator generated by the updates is positive definite. In the following we denote the specific operators in matrix notation and hence use <span>$H_k$</span> and <span>$B_k$</span>, respectively.</p><h2 id="Direction-Updates"><a class="docs-heading-anchor" href="#Direction-Updates">Direction Updates</a><a id="Direction-Updates-1"></a><a class="docs-heading-anchor-permalink" href="#Direction-Updates" title="Permalink"></a></h2><p>In general there are different ways to compute a fixed <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a>. In general these are represented by</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractQuasiNewtonDirectionUpdate" href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>Manopt.AbstractQuasiNewtonDirectionUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractQuasiNewtonDirectionUpdate</code></pre><p>An abstract representation of an Quasi Newton Update rule to determine the next direction given current <a href="quasi_Newton.html#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>.</p><p>All subtypes should be functors, i.e. one should be able to call them as <code>H(M,x,d)</code> to compute a new direction update.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonMatrixDirectionUpdate" href="#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>Manopt.QuasiNewtonMatrixDirectionUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonMatrixDirectionUpdate &lt;: AbstractQuasiNewtonDirectionUpdate</code></pre><p>These <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a>s represent any quasi-Newton update rule, where the operator is stored as a matrix. A distinction is made between the update of the approximation of the Hessian, <span>$H_k \mapsto H_{k+1}$</span>, and the update of the approximation of the Hessian inverse, <span>$B_k \mapsto B_{k+1}$</span>. For the first case, the coordinates of the search direction <span>$η_k$</span> with respect to a basis <span>$\{b_i\}^{n}_{i=1}$</span> are determined by solving a linear system of equations, i.e.</p><p class="math-container">\[\text{Solve} \quad \hat{η_k} = - H_k \widehat{\operatorname{grad}f(x_k)}\]</p><p>where <span>$H_k$</span> is the matrix representing the operator with respect to the basis <span>$\{b_i\}^{n}_{i=1}$</span> and <span>$\widehat{\operatorname{grad}f(x_k)}$</span> represents the coordinates of the gradient of the objective function <span>$f$</span> in <span>$x_k$</span> with respect to the basis <span>$\{b_i\}^{n}_{i=1}$</span>. If a method is chosen where Hessian inverse is approximated, the coordinates of the search direction <span>$η_k$</span> with respect to a basis <span>$\{b_i\}^{n}_{i=1}$</span> are obtained simply by matrix-vector multiplication, i.e.</p><p class="math-container">\[\hat{η_k} = - B_k \widehat{\operatorname{grad}f(x_k)}\]</p><p>where <span>$B_k$</span> is the matrix representing the operator with respect to the basis <span>$\{b_i\}^{n}_{i=1}$</span> and <span>$\widehat{\operatorname{grad}f(x_k)}$</span> as above. In the end, the search direction <span>$η_k$</span> is generated from the coordinates <span>$\hat{eta_k}$</span> and the vectors of the basis <span>$\{b_i\}^{n}_{i=1}$</span> in both variants. The <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a> indicates which quasi-Newton update rule is used. In all of them, the Euclidean update formula is used to generate the matrix <span>$H_{k+1}$</span> and <span>$B_{k+1}$</span>, and the basis <span>$\{b_i\}^{n}_{i=1}$</span> is transported into the upcoming tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>, preferably with an isometric vector transport, or generated there.</p><p><strong>Fields</strong></p><ul><li><code>update</code> – a <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a>.</li><li><code>basis</code> – the basis.</li><li><code>matrix</code> – (<code>Matrix{Float64}(I, manifold_dimension(M), manifold_dimension(M))</code>) the matrix which represents the approximating operator.</li><li><code>scale</code> – (`true) indicates whether the initial matrix (= identity matrix) should be scaled before the first update.</li><li><code>vector_transport_method</code> – (<code>vector_transport_method</code>)an <code>AbstractVectorTransportMethod</code></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonMatrixDirectionUpdate(M::AbstractManifold, update, basis, matrix;
scale=true, vector_transport_method=default_vector_transport_method(M))</code></pre><p>Generate the Update rule with defaults from a manifold and the names corresponding to the fields above.</p><p><strong>See also</strong></p><p><a href="quasi_Newton.html#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a> <a href="quasi_Newton.html#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>QuasiNewtonCautiousDirectionUpdate</code></a> <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L287-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonLimitedMemoryDirectionUpdate" href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>Manopt.QuasiNewtonLimitedMemoryDirectionUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonLimitedMemoryDirectionUpdate &lt;: AbstractQuasiNewtonDirectionUpdate</code></pre><p>This <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> represents the limited-memory Riemannian BFGS update, where the approximating  operator is represented by <span>$m$</span> stored pairs of tangent vectors <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m}^{k-1}$</span> in the <span>$k$</span>-th iteration. For the calculation of the search direction <span>$η_k$</span>, the generalisation of the two-loop recursion is used (see <a href="../references.html#HuangGallivanAbsil:2015">Huang, Gallican, Absil, SIAM J. Optim., 2015</a>), since it only requires inner products and linear combinations of tangent vectors in <span>$T_{x_k} \mathcal{M}$</span>. For that the stored pairs of tangent vectors <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m}^{k-1}$</span>, the gradient <span>$\operatorname{grad}f(x_k)$</span> of the objective function <span>$f$</span> in <span>$x_k$</span> and the positive definite self-adjoint operator</p><p class="math-container">\[\mathcal{B}^{(0)}_k[⋅] = \frac{g_{x_k}(s_{k-1}, y_{k-1})}{g_{x_k}(y_{k-1}, y_{k-1})} \; \mathrm{id}_{T_{x_k} \mathcal{M}}[⋅]\]</p><p>are used. The two-loop recursion can be understood as that the <a href="quasi_Newton.html#Manopt.InverseBFGS"><code>InverseBFGS</code></a> update is executed <span>$m$</span> times in a row on <span>$\mathcal{B}^{(0)}_k[⋅]$</span> using the tangent vectors <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m}^{k-1}$</span>, and in the same time the resulting operator <span>$\mathcal{B}^{LRBFGS}_k [⋅]$</span> is directly applied on <span>$\operatorname{grad}f(x_k)$</span>. When updating there are two cases: if there is still free memory, i.e. <span>$k &lt; m$</span>, the previously stored vector pairs <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m}^{k-1}$</span> have to be transported into the upcoming tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>; if there is no free memory, the oldest pair <span>$\{ \widetilde{s}_{k−m}, \widetilde{y}_{k−m}\}$</span> has to be discarded and then all the remaining vector pairs <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m+1}^{k-1}$</span> are transported into the tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>. After that we calculate and store <span>$s_k = \widetilde{s}_k = T^{S}_{x_k, α_k η_k}(α_k η_k)$</span> and <span>$y_k = \widetilde{y}_k$</span>. This process ensures that new information about the objective function is always included and the old, probably no longer relevant, information is discarded.</p><p><strong>Fields</strong></p><ul><li><code>memory_s</code> – the set of the stored (and transported) search directions times step size <span>$\{ \widetilde{s}_i\}_{i=k-m}^{k-1}$</span>.</li><li><code>memory_y</code> – set of the stored gradient differences <span>$\{ \widetilde{y}_i\}_{i=k-m}^{k-1}$</span>.</li><li><code>ξ</code> – a variable used in the two-loop recursion.</li><li><code>ρ</code> – a variable used in the two-loop recursion.</li><li><code>scale</code> –</li><li><code>vector_transport_method</code> – a <code>AbstractVectorTransportMethod</code></li><li><code>message</code> – a string containing a potential warning that might have appeared</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonLimitedMemoryDirectionUpdate(
    M::AbstractManifold,
    x,
    update::AbstractQuasiNewtonUpdateRule,
    memory_size;
    initial_vector=zero_vector(M,x),
    scale=1.0
    project=true
    )</code></pre><p><strong>See also</strong></p><p><a href="quasi_Newton.html#Manopt.InverseBFGS"><code>InverseBFGS</code></a> <a href="quasi_Newton.html#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>QuasiNewtonCautiousDirectionUpdate</code></a> <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L381-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonCautiousDirectionUpdate" href="#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>Manopt.QuasiNewtonCautiousDirectionUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonCautiousDirectionUpdate &lt;: AbstractQuasiNewtonDirectionUpdate</code></pre><p>These <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a>s represent any quasi-Newton update rule, which are based on the idea of a so-called cautious update. The search direction is calculated as given in <a href="quasi_Newton.html#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> or <a href="quasi_Newton.html#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a>, butut the update  then is only executed if</p><p class="math-container">\[\frac{g_{x_{k+1}}(y_k,s_k)}{\lVert s_k \rVert^{2}_{x_{k+1}}} \geq \theta(\lVert \operatorname{grad}f(x_k) \rVert_{x_k}),\]</p><p>is satisfied, where <span>$\theta$</span> is a monotone increasing function satisfying <span>$\theta(0) = 0$</span> and <span>$\theta$</span> is strictly increasing at <span>$0$</span>. If this is not the case, the corresponding update will be skipped, which means that for <a href="quasi_Newton.html#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> the matrix <span>$H_k$</span> or <span>$B_k$</span> is not updated. The basis <span>$\{b_i\}^{n}_{i=1}$</span> is nevertheless transported into the upcoming tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>, and for <a href="quasi_Newton.html#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a> neither the oldest vector pair <span>$\{ \widetilde{s}_{k−m}, \widetilde{y}_{k−m}\}$</span> is discarded nor the newest vector pair <span>$\{ \widetilde{s}_{k}, \widetilde{y}_{k}\}$</span> is added into storage, but all stored vector pairs <span>$\{ \widetilde{s}_i, \widetilde{y}_i\}_{i=k-m}^{k-1}$</span> are transported into the tangent space <span>$T_{x_{k+1}} \mathcal{M}$</span>. If <a href="quasi_Newton.html#Manopt.InverseBFGS"><code>InverseBFGS</code></a> or <a href="quasi_Newton.html#Manopt.InverseBFGS"><code>InverseBFGS</code></a> is chosen as update, then the resulting method follows the method of <a href="../references.html#HuangAbsilGallivan:2018">Huang, Absil, Gallivan, SIAM J. Optim., 2018</a>, taking into account that the corresponding step size is chosen.</p><p><strong>Fields</strong></p><ul><li><code>update</code> – an <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a></li><li><code>θ</code> – a monotone increasing function satisfying <span>$θ(0) = 0$</span> and <span>$θ$</span> is strictly increasing at <span>$0$</span>.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonCautiousDirectionUpdate(U::QuasiNewtonMatrixDirectionUpdate; θ = x -&gt; x)
QuasiNewtonCautiousDirectionUpdate(U::QuasiNewtonLimitedMemoryDirectionUpdate; θ = x -&gt; x)</code></pre><p>Generate a cautious update for either a matrix based or a limited memorz based update rule.</p><p><strong>See also</strong></p><p><a href="quasi_Newton.html#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> <a href="quasi_Newton.html#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L510-L552">source</a></section></article><h2 id="Hessian-Update-Rules"><a class="docs-heading-anchor" href="#Hessian-Update-Rules">Hessian Update Rules</a><a id="Hessian-Update-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Hessian-Update-Rules" title="Permalink"></a></h2><p>Using</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.update_hessian!" href="#Manopt.update_hessian!"><code>Manopt.update_hessian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_hessian!(d, amp, st, p_old, iter)</code></pre><p>update the hessian within the <a href="quasi_Newton.html#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a> <code>o</code> given a <a href="../plans/problem.html#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> as well as the an <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> <code>d</code> and the last iterate <code>p_old</code>. Note that the current (<code>iter</code>th) iterate is already stored in <code>o.x</code>.</p><p>See also <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a> for the different rules that are available within <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/solvers/quasi_Newton.jl#L363-L372">source</a></section></article><p>the following update formulae for either <span>$H_{k+1}$</span> or <span>$B_{k+1}$</span> are available.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractQuasiNewtonUpdateRule" href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>Manopt.AbstractQuasiNewtonUpdateRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractQuasiNewtonUpdateRule</code></pre><p>Specify a type for the different <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a>s, that is, e.g. for a <a href="quasi_Newton.html#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> there are several different updates to the matrix, while the default for <a href="quasi_Newton.html#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a> the most prominent is <a href="quasi_Newton.html#Manopt.InverseBFGS"><code>InverseBFGS</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.BFGS" href="#Manopt.BFGS"><code>Manopt.BFGS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BFGS &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian BFGS update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{H}_k^\mathrm{BFGS}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(α_k η_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{BFGS}_{k+1} = \widetilde{H}^\mathrm{BFGS}_k  + \frac{y_k y^{\mathrm{T}}_k }{s^{\mathrm{T}}_k y_k} - \frac{\widetilde{H}^\mathrm{BFGS}_k s_k s^{\mathrm{T}}_k \widetilde{H}^\mathrm{BFGS}_k }{s^{\mathrm{T}}_k \widetilde{H}^\mathrm{BFGS}_k s_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="quasi_Newton.html#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, α_k η_k}(α_k η_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, α_k η_k}(\operatorname{grad}f(x_k)) ∈ T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.DFP" href="#Manopt.DFP"><code>Manopt.DFP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DFP &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in an <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian DFP update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{H}_k^\mathrm{DFP}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(α_k η_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{DFP}_{k+1} = \Bigl(
  \mathrm{id}_{T_{x_{k+1}} \mathcal{M}} - \frac{y_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
\Bigr)
\widetilde{H}^\mathrm{DFP}_k
\Bigl(
  \mathrm{id}_{T_{x_{k+1}} \mathcal{M}} - \frac{s_k y^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
\Bigr) + \frac{y_k y^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="quasi_Newton.html#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, α_k η_k}(α_k η_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, α_k η_k}(\operatorname{grad}f(x_k)) ∈ T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L74-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.Broyden" href="#Manopt.Broyden"><code>Manopt.Broyden</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Broyden &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian Broyden update is used in the Riemannian quasi-Newton method, which is as a convex combination of <a href="quasi_Newton.html#Manopt.BFGS"><code>BFGS</code></a> and <a href="quasi_Newton.html#Manopt.DFP"><code>DFP</code></a>.</p><p>We denote by <span>$\widetilde{H}_k^\mathrm{Br}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(α_k η_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{Br}_{k+1} = \widetilde{H}^\mathrm{Br}_k
  - \frac{\widetilde{H}^\mathrm{Br}_k s_k s^{\mathrm{T}}_k \widetilde{H}^\mathrm{Br}_k}{s^{\mathrm{T}}_k \widetilde{H}^\mathrm{Br}_k s_k} + \frac{y_k y^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
  + φ_k s^{\mathrm{T}}_k \widetilde{H}^\mathrm{Br}_k s_k
  \Bigl(
        \frac{y_k}{s^{\mathrm{T}}_k y_k} - \frac{\widetilde{H}^\mathrm{Br}_k s_k}{s^{\mathrm{T}}_k \widetilde{H}^\mathrm{Br}_k s_k}
  \Bigr)
  \Bigl(
        \frac{y_k}{s^{\mathrm{T}}_k y_k} - \frac{\widetilde{H}^\mathrm{Br}_k s_k}{s^{\mathrm{T}}_k \widetilde{H}^\mathrm{Br}_k s_k}
  \Bigr)^{\mathrm{T}}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="quasi_Newton.html#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, α_k η_k}(α_k η_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, α_k η_k}(\operatorname{grad}f(x_k)) ∈ T_{x_{k+1}} \mathcal{M},\]</p><p>respectively, and <span>$φ_k$</span> is the Broyden factor which is <code>:constant</code> by default but can also be set to <code>:Davidon</code>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">Broyden(φ, update_rule::Symbol = :constant)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L208-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.SR1" href="#Manopt.SR1"><code>Manopt.SR1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SR1 &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian SR1 update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{H}_k^\mathrm{SR1}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(α_k η_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{SR1}_{k+1} = \widetilde{H}^\mathrm{SR1}_k
+ \frac{
  (y_k - \widetilde{H}^\mathrm{SR1}_k s_k) (y_k - \widetilde{H}^\mathrm{SR1}_k s_k)^{\mathrm{T}}
}{
(y_k - \widetilde{H}^\mathrm{SR1}_k s_k)^{\mathrm{T}} s_k
}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="quasi_Newton.html#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, α_k η_k}(α_k η_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, α_k η_k}(\operatorname{grad}f(x_k)) ∈ T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p><p>This method can be stabilized by only performing the update if denominator is larger than <span>$r\lVert s_k\rVert_{x_{k+1}}\lVert y_k - \widetilde{H}^\mathrm{SR1}_k s_k \rVert_{x_{k+1}}$</span> for some <span>$r&gt;0$</span>. For more details, see Section 6.2 in <a href="../references.html#NocedalWright:2006">Nocedal, Wright, Springer, 2006</a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SR1(r::Float64=-1.0)</code></pre><p>Generate the <code>SR1</code> update, which by default does not include the check (since the default sets <span>$t&lt;0$</span>`)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L127-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseBFGS" href="#Manopt.InverseBFGS"><code>Manopt.InverseBFGS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InverseBFGS &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the inverse Riemannian BFGS update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{B}_k^\mathrm{BFGS}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(α_k η_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{BFGS}_{k+1}  = \Bigl(
  \mathrm{id}_{T_{x_{k+1}} \mathcal{M}} - \frac{s_k y^{\mathrm{T}}_k }{s^{\mathrm{T}}_k y_k}
\Bigr)
\widetilde{B}^\mathrm{BFGS}_k
\Bigl(
  \mathrm{id}_{T_{x_{k+1}} \mathcal{M}} - \frac{y_k s^{\mathrm{T}}_k }{s^{\mathrm{T}}_k y_k}
\Bigr) + \frac{s_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="quasi_Newton.html#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, α_k η_k}(α_k η_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, α_k η_k}(\operatorname{grad}f(x_k)) ∈ T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L45-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseDFP" href="#Manopt.InverseDFP"><code>Manopt.InverseDFP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InverseDFP &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the inverse Riemannian DFP update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{B}_k^\mathrm{DFP}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(α_k η_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{DFP}_{k+1} = \widetilde{B}^\mathrm{DFP}_k + \frac{s_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
  - \frac{\widetilde{B}^\mathrm{DFP}_k y_k y^{\mathrm{T}}_k \widetilde{B}^\mathrm{DFP}_k}{y^{\mathrm{T}}_k \widetilde{B}^\mathrm{DFP}_k y_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="quasi_Newton.html#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, α_k η_k}(α_k η_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, α_k η_k}(\operatorname{grad}f(x_k)) ∈ T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L103-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseBroyden" href="#Manopt.InverseBroyden"><code>Manopt.InverseBroyden</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InverseBroyden &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>Indicates in <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian Broyden update is used in the Riemannian quasi-Newton method, which is as a convex combination of <a href="quasi_Newton.html#Manopt.InverseBFGS"><code>InverseBFGS</code></a> and <a href="quasi_Newton.html#Manopt.InverseDFP"><code>InverseDFP</code></a>.</p><p>We denote by <span>$\widetilde{H}_k^\mathrm{Br}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(α_k η_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{Br}_{k+1} = \widetilde{B}^\mathrm{Br}_k
 - \frac{\widetilde{B}^\mathrm{Br}_k y_k y^{\mathrm{T}}_k \widetilde{B}^\mathrm{Br}_k}{y^{\mathrm{T}}_k \widetilde{B}^\mathrm{Br}_k y_k}
   + \frac{s_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
 + φ_k y^{\mathrm{T}}_k \widetilde{B}^\mathrm{Br}_k y_k
 \Bigl(
     \frac{s_k}{s^{\mathrm{T}}_k y_k} - \frac{\widetilde{B}^\mathrm{Br}_k y_k}{y^{\mathrm{T}}_k \widetilde{B}^\mathrm{Br}_k y_k}
    \Bigr) \Bigl(
        \frac{s_k}{s^{\mathrm{T}}_k y_k} - \frac{\widetilde{B}^\mathrm{Br}_k y_k}{y^{\mathrm{T}}_k \widetilde{B}^\mathrm{Br}_k y_k}
 \Bigr)^{\mathrm{T}}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="quasi_Newton.html#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, α_k η_k}(α_k η_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, α_k η_k}(\operatorname{grad}f(x_k)) ∈ T_{x_{k+1}} \mathcal{M},\]</p><p>respectively, and <span>$φ_k$</span> is the Broyden factor which is <code>:constant</code> by default but can also be set to <code>:Davidon</code>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">InverseBroyden(φ, update_rule::Symbol = :constant)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L246-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseSR1" href="#Manopt.InverseSR1"><code>Manopt.InverseSR1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InverseSR1 &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the inverse Riemannian SR1 update is used in the Riemannian quasi-Newton method.</p><p>We denote by <span>$\widetilde{B}_k^\mathrm{SR1}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(α_k η_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{SR1}_{k+1} = \widetilde{B}^\mathrm{SR1}_k
+ \frac{
  (s_k - \widetilde{B}^\mathrm{SR1}_k y_k) (s_k - \widetilde{B}^\mathrm{SR1}_k y_k)^{\mathrm{T}}
}{
  (s_k - \widetilde{B}^\mathrm{SR1}_k y_k)^{\mathrm{T}} y_k
}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="quasi_Newton.html#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, α_k η_k}(α_k η_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, α_k η_k}(\operatorname{grad}f(x_k)) ∈ T_{x_{k+1}} \mathcal{M},\]</p><p>respectively.</p><p>This method can be stabilized by only performing the update if denominator is larger than <span>$r\lVert y_k\rVert_{x_{k+1}}\lVert s_k - \widetilde{H}^\mathrm{SR1}_k y_k \rVert_{x_{k+1}}$</span> for some <span>$r&gt;0$</span>. For more details, see Section 6.2 in <a href="../references.html#NocedalWright:2006">Nocedal, Wright, Springer, 2006</a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">InverseSR1(r::Float64=-1.0)</code></pre><p>Generate the <code>InverseSR1</code> update, which by default does not include the check, since the default sets <span>$t&lt;0$</span>`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/plans/quasi_newton_plan.jl#L167-L202">source</a></section></article><h2 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h2><p>The quasi Newton algorithm is based on a <a href="../plans/problem.html#Manopt.DefaultManoptProblem"><code>DefaultManoptProblem</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonState" href="#Manopt.QuasiNewtonState"><code>Manopt.QuasiNewtonState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonState &lt;: AbstractManoptSolverState</code></pre><p>These Quasi Newton <a href="../plans/state.html#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> represent any quasi-Newton based method and can be used with any update rule for the direction.</p><p><strong>Fields</strong></p><ul><li><code>p</code> – the current iterate, a point on a manifold</li><li><code>X</code> – the current gradient</li><li><code>sk</code> – the current step</li><li><code>yk</code> the current gradient difference</li><li><code>direction_update</code> - an <a href="quasi_Newton.html#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> rule.</li><li><code>retraction_method</code> – an <code>AbstractRetractionMethod</code></li><li><code>stop</code> – a <a href="../plans/stopping_criteria.html#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonState(
    M::AbstractManifold,
    x;
    initial_vector=zero_vector(M,x),
    direction_update::D=QuasiNewtonLimitedMemoryDirectionUpdate(M, x, InverseBFGS(), 20;
        vector_transport_method=vector_transport_method,
    )
    stopping_criterion=StopAfterIteration(1000) | StopWhenGradientNormLess(1e-6),
    retraction_method::RM=default_retraction_method(M, typeof(p)),
    vector_transport_method::VTM=default_vector_transport_method(M, typeof(p)),
    stepsize=default_stepsize(M; QuasiNewtonState)
)</code></pre><p><strong>See also</strong></p><p><a href="quasi_Newton.html#Manopt.quasi_Newton"><code>quasi_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/ed8fcef49b6f68715e7060ec64a86630387c874e/src/solvers/quasi_Newton.jl#L1-L34">source</a></section></article><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[HAG18]</dt><dd><div>W. Huang, P.-A. Absil and K. A. Gallivan. <em>A Riemannian BFGS method without differentiated retraction for nonconvex optimization problems</em>. <a href="https://doi.org/10.1137/17M1127582">SIAM Journal on Optimization <strong>28</strong>, 470–495</a> (2018).</div></dd><dt>[HGA15]</dt><dd><div>W. Huang, K. A. Gallivan and P.-A. Absil. <em>A Broyden class of quasi-Newton methods for Riemannian optimization</em>. <a href="https://doi.org/10.1137/140955483">SIAM Journal on Optimization <strong>25</strong>, 1660–1685</a> (2015).</div></dd><dt>[NW06]</dt><dd><div>J. Nocedal and S. J. Wright. <a href="https://doi.org/10.1007/978-0-387-40065-5"><em>Numerical Optimization</em></a>. 2 Edition (Springer, New York, 2006).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="primal_dual_semismooth_Newton.html">« Primal-dual Riemannian semismooth Newton</a><a class="docs-footer-nextpage" href="stochastic_gradient_descent.html">Stochastic Gradient Descent »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Monday 6 November 2023 12:02">Monday 6 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
