var documenterSearchIndex = {"docs":
[{"location":"#Welcome-to-Manopt.jl-1","page":"Home","title":"Welcome to Manopt.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = Manopt","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Manopt.Manopt","category":"page"},{"location":"#Manopt.Manopt","page":"Home","title":"Manopt.Manopt","text":"Manopt.jl – Optimization on Manifolds in Julia.\n\n\n\n\n\n","category":"module"},{"location":"#","page":"Home","title":"Home","text":"For a function fcolonmathcal M to mathbb R defined on a Riemannian manifold mathcal M we aim to solve","category":"page"},{"location":"#","page":"Home","title":"Home","text":"operatorname*argmin_xinmathcal M f(x)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or in other words: find the point x on the manifold, where f reaches its minimal function value.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Manopt.jl provides a framework for optimization on manifolds. Based on Manopt and MVIRT, both implemented in Matlab, this toolbox provide an easy access to optimization methods on manifolds for Julia, including example data and visualization methods.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you want to delve right into Manopt.jl check out the Getting Started: Optimize! tutorial.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Manopt.jl makes it easy to use an algorithm for your favorite manifold as well as a manifold for your favorite algorithm. It already provides many manifolds and algorithms, which can easily be enhanced, for example to record certain data or display information throughout iterations.","category":"page"},{"location":"#Main-Features-1","page":"Home","title":"Main Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"1. Manifolds Manifolds consist of three elements: a Manifold type that stores general information about the manifold, for example a name, or for example in order to generate a randomMPoint, an MPoint storing data to represent a point on the manifold, for example a vector or a matrix, and a TVector string data to represent a point in a tangent space T_xmathcal M of such an MPoint. If a manifold has certain properties, for example if it is a matrix manifold or a Lie group, see for example the binary operator ⊗. For a list of available manifolds, see the list of manifolds","category":"page"},{"location":"#","page":"Home","title":"Home","text":"2. Functions on Manifolds Several functions are available, implemented on an arbitrary manifold, cost functions, differentials, and gradients as well as proximal maps, but also several jacobi Fields and their adjoints.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"3. Optimization Algorithms (Solvers) For every optimization algorithm, a solver is implemented based on a Problem that describes the problem to solve and its Options that set up the solver, store interims values. Together they form a plan.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"4. Visualization To visualize and interpret results, Manopt.jl aims to provide both easy plot functions as well as exports. Furthermore a system to get debug during the iterations of an algorithms as well as record capabilities, i.e. to record a specified tuple of values per iteration, most prominently RecordCost and RecordIterate. Take a look at the Getting Started: Optimize! tutorial how to easily activate this.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"All four parts are accompanied by a documentation that can also be accessed from within Julia REPL and provides detailed information, e.g. the formula for an exponential or logarithmic map on the manifold of symmetric positive definite matrices or literature references for an algorithm like cyclicProximalPoint.","category":"page"},{"location":"#Notation-1","page":"Home","title":"Notation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"During this documentation, we refer to a variable with e.g. both x and x depending on whether the context refers to a code fragment or a mathematical formula, respectively.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Symbol used for\nmathcal M mathcal N a manifold\ndd_1ldotsd_n dimension(s) of a manifold\nxyzx_1ldotsx_n points on a manifold\nT_xmathcal M the tangent space of xinmathcal M\nxinuetaxi_1ldotsxi_n tangent vectors, might be extended by the base point, i.e. xi_x\nlog_xy logarithmic map\nexp_xxi exponential map\ng(t xy) geodesic connecting xyinmathcal M with tin 01\nlangle cdot cdotrangle_x Riemannian inner product on T_xmathcal M\noperatornamePT_xto yxi parallel transport of xiin T_xmathcal M from x to y along g(cdotxy)","category":"page"},{"location":"#Literature-1","page":"Home","title":"Literature","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"<ul><li id=\"AbsilMahonySepulchre2008\">\n    [<a>Absil, Mahony, Sepulchre, 2008</a>]\n    P.-A. Absil, R. Mahony and R. Sepulchre,\n    <emph>Optimization Algorithms on\n    Matrix Manifolds</emph>, Princeton University Press, 2008,\n    doi: <a href=\"https://doi.org/10.1515/9781400830244\">10.1515/9781400830244</a>,\n    <a href=\"http://press.princeton.edu/chapters/absil/\">open access</a>.\n</li></ul>","category":"page"},{"location":"about/#About-1","page":"About","title":"About","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"Manopt.jl inherited its name from Manopt, a Matlab toolbox. It is currently Maintained by Ronny Bergmann (manopt@ronnybergmann.net) with contributions from Tom Christian Riemer, who implemented some of the manifolds.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"If you want to contribute a manifold or algorithm or have any questions, visit the GitHub repository to clone/fork the repository or open an issue.","category":"page"},{"location":"manifolds/#RiemannianManifolds-1","page":"Introduction","title":"Riemannian Manifolds","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"CurrentModule = Manopt","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"All manifolds inherit from Manifold to store their main properties, which is most prominently the manifold dimension and the name of the manifold. This will be extended in the future, for example properties denoting whether the manifold is explicitly given in the sense of a closed form exponential and logarithmic map for example, or only approximately.","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"A Riemannian manifold in Manopt.jl consist of three types:","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"Manifold\nMPoint\nTVector","category":"page"},{"location":"manifolds/#Manopt.Manifold","page":"Introduction","title":"Manopt.Manifold","text":"An abstract manifold mathcal M to keep global information on a specific manifold\n\n\n\n","category":"type"},{"location":"manifolds/#Manopt.MPoint","page":"Introduction","title":"Manopt.MPoint","text":"An abstract point x on a Manifold mathcal M.\n\n\n\n","category":"type"},{"location":"manifolds/#Manopt.TVector","page":"Introduction","title":"Manopt.TVector","text":"A tangent vector xi in T_xmathcal M at a MPoint point x on a Manifold mathcal M.\n\n\n\n","category":"type"},{"location":"manifolds/#Manifolds-1","page":"Introduction","title":"List of available Manifolds","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"Furthermore there are two types accompanying each manifold – a point on the manifold inheriting from MPoint and the tangent vector TVector. For both the term manifold is shortened to M for concise naming. Each manifold also inherits such a short abbreviation, see Abbr. in the following table.","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"Manifold mathcal M File Abbr. Comment\nA manifold mathcal M Manifold.jl M \n1-sphere mathbb S^1 Circle.jl S1 represented as angles xin-pipi)\nEuclidean space mathbb R^n Euclidean.jl Rn n-dimensional Euclidean space mathbb R^n\nGrassmannian manifold mathrmGr(kn) Grassmannian.jl Gr embedded in mathbb R^ntimes k\nn-dim. Hyperbolic space mathbb H^n Hyperbolic.jl Hn embedded in mathbb R^n+1\nspecial orthogonal group mathrmSO(n) Rotations.jl SO represented as rotation matrices\nn-sphere mathbb S^n Sphere.jl Sn embedded in mathbb R^n+1\nStiefel mathrmSt(kn) Stiefel.jl St contains both the real- ad the complex-valued case\nsymmetric matrices mathcalSym(n) Symmetric.jl Sym ntimes n symmetric matrices\nsymmetric positive definite matrices mathcal P(n) SymmetricPositiveDefinite.jl SPD ntimes n symmetric positive matrices using the affine metric","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"If you're missing your favorite manifold, give us a note on Github.","category":"page"},{"location":"manifolds/#Special-Types-of-Manifolds-1","page":"Introduction","title":"Special Types of Manifolds","text":"","category":"section"},{"location":"manifolds/#Manifolds-build-upon-Manifolds-1","page":"Introduction","title":"Manifolds build upon Manifolds","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"Manifold mathcal M File Abbr. Comment\nPower manifold Power.jl Pow Builds mathcal N^d_1timescdottimes d_k of any manifold mathcal N\nProduct manifold Product.jl Prod Build the product manifold mathcal N_1timescdotstimesmathcal N_k of manifolds\nTangent bundle TangentBundle.jl TB tangent bundle of a manifold, i.e. the set of all tuples (xxi) xi in T_xmathcal M, xinmathcal M with the induced metric.","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"for more details see Combined Manifolds","category":"page"},{"location":"manifolds/#Special-Properties-of-Manifolds-1","page":"Introduction","title":"Special Properties of Manifolds","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"Special types of manifolds are introduced by SimpleTraits.jl. They can be used to clarify that a manifold possesses a certain property. For example two points on a matrix manifold can be multiplied, though the result is not necessarily a point on the manifold anymore. Traits have to goals here: Provide functions that are common for all manifolds of such a type (e.g. the ⊗ for Lie groups) as a common interface and to specify certain functions or solvers for these certain types, that for example take advantage of ⊗ then.","category":"page"},{"location":"manifolds/#Embedded-Manifold-1","page":"Introduction","title":"Embedded Manifold","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"IsEmbeddedM\nIsEmbeddedP\nIsEmbeddedV","category":"page"},{"location":"manifolds/#Manopt.IsEmbeddedM","page":"Introduction","title":"Manopt.IsEmbeddedM","text":"IsEmbeddedM{X}\n\nAn abstract Manifold that is embedded in some Euclidean space. These manifolds may have projections and converters for gradient and Hessian.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#Manopt.IsEmbeddedP","page":"Introduction","title":"Manopt.IsEmbeddedP","text":"IsEmbeddedP{X}\n\nAn abstract MPoint belonging to an embedded manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#Manopt.IsEmbeddedV","page":"Introduction","title":"Manopt.IsEmbeddedV","text":"IsEmbeddedV{X}\n\nAn abstract TVector belonging to an embedded manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#LieGroup-1","page":"Introduction","title":"Lie Group Manifold","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"IsLieGroupM\nIsLieGroupP\nIsLieGroupV\n⊗","category":"page"},{"location":"manifolds/#Manopt.IsLieGroupM","page":"Introduction","title":"Manopt.IsLieGroupM","text":"IsLieGroupM{X}\n\nIndicates that X is a Manifold with a Lie group structure. This also introdcues a group operation ⊗ of two MPoints of X.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#Manopt.IsLieGroupP","page":"Introduction","title":"Manopt.IsLieGroupP","text":"IsLieGroupP{X}\n\nAn abstract MPoint belonging to a Lie group manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#Manopt.IsLieGroupV","page":"Introduction","title":"Manopt.IsLieGroupV","text":"IsLieGroupV{X}\n\nAn abstract TVector belonging to a Lie group manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#Manopt.:⊗","page":"Introduction","title":"Manopt.:⊗","text":"⊗(x,y)\n\nthe binary operator x ⊗ y represents the Lie group action for a Lie group Manifold, see IsLieGroupM. \n\n\n\n","category":"function"},{"location":"manifolds/#MatrixManifold-1","page":"Introduction","title":"Matrix Manifold","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"IsMatrixM\nIsMatrixP\nIsMatrixTV","category":"page"},{"location":"manifolds/#Manopt.IsMatrixM","page":"Introduction","title":"Manopt.IsMatrixM","text":"IsMatrixM{X}\n\nAn abstract Manifold to represent a manifold whose points are matrices. For these manifolds the usual operators (+,-,*) are overloaded for points. Furthermore, the transpose is also overloaded, though it returns the matrix, since the dimensions mit be different for rectangular matrices.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#Manopt.IsMatrixP","page":"Introduction","title":"Manopt.IsMatrixP","text":"IsMatrixP{X}\n\nAn abstract Manifold Point belonging to a matrix manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#Manopt.IsMatrixTV","page":"Introduction","title":"Manopt.IsMatrixTV","text":"IsMatrixTV{X}\n\nAn abstract Manifold Point belonging to a matrix manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#Functions-that-need-to-be-implemented-for-a-Manifold-1","page":"Introduction","title":"Functions that need to be implemented for a Manifold","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"If you plan to implement a new manifold within Manopt.jl, the following functions should be implemented. If you only implement a few of these functions, not all algorithms might work. all these functions have a fallback providing an error message if the function is not (yet) implemented. Otherwise, for example, if the field of the inner representant of MPoint or TVector is the field .value of your data structure, the default implementation of getValue directly works. In the following list M <: Manifold the manifold type  represents the manifold Q,P <: MPoint the type of a point on the new manifold, T <: TVector a corresponding tangent vector in a suitable tangent space,","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"addNoise(M::mT, x::P, options...) where {mT <: Manifold, P <: MPoint}\ndistance(M::mT, x::T, y::T) where {mT <: Manifold, T <: MPoint}\ndot(M::mT, x::P, ξ::T, ν::S) where {mT <: Manifold, P <: MPoint, T <: TVector, S <: TVector}\nexp(M::mT, x::P, ξ::T,t::Float64=1.0) where {mT<:Manifold, P<:MPoint, T<:TVector, N<:Number}\ngetValue(ξ::P) where {P <: MPoint}\ngetValue(ξ::T) where {T <: TVector}\nlog(::mT,::P,::Q) where {mT<:Manifold, P<:MPoint, Q<:MPoint}\nmanifoldDimension(::P) where {P <: MPoint}\nmanifoldDimension(::mT) where {mT <: Manifold}\nnorm(::mT,::P,::T) where {mT<:Manifold, P<: MPoint, T<:TVector}\nparallelTransport(::mT,::P,::Q,::T) where {mT <: Manifold, P <: MPoint, Q <: MPoint, T <: TVector}\nrandomMPoint(M::mT,s::Symbol,options...) where {mT <: Manifold}\nrandomTVector(M::mT,p::P,s::Symbol,options...) where {mT <: Manifold, P<: MPoint}\ntangentONB(::mT, ::P, ::Q) where {mT <: Manifold, P <: MPoint, Q <: MPoint}\ntangentONB(::mT, ::P, ::T) where {mT <: Manifold, P <: MPoint, T <: TVector}\ntypeofMPoint(::T) where {T <: TVector}\ntypeofMPoint(::Type{T}) where {T <: TVector}\ntypeofTVector(::P) where {P <: MPoint}\ntypeofTVector(::Type{P}) where {P <: MPoint}\ntypicalDistance(M::mT) where {mT <: Manifold}\nzeroTVector(::mT, ::P) where {mT <: Manifold, P <: MPoint}","category":"page"},{"location":"manifolds/#Manopt.addNoise-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P,Vararg{Any,N} where N}} where P<:MPoint where mT<:Manifold","page":"Introduction","title":"Manopt.addNoise","text":"addNoise(M,x)\n\nadd noise to a MPoint x on the Manifold M by using the randomTVector method and doing an exponential step. Optional parameters, like the type of noise and parameters for the noise may be given and are just passed on-\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.distance-Union{Tuple{T}, Tuple{mT}, Tuple{mT,T,T}} where T<:MPoint where mT<:Manifold","page":"Introduction","title":"Manopt.distance","text":"distance(M,x,y)\n\ncomputes the gedoesic distance between two MPoints x and y on a Manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/#LinearAlgebra.dot-Union{Tuple{S}, Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T,S}} where S<:TVector where T<:TVector where P<:MPoint where mT<:Manifold","page":"Introduction","title":"LinearAlgebra.dot","text":"dot(M, x, ξ, ν)\n\nComputes the inner product of two TVectors ξ and ν from the tangent space at the MPoint x on the Manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/#Base.exp-Union{Tuple{N}, Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}, Tuple{mT,P,T,Float64}} where N<:Number where T<:TVector where P<:MPoint where mT<:Manifold","page":"Introduction","title":"Base.exp","text":"exp(M,x,ξ,[t=1.0])\n\ncomputes the exponential map at an MPoint x for the TVector ξ on the Manifold M. The optional parameter t can be used to shorten ξ to tξ.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.getValue-Union{Tuple{P}, Tuple{P}} where P<:MPoint","page":"Introduction","title":"Manopt.getValue","text":"getValue(x)\n\nget the value representing the MPoint x. This function defaults to returning x.value; if your representation is  different, you should implement this function for your type\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.getValue-Union{Tuple{T}, Tuple{T}} where T<:TVector","page":"Introduction","title":"Manopt.getValue","text":"getValue(ξ)\n\nget the value representing the TVector ξ. This function defaults to returning ξ.value; if your representation is  different, you should implement this function for your type\n\n\n\n","category":"method"},{"location":"manifolds/#Base.log-Union{Tuple{Q}, Tuple{P}, Tuple{mT}, Tuple{mT,P,Q}} where Q<:MPoint where P<:MPoint where mT<:Manifold","page":"Introduction","title":"Base.log","text":"log(M,x,y)\n\ncomputes the TVector in the tangent space T_xmathcal M at the MPoint x such that the corresponding geodesic reaches the MPoint y after time 1 on the Manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.manifoldDimension-Union{Tuple{P}, Tuple{P}} where P<:MPoint","page":"Introduction","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturn the dimension of the manifold M the point x belongs to.\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.manifoldDimension-Union{Tuple{mT}, Tuple{mT}} where mT<:Manifold","page":"Introduction","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturns the dimension of the manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/#LinearAlgebra.norm-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Introduction","title":"LinearAlgebra.norm","text":"norm(M,x,ξ)\n\ncomputes the length of a TVector ξ in the tangent space of the MPoint x on the Manifold M induced by the inner product.\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.parallelTransport-Union{Tuple{T}, Tuple{Q}, Tuple{P}, Tuple{mT}, Tuple{mT,P,Q,T}} where T<:TVector where Q<:MPoint where P<:MPoint where mT<:Manifold","page":"Introduction","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,y,ξ)\n\nParallel transport of a vector ξ given at the tangent space T_xmathcal M of x to the tangent space T_ymathcal M at y along the geodesic form x to y. If the geodesic is not unique, this function takes the same choice as geodesic.\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.randomMPoint-Union{Tuple{mT}, Tuple{mT,Symbol,Vararg{Any,N} where N}} where mT<:Manifold","page":"Introduction","title":"Manopt.randomMPoint","text":"randomMPoint(M,x [,:Gaussian,options...])\n\ngenerate a random MPoint on the Manifold M by falling back to the default :Gaussian noise with the default standard deviation on the specific manifold.\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.randomTVector-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P,Symbol,Vararg{Any,N} where N}} where P<:MPoint where mT<:Manifold","page":"Introduction","title":"Manopt.randomTVector","text":"randomTVector(M,x [,:Gaussian,options...])\n\ngenerate a random tangent vector at MPoint x on the Manifold M using :Gaussian noise where options usually contain the standard deviation σ on the specific manifold.\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.tangentONB-Union{Tuple{Q}, Tuple{P}, Tuple{mT}, Tuple{mT,P,Q}} where Q<:MPoint where P<:MPoint where mT<:Manifold","page":"Introduction","title":"Manopt.tangentONB","text":"(Ξ,κ) = tangentONB(M,x,y)\n\ncompute an ONB within the tangent space T_xmathcal M such that xi=log_xy is the first vector and compute the eigenvalues of the curvature tensor R(Xidot g)dot g, where g=g_xxi is the geodesic with g(0)=x, dot g(0) = xi, i.e. kappa_1 corresponding to Xi_1=xi is zero.\n\nSee also\n\njacobiField, adjointJacobiField.\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.tangentONB-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Introduction","title":"Manopt.tangentONB","text":"(Ξ,κ) = tangentONB(M,x,ξ)\n\ncompute an ONB within the tangent space T_xmathcal M such that xi is the first vector and compute the eigenvalues of the curvature tensor R(Xidot g)dot g, where g=g_xxi is the geodesic with g(0)=x, dot g(0) = xi, i.e. kappa_1 corresponding to Xi_1=xi is zero.\n\nSee also\n\njacobiField, adjointJacobiField.\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.typeofMPoint-Union{Tuple{T}, Tuple{T}} where T<:TVector","page":"Introduction","title":"Manopt.typeofMPoint","text":"typeofMPoint(ξ)\n\nreturn the MPoint belonging to the TVector type of ξ.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.typeofMPoint-Union{Tuple{Type{T}}, Tuple{T}} where T<:TVector","page":"Introduction","title":"Manopt.typeofMPoint","text":"typeofMPoint(T)\n\nreturn the MPoint belonging to the TVector type T.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.typeofTVector-Union{Tuple{P}, Tuple{P}} where P<:MPoint","page":"Introduction","title":"Manopt.typeofTVector","text":"typeofTVector(x)\n\nreturn the TVector belonging to the MPoint type of x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.typeofTVector-Union{Tuple{Type{P}}, Tuple{P}} where P<:MPoint","page":"Introduction","title":"Manopt.typeofTVector","text":"typeofTVector(P)\n\nreturns the TVector belonging to the MPoint type P.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.typicalDistance-Union{Tuple{mT}, Tuple{mT}} where mT<:Manifold","page":"Introduction","title":"Manopt.typicalDistance","text":"typicalDistance(M)\n\nreturns the typical distance on the Manifold M, which is for example the longest distance in a unit cell or injectivity radius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.zeroTVector-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P}} where P<:MPoint where mT<:Manifold","page":"Introduction","title":"Manopt.zeroTVector","text":"ξ = zeroTVector(M,x)\n\nreturns a zero vector in the tangent space T_xmathcal M of the MPoint xinmathcal M on the Manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/#Functions-implemented-for-a-general-manifold-1","page":"Introduction","title":"Functions implemented for a general manifold","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"the following base functions are implemented for general manifolds and are based on the functions from the last section","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"adjointJacobiField\ngeodesic\njacobiField\nManopt.mean\nManopt.median\nmidPoint\nreflection\nvariance","category":"page"},{"location":"manifolds/#Manopt.adjointJacobiField","page":"Introduction","title":"Manopt.adjointJacobiField","text":"ζ = adjointJacobiField(M,x,y,t,η,w)\n\ncompute the AdjointJacobiField J along the geodesic g_xy on the manifold mathcal M with initial conditions (depending on the application) etain T_g(txy)mathcal M and weights beta. The result is a vector zeta in T_xmathcal M. The main difference to jacobiField is the, that the input eta and the output zeta switched tangent spaces.\n\nFor detais see jacobiField\n\n\n\n","category":"function"},{"location":"manifolds/#Manopt.geodesic","page":"Introduction","title":"Manopt.geodesic","text":"geodesic(M,x,y)\n\nreturn a function to evaluate the geodesic connecting the two MPoints x and y on the Manifold M.\n\n\n\n\n\ngeodesic(M,x,y,n)\n\nreturn vector containing the equispaced n sample-values along the geodesic connecting the two MPoints x and y on the Manifold M.\n\n\n\n\n\ngeodesic(M,x,y,t)\n\nreturn the point along the geodesic from MPoint x to y given by at value t (in [0,1]) on the Manifold M\n\n\n\n\n\ngeodesic(M,x,y,T)\n\nreturn vector containing the MPoint along the geodesic from MPoint x to y on the Manifold M specified by the points from the vector T (of numbers between 0 and 1).\n\n\n\n\n\n","category":"function"},{"location":"manifolds/#Manopt.jacobiField","page":"Introduction","title":"Manopt.jacobiField","text":"ζ = jacobiField(M,x,y,t,η,β)\n\ncompute the jacobiField J along the geodesic g_xy on the Manifold M mathcal M with initial conditions (depending on the application) etain T_xmathcal M and weights beta. The result is a TVector in zeta in T_g(txy)mathcal M.\n\nSee also\n\nadjointJacobiField\n\n\n\n","category":"function"},{"location":"manifolds/#Statistics.mean","page":"Introduction","title":"Statistics.mean","text":"y = mean(M,x)\n\ncompute the Riemannian center of mass of the data given by the vector of MPoints x on the Manifold M. calculates the Riemannian Center of Mass (Karcher mean) of the input data x as an Array of MPoints on the Manifold with a steepestDescent or a cyclicProximalPoint.\n\nOptional\n\ninitialValue – (x[1]) the value to initialize the algorithm to\nmethod – (:GradientDescent) symbol indicating the algorithm to use, so the second variant is :CyclicProximalPoint\nweights – (1/n) compute a weighted Karcher mean, i.e. the dault is to set all weights to be 1/n where n is the length of x.\n\nas well as optional parameters that are passed down to the corresponding algorithm\n\n\n\n\n\n","category":"function"},{"location":"manifolds/#Statistics.median","page":"Introduction","title":"Statistics.median","text":"y = median(M,x)\n\ncompute the median of the data given by the vector of MPoints x on the Manifold M. calculates the Riemannian Center of Mass (Karcher mean) of the input data x as an Array of MPoints on the Manifold with a cyclicProximalPoint.\n\nOptional\n\ninitialValue – (x[1]) the value to initialize the algorithm to\nmethod – (:CyclicProximalPoint) symbol indicating the algorithm to use\nweights – (1/n) compute a weighted Karcher mean, i.e. the dault is to set all weights to be 1/n where n is the length of x.\n\nas well as optional parameters that are passed down to the corresponding algorithm\n\n\n\n","category":"function"},{"location":"manifolds/#Manopt.midPoint","page":"Introduction","title":"Manopt.midPoint","text":"midPoint(M,x,y,z)\n\ncompute the mid point between x and y. If there is more than one mid point of (not neccessarily miniizing) geodesics (i.e. on the sphere), the one nearest to z.\n\n\n\n\n\nmidPoint(M,x,y)\n\ncompute the (geodesic) mid point of the two MPoints x and y on the Manifold M. If the geodesic is not unique, either a deterministic choice is returned or an error is raised. For the deteministic choixe, see midPoint(M,x,y,z), the mid point closest to a third MPoint z.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/#Manopt.reflection","page":"Introduction","title":"Manopt.reflection","text":"y = reflection(M,p,x)\n\nreflect the MPoint x at MPoint p, i.e. compute y = R_p(x) = exp_p(-log_px). On Euclidean space this results in the point reflection R_p(x) = p - (x-p) = 2p-x.\n\nArguments\n\nM – a Manifold mathcal M\np – an MPoint pinmathcal M to relfect at\nx – an MPoint xinmathcal M that is reflected\n\nOutput\n\ny – the resulting reflection.\n\n\n\n","category":"function"},{"location":"manifolds/#Manopt.variance","page":"Introduction","title":"Manopt.variance","text":"variance(M,x)\n\nreturns the variance of the vector x of MPoints on the Manifold M\n\n\n\n\n\n","category":"function"},{"location":"manifolds/#A-decorator-for-checks-and-validation-1","page":"Introduction","title":"A decorator for checks and validation","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"In order to check and/or validate tangent vectors, the decorator pattern TVectorE is available for any subtype of TVector as follows","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"TVectorE","category":"page"},{"location":"manifolds/#Manopt.TVectorE","page":"Introduction","title":"Manopt.TVectorE","text":"TVectorE <: MPoint\n\nA decorator pattern based extension of TVector to additionally store the base point. The decorator is then used to verify, that exp and dot are only called with correct base points.\n\nConstructors\n\nTVectorE(ξ,x [,v=true])\n\nconstructs an extended tangential vector based on the TVector ξ with base MPoint x with optional validation v. If none of the first two arguments is an extended element, v defaults to true, otherwise, the one which is an extended is inherited or the && of both validations.\n\n\n\n","category":"type"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"together with a small helper MPointE that indicates to the log to returns an extended tangent vector as soon as one of its arguments is an extended manifold point.","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"MPointE","category":"page"},{"location":"manifolds/#Manopt.MPointE","page":"Introduction","title":"Manopt.MPointE","text":"MPointE <: MPoint\n\nA decorator pattern based extension of MPoint to identify when to switch to the extended TVectorE for functions just working on points, e.g. log. The constructor avoids multiple encapsualtions of extensions.\n\nConstructors\n\nMPointE(x [,v=true])\n\nthe point can constructed by extending an existing MPoint. optionally, the validation can be turned off (but is trueby default). If x is a MPointE the default of v is taken from x.\n\n\n\n","category":"type"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"for these two data items, the following additional features that are activated","category":"page"},{"location":"manifolds/#Inheritance-1","page":"Introduction","title":"Inheritance","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"Basic functions like exp, log, parallelTransport, and randomTVector return an extended MPointE or TVectorE whenever one of its arguments is an extended input. This enables, that setting (only) one input for a calculation to an extended version, this property propagates this into all the algorithm.","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"Note that this might increase memory usage and hence reduce performance, since for any TVectorE internally stores both a TVector as well as its base MPoint (as extension).","category":"page"},{"location":"manifolds/#Checks-1","page":"Introduction","title":"Checks","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"checkBasePoint","category":"page"},{"location":"manifolds/#Manopt.checkBasePoint","page":"Introduction","title":"Manopt.checkBasePoint","text":"checkBasePoint(ξ,ν)\n\nchecks, whether the base of two tangent vectors is identical, if both tangent vectors are of type TVectorE. If one of them is not an extended vector, the function returns true, expecting the tangent vector implicitly to be correct.\n\n\n\n\n\ncheckBasePoint(ξ,x)\n\nchecks, whether the base of the tangent vector ξ is x. If ξ is not an extended tangent vector TVectorE the function returns true, assuming the base implicitly to be correct\n\n\n\n\n\n","category":"function"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"For extended data decorators, whenever possible in the basic functions listed above a checkBasePoint completely automatically performed. For example, when calling exp(M,x,ξ), as soon as ξ is an extended vector, checkBasePoint(x,ξ) is called before performing the original exponential map.","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"This way, as many checks are performed, whether corresponding points and vectors or two vectors involved have the correct base points.","category":"page"},{"location":"manifolds/#Validation-1","page":"Introduction","title":"Validation","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"Every extended type carries a further boolean validation, whose default is true, i.e. to perform validation. activating validation one needs to implement the following two functions, otherwise, a lot of warnings might occur.","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"validateMPoint(::mT, ::P) where {mT <: Manifold, P <: MPoint}\nvalidateTVector(::mT,::P,::T) where {mT<:Manifold, P<: MPoint, T<:TVector}","category":"page"},{"location":"manifolds/#Manopt.validateMPoint-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P}} where P<:MPoint where mT<:Manifold","page":"Introduction","title":"Manopt.validateMPoint","text":"validateMPoint(M,x)\n\ncheck, whether the data in the MPoint x is a valid point on the Manifold M. This is used to validate parameters and results during computations using MPointEs. Note that the default fallback is just a warning that no validation is available.\n\nThe function should throw an error if x is not point on the manifold M, otherwise it should return true.\n\n\n\n","category":"method"},{"location":"manifolds/#Manopt.validateTVector-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Introduction","title":"Manopt.validateTVector","text":"validateTVector(M,x,ξ)\n\ncheck, whether the data in the TVector ξ is a valid tangent vector #to the MPoint x on the Manifold M. This is used to validate parameters and results during computations when using MPointEs.  Note that the default fallback is just a warning that no validation is available.\n\nAvailable validations should throw an error if x is not on M or ξ is not in the tangent space of x. If ξ is valid, the function returns true.\n\n\n\n","category":"method"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"whenever possible (see checkBasePoint above). Since such a validation might not be available for your favorite manifold, you can deactivate validation by setting the boolean to false. Every new extended type inherits the false, whenever one of its part (i.e. either the TVector or MPoint) has validation set to false.","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"So while checking as often as possible, this feature can easily be deactivated.","category":"page"},{"location":"manifolds/#Internals-1","page":"Introduction","title":"Internals","text":"","category":"section"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"To access the inner value of MPointE and the base stored in TVectorE you can use","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"strip\ngetBasePoint","category":"page"},{"location":"manifolds/#Base.strip","page":"Introduction","title":"Base.strip","text":"strip(ξ)\n\nreturns the internal TVector of an extended tangent vector TVectorE.\n\n\n\n\n\nstrip(x)\n\nreturns the MPoint the MPointE x stores internally. If applied to an already non-extended MPoint, nothing happens.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/#Manopt.getBasePoint","page":"Introduction","title":"Manopt.getBasePoint","text":"getBasePoint(ξ)\n\nreturns the base point of an extended tangent vector. To continue promotion of the extended type, the result is always a MPointE. To eliminate the decorator, use strip.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"Furthermore the following functions are mapping to the internally stored data and encapsulate the results with the extended variant if applicable","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"getValue\naddNoise\ndistance\ndot\nexp\ngetValue\nlog\nmanifoldDimension\nnorm\nparallelTransport\nrandomMPoint\nrandomTVector\ntangentONB\ntypicalDistance\nzeroTVector","category":"page"},{"location":"manifolds/#","page":"Introduction","title":"Introduction","text":"as well as mathematical operators on tangent vectors and comparison operators.","category":"page"},{"location":"manifolds/combined/#CombinedManifolds-1","page":"Combinations of Manifolds","title":"Special Manifolds build upon one or more Riemannian manifolds","text":"","category":"section"},{"location":"manifolds/combined/#","page":"Combinations of Manifolds","title":"Combinations of Manifolds","text":"CurrentModule = Manopt","category":"page"},{"location":"manifolds/combined/#SubSecTangentBundle-1","page":"Combinations of Manifolds","title":"Tangent bundle","text":"","category":"section"},{"location":"manifolds/combined/#","page":"Combinations of Manifolds","title":"Combinations of Manifolds","text":"The tangent bundle Tmathcal M of a manifold mathcal M consists of all tuples (xxi) in Tmathcal M, where xiin T_xmathcal M, xin mathcal M, where the metric is inherited component wise and for the exponential and logarithmic map, the second component requires a parallelTransport.","category":"page"},{"location":"manifolds/combined/#Tangent-Bundle-Types-1","page":"Combinations of Manifolds","title":"Tangent Bundle Types","text":"","category":"section"},{"location":"manifolds/combined/#","page":"Combinations of Manifolds","title":"Combinations of Manifolds","text":"Modules = [Manopt]\nPages = [\"manifolds/TangentBundle.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/combined/#Manopt.TBPoint","page":"Combinations of Manifolds","title":"Manopt.TBPoint","text":"TBPoint <: MPoint\n\nA point Nin mathcal M on the manifold mathcal M = Tmathcal N represented by a tuple (x,ξ), where xinmathcal N is a point on the manifold and xi=xi_xin T_xmathcal N is a point in the tangent space at x.\n\nTwo constructors are available:\n\nTBPoint(x,ξ) to construct a tangent bundle point by specifying both an MPoint x and a TVector ξ.\nTBPoint( (X) ) to construct a tangent bundle point from a tuple X=(x,ξ),\n\ni.e. the value  of another tangent bundle point.\n\n\n\n","category":"type"},{"location":"manifolds/combined/#Manopt.TBTVector","page":"Combinations of Manifolds","title":"Manopt.TBTVector","text":"TBTVector <: TVector\n\nA tangent vector Xi in T_Xmathcal M on the manifold mathcal M = Tmathcal N for the (base) manifold mathcal N. Both tangent components can be represented by elements from the base point x from within X=(xxi). Both components are from the same space since TT_xmathcal N= T_xmathcal N, hence the tangent vector is a tuple (xinu)in T_xmathcal Ntimes T_xmathcal N. As for the TBPoint two constructors are available, one for stwo seperate tangent vectors, one for a tuple of two tangent vectors.\n\n\n\n","category":"type"},{"location":"manifolds/combined/#Manopt.TangentBundle","page":"Combinations of Manifolds","title":"Manopt.TangentBundle","text":"TangentBundle <: Manifold\n\nThe manifold mathcal M = Tmathcal N obtained by looking at the tangent bundle of a Manifolds tangent spaces. The manifold obtained is of dimension 2d, where d is the dimension of the manifold mathcal N considered.\n\nTo keep notations clear, small letters will always refer to points (x,y) or tangent vectors (ξ,η) on the manifold mathcal N, while capital letters (X, Y, Z and Ξ,Η) will refer to points and tangent vectors in the tangent bundle respectively.\n\nAbbreviation\n\nTB\n\nConstructor\n\nTangentBundle(M)\n\ngenerates the tangent bundle to the Manifold M.\n\n\n\n","category":"type"},{"location":"manifolds/combined/#Tangent-Bundle-Functions-1","page":"Combinations of Manifolds","title":"Tangent Bundle Functions","text":"","category":"section"},{"location":"manifolds/combined/#","page":"Combinations of Manifolds","title":"Combinations of Manifolds","text":"Modules = [Manopt]\nPages = [\"manifolds/TangentBundle.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/combined/#Base.exp","page":"Combinations of Manifolds","title":"Base.exp","text":"exp(M,X,Ξ[, t=1.0])\n\nCompute the exponential map on the TangentBundle M=Tmathcal N with respect to the TBPointX=(x,ξ) and the TBTVectorΞ=(Ξx,Ξξ), which consists of the exponential map in the first component (exp(x,Ξx,t) and a (scaled) addition in the second (ξ + tΞξ) in the second component followed by a parallel transport.\n\n\n\n","category":"function"},{"location":"manifolds/combined/#Base.log-Tuple{TangentBundle,TBPoint,TBPoint}","page":"Combinations of Manifolds","title":"Base.log","text":"log(M,X,Y)\n\nCompute the logarithmic map on the TangentBundle mathcal M=Tmathcal N, i.e. the log for the base manifold component and a parallel transport and a minus for the tangent components.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#LinearAlgebra.dot-Tuple{TangentBundle,TBPoint,TBTVector,TBTVector}","page":"Combinations of Manifolds","title":"LinearAlgebra.dot","text":"dot(M,X,Ξ,Η)\n\nCompute the Riemannian inner product for two TBTVectors Ξ and Η from T_Xmathcal M of the TangentBundleM = TN given by the sum of the two inner products of the tangent vector components\n\n\n\n","category":"method"},{"location":"manifolds/combined/#LinearAlgebra.norm-Tuple{TangentBundle,TBPoint,TBTVector}","page":"Combinations of Manifolds","title":"LinearAlgebra.norm","text":"norm(M,X,Ξ)\n\nComputes the norm of the TBTVectorΞ in the tangent space T_xmathcal M at TBPointX of the TangentBundle M.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.distance-Tuple{TangentBundle,TBPoint,TBPoint}","page":"Combinations of Manifolds","title":"Manopt.distance","text":"distance(M,X,Y)\n\nCompute the Riemannian distance on mathcal M=Tmathcal N by employing the distance on the manifold for the base component and the vector norm on the tangent space, and then take the Eucklidean Norm of the vector from mathbb R^2.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.getBase-Tuple{TBTVector}","page":"Combinations of Manifolds","title":"Manopt.getBase","text":"getBase(Ξ)\n\nreturn the base of the TBTVectorΞ, i.e. its first TVector.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.getBase-Tuple{TangentBundle}","page":"Combinations of Manifolds","title":"Manopt.getBase","text":"getBase(M)\n\nreturn the base manifold of the TangentBundle Manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.getBase-Union{Tuple{TBPoint{P,T}}, Tuple{T}, Tuple{P}} where T<:TVector where P<:MPoint","page":"Combinations of Manifolds","title":"Manopt.getBase","text":"getBase(X)\n\nreturn the base of the TBPointX, i.e. its MPoint.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.getTangent-Tuple{TBTVector}","page":"Combinations of Manifolds","title":"Manopt.getTangent","text":"getTangent(Ξ)\n\nreturn the tangent of the TBTVectorΞ, i.e. its second TBTVector.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.getTangent-Union{Tuple{TBPoint{P,T}}, Tuple{T}, Tuple{P}} where T<:TVector where P<:MPoint","page":"Combinations of Manifolds","title":"Manopt.getTangent","text":"getTangent(X)\n\nreturn the tangent of the TBPointX, i.e. the its TVector.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.getValue-Tuple{TBTVector}","page":"Combinations of Manifolds","title":"Manopt.getValue","text":"getValue(Ξ)\n\nreturn the Tuple contained in the TBTVectorΞ, i.e. its tuple of two TVectors.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.getValue-Union{Tuple{TBPoint{P,T}}, Tuple{T}, Tuple{P}} where T<:TVector where P<:MPoint","page":"Combinations of Manifolds","title":"Manopt.getValue","text":"getValue(X)\n\nreturn the value of the TBPoint X, i.e. the Tuple of a MPoint and its TVector.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.manifoldDimension-Tuple{TBPoint}","page":"Combinations of Manifolds","title":"Manopt.manifoldDimension","text":"manifoldDimension(X)\n\nreturns the dimension of the TangentBundle M=Tmathcal N to which X bvelongs, which is twice the dimension of the base manifold.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.manifoldDimension-Tuple{TangentBundle}","page":"Combinations of Manifolds","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturns the dimension of the TangentBundle M=Tmathcal N, i.e., twice the dimension of the base manifold N.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.parallelTransport-Tuple{TangentBundle,TBPoint,TBPoint,TBTVector}","page":"Combinations of Manifolds","title":"Manopt.parallelTransport","text":"parallelTransport(M,X,Y,Ξ)\n\nCompute the paralllel transport of the TBTVectorΞ from the tangent space T_Xmathcal M at TBPointX to T_Ymathcal M at TBPointY on the TangentBundle M provided that the corresponding geodesic g(cdotxy) is unique. Then both components of Xi=(Xi_xXi_xi) are parallely transported using the parallel transport of the underlying base manifold.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.randomMPoint-Tuple{TangentBundle}","page":"Combinations of Manifolds","title":"Manopt.randomMPoint","text":"randomMPoint(M)\n\nreturns a random point on the TangentBundle M by producing a randomMPoint  random point on the base manifold and randomTVector in the correspoinding tangent plane.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.randomTVector-Tuple{TangentBundle,TBPoint}","page":"Combinations of Manifolds","title":"Manopt.randomTVector","text":"randomTVector(M,x)\n\nreturns a random tangent vector the TangentBundle M by producing two randomTVectors in the correspoinding tangent plane of the getBase of the TBPoint x.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.tangentONB-Tuple{TangentBundle,TBPoint,TBPoint}","page":"Combinations of Manifolds","title":"Manopt.tangentONB","text":"tangentONB(M,X,Y)\n\nconstructs a tangent ONB in the tangent space of the TBPointX on the TangentBundle M, where log_XY is the first component.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.tangentONB-Tuple{TangentBundle,TBPoint,TBTVector}","page":"Combinations of Manifolds","title":"Manopt.tangentONB","text":"Η,κ = tangentONB(M,X,Ξ)\n\nconstructs a tangent ONB in T_Xmathcal M, i.e. in the tangent space of the TBPoint x on the TangentBundle M whose first vector is given by the TBTVectorΞ. It is constructed by using twice the tangent ONB of the base manifold.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.typicalDistance-Tuple{TangentBundle}","page":"Combinations of Manifolds","title":"Manopt.typicalDistance","text":"typicalDistance(M)\n\nreturns the typical distance on the TangentBundle M, i.e. for mathcal M = Tmathcal N we obtain t_mathcal M = sqrtt_mathcal N^2 + d_mathcal N^2, where d denotes the manifold dimension.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.validateMPoint-Tuple{TangentBundle,TBPoint}","page":"Combinations of Manifolds","title":"Manopt.validateMPoint","text":"validateMPoint(M,X)\n\nvalidate that the TBPointX is a valid point on the TangentBundle M, i.e. the first component is a point on the base manifold and the second a tangent vector is the tangent space of the first \n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.validateTVector-Tuple{TangentBundle,TBPoint,TBTVector}","page":"Combinations of Manifolds","title":"Manopt.validateTVector","text":"validateTVector(M,X,Ξ)\n\nvalidate, that the TBTVectorΞ is a valid tangent vector in the tangent space of the TBPointX on the TangentBundle M, i.e. both components of Ξ are tangent vectors in the tangent space of the base component of X, since the tangent space of the tangent space is represented as the tangent space itself.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.zeroTVector-Union{Tuple{P}, Tuple{Mt}, Tuple{TangentBundle{Mt},TBPoint{P,T} where T<:TVector}} where P<:MPoint where Mt<:Manifold","page":"Combinations of Manifolds","title":"Manopt.zeroTVector","text":"zeroTVector(M,X)\n\nreturns a zero vector in the tangent space T_Xmathcal M of the TangentBundle X=(xξ)in Tmathcal N by creating two zero vectors in T_xmathcal M.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Power-Manifold-1","page":"Combinations of Manifolds","title":"Power Manifold","text":"","category":"section"},{"location":"manifolds/combined/#","page":"Combinations of Manifolds","title":"Combinations of Manifolds","text":"The product manifold mathcal M^n, where ninmathbb N^k represents arrays that are manifold-valued, for example, if n is a number (k=1) we obtain a manifold-valued signal finmathcal M^n. Many operations are performed element wise, while for example the distance on the power manifold is the ell^2 norm of the element wise distances.","category":"page"},{"location":"manifolds/combined/#Power-Manifold-Types-1","page":"Combinations of Manifolds","title":"Power Manifold Types","text":"","category":"section"},{"location":"manifolds/combined/#","page":"Combinations of Manifolds","title":"Combinations of Manifolds","text":"Modules = [Manopt]\nPages = [\"manifolds/Power.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/combined/#Manopt.PowPoint","page":"Combinations of Manifolds","title":"Manopt.PowPoint","text":"PowPoint <: MPoint\n\nA point on the power manifold mathcal M = mathcal N^n represented by an array (of size n) of MPoints.\n\n\n\n","category":"type"},{"location":"manifolds/combined/#Manopt.PowTVector","page":"Combinations of Manifolds","title":"Manopt.PowTVector","text":"PowTVector <: TVector\n\nA tangent vector on the power manifold mathcal M = mathcal N^n represented by an array (of size n) of TVectors.\n\n\n\n","category":"type"},{"location":"manifolds/combined/#Manopt.Power","page":"Combinations of Manifolds","title":"Manopt.Power","text":"Power{M<:Manifold} <: Manifold\n\nA power manifold mathcal M = mathcal N^n, where n can be an integer or an integer vector.\n\nAbbreviation\n\nPow\n\nConstructors\n\nPower(M,n)\n\nconstruct the power manifold mathcal M^n for a Manifold M and a natural number n.\n\nPower(M,n)\n\nconstruct the power manifold mathcal M^n_1times n_2timescdotstimes n_d for a Manifold M and a Tuple or Array n of natural numbers.\n\n\n\n","category":"type"},{"location":"manifolds/combined/#Power-Manifold-Functions-1","page":"Combinations of Manifolds","title":"Power Manifold Functions","text":"","category":"section"},{"location":"manifolds/combined/#","page":"Combinations of Manifolds","title":"Combinations of Manifolds","text":"Modules = [Manopt]\nPages = [\"manifolds/Power.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/combined/#Base.exp","page":"Combinations of Manifolds","title":"Base.exp","text":"exp(M,x,ξ[, t=1.0])\n\ncompute the product exponential map on the Power manifold M and return the corresponding PowPoint.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/combined/#Base.log-Tuple{Power,PowPoint,PowPoint}","page":"Combinations of Manifolds","title":"Base.log","text":"log(M,x,y)\n\ncompute the product logarithmic map on the Power manifold M and return the corresponding PowTVector.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/combined/#LinearAlgebra.dot-Tuple{Power,PowPoint,PowTVector,PowTVector}","page":"Combinations of Manifolds","title":"LinearAlgebra.dot","text":"dot(M,x,ξ,ν)\n\ncompute the inner product as sum of the component inner products on the Power manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/combined/#LinearAlgebra.norm-Tuple{Power,PowPoint,PowTVector}","page":"Combinations of Manifolds","title":"LinearAlgebra.norm","text":"norm(M,x,ξ)\n\ncompute the norm of the [PowTVector] ξ induced by the metric on the manifold components of the Power manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.distance-Tuple{Power,PowPoint,PowPoint}","page":"Combinations of Manifolds","title":"Manopt.distance","text":"distance(M,x,y)\n\ncompute a vectorized version of distance on the [Power] manifold M for two PowPoint x and y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.manifoldDimension-Tuple{PowPoint}","page":"Combinations of Manifolds","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturn the (product of) dimension(s) of the Power the PowPointx belongs to.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.manifoldDimension-Tuple{Power}","page":"Combinations of Manifolds","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturn the (product of) dimension(s) of the Power manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.parallelTransport-Tuple{Power,PowPoint,PowPoint,PowTVector}","page":"Combinations of Manifolds","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,y,ξ)\n\ncompute the product parallelTransport map on the Power manifold M from the PowPoint x to y of the PowTVector ξ.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.project-Tuple{Power,PowPoint,Array{#s37,N} where N where #s37}","page":"Combinations of Manifolds","title":"Manopt.project","text":"project(M,x,v)\n\ncompute the product project map on the Power manifold M of the PowPoint x. v is an array of the elements, embedded in the same space as the manifold, which get projected elementwise.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.randomMPoint-Tuple{Power,Vararg{Any,N} where N}","page":"Combinations of Manifolds","title":"Manopt.randomMPoint","text":"randomMPoint(M)\n\nconstruct a random point on the Power manifold M, by creating n points on the Manifold M.manifold as corresponding PowPoint. Optional values are passed down.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.randomTVector-Tuple{Power,PowPoint,Vararg{Any,N} where N}","page":"Combinations of Manifolds","title":"Manopt.randomTVector","text":"randomTVector(M,x)\n\nconstruct a random tangent vector on the Power manifold M, by creating n tangent vectors on the Manifold M.manifold at the enrties of the PowPoint x. Optional values are passed down.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.tangentONB-Tuple{Power,PowPoint,PowPoint}","page":"Combinations of Manifolds","title":"Manopt.tangentONB","text":"(Ξ,κ) = tangentONB(M,x,y)\n\ncompute an ONB within the tangent space T_xmathcal M such that xi=log_xy is the first vector and compute the eigenvalues of the curvature tensor R(Xidot g)dot g, where g=g_xxi is the geodesic with g(0)=x, dot g(0) = xi, i.e. kappa_1 corresponding to Xi_1=xi is zero.\n\nSee also\n\njacobiField, adjointJacobiField.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.typicalDistance-Tuple{Power}","page":"Combinations of Manifolds","title":"Manopt.typicalDistance","text":"typicalDistance(M)\n\nreturns the typical distance on the Power manifold M, which is based on the elementwise manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.zeroTVector-Union{Tuple{N}, Tuple{P}, Tuple{Mt}, Tuple{Power{Mt},PowPoint{P,N}}} where N where P<:MPoint where Mt<:Manifold","page":"Combinations of Manifolds","title":"Manopt.zeroTVector","text":"ξ = zeroTVector(M,x)\n\nreturns a zero vector in the tangent space T_xmathcal M of the PowPoint xinmathcal M on the Power manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Product-Manifold-1","page":"Combinations of Manifolds","title":"Product Manifold","text":"","category":"section"},{"location":"manifolds/combined/#","page":"Combinations of Manifolds","title":"Combinations of Manifolds","text":"A little more general is the product manifold, where mathcal M = mathcal N_1timescdotstimesmathcal N_n, ninmathbb N^k is a product of manifolds, i.e. for a value finmathcal M we have that f_iinmathcal N_i, where i might be a multi-index.","category":"page"},{"location":"manifolds/combined/#Product-Manifold-Types-1","page":"Combinations of Manifolds","title":"Product Manifold Types","text":"","category":"section"},{"location":"manifolds/combined/#","page":"Combinations of Manifolds","title":"Combinations of Manifolds","text":"Modules = [Manopt]\nPages = [\"manifolds/Product.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/combined/#Manopt.ProdPoint","page":"Combinations of Manifolds","title":"Manopt.ProdPoint","text":"ProdPoint <: MPoint\n\nA point on the Product mathcal M = mathcal N_1timesmathcal N_2timescdotstimesmathcal N_m,minmathbb N, represented by a vector or array of MPoints.\n\n\n\n","category":"type"},{"location":"manifolds/combined/#Manopt.ProdTVector","page":"Combinations of Manifolds","title":"Manopt.ProdTVector","text":"ProdTVector <: TVector\n\nA tangent vector in the product of tangent spaces of the Product Tmathcal M = Tmathcal N_1times Tmathcal N_2timescdotstimes Tmathcal N_m,minmathbb N, represented by a vector or array of TVectors.\n\n\n\n","category":"type"},{"location":"manifolds/combined/#Manopt.Product","page":"Combinations of Manifolds","title":"Manopt.Product","text":"Product{M<:Manifold} <: Manifold\n\na product manifold mathcal M = mathcal N_1timesmathcal N_2timescdotstimesmathcal N_m, minmathbb N, concatinates a set of manifolds mathcal N_i, i=1ldotsm, into one using the sum of the metrics to impose a metric on this manifold. The manifold can also be an arbitrary Array of manifolds, not necessarily only a vector.\n\nAbbreviation\n\nProd\n\nConstructor\n\nProduct(m)\n\nconstructs a Power Manifold based on an array m of Manifolds.\n\n\n\n","category":"type"},{"location":"manifolds/combined/#Product-Manifold-Functions-1","page":"Combinations of Manifolds","title":"Product Manifold Functions","text":"","category":"section"},{"location":"manifolds/combined/#","page":"Combinations of Manifolds","title":"Combinations of Manifolds","text":"Modules = [Manopt]\nPages = [\"manifolds/Product.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/combined/#Base.exp","page":"Combinations of Manifolds","title":"Base.exp","text":"exp(M,x,ξ)\n\ncomputes the product exponential map on the Product manifold M and returns the corresponding ProdPoint.\n\n\n\n","category":"function"},{"location":"manifolds/combined/#Base.log-Tuple{Product,ProdPoint,ProdPoint}","page":"Combinations of Manifolds","title":"Base.log","text":"log(M,x,y)\n\ncomputes the product logarithmic map from ProdPoint x to y on the Product manifold M and returns the corresponding ProdTVector.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#LinearAlgebra.dot-Tuple{Product,ProdPoint,ProdTVector,ProdTVector}","page":"Combinations of Manifolds","title":"LinearAlgebra.dot","text":"dot(M,x,ξ,ν)\n\ncompute the inner product as sum of the component inner products on the Product manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#LinearAlgebra.norm-Tuple{Product,ProdPoint,ProdTVector}","page":"Combinations of Manifolds","title":"LinearAlgebra.norm","text":"norm(M,x,ξ)\n\nnorm of the ProdTVector ξ induced by the metric on the manifold components of the Product manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.distance-Tuple{Product,ProdPoint,ProdPoint}","page":"Combinations of Manifolds","title":"Manopt.distance","text":"distance(M,x,y)\n\ncompute a vectorized version of distance for two ProdPoints x and y on the Product manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.manifoldDimension-Tuple{ProdPoint}","page":"Combinations of Manifolds","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturns the (product of) dimension(s) of the Product manifold M the ProdPoint x belongs to.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.manifoldDimension-Tuple{Product}","page":"Combinations of Manifolds","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturns the (product of) dimension(s) of the Product manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.parallelTransport-Tuple{Product,ProdPoint,ProdPoint,ProdTVector}","page":"Combinations of Manifolds","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,ξ)\n\ncomputes the product parallelTransport map on the Product manifold M and returns the corresponding ProdTVector.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.project-Tuple{Product,ProdPoint,Array{#s37,N} where N where #s37}","page":"Combinations of Manifolds","title":"Manopt.project","text":"project(M,x,v)\n\ncompute the product project map on the Product manifold M of the ProdPoint x. v is an array of the elements, embedded in the same space as the manifold, which get projected elementwise.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.randomMPoint-Tuple{Product,Vararg{Any,N} where N}","page":"Combinations of Manifolds","title":"Manopt.randomMPoint","text":"randomMPoint(M)\n\ngenerate a random point on Product manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.randomTVector-Union{Tuple{N}, Tuple{Product,ProdPoint,Vararg{Any,N} where N}} where N","page":"Combinations of Manifolds","title":"Manopt.randomTVector","text":"randomTVector(M,x)\n\ngenerate a random tangent vector in the tangent space of the ProdPoint x on Product manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.retraction","page":"Combinations of Manifolds","title":"Manopt.retraction","text":"retraction(M,x,ξ [,t=1.0])\n\nmove the ProdPoint x in the direction of the ProdTVector ξ on the Product manifold M.\n\n\n\n","category":"function"},{"location":"manifolds/combined/#Manopt.typicalDistance-Tuple{Product}","page":"Combinations of Manifolds","title":"Manopt.typicalDistance","text":"typicalDistance(M)\n\nreturns the typical distance on Product manifold M, which is the minimum of the internal ones.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.validateMPoint-Tuple{Product,ProdPoint}","page":"Combinations of Manifolds","title":"Manopt.validateMPoint","text":"validateMPoint(M,x)\n\nvalidate, that the ProdPoint x is a point on the Product manifold M, i.e. that the array dimensions are correct and that all elements are valid points on each elements manifolds\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.validateTVector-Tuple{Product,ProdPoint,ProdTVector}","page":"Combinations of Manifolds","title":"Manopt.validateTVector","text":"validateTVector(M,x,ξ)\n\nvalidate, that the ProdTVector ξ is a valid tangent vector to the ProdPoint x on the Product manifold M, i.e. that all three array dimensions match and this validation holds elementwise.\n\n\n\n","category":"method"},{"location":"manifolds/combined/#Manopt.zeroTVector-Tuple{Product,ProdPoint}","page":"Combinations of Manifolds","title":"Manopt.zeroTVector","text":"ξ = zeroTVector(M,x)\n\nreturns a zero vector in the tangent space T_xmathcal M of the ProdPoint xinmathcal M on the Product manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#CircleManifold-1","page":"The Circle mathbb S^1","title":"The 1-dimensional sphere mathbb S^1 represented by angles","text":"","category":"section"},{"location":"manifolds/circle/#","page":"The Circle mathbb S^1","title":"The Circle mathbb S^1","text":"The circle mathbb S^1 possesses the following instances of the abstract types Manifold, MPoint, and TVector.","category":"page"},{"location":"manifolds/circle/#","page":"The Circle mathbb S^1","title":"The Circle mathbb S^1","text":"Modules = [Manopt]\nPages = [\"manifolds/Circle.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/circle/#Manopt.Circle","page":"The Circle mathbb S^1","title":"Manopt.Circle","text":"Circle <: Manifold\n\nThe one-dimensional manifold mathbb S^1 represented by angles. Note that one can also use the n-dimensional sphere with n=1 to obtain the same manifold represented by unit vectors in mathbb R^2.\n\nAbbreviation\n\nS1\n\nConstructor\n\nCircle()\n\nconstruct a circle\n\n\n\n","category":"type"},{"location":"manifolds/circle/#Manopt.S1Point","page":"The Circle mathbb S^1","title":"Manopt.S1Point","text":"S1Point <: MPoint\n\na point xinmathbb S^1 represented by an angle getValue(x)in-pipi), usually referred to as “cyclic“ or “phase” data.\n\n\n\n","category":"type"},{"location":"manifolds/circle/#Manopt.S1TVector","page":"The Circle mathbb S^1","title":"Manopt.S1TVector","text":"S1TVector <: TVector\n\na tangent vector xiinmathbb S^1 represented by a real value getValue(ξ)inmathbb R.\n\n\n\n","category":"type"},{"location":"manifolds/circle/#Functions-1","page":"The Circle mathbb S^1","title":"Functions","text":"","category":"section"},{"location":"manifolds/circle/#","page":"The Circle mathbb S^1","title":"The Circle mathbb S^1","text":"Modules = [Manopt]\nPages = [\"manifolds/Circle.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/circle/#Base.exp","page":"The Circle mathbb S^1","title":"Base.exp","text":"exp(M,x,ξ,[t=1.0])\n\ncompute the exponential map on the Circle mathbb S^1 with respect to the S1Point x and the S1TVector ξ, which can be shortened with t to tξ. The formula reads\n\ny = (x+xi)_2pi\n\nwhere (cdot)_2pi is the symmetric remainder modulo 2pi, see symRem.\n\n\n\n","category":"function"},{"location":"manifolds/circle/#Base.log-Tuple{Circle,S1Point,S1Point}","page":"The Circle mathbb S^1","title":"Base.log","text":"log(M,x,y)\n\ncompute the logarithmic map on the Circle mathbb S^1, i.e., the S1TVector ξ whose corresponding geodesic starting from S1Point x reaches the S1Pointy after time 1. The formula reads\n\nxi = (y-x)_2pi\n\nwhere (cdot)_2pi is the symmetric remainder modulo 2pi, see symRem.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#LinearAlgebra.dot-Tuple{Circle,S1Point,S1TVector,S1TVector}","page":"The Circle mathbb S^1","title":"LinearAlgebra.dot","text":"dot(M,x,ξ,ν)\n\ncompute the inner product of two S1TVectors in the tangent space T_xmathbb S^1 of the S1Point x. Since the values are angles, we obtain langle xinurangle_x = xinu.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#LinearAlgebra.norm-Tuple{Circle,S1Point,S1TVector}","page":"The Circle mathbb S^1","title":"LinearAlgebra.norm","text":"norm(M,x,ξ)\n\ncompute the norm of the S1TVector ξ in the tangent space T_xmathcal M at S1Point x of the Circle mathbb S^1, which is just its absolute value lvertxirvert.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.distance-Tuple{Circle,S1Point,S1Point}","page":"The Circle mathbb S^1","title":"Manopt.distance","text":"distance(M,x,y)\n\nreturn the distance two cyclic data items, which is given by lvert (x-y)_2pi rvert  where (cdot)_2pi is the symmetric remainder modulo 2pi, see symRem.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.embed-Tuple{Circle,S1Point}","page":"The Circle mathbb S^1","title":"Manopt.embed","text":"embed(M,x)\n\nembed the CircleManifold, i.e. turn the S1Point into an SnPoint on the manifold Sphere(1) embedded in mathbb R^2.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.manifoldDimension-Tuple{Circle}","page":"The Circle mathbb S^1","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturn the dimension of the Circle manifold, i.e., 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.manifoldDimension-Tuple{S1Point}","page":"The Circle mathbb S^1","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturn the dimension of the manifold the S1Point x belongs to, i.e. of the Circle, which is 1.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.opposite-Tuple{Circle,S1Point}","page":"The Circle mathbb S^1","title":"Manopt.opposite","text":"opposite(M,x)\n\nreturn the antipodal S1Point of x on the Circle M, i.e. y = (x+pi)_2pi.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.parallelTransport-Tuple{Circle,S1Point,S1Point,S1TVector}","page":"The Circle mathbb S^1","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,y,ξ)\n\ncompute the parallel transport of the S1TVector ξ from the tangent space T_xmathbb S^1 at the S1Point x to T_ymathbb S^1 at the S1Pointy. Since the Sphere M is represented in angles this is the identity.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.project-Tuple{Circle,S1Point,Float64}","page":"The Circle mathbb S^1","title":"Manopt.project","text":"project(M,x,v)\n\nproject a number v on the tangent space of the S1Point x.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.randomMPoint-Tuple{Circle,Val{:Uniform}}","page":"The Circle mathbb S^1","title":"Manopt.randomMPoint","text":"randomMPoint(M,:Uniform)\n\nreturn a random S1Point on the Circle mathbb S^1 by picking a random element from -pipi) uniformly.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.randomTVector","page":"The Circle mathbb S^1","title":"Manopt.randomTVector","text":"randomTVector(M,x [,Gaussian,σ=1.0])\n\nreturns a random tangent vector from the tangent space of the S1Point  x on the Circle mathbb S^1 by using a normal distribution with mean 0 and standard deviation 1.\n\n\n\n","category":"function"},{"location":"manifolds/circle/#Manopt.symRem","page":"The Circle mathbb S^1","title":"Manopt.symRem","text":"symRem(x,[T=π])\n\nsymmetric remainder of x with respect to the interall 2*T, i.e. (x+T)%2T, where the default for T is pi\n\n\n\n","category":"function"},{"location":"manifolds/circle/#Manopt.tangentONB-Tuple{Circle,S1Point,S1Point}","page":"The Circle mathbb S^1","title":"Manopt.tangentONB","text":"(Ξ,κ) = tangentONB(M,x,y)\n\ncompute an ONB within the tangent space T_xmathcal M such that xi=log_xy is the first vector and compute the eigenvalues of the curvature tensor R(Xidot g)dot g, where g=g_xxi is the geodesic with g(0)=x, dot g(0) = xi, i.e. kappa_1 corresponding to Xi_1=xi is zero.\n\nSee also\n\njacobiField, adjointJacobiField.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.tangentONB-Tuple{Circle,S1Point,S1TVector}","page":"The Circle mathbb S^1","title":"Manopt.tangentONB","text":"(Ξ,κ) = tangentONB(M,x,ξ)\n\ncompute an ONB within the tangent space T_xmathcal M such that xi is the first vector and compute the eigenvalues of the curvature tensor R(Xidot g)dot g, where g=g_xxi is the geodesic with g(0)=x, dot g(0) = xi, i.e. kappa_1 corresponding to Xi_1=xi is zero.\n\nSee also\n\njacobiField, adjointJacobiField.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.typicalDistance-Tuple{Circle}","page":"The Circle mathbb S^1","title":"Manopt.typicalDistance","text":"typicalDistance(M)\n\nreturns the typical distance on the Circle M: π.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.validateMPoint-Tuple{Circle,S1Point}","page":"The Circle mathbb S^1","title":"Manopt.validateMPoint","text":"validateMPoint(M,x)\n\nvalidate, that a S1Point x has a valid value for a point on the Circle M=mathbb S^1, i.e. is within -pipi).\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.validateTVector-Tuple{Circle,S1Point,S1TVector}","page":"The Circle mathbb S^1","title":"Manopt.validateTVector","text":"validateTVector(M,x,ξ)\n\nvalidate, that the S1TVector ξ is a valid tangent vector in the tangent space of the S1Point x ont the Circle M=mathbb S^1, though this is always the case since all real values are valid.\n\n\n\n","category":"method"},{"location":"manifolds/circle/#Manopt.zeroTVector-Tuple{Circle,S1Point}","page":"The Circle mathbb S^1","title":"Manopt.zeroTVector","text":"ξ = zeroTVector(M,x)\n\nreturns a zero vector in the tangent space T_xmathcal M of the S1Point xinmathbb S^1 on the CircleS1.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#EuclideanSpace-1","page":"The Euclidean Space mathbb R^n","title":"The n-dimensional Euclidean Space mathbb R^n","text":"","category":"section"},{"location":"manifolds/euclidean/#","page":"The Euclidean Space mathbb R^n","title":"The Euclidean Space mathbb R^n","text":"The Euclidean space serves as a fallback to standard methods or as a part of a Product. Let's start with the following instances of the abstract types Manifold, MPoint, and TVector.","category":"page"},{"location":"manifolds/euclidean/#","page":"The Euclidean Space mathbb R^n","title":"The Euclidean Space mathbb R^n","text":"Modules = [Manopt]\nPages = [\"manifolds/Euclidean.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/euclidean/#Manopt.Euclidean","page":"The Euclidean Space mathbb R^n","title":"Manopt.Euclidean","text":"Euclidean <: Manifold\n\nThe manifold mathcal M = mathbb R^n of the n-dimensional Euclidean vector space. We employ the notation langlecdotcdotrangle for the inner product and lVertcdotrVert_2 for its induced norm.\n\nAbbreviation\n\nRn\n\nConstructor\n\nEuclidean(n)\n\nconstruct the n-dimensional Euclidean space mathbb R^n.\n\n\n\n","category":"type"},{"location":"manifolds/euclidean/#Manopt.RnPoint","page":"The Euclidean Space mathbb R^n","title":"Manopt.RnPoint","text":"RnPoint <: MPoint\n\nthe point xinmathcal M for mathcal M=mathbb R^n represented by an n-dimensional Vector{T}, where T <: AbstractFloat.\n\n\n\n","category":"type"},{"location":"manifolds/euclidean/#Manopt.RnTVector","page":"The Euclidean Space mathbb R^n","title":"Manopt.RnTVector","text":"RnTVector <: TVector\n\nthe tangent vector xi in T_xmathcal M for mathcal M=mathbb R^n represented by an n-dimensional Vector{T}, where T <: AbstractFloat.\n\n\n\n","category":"type"},{"location":"manifolds/euclidean/#Functions-1","page":"The Euclidean Space mathbb R^n","title":"Functions","text":"","category":"section"},{"location":"manifolds/euclidean/#","page":"The Euclidean Space mathbb R^n","title":"The Euclidean Space mathbb R^n","text":"Modules = [Manopt]\nPages = [\"manifolds/Euclidean.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/euclidean/#Base.exp-Union{Tuple{T}, Tuple{Euclidean,RnPoint{T},RnTVector{T}}, Tuple{Euclidean,RnPoint{T},RnTVector{T},Float64}} where T<:AbstractFloat","page":"The Euclidean Space mathbb R^n","title":"Base.exp","text":"exp(M,x,ξ[, t=1.0])\n\ncompute the exponential map on the Euclidean manifold M, i.e. x+t*xi, where the scaling parameter t is optional.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Base.log-Union{Tuple{T}, Tuple{Euclidean,RnPoint{T},RnPoint{T}}} where T<:AbstractFloat","page":"The Euclidean Space mathbb R^n","title":"Base.log","text":"log(M,x,y)\n\ncomputes the logarithmic map on the Euclidean manifold M, i.e. y-x.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#LinearAlgebra.dot-Union{Tuple{T}, Tuple{Euclidean,RnPoint{T},RnTVector{T},RnTVector{T}}} where T<:AbstractFloat","page":"The Euclidean Space mathbb R^n","title":"LinearAlgebra.dot","text":"dot(M,x,ξ,ν)\n\nComputes the Euclidean inner product of ξ and ν, i.e. langlexinurangle = displaystylesum_k=1^n xi_knu_k.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manopt.distance-Union{Tuple{T}, Tuple{Euclidean,RnPoint{T},RnPoint{T}}} where T<:AbstractFloat","page":"The Euclidean Space mathbb R^n","title":"Manopt.distance","text":"distance(M,x,y)\n\ncompute the Euclidean distance lVert x - yrVert\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manopt.injectivityRadius-Tuple{Euclidean}","page":"The Euclidean Space mathbb R^n","title":"Manopt.injectivityRadius","text":"injectivityRadius(M)\n\nreturn the injectivity radius of the Euclidean manifold M=mathbb R^n.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manopt.manifoldDimension-Tuple{Euclidean}","page":"The Euclidean Space mathbb R^n","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturn the manifold dimension of the Euclidean manifold M, i.e. the length of the vectors stored in M.dimension, i.e. n.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manopt.manifoldDimension-Tuple{RnPoint}","page":"The Euclidean Space mathbb R^n","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturn the manifold dimension of the RnPoint x, i.e. n.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manopt.parallelTransport-Union{Tuple{T}, Tuple{Euclidean,RnPoint{T},RnPoint{T},RnTVector{T}}} where T<:AbstractFloat","page":"The Euclidean Space mathbb R^n","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,y,ξ)\n\ncompute the parallel transport  the Euclidean manifold M, which is the identity.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manopt.project-Union{Tuple{T}, Tuple{Euclidean,RnPoint{T},Array{T,1}}} where T<:AbstractFloat","page":"The Euclidean Space mathbb R^n","title":"Manopt.project","text":"project(M,x,v)\n\nproject a n-dimensional Vector{T} v on the tangent space of the RnPoint{T} x. Since the tangent space is identical to the mathbb R^n, the mapping can be realized with the identity, i.e. operatornameproject(Mxv) = v.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manopt.randomMPoint","page":"The Euclidean Space mathbb R^n","title":"Manopt.randomMPoint","text":"randomMPoint(M[,T=Float64])\n\ngenerate a random point on the Euclidean manifold M, where the optional parameter determines the type of the entries of the resulting RnPoint.\n\n\n\n","category":"function"},{"location":"manifolds/euclidean/#Manopt.tangentONB-Union{Tuple{T}, Tuple{Euclidean,RnPoint{T},RnPoint{T}}} where T<:AbstractFloat","page":"The Euclidean Space mathbb R^n","title":"Manopt.tangentONB","text":"(Ξ,κ) = tangentONB(M,x,y)\n\ncompute an ONB within the tangent space T_xmathcal M at the MPoint on the Euclidean manifold M, such that xi=log_xy is the first vector and compute the eigenvalues of the curvature tensor R(Xidot g)dot g, where g=g_xxi is the geodesic with g(0)=x, dot g(0) = xi, i.e. kappa_1 corresponding to Xi_1=xi is zero.\n\nSee also\n\njacobiField, adjointJacobiField.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manopt.typicalDistance-Tuple{Euclidean}","page":"The Euclidean Space mathbb R^n","title":"Manopt.typicalDistance","text":"typicalDistance(M)\n\nreturns the typical distance on the Euclidean manifold M: sqrtn.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manopt.validateMPoint-Tuple{Euclidean,RnPoint}","page":"The Euclidean Space mathbb R^n","title":"Manopt.validateMPoint","text":"validateMPoint(M,x)\n\nChecks that a RnPoint x has a valid value for a point on the Euclidean manifold M=mathbb R^n, which is the case if the dimensions fit.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manopt.validateTVector-Tuple{Euclidean,RnPoint,RnTVector}","page":"The Euclidean Space mathbb R^n","title":"Manopt.validateTVector","text":"validateTVector(M,x,ξ)\n\nChecks, that the RnTVector ξ is a valid tangent vector in the tangent space of the RnPoint x ont the Euclidean manifold M, which is always the case as long as their vector dimensions agree.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean/#Manopt.zeroTVector-Union{Tuple{T}, Tuple{Euclidean,RnPoint{T}}} where T<:AbstractFloat","page":"The Euclidean Space mathbb R^n","title":"Manopt.zeroTVector","text":"ξ = zeroTVector(M,x)\n\nreturns a zero vector in the tangent space T_xmathcal M of the RnPoint xinmathbb R^n on the Euclidean manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#GrassmannianManifold-1","page":"The Grassmannian Manifold mathrmGr(kn)","title":"The Grassmannian manifold mathrmGr(kn) embedded in mathbb R^ntimes k","text":"","category":"section"},{"location":"manifolds/grassmannian/#","page":"The Grassmannian Manifold mathrmGr(kn)","title":"The Grassmannian Manifold mathrmGr(kn)","text":"The manifold mathcal M = mathrmGr(kn) of the set of k-dimensional subspaces in mathbbK^n. This set can be written as","category":"page"},{"location":"manifolds/grassmannian/#","page":"The Grassmannian Manifold mathrmGr(kn)","title":"The Grassmannian Manifold mathrmGr(kn)","text":"mathrmGr(kn) = bigl operatornamespan(x)\n big x in mathbbK^ntimes k bar x^mathrmTx = mathrmI_k bigr","category":"page"},{"location":"manifolds/grassmannian/#","page":"The Grassmannian Manifold mathrmGr(kn)","title":"The Grassmannian Manifold mathrmGr(kn)","text":"Here we consider the vector spaces mathbbK^k, where mathbbK is equal to mathbbC or mathbbR, which are subspaces of mathbbK^n with ngeq k. Thus all the manifolds produced are compact and smooth. The manifold is named after Hermann Günther Graßmann (1809-1877). The Grassmannian manifold mathcal M = mathrmGr(kn) possesses the following instances of the abstract types Manifold, MPoint, and TVector.","category":"page"},{"location":"manifolds/grassmannian/#","page":"The Grassmannian Manifold mathrmGr(kn)","title":"The Grassmannian Manifold mathrmGr(kn)","text":"Modules = [Manopt]\nPages = [\"manifolds/Grassmannian.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/grassmannian/#Manopt.GrPoint","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.GrPoint","text":"GrPoint <: MPoint\n\nA point x on the manifold mathcal M = mathrmGr(kn) is an orthonormal matrix of size $ n×k$. The matrix is a numerical representation of the vector subspace its columns span.\n\nConstructor\n\nGrPoint(p)\n\nwhere p::Matrix is an orthonormal matrix of dimension nk.\n\n\n\n","category":"type"},{"location":"manifolds/grassmannian/#Manopt.GrTVector","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.GrTVector","text":"GrTVector <: TVector\n\nA tangent vector xi in T_xmathcal M on the manifold mathcal M = mathrmGr(kn). The tangent space is given by as\n\nT_xmathrmGr(kn) = bigl\nxi in mathbbK^ntimes k  big\n bar ξ^mathrmTx = bar x^mathrmTξ = 0_kk bigr\n\nConstructor\n\nGrTVector(ξ)\n\nwhere ξ is an ntimes k Matrix that satisfies the above.\n\n\n\n","category":"type"},{"location":"manifolds/grassmannian/#Manopt.Grassmannian","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.Grassmannian","text":"Grassmannian <: Manifold\n\nThe manifold mathcal M = mathrmGr(kn) of the set of k-dimensional subspaces in mathbbK^n represented by ntimes k orthonormal matrices, that are either real- or complex-valued.\n\nAbbreviation\n\nGr\n\nConstructor\n\nGrassmannian(k, n[, d=Float64])\n\ngenerates the manifold mathrmGr(kn) where the integer n is the number of rows and k is the number of columns of the matrices and the optional parameter d sets the DataType of the matrix entries.\n\n\n\n","category":"type"},{"location":"manifolds/grassmannian/#Functions-1","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Functions","text":"","category":"section"},{"location":"manifolds/grassmannian/#","page":"The Grassmannian Manifold mathrmGr(kn)","title":"The Grassmannian Manifold mathrmGr(kn)","text":"Modules = [Manopt]\nPages = [\"manifolds/Grassmannian.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/grassmannian/#Base.exp-Union{Tuple{T}, Tuple{U}, Tuple{Grassmannian{T},GrPoint{T},GrTVector{T}}, Tuple{Grassmannian{T},GrPoint{T},GrTVector{T},Float64}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Base.exp","text":"exp(M,x,ξ,[t=1.0])\n\ncompute the exponential map on the Grassmannian manifold M= mathrmGr(kn) with respect to the GrPoint x and the GrTVector ξ, which can be shortened with t to tξ. Let USV = txi denote the SVD decomposition of txi. Then we compute\n\nA = xcdot Vcdot cos(S)cdot bar V^mathrmT + U cdot sin(S) cdot bar V^mathrmT\n\nwhere cosine and sine are applied element wise to the diagonal entries of S. The resulting point y of the exponential map is then the matrix Q of the QR decomposition A=QR of A.\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Base.log-Union{Tuple{T}, Tuple{U}, Tuple{Grassmannian{T},GrPoint{T},GrPoint{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Base.log","text":"log(M,x,y)\n\ncompute the logarithmic map on the Grassmannian manifold mathcal M=mathrmGr(kn), i.e. the GrTVector whose corresponding geodesic starting from GrPoint x reaches the GrPoint y after time 1 on the Grassmannian manifold M. The formula reads\n\nlog_x y = Vcdot operatornameatan(S) cdot bar U^mathrmT\n\nwhere U and V are the unitary matrices and S is a diagonal matrix containing the singular values of the SVD-decomposition of\n\nUSV = (bar y^mathrmTx)^-1 ( bar y^mathrmT - bar y^mathrmTxbar x^mathrmT )\n\nand the operatornameatan is meant elementwise.\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#LinearAlgebra.dot-Union{Tuple{T}, Tuple{U}, Tuple{Grassmannian{T},GrPoint{T},GrTVector{T},GrTVector{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"LinearAlgebra.dot","text":"dot(M,x,ξ,ν)\n\ncompute the Riemannian inner product for two GrTVectors ξ and ν from T_xmathcal M of the Grassmannian manifold M given by\n\nlangle xi nu rangle_x = operatornameRe(operatornametr(xi^mathrmT ν))\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#LinearAlgebra.norm-Union{Tuple{T}, Tuple{U}, Tuple{Grassmannian{T},GrPoint{T},GrTVector{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"LinearAlgebra.norm","text":"norm(M,x,ξ)\n\ncompute the norm of the GrTVector ξ in the tangent space T_xmathcal M at GrPoint x of the Grassmannian manifold M.\n\nlVert xi rVert_x = sqrtsum_ij=0^n xi_ij^2\n\nwhere xi_ij are the entries of the matrix ξ, i.e. the norm is given by the Frobenius norm of ξ.\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Manopt.distance-Union{Tuple{T}, Tuple{U}, Tuple{Grassmannian{T},GrPoint{T},GrPoint{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.distance","text":"distance(M,x,y)\n\ncompute the Riemannian distance on Grassmannian manifold M= mathrmGr(kn) embedded in mathbb R. Let USV = bar x^mathrmTy denote the SVD decomposition of xy. Then we compute\n\nd_mathrmGR(kn)(xy) = operatornamenorm(operatornameRe(b))\n\nwhere\n\nb_i=begincases 0  textif  S_i1  operatornameacos(S_i)   textif  S_i1 endcases\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Manopt.injectivityRadius-Tuple{Grassmannian}","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.injectivityRadius","text":"injectivityRadius(M)\n\nreturn the injectivity radius of the Grassmannian manifold M= mathrmGr(kn).\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Manopt.inverseRetraction-Union{Tuple{T}, Tuple{Grassmannian{T},GrPoint{T},GrPoint{T}}} where T<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.inverseRetraction","text":"inverseRetraction(M,x,y)\n\nreturn a GrTVector ξ of the tagent space T_xmathrmGr(kn) with which the GrPoint y can be reached on the Grassmannian manifold Mby the retraction from the GrPoint x after time 1. The formula reads\n\nxi = y cdot (x^mathrmTy)^-1 - x\n\nThis function is implemented only for the case mathbbK=mathbbR. This is also the standard retraction.\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Manopt.manifoldDimension-Union{Tuple{GrPoint{T}}, Tuple{T}} where T<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturn the dimension of the Grassmannian manifold M= mathrmGr(kn), the GrPoint x, itself embedded in mathbbK^ntimes k, belongs to. The dimension for mathbbK=mathbbR is defined by\n\nk(n-k)\n\nand for mathbbK=mathbbC\n\n2k cdot (n-k)\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Manopt.manifoldDimension-Union{Tuple{Grassmannian{T}}, Tuple{T}} where T<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturn the dimension of the Grassmannian manifold M. The dimension for mathbbK=mathbbR is defined by\n\nk(n-k)\n\nand for mathbbK=mathbbC\n\n2k cdot (n-k)\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Manopt.parallelTransport-Union{Tuple{T}, Tuple{U}, Tuple{Grassmannian{T},GrPoint{T},GrPoint{T},GrTVector{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,y,ξ)\n\ncompute the paralllel transport of the GrTVector ξ from the tangent space T_xmathcal M at GrPoint x to T_ymathcal M at GrPoint y on the Grassmannian manifold M provided that the corresponding geodesic g(cdotxy) is unique. The formula reads\n\nP_xto y(xi) = operatornameproj_mathcal M(yxi)\n\nwhere operatornameproj_mathcal M is the project onto the tangent space T_ymathcal M.\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Manopt.project-Union{Tuple{T}, Tuple{U}, Tuple{Grassmannian{T},GrPoint{T},Array{T,2}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.project","text":"project(M,x,v)\n\nproject a matrix v orthogonally on the GrPoint x of the manifold Grassmannian manifold M. The formula reads\n\noperatornameproj_mathcal M(xv) = v-x(bar x^mathrmTv)\n\ni.e. the difference matrix of the image and the output matrix lies in the orthogonal complement of all GrTVectors from the tangent space T_xmathcal M at GrPoint x.\n\nsee also\n\nparallelTransport, randomTVector\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Manopt.randomMPoint-Union{Tuple{T}, Tuple{U}, Tuple{Grassmannian{T},Val{:Gaussian}}, Tuple{Grassmannian{T},Val{:Gaussian},Float64}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.randomMPoint","text":"randomMPoint(M [,type=:Gaussian, σ=1.0])\n\nreturn a random GrPoint x on Grassmannian manifold M by generating a random (Gaussian) matrix with standard deviation σ in matching size, which is orthonormal.\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Manopt.randomTVector-Union{Tuple{T}, Tuple{U}, Tuple{Grassmannian{T},GrPoint{T},Val{:Gaussian}}, Tuple{Grassmannian{T},GrPoint{T},Val{:Gaussian},Float64}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.randomTVector","text":"randomTVector(M,x [,type=:Gaussian, σ=1.0])\n\nreturn a (Gaussian) random vector GrTVector in the tangential space T_xmathrmGr(kn) with mean zero and standard deviation σ by projecting a random Matrix onto the  GrPoint x with project.\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Manopt.retraction-Union{Tuple{T}, Tuple{U}, Tuple{Grassmannian{T},GrPoint{T},GrTVector{T}}, Tuple{Grassmannian{T},GrPoint{T},GrTVector{T},Float64}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.retraction","text":"retraction(M,x,ξ,[t=1.0])\n\nmove the GrPoint x in the direction of the GrTVector ξ on the  Grassmannian manifold M. This SVD-based retraction is an approximation of the exponential map exp. Let\n\nUSV = x + tξ\n\nbe the singular value decomposition, then the formula reads\n\noperatornameretr_xxi = Ubar V^mathrmT\n\n\n\n","category":"method"},{"location":"manifolds/grassmannian/#Manopt.zeroTVector-Union{Tuple{T}, Tuple{U}, Tuple{Grassmannian{T},GrPoint{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Grassmannian Manifold mathrmGr(kn)","title":"Manopt.zeroTVector","text":"zeroTVector(M,x)\n\nreturn a zero tangent vector in the tangent space of the GrPoint on the Grassmannian manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#HyperbolicManifold-1","page":"The Hyperbolic Space mathbb H^n","title":"The n-dimensional Hyperbolic space mathbb H^n embedded in mathbb R^n+1","text":"","category":"section"},{"location":"manifolds/hyperbolic/#","page":"The Hyperbolic Space mathbb H^n","title":"The Hyperbolic Space mathbb H^n","text":"The hyperbolic space mathbb H^n posesses the following instances of the abstract types Manifold, MPoint, and TVector.","category":"page"},{"location":"manifolds/hyperbolic/#","page":"The Hyperbolic Space mathbb H^n","title":"The Hyperbolic Space mathbb H^n","text":"Modules = [Manopt]\nPages = [\"manifolds/Hyperbolic.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/hyperbolic/#Manopt.HnPoint","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.HnPoint","text":"HnPoint <: MPoint\n\nA point x on the manifold mathbb H^n represented by a vector xinmathbb R^n+1 with Minkowski inner product\n\nlangle xxrangle_mathrmM = -x_n+1^2 + sum_k=1^n x_k^2 = -1\n\n.\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic/#Manopt.HnTVector","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.HnTVector","text":"HnTVector <: TVector\n\nA tangent vector xi in T_xmathbb H^n to a HnPoint x on the n-dimensional Hyperbolic space mathbb H^n. To be precise xiinmathbb R^n+1 is hyperbocally orthogonal to xinmathbb R^n+1, i.e. orthogonal with respect to the Minkowski inner product\n\nlangle xi x rangle_mathrmM = -xi_n+1x_n+1 + sum_k=1^n xi_k x_k = 0\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic/#Manopt.Hyperbolic","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.Hyperbolic","text":"Hyperbolic <: Manifold\n\nThe manifold mathbb H^n is the set\n\nmathbb H^n = Biglxinmathbb R^n+1\n Big langle xx rangle_mathrmM= -x_n+1^2\n+ displaystylesum_k=1^n x_k^2 = -1 x_n+1  0Bigr\n\nwhere langlecdotcdotrangle_mathrmM denotes the MinkowskiDot is Minkowski inner product, and this inner product in the embedded space yields the Riemannian metric when restricted to the tangent bundle Tmathbb H^n.\n\nThis manifold is a matrix manifold (see IsMatrixM) and embedded (see IsEmbeddedM).\n\nAbbreviation\n\nHn\n\nConstructor\n\nHyperbolic(n)\n\ngenerates the n-dimensional hyperbolic manifold embedded in mathbb R^n+1.\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic/#Functions-1","page":"The Hyperbolic Space mathbb H^n","title":"Functions","text":"","category":"section"},{"location":"manifolds/hyperbolic/#","page":"The Hyperbolic Space mathbb H^n","title":"The Hyperbolic Space mathbb H^n","text":"Modules = [Manopt]\nPages = [\"manifolds/Hyperbolic.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/hyperbolic/#Base.exp-Union{Tuple{T}, Tuple{Hyperbolic,HnPoint{T},HnTVector{T}}, Tuple{Hyperbolic,HnPoint{T},HnTVector{T},Float64}} where T<:AbstractFloat","page":"The Hyperbolic Space mathbb H^n","title":"Base.exp","text":"exp(M,x,ξ,[t=1.0])\n\ncomputes the exponential map on the Hyperbolic space mathbb H^n with respect to the HnPoint x and the HnTVector ξ, which can be shortened with t to tξ. The formula reads\n\nexp_xxi = cosh(sqrtlanglexixirangle_mathrmM)x + operatornamesinh(sqrtlanglexixirangle_mathrmM)fracxisqrtlanglexixirangle_mathrmM\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Base.log-Union{Tuple{T}, Tuple{Hyperbolic,HnPoint{T},HnPoint{T}}} where T<:AbstractFloat","page":"The Hyperbolic Space mathbb H^n","title":"Base.log","text":"log(M,x,y)\n\ncomputes the logarithmic map on the Hyperbolic space mathbb H^n, i.e., the HnTVector whose corresponding geodesic starting from HnPoint x reaches the HnPoint y after time 1 on the Hyperbolic space mathbb H^n. The formula reads for xneq y\n\nlog_x y = d_mathbb H^n(xy)fracy-langle xyrangle_mathrmM xlVert y-langle xyrangle_mathrmM x rVert_2\n\nand is zero otherwise.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#LinearAlgebra.dot-Union{Tuple{T}, Tuple{Hyperbolic,HnPoint{T},HnTVector{T},HnTVector{T}}} where T<:AbstractFloat","page":"The Hyperbolic Space mathbb H^n","title":"LinearAlgebra.dot","text":"dot(M,x,ξ,ν)\n\ncompute the Riemannian inner product for two HnTVectors ξ and ν from T_xmathcal M of the Hyperbolic space mathbb H^n given by langle xi nu rangle_mathrmM the MinkowskiDot Minkowski inner product on mathbb R^n+1.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#LinearAlgebra.norm-Union{Tuple{T}, Tuple{Hyperbolic,HnPoint{T},HnTVector{T}}} where T<:AbstractFloat","page":"The Hyperbolic Space mathbb H^n","title":"LinearAlgebra.norm","text":"norm(M,x,ξ)\n\nComputes the norm of the HnTVector ξ in the tangent space T_xmathcal M at HnPoint x of the Hyperbolic space mathbb H^n.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.MinkowskiDot-Tuple{Array{T,1} where T,Array{T,1} where T}","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.MinkowskiDot","text":"MinkowskiDot(a,b)\n\ncomputes the Minkowski inner product of two Vectors a and b of same length n+1, i.e.\n\nlangle abrangle_mathrmM = -a_n+1b_n+1 +\ndisplaystylesum_k=1^n a_kb_k\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.distance-Union{Tuple{T}, Tuple{Hyperbolic,HnPoint{T},HnPoint{T}}} where T<:AbstractFloat","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.distance","text":"distance(M,x,y)\n\ncompute the Riemannian distance on the Hyperbolic space mathbb H^n embedded in mathbb R^n+1 can be computed as\n\nd_mathbb H^n(xy)\n= operatornameacosh bigl(-langle xyrangle_mathrmMbigr)\n\nwhere langle xyrangle_mathrmM = -x_n+1y_n+1 + displaystylesum_k=1^n x_ky_k denotes the MinkowskiDot Minkowski inner product on mathbb R^n+1.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.manifoldDimension-Tuple{HnPoint}","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturns the dimension of the Hyperbolic space mathbb H^n, the HnPoint x, itself embedded in mathbb R^n+1, belongs to.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.manifoldDimension-Tuple{Hyperbolic}","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturns the dimension of the Hyperbolic space mathbb H^n.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.parallelTransport-Union{Tuple{T}, Tuple{Hyperbolic,HnPoint{T},HnPoint{T},HnTVector{T}}} where T<:AbstractFloat","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,y,ξ)\n\nCompute the paralllel transport of the HnTVector ξ from the tangent space T_xmathcal M at HnPoint x to T_ymathcal M at HnPoint y on the Hyperbolic space mathbb H^n along the unique geodesic g(cdotxy). The formula reads\n\nP_xto y(xi) = xi - fraclangle log_xyxirangle_x\nd^2_mathbb H^n(xy)bigl(log_xy + log_yx bigr)\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.project-Union{Tuple{T}, Tuple{Hyperbolic,HnPoint{T},Array{T,1}}} where T<:AbstractFloat","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.project","text":"ξ = project(M,x,v)\n\nperform an orthogonal projection with respect to the Minkowski inner product, i.e. ξ is a tangent vector at the HnPoint x on Hyperbolic space M.\n\nThe formula reads\n\nxi = v + langle xvrangle_mathrmM x\n\nwhere langle cdot cdot rangle_mathrmM denotes the Minkowski inner product in the embedding, see MinkowskiDot.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.randomMPoint-Tuple{Hyperbolic}","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.randomMPoint","text":"randomMPoint(M:Hyperbolic)\n\ngenerate a random point by creating a randn point in mathbb R^n and calculate the remaining point such that the MinkowskiDot is -1.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.randomTVector-Union{Tuple{T}, Tuple{Hyperbolic,HnPoint{T}}} where T<:AbstractFloat","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.randomTVector","text":"randomTVector(M)\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.typicalDistance-Tuple{Hyperbolic}","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.typicalDistance","text":"typicalDistance(M)\n\nreturns the typical distance on the Hyperbolic space M: sqrtn.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.validateMPoint-Tuple{Hyperbolic,HnPoint}","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.validateMPoint","text":"validateMPoint(M,x)\n\nvalidate, that the HnPoint x is a valid point on the Hyperbolic space M, i.e. that the dimension of xinmathbb H^n is correct and that its MinkowskiDot inner product is langle xxrangle_mathrmM = -1.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.validateTVector-Tuple{Hyperbolic,HnPoint,HnTVector}","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.validateTVector","text":"validateTVector(M,x,ξ)\n\ncheck that the HnTVector ξ is a valid tangent vector in the tangent space of the HnPoint x on the Hyperbolic space M, i.e. x is a valid point on M, the vectors within ξ and x agree in length and the Minkowski inner product MinkowskiDot(x,ξ)is zero.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic/#Manopt.zeroTVector-Union{Tuple{T}, Tuple{Hyperbolic,HnPoint{T}}} where T<:AbstractFloat","page":"The Hyperbolic Space mathbb H^n","title":"Manopt.zeroTVector","text":"ξ = zeroTVector(M,x)\n\nreturns a zero vector in the tangent space T_xmathcal M of the HnPoint xinmathbb H^n on the Hyperbolic space M.\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#SOn-1","page":"The Special Orthogonal Group mathrmSO(n)","title":"The Manifold operatornameSO(n) of rotations","text":"","category":"section"},{"location":"manifolds/rotations/#","page":"The Special Orthogonal Group mathrmSO(n)","title":"The Special Orthogonal Group mathrmSO(n)","text":"The manifold mathcal M = mathrmSO(n) of orthogonal matrices with determinant +1 in mathbb R^ntimes n, i.e.","category":"page"},{"location":"manifolds/rotations/#","page":"The Special Orthogonal Group mathrmSO(n)","title":"The Special Orthogonal Group mathrmSO(n)","text":"mathrmSO(n) = biglR in mathbbR^ntimes n big RR^mathrmT =\nR^mathrmTR = mathrmI_n operatornamedet(R) = 1 bigr","category":"page"},{"location":"manifolds/rotations/#","page":"The Special Orthogonal Group mathrmSO(n)","title":"The Special Orthogonal Group mathrmSO(n)","text":"The mathrmSO(n) is a subgroup of the orthogonal group mathrmO(n) and also known as the special orthogonal group or the set of rotations group.","category":"page"},{"location":"manifolds/rotations/#Applications-1","page":"The Special Orthogonal Group mathrmSO(n)","title":"Applications","text":"","category":"section"},{"location":"manifolds/rotations/#","page":"The Special Orthogonal Group mathrmSO(n)","title":"The Special Orthogonal Group mathrmSO(n)","text":"The manifold of rotations appears for example in Electron Backscatter diffraction (EBSD), where orientations (modulo a symmetry group) are measured. For more details on symmetry groups, see for example the MTEX toolbox, where several image processing methods are implemented on mathrmSO(3)-valued data, taking also the symmetries in the crystal orientations into account. ","category":"page"},{"location":"manifolds/rotations/#","page":"The Special Orthogonal Group mathrmSO(n)","title":"The Special Orthogonal Group mathrmSO(n)","text":"A paper concerned with discrete regression on mathrmSO(n) is","category":"page"},{"location":"manifolds/rotations/#","page":"The Special Orthogonal Group mathrmSO(n)","title":"The Special Orthogonal Group mathrmSO(n)","text":"Boumal, N; Absil, P.–A.: A discrete Recgression Method on Manifolds and its Application to Data on mathrmSO(n), IFAC Proceedings Volume 44, Issue 1, pp 2284–2289. doi: 10.3182/20110828-6-IT-1002.00542","category":"page"},{"location":"manifolds/rotations/#","page":"The Special Orthogonal Group mathrmSO(n)","title":"The Special Orthogonal Group mathrmSO(n)","text":"which also includes the formulae for several functions implemented for this manifold within Manopt.jl. ","category":"page"},{"location":"manifolds/rotations/#Types-1","page":"The Special Orthogonal Group mathrmSO(n)","title":"Types","text":"","category":"section"},{"location":"manifolds/rotations/#","page":"The Special Orthogonal Group mathrmSO(n)","title":"The Special Orthogonal Group mathrmSO(n)","text":"The manifold posesses the following instances of the abstract types Manifold, MPoint, and TVector.","category":"page"},{"location":"manifolds/rotations/#","page":"The Special Orthogonal Group mathrmSO(n)","title":"The Special Orthogonal Group mathrmSO(n)","text":"Modules = [Manopt]\nPages = [\"manifolds/Rotations.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/rotations/#Manopt.Rotations","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.Rotations","text":"Rotations <: Manifold\n\nThe manifold mathcal M = mathrmSO(n) represented by ntimes n real-valued orthogonal matrices with determinant +1.\n\nAbbreviation\n\nSO\n\nConstructor\n\nRotations(n)\n\ngenerates the manifold mathrmSO(n) where the integer n is the number of rows or columns of the matrices.\n\n\n\n","category":"type"},{"location":"manifolds/rotations/#Manopt.SOPoint","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.SOPoint","text":"SOPoint <: MPoint\n\nA point x on the manifold mathcal M = mathrmSO(n) is represented by an orthogonal matrix with determinant +1 from mathbb R^ntimes n\n\nConstructor\n\nSOPoint(x)\n\nwhere x is an orthogonal matrix with determinant +1 of dimension nn.\n\n\n\n","category":"type"},{"location":"manifolds/rotations/#Manopt.SOTVector","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.SOTVector","text":"SOTVector <: TVector\n\nA tangent vector xi in T_xmathcal M on the manifold mathcal M = mathrmSO(n). The tangent space is given by as\n\nT_xmathrmSO(n) = biglxxi in mathbb R^ntimes n\nbig xi + xi^T = 0 bigr\n\nSince the manifold of rotations is a Lie group, it suffices to store just the skew-symmetric matrix xi. This has to be taken into account in all formulae.\n\nConstructor\n\nSOTVector(ξ)\n\nwhere ξ is an ntimes n Matrix that is skew-symmetric.\n\n\n\n","category":"type"},{"location":"manifolds/rotations/#Functions-1","page":"The Special Orthogonal Group mathrmSO(n)","title":"Functions","text":"","category":"section"},{"location":"manifolds/rotations/#","page":"The Special Orthogonal Group mathrmSO(n)","title":"The Special Orthogonal Group mathrmSO(n)","text":"Modules = [Manopt]\nPages = [\"manifolds/Rotations.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/rotations/#Base.exp","page":"The Special Orthogonal Group mathrmSO(n)","title":"Base.exp","text":"exp(M,x,ξ,[t=1.0])\n\ncompute the exponential map on the Rotations manifold M=mathrmSO(n) with respect to the SOPoint x and the SOTVector ξ, which can be shortened with t to tξ. The formula reads\n\noperatornameexp_x(tξ) = x cdot operatornameExp(tξ)\n\nwhere operatornameExp denotes matrix exponential.\n\n\n\n","category":"function"},{"location":"manifolds/rotations/#Base.log-Tuple{Rotations,SOPoint,SOPoint}","page":"The Special Orthogonal Group mathrmSO(n)","title":"Base.log","text":"log(M,x,y)\n\ncompute the logarithmic map on the Rotations manifold M=mathrmSO(n), which is given by\n\noperatornamelog_x y =\n  frac12 bigl(operatornameLog(x^mathrmTy)\n  - (operatornameLog x^mathrmTy)^mathrmT)\n\nwhere operatornameLog denotes the matrix logarithm.\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#LinearAlgebra.dot-Tuple{Rotations,SOPoint,SOTVector,SOTVector}","page":"The Special Orthogonal Group mathrmSO(n)","title":"LinearAlgebra.dot","text":"dot(M,x,ξ,ν)\n\ncompute the Riemannian inner product for two SOTVectors ξ and ν from T_xmathcal M of the Rotations manifold M given by\n\nlangle xi nu rangle_x = operatornametr(xi^Tnu)\n\ni.e. the inner product in the embedded space mathbb R^ntimes n.\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#LinearAlgebra.norm-Tuple{Rotations,SOPoint,SOTVector}","page":"The Special Orthogonal Group mathrmSO(n)","title":"LinearAlgebra.norm","text":"norm(M,x,ξ)\n\ncompute the norm of the SOTVector ξ in the tangent space T_xmathcal M at SOPoint x of the Rotations manifold M.\n\nlVert xi rVert_x = sqrtsum_ij=0^n xi_ij^2\n\nwhere xi_ij are the entries of the skew-symmetric matrix ξ, i.e. the norm is given by the Frobenius norm of ξ.\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manopt.distance-Tuple{Rotations,SOPoint,SOPoint}","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.distance","text":"distance(M,x,y)\n\ncompute the Riemannian distance on Rotations manifold M = mathrmSO(n) embedded in mathbb R^ntimes n, which is given by\n\nd(xy) = lVert operatornamelog_xy rVert_x\n\nwhere operatornamelog_cdotcdot denotes the logarithmic map on the Rotations mathcal M=mathrmSO(n).\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manopt.injectivityRadius-Tuple{Rotations}","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.injectivityRadius","text":"injectivityRadius(M)\n\nreturn the injectivity radius of the Rotations manifold M=mathrmSO(n).\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manopt.inverseRetractionPolar-Tuple{Rotations,SOPoint,SOPoint}","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.inverseRetractionPolar","text":"inverseRetractionPolar(M,x,y)\n\nreturn a SOTVector ξ of the tagent space T_xmathrmSO(n) of the SOPoint x on the Rotations manifold M with which the SOPoint y can be reached by the retractionPolar after time 1. The formula reads\n\nξ = -frac12(x^mathrmTys - (x^mathrmTys)^mathrmT)\n\nwhere s is the solution to the Sylvester equation\n\nx^mathrmTys + s(x^mathrmTy)^mathrmT + 2mathrmI_n = 0\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manopt.inverseRetractionQR-Tuple{Rotations,SOPoint,SOPoint}","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.inverseRetractionQR","text":"inverseRetractionQR(M,x,y)\n\nreturn a SOTVector ξ of the tagent space T_xmathrmSO(n) of the SOPoint x on the Rotations manifold M with which the SOPoint y can be reached by the retractionQR from the SOPoint x after time 1.\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manopt.manifoldDimension-Tuple{Rotations}","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturn the dimension of the Rotations manifold M= mathrmSO(n). The dimension is defined by\n\nfracn(n-1)2\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manopt.manifoldDimension-Tuple{SOPoint}","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturn the dimension of the Rotations manifold M= mathrmSO(n), the SOPoint x, itself embedded in mathbb R^ntimes n, belongs to. The dimension is defined by\n\nfracn(n-1)2\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manopt.parallelTransport-Tuple{Rotations,SOPoint,SOPoint,SOTVector}","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,y,ξ)\n\ncompute the parallel transport of the SOTVector ξ from the tangent space T_xmathcal M at SOPoint x to T_ymathcal M at SOPoint y on the Rotations M along g provided that the corresponding geodesic g(cdotxy) is unique. Since we have only stored the skew-symmetric matrix as a SOTVector ξ, the function returns the the SOTVector ξ.\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manopt.project-Tuple{Rotations,SOPoint,Array{T,2} where T}","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.project","text":"project(M,x,v)\n\nproject a ntimes n Matrix v on the tangent space of the SOPoint x.\n\n\n\n","category":"method"},{"location":"manifolds/rotations/#Manopt.randomMPoint","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.randomMPoint","text":"randomMPoint(M[, type=:Gaussian, σ=1.0])\n\nreturn a random SOPoint x on the manifold Rotations M by generating a (Gaussian) random orthogonal matrix with determinant +1. Let\n\nQR = A\n\nbe the QR decomposition of a random matrix A, then the formula reads\n\nx = QD\n\nwhere D is a diagonal matrix with the signs of the diagonal entries of R, i.e.\n\nD_ij=begincases operatornamesgn(R_ij)  textif  i=j  0   textotherwise endcases\n\nIt can happen that the matrix gets -1 as a determinant. In this case, the first and second columns are swapped.\n\n\n\n","category":"function"},{"location":"manifolds/rotations/#Manopt.randomTVector","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.randomTVector","text":"randomTVector(M,x[, type=:Gaussian, σ=1.0])\n\nreturn a random SOTVector in the tangent space T_xmathrmSO(n) of the SOPoint x on the Rotations manifold M by generating a random skew-symmetric matrix. The function takes the real upper triangular matrix of a (Gaussian) random matrix A with dimension ntimes n and subtracts its transposed matrix. Finally, the matrix is ​​normalized.\n\n\n\n","category":"function"},{"location":"manifolds/rotations/#Manopt.retractionPolar","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.retractionPolar","text":"retractionPolar(M,x,ξ [,t=1.0])\n\nmove the SOPoint x in the direction of the SOTVector ξ on the  Rotations manifold M. This SVD-based retraction is a second-order approximation of the exponential map. Let\n\nUSV = x + txξ\n\nbe the singular value decomposition, then the formula reads\n\noperatornameretr_xxi = UV^mathrmT\n\n\n\n","category":"function"},{"location":"manifolds/rotations/#Manopt.retractionQR","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.retractionQR","text":"retractionQR(M,x,ξ [,t=1.0])\n\nmove the SOPoint x in the direction of the SOTVector ξ on the Rotations manifold M. This QR-based retraction is a first-order approximation of the exponential map. Let\n\nQR = x + txξ\n\nbe the QR decomposition, then the formula reads\n\noperatornameretr_xxi = QD\n\nwhere the matrix D is given by\n\nD_ij=begincases\noperatornamesgn(R_ij+05)  textif  i=j \n0   textotherwise\nendcases\n\n\n\n","category":"function"},{"location":"manifolds/rotations/#Manopt.zeroTVector-Tuple{Rotations,SOPoint}","page":"The Special Orthogonal Group mathrmSO(n)","title":"Manopt.zeroTVector","text":"zeroTVector(M,x)\n\nreturn a zero SOTVector xi from the tagent space T_xmathrmSO(n) of SOPoint x on the Rotations manifold M, i.e. a zero matrix.\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#SphereManifold-1","page":"The Sphere mathbb S^n","title":"The n-sphere mathbb S^n embedded in mathbb R^n+1","text":"","category":"section"},{"location":"manifolds/sphere/#","page":"The Sphere mathbb S^n","title":"The Sphere mathbb S^n","text":"The Sphere mathcal M = mathbb S^n posesses the following instances of the abstract types Manifold, MPoint, and TVector.","category":"page"},{"location":"manifolds/sphere/#","page":"The Sphere mathbb S^n","title":"The Sphere mathbb S^n","text":"Modules = [Manopt]\nPages = [\"manifolds/Sphere.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/sphere/#Manopt.SnPoint","page":"The Sphere mathbb S^n","title":"Manopt.SnPoint","text":"SnPoint <: MPoint\n\nA point x on the manifold mathcal M = mathbb S^n represented by a unit vector from mathbb R^n+1\n\n\n\n","category":"type"},{"location":"manifolds/sphere/#Manopt.SnTVector","page":"The Sphere mathbb S^n","title":"Manopt.SnTVector","text":"SnTVector <: TVector\n\nA tangent vector xi in T_xmathcal M on the manifold mathcal M = mathbb S^n. For the representation the tangent space can be given as T_xmathbb S^n = biglxi in mathbb R^n+1 big langle xxirangle = 0bigr, where langlecdotcdotrangle denotes the Euclidean inner product on mathbb R^n+1.\n\n\n\n","category":"type"},{"location":"manifolds/sphere/#Manopt.Sphere","page":"The Sphere mathbb S^n","title":"Manopt.Sphere","text":"Sphere <: Manifold\n\nThe manifold mathcal M = mathbb S^n of unit vectors in mathbb R^n+1. This manifold is a matrix manifold (see IsMatrixM) and embedded (see IsEmbeddedM).\n\nAbbreviation\n\nSn\n\nConstructor\n\nSphere(n)\n\ngenerate the sphere mathbb S^n\n\nIts abbreviation isSn`.\n\n\n\n","category":"type"},{"location":"manifolds/sphere/#Functions-1","page":"The Sphere mathbb S^n","title":"Functions","text":"","category":"section"},{"location":"manifolds/sphere/#","page":"The Sphere mathbb S^n","title":"The Sphere mathbb S^n","text":"Modules = [Manopt]\nPages = [\"manifolds/Sphere.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/sphere/#Base.exp","page":"The Sphere mathbb S^n","title":"Base.exp","text":"exp(M,x,ξ[, t=1.0])\n\nCompute the exponential map on the Sphere M=mathbb S^n with respect to the SnPoint x and the SnTVector ξ, which can be shortened with t to tξ. The formula reads\n\nexp_xxi = cos(lVertxirVert_2)x + sin(lVertxirVert_2)fracxilVertxirVert_2\n\n\n\n","category":"function"},{"location":"manifolds/sphere/#Base.log-Tuple{Sphere,SnPoint,SnPoint}","page":"The Sphere mathbb S^n","title":"Base.log","text":"log(M,x,y)\n\nCompute the logarithmic map on the Sphere mathcal M=mathbb S^n, i.e. the SnTVector whose corresponding geodesic starting from SnPoint x reaches the SnPointy after time 1 on the Sphere M. The formula reads for xneq -y\n\nlog_x y = d_mathbb S^n(xy)fracy-langle xyrangle xlVert y-langle xyrangle x rVert_2\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#LinearAlgebra.dot-Tuple{Sphere,SnPoint,SnTVector,SnTVector}","page":"The Sphere mathbb S^n","title":"LinearAlgebra.dot","text":"dot(M,x,ξ,ν)\n\nCompute the Riemannian inner product for two SnTVectors ξ and ν from T_xmathcal M of the Sphere M given by langle xi nu rangle_x = langle xinu rangle, i.e. the inner product in the embedded space mathbb R^n+1.\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#LinearAlgebra.norm-Tuple{Sphere,SnPoint,SnTVector}","page":"The Sphere mathbb S^n","title":"LinearAlgebra.norm","text":"norm(M,x,ξ)\n\nComputes the norm of the SnTVector ξ in the tangent space T_xmathcal M at SnPoint x of the Sphere M.\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manopt.distance-Tuple{Sphere,SnPoint,SnPoint}","page":"The Sphere mathbb S^n","title":"Manopt.distance","text":"distance(M,x,y)\n\nCompute the Riemannian distance on mathcal M=mathbb S^n embedded in mathbb R^n+1, which is given by\n\n$ d_{\\mathbb S^n}(x,y) = \\operatorname{acos} \\bigl(\\langle x,y\\rangle\\bigr), $\n\nwhere langlecdotcdotrangle denotes the Euclidean inner product on mathbb R^n+1.\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manopt.injectivityRadius-Tuple{Sphere}","page":"The Sphere mathbb S^n","title":"Manopt.injectivityRadius","text":"injectivityRadius(M)\n\nreturn the injectivity radius of the Sphere manifold M=mathbb S^n.\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manopt.manifoldDimension-Tuple{SnPoint}","page":"The Sphere mathbb S^n","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturns the dimension of the Sphere M=mathbb S^n, the SnPoint x, itself embedded in mathbb R^n+1, belongs to.\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manopt.manifoldDimension-Tuple{Sphere}","page":"The Sphere mathbb S^n","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturns the dimension of the Sphere M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manopt.opposite-Tuple{Sphere,SnPoint}","page":"The Sphere mathbb S^n","title":"Manopt.opposite","text":"opposite(M,x)\n\nreturns the antipodal point of x, i.e. $ y = -x $.\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manopt.parallelTransport-Tuple{Sphere,SnPoint,SnPoint,SnTVector}","page":"The Sphere mathbb S^n","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,y,ξ)\n\nCompute the paralllel transport of the SnTVector ξ from the tangent space T_xmathcal M at SnPoint x to T_ymathcal M at SnPointy on the Sphere M provided that the corresponding geodesic g(cdotxy) is unique. The formula reads\n\nP_xto y(xi) = xi - fraclangle log_xyxirangle_xd^2_mathbb S^n(xy)\nbigl(log_xy + log_yx bigr)\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manopt.project-Union{Tuple{T}, Tuple{Sphere,SnPoint,Array{T,1}}} where T<:AbstractFloat","page":"The Sphere mathbb S^n","title":"Manopt.project","text":"project(M,x,v)\n\nproject a vector from the embedding onto the tangent space T_xmathbb S^n of a point x in the Sphere M.\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manopt.randomMPoint","page":"The Sphere mathbb S^n","title":"Manopt.randomMPoint","text":"randomMPoint(M [,:Gaussian, σ=1.0])\n\nreturn a random point on the Sphere by projecting a normal distirbuted vector from within the embedding to the sphere.\n\n\n\n","category":"function"},{"location":"manifolds/sphere/#Manopt.randomTVector","page":"The Sphere mathbb S^n","title":"Manopt.randomTVector","text":"randomTVector(M,x [,:Gaussian,σ=1.0])\n\nreturn a random tangent vector in the tangent space of the SnPoint x on the Sphere M.\n\n\n\n","category":"function"},{"location":"manifolds/sphere/#Manopt.typicalDistance-Tuple{Sphere}","page":"The Sphere mathbb S^n","title":"Manopt.typicalDistance","text":"typicalDistance(M)\n\nreturns the typical distance on the SphereSn: π.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manopt.validateMPoint-Tuple{Sphere,SnPoint}","page":"The Sphere mathbb S^n","title":"Manopt.validateMPoint","text":"validateMPoint(M,x)\n\nvalidate, whether the SnPoint x is on the Sphere M=mathbb S^n, i.e. that the vector is of the correct dimension n and its norm is lVert x rVert = 1.\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manopt.validateTVector-Tuple{Sphere,SnPoint,SnTVector}","page":"The Sphere mathbb S^n","title":"Manopt.validateTVector","text":"validateTVector(M,x,ξ)\n\nvalidate, whether the tangent vector SnTVector ξ is in the tangent space of SnPoint x is on the Sphere M=mathbb S^n, i.e. that all three lengths are correct and x^mathrmTxi = 0.\n\n\n\n","category":"method"},{"location":"manifolds/sphere/#Manopt.zeroTVector-Tuple{Sphere,SnPoint}","page":"The Sphere mathbb S^n","title":"Manopt.zeroTVector","text":"ξ = zeroTVector(M,x)\n\nreturns a zero vector in the tangent space T_xmathcal M of the SnPoint xinmathbb S^n on the SphereSn.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#StiefelManifold-1","page":"The Stiefel Manifold mathrmSt(kn)","title":"The Stiefel manifold mathrmSt(kn) embedded in mathbb K^ntimes k","text":"","category":"section"},{"location":"manifolds/stiefel/#","page":"The Stiefel Manifold mathrmSt(kn)","title":"The Stiefel Manifold mathrmSt(kn)","text":"The manifold mathcal M = mathrmSt(kn) is an embedded submanifold of mathbbK^nk, which represents all orthonormal k-frames in mathbbK^n. The set can be written as","category":"page"},{"location":"manifolds/stiefel/#","page":"The Stiefel Manifold mathrmSt(kn)","title":"The Stiefel Manifold mathrmSt(kn)","text":"mathrmSt(kn) = bigl x in mathbbK^ntimes k big bar x^mathrmTx = I_k bigl","category":"page"},{"location":"manifolds/stiefel/#","page":"The Stiefel Manifold mathrmSt(kn)","title":"The Stiefel Manifold mathrmSt(kn)","text":"The Stiefel manifold mathrmSt(kn) can be thought of as a set of nk matrices by writing a k-frame as a matrix of k column vectors in mathbbK^n. It is named after the mathematician Eduard Stiefel (1909–1978). The Stiefel manifold mathcal M = mathrmSt(kn) posesses the following instances of the abstract types Manifold, MPoint, and TVector.","category":"page"},{"location":"manifolds/stiefel/#","page":"The Stiefel Manifold mathrmSt(kn)","title":"The Stiefel Manifold mathrmSt(kn)","text":"Modules = [Manopt]\nPages = [\"manifolds/Stiefel.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/stiefel/#Manopt.StPoint","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.StPoint","text":"StPoint <: MPoint\n\nA point x on the manifold mathcal M = mathrmSt(kn) is represented by an orthogonal matrix from mathbbK^ntimes k\n\nConstructor\n\nStPoint(Matrix)\n\nwhere Matrix is an orthogonal matrix of dimension nk.\n\n\n\n","category":"type"},{"location":"manifolds/stiefel/#Manopt.StTVector","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.StTVector","text":"StTVector <: TVector\n\nA tangent vector xi in T_xmathcal M on the manifold mathcal M = mathrmSt(kn). The tangent space is given by as\n\nT_xmathrmSt(kn) = biglxi in mathbbK^ntimes k big x^mathrmTξ+ξ^mathrmTx=0 bigr\n\n.\n\nConstructor\n\nStTVector(ξ)\n\nwhere ξ is an ntimes k Matrix that satisfies the above.\n\n\n\n","category":"type"},{"location":"manifolds/stiefel/#Manopt.Stiefel","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.Stiefel","text":"Stiefel{T<:Union{U, Complex{U}} <: Manifold\n\nThe manifold mathcal M = mathrmSt(kn) represented by ntimes k orthogonal matrices, that are either real- or complex-valued.\n\nAbbreviation\n\nSt\n\nConstructor\n\n Stiefel(k, n[, d=Float64])\n\ngenerate the manifold mathrmSt(kn) where the integer n is the number of rows and k is the number of columns of the matrices and the optional parameter d sets the DataType of the matrix entries.\n\n\n\n","category":"type"},{"location":"manifolds/stiefel/#Functions-1","page":"The Stiefel Manifold mathrmSt(kn)","title":"Functions","text":"","category":"section"},{"location":"manifolds/stiefel/#","page":"The Stiefel Manifold mathrmSt(kn)","title":"The Stiefel Manifold mathrmSt(kn)","text":"Modules = [Manopt]\nPages = [\"manifolds/Stiefel.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/stiefel/#Base.exp-Union{Tuple{T}, Tuple{U}, Tuple{Stiefel{T},StPoint{T},StTVector{T}}, Tuple{Stiefel{T},StPoint{T},StTVector{T},Float64}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Base.exp","text":"exp(M,x,ξ [,t=1.0])\n\ncompute the exponential map on the Stiefel manifold M= mathrmSt(kn) with respect to the StPoint x and the StTVector ξ, which can be shortened with t to tξ. The formula reads\n\noperatornameexp_x tξ = beginpmatrix\n   xtxi\n endpmatrix\n operatornameExp\n left(\n beginpmatrix bar x^mathrmTxi  -bar xi^mathrmTxi\n I_kk  bar x^mathrmTxiendpmatrix\n right)\nbeginpmatrix  operatornameExp( -bar x^mathrmTxi)  0_kkendpmatrix\n\nwhere operatornameExp denotes matrix exponential, and I_kk and 0_kk are the identity matrix and the zero matrix of dimension kk, respectively.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#LinearAlgebra.dot-Union{Tuple{T}, Tuple{U}, Tuple{Stiefel{T},StPoint{T},StTVector{T},StTVector{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"LinearAlgebra.dot","text":"dot(M,x,ξ,ν)\n\ncompute the Riemannian inner product for two StTVectors ξ and ν from T_xmathcal M of the Stiefel manifold M given by\n\nlangle xi nu rangle_x = operatornametrace(bar xi^mathrmTnu)\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#LinearAlgebra.norm-Union{Tuple{T}, Tuple{U}, Tuple{Stiefel{T},StPoint{T},StTVector{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"LinearAlgebra.norm","text":"norm(M,x,ξ)\n\ncompute the norm of the StTVector ξ in the tangent space T_xmathcal M at StPoint x of the Stiefel manifold M.\n\nlVert xi rVert_x = sqrtsum_ij=0^n xi_ij^2\n\nwhere xi_ij are the entries of the matrix ξ, i.e. the norm is given by the Frobenius norm of ξ.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.injectivityRadius-Tuple{Stiefel}","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.injectivityRadius","text":"injectivityRadius(M)\n\nreturn the injectivity radius of the Stiefel manifold M= mathrmSt(kn).\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.inverseRetractionPolar-Union{Tuple{T}, Tuple{Stiefel{T},StPoint{T},StPoint{T}}} where T<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.inverseRetractionPolar","text":"inverseRetractionPolar(M,x,y)\n\nreturn a StTVector ξ of the tagent space T_xmathrmSO(n) of the StPoint x on the Stiefel manifold M with which the StPoint y can be reached by the retractionPolar  after time 1. The formula reads\n\nξ = ys-x\n\nwhere s is the solution to the Lyapunov equation\n\nx^mathrmTys + s(x^mathrmTy)^mathrmT + 2mathrmI_k = 0\n\nThis function is implemented only for the case mathbbK=mathbbR.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.inverseRetractionQR-Union{Tuple{T}, Tuple{Stiefel{T},StPoint{T},StPoint{T}}} where T<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.inverseRetractionQR","text":"inverseRetractionQR(M,x,y)\n\nreturn a StTVector ξ of the tagent space T_xmathrmSO(n) of the StPoint x on the Stiefel manifold M with which the StPoint y can be reached by the retractionQR after time 1. This function is implemented only for the case mathbbK=mathbbR. This is also the standard retraction.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.manifoldDimension-Union{Tuple{StPoint{T}}, Tuple{T}} where T<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturn the dimension of the Stiefel manifold M= mathrmSt(kn), the StPoint x, itself embedded in mathbb R^ntimes k, belongs to. The dimension for mathbbK=mathbbR is given by\n\nnk - frac12k(k+1)\n\nand for mathbbK=mathbbC\n\n2nk - k^2\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.manifoldDimension-Union{Tuple{Stiefel{T}}, Tuple{T}} where T<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturn the dimension of the Stiefel manifold M. The dimension for mathbbK=mathbbR is given by\n\nnk - frac12k(k+1)\n\nand for mathbbK=mathbbC\n\n2nk - k^2\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.parallelTransport-Union{Tuple{T}, Tuple{U}, Tuple{Stiefel{T},StPoint{T},StPoint{T},StTVector{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,y,ξ)\n\ncompute the paralllel transport of the StTVector ξ from the tangent space T_xmathcal M at StPoint x to T_ymathcal M at StPoint y on the Stiefel manifold M provided that the corresponding geodesic g(cdotxy) is unique. The formula reads\n\nP_xto y(xi) = operatornameproj_mathcal M(yxi)\n\nwhere operatornameproj_mathcal M is the project onto the tangent space T_ymathcal M.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.project-Union{Tuple{T}, Tuple{U}, Tuple{Stiefel{T},StPoint{T},Array{T,2}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.project","text":"project(M,x,q)\n\nproject a Matrix q orthogonally on the tangent space of the StPoint x on the Stiefel manifold M. The formula reads\n\noperatornameproj_mathcal M(xq) = q-xB\n\nwhere\n\nB=frac12 (x^mathrmTbar q)^mathrmT bar x^mathrmTq\n\nsee also\n\nparallelTransport, randomTVector\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.randomMPoint-Union{Tuple{T}, Tuple{U}, Tuple{Stiefel{T},Val{:Gaussian}}, Tuple{Stiefel{T},Val{:Gaussian},Float64}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.randomMPoint","text":"randomMPoint(M [,:Gaussian, σ=1.0])\n\nreturn a random (Gaussian) StPoint x on the manifold Stiefel manifold M by generating a (Gaussian) matrix with standard deviation σ and return the orthogonalized version, i.e. return ​​the Q component of the QR decomposition of the random matrix of size nk.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.randomTVector-Union{Tuple{T}, Tuple{U}, Tuple{Stiefel{T},StPoint{T},Val{:Gaussian}}, Tuple{Stiefel{T},StPoint{T},Val{:Gaussian},Float64}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.randomTVector","text":"randomTVector(M,x [,:Gaussian, σ=1.0])\n\nreturn a random vector StTVector in the tangential space T_xmathrmSt(kn) by generating a random matrix of size nk and projecting it onto StPoint x with project.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.retractionPolar-Union{Tuple{T}, Tuple{Stiefel{T},StPoint{T},StTVector{T}}, Tuple{Stiefel{T},StPoint{T},StTVector{T},Float64}} where T<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.retractionPolar","text":"retractionPolar(M,x,ξ,[t=1.0])\n\nmove the StPoint x in the direction of the StTVector ξ on the  Stiefel manifold M. This SVD-based retraction is a second-order approximation of the exponential map exp. Let\n\nUSV = x + tξ\n\nbe the singular value decomposition, then the formula reads\n\noperatornameretr_xxi = UV^mathrmT\n\nThis function is implemented only for the case mathbbK=mathbbR.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.retractionQR-Union{Tuple{T}, Tuple{U}, Tuple{Stiefel{T},StPoint{T},StTVector{T}}, Tuple{Stiefel{T},StPoint{T},StTVector{T},Float64}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.retractionQR","text":"retractionQR(M,x,ξ,[t=1.0])\n\nmove the StPoint x in the direction of the StTVector ξ on the  Stiefel manifold M. This QR-based retraction is a first-order approximation of the exponential map exp. Let\n\nQR = x + tξ\n\nbe the QR decomposition, then the formula reads\n\noperatornameretr_xxi = QD\n\nwhere D is a nk matrix with the signs of the diagonal entries of R plus 05 on the upper diagonal, i.e.\n\nD_ij=begincases operatornamesgn(R_ij+05)  textif  i=j  0   textotherwise endcases\n\nThis is also the standard retraction.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.validateMPoint-Union{Tuple{T}, Tuple{U}, Tuple{Stiefel{T},StPoint{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.validateMPoint","text":"validateMPoint(M,x)\n\nvalidate that the StPoint x is a valid point on the Stiefel manifold M, i.e. that both dimensions and the rank are correct as well as that all columns are orthonormal.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.validateTVector-Union{Tuple{T}, Tuple{U}, Tuple{Stiefel{T},StPoint{T},StTVector{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.validateTVector","text":"validateMPoint(M,x,ξ)\n\nvalidate that the StTVector ξ is a valid tangent vector to StPoint x on the Stiefel manifold M, i.e. that both dimensions agree and bar x^mathrmT is skew symmetric.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel/#Manopt.zeroTVector-Union{Tuple{T}, Tuple{U}, Tuple{Stiefel{T},StPoint{T}}} where T<:Union{Complex{U}, U} where U<:AbstractFloat","page":"The Stiefel Manifold mathrmSt(kn)","title":"Manopt.zeroTVector","text":"ξ = zeroTVector(M,x)\n\nreturn a zero vector in the tangent space T_xmathcal M of the StPoint xinmathrmSt(kn) on the Stiefel manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#SymmetricManifold-1","page":"The Symmetric Matrices mathrmSym(n)","title":"The ntimes n symmetric matrices mathrmSym(n) embedded in mathbb R^ntimes n","text":"","category":"section"},{"location":"manifolds/symmetric/#","page":"The Symmetric Matrices mathrmSym(n)","title":"The Symmetric Matrices mathrmSym(n)","text":"The manifold of symmetric matrices mathcalSym(n) posesses the following instances of the abstract types Manifold, MPoint, and TVector.","category":"page"},{"location":"manifolds/symmetric/#","page":"The Symmetric Matrices mathrmSym(n)","title":"The Symmetric Matrices mathrmSym(n)","text":"Modules = [Manopt]\nPages = [\"manifolds/Symmetric.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/symmetric/#Manopt.SymPoint","page":"The Symmetric Matrices mathrmSym(n)","title":"Manopt.SymPoint","text":"SymPoint <: MPoint\n\nA point x on the manifold mathcal M = mathrmSym(n) of ntimes n symmetric matrices, represented in the redundant way of a symmetric matrix (instead of storing just the upper half).\n\n\n\n","category":"type"},{"location":"manifolds/symmetric/#Manopt.SymTVector","page":"The Symmetric Matrices mathrmSym(n)","title":"Manopt.SymTVector","text":"SymTVector <: TVector\n\nA tangent vector xi in T_xmathcal M of a symmetric matrix xinmathcal M.\n\n\n\n","category":"type"},{"location":"manifolds/symmetric/#Manopt.Symmetric","page":"The Symmetric Matrices mathrmSym(n)","title":"Manopt.Symmetric","text":"Symmetric <: Manifold\n\nThe manifold mathcal M = mathrmSym(n), where mathrmSym(n) =  x in mathbb R^ntimes n  x = x^mathrmT , ninmathbb N, denotes the manifold of symmetric matrices equipped with the trace inner product and its induced Forbenius norm.\n\nAbbreviation\n\nSym or Sym(n), respectively.\n\nConstructor\n\nSymmetric(n)\n\ngenerates the manifold of n-by-n symmetric matrices.\n\n\n\n","category":"type"},{"location":"manifolds/symmetric/#Functions-1","page":"The Symmetric Matrices mathrmSym(n)","title":"Functions","text":"","category":"section"},{"location":"manifolds/symmetric/#","page":"The Symmetric Matrices mathrmSym(n)","title":"The Symmetric Matrices mathrmSym(n)","text":"Modules = [Manopt]\nPages = [\"manifolds/Symmetric.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/symmetric/#Base.exp","page":"The Symmetric Matrices mathrmSym(n)","title":"Base.exp","text":"exp(M,x,ξ[, t=1.0])\n\ncompute the exponential map on the Symmetric manifold M given a SymPoint x and a SymTVector ξ, as well as an optional scaling factor t. The exponential map is given by\n\nexp_xξ = x+ξ\n\n\n\n","category":"function"},{"location":"manifolds/symmetric/#Base.log-Tuple{Symmetric,SymPoint,SymPoint}","page":"The Symmetric Matrices mathrmSym(n)","title":"Base.log","text":"log(M,x,y)\n\ncompute the logarithmic map for two SymPointx,y on the Symmetric M, which is given by log_xy = y-x.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#LinearAlgebra.dot-Tuple{Symmetric,SymPoint,SymTVector,SymTVector}","page":"The Symmetric Matrices mathrmSym(n)","title":"LinearAlgebra.dot","text":"dot(M,x,ξ,ν)\n\ninner product of two SymTVectors ξ,ν lying in the tangent space of the SymPoint x on the Symmetric manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#LinearAlgebra.norm-Tuple{Symmetric,SymPoint,SymTVector}","page":"The Symmetric Matrices mathrmSym(n)","title":"LinearAlgebra.norm","text":"norm(M,x,ξ)\n\ncomputes the norm of the SymTVector ξ in the tangent space of the SymPoint x on the Symmetric M embedded in the Euclidean space, i.e. by its Frobenius norm.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#Manopt.distance-Tuple{Symmetric,SymPoint,SymPoint}","page":"The Symmetric Matrices mathrmSym(n)","title":"Manopt.distance","text":"distance(M,x,y)\n\ndistance of two SymPoints x,y on the Symmetric manifold M` inherited from embedding them in mathbb R^ntimes n, i.e. use the Frobenious norm of the difference.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#Manopt.manifoldDimension-Tuple{SymPoint}","page":"The Symmetric Matrices mathrmSym(n)","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturns the manifold dimension the SymPoint x belongs to.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#Manopt.manifoldDimension-Tuple{Symmetric}","page":"The Symmetric Matrices mathrmSym(n)","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturns the manifold dimension of the Symmetric manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#Manopt.parallelTransport-Tuple{Symmetric,SymPoint,SymPoint,SymTVector}","page":"The Symmetric Matrices mathrmSym(n)","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,y,ξ)\n\ncompute the parallel transport of a SymTVector ξ from the tangent space at the SymPoint x to the SymPointy on the Symmetric manifold M. Since the metric is inherited from the embedding space, it is just the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#Manopt.typicalDistance-Tuple{Symmetric}","page":"The Symmetric Matrices mathrmSym(n)","title":"Manopt.typicalDistance","text":"typicalDistance(M)\n\nreturns the typical distance on the Symmetric manifold M, i.e. sqrtn.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#Manopt.validateMPoint-Tuple{Symmetric,SymPoint}","page":"The Symmetric Matrices mathrmSym(n)","title":"Manopt.validateMPoint","text":"validateMPoint(M,x)\n\nvalidate, that the SymPoint x is a valid point on the Symmetric manifold M, i.e. that its dimensions are correct and that the matrix is symmetric.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#Manopt.validateTVector-Tuple{Symmetric,SymPoint,SymTVector}","page":"The Symmetric Matrices mathrmSym(n)","title":"Manopt.validateTVector","text":"validateTVector(M,x,ξ)\n\nvalidate, that the SymTVector is a valid tangent vector to the SymPoint x on the Symmetric manifold M, i.e. that its dimensions are correct and that the matrix is symmetric.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric/#Manopt.zeroTVector-Tuple{Symmetric,SymPoint}","page":"The Symmetric Matrices mathrmSym(n)","title":"Manopt.zeroTVector","text":"ξ = zeroTVector(M,x)\n\nreturns a zero vector in the tangent space T_xmathcal M of the SymPoint x on  the Symmetric manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#SymmetricPositiveDefiniteManifold-1","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"The Symmetric Positive Definite ntimes n Matrices","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite/#","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"The Symmetric Positive Definite Matrices mathcal P(n)","text":"The manifold of symmetric positive definite matrices mathcal P(3) = bigl A in mathbb R^ntimes n big  A = A^mathrmT text and  x^mathrmTAx  0 text for  0neq x inmathbb R^n bigr posesses the following instances of the abstract types Manifold, MPoint, and TVector.","category":"page"},{"location":"manifolds/symmetricpositivedefinite/#","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"The Symmetric Positive Definite Matrices mathcal P(n)","text":"Modules = [Manopt]\nPages = [\"manifolds/SymmetricPositiveDefinite.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.SPDPoint","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.SPDPoint","text":"SPDPoint <: MPoint\n\nA point x on the SymmetricPositiveDefinite manifold mathcal M = mathcal P(n) of ntimes n, represented in the redundant way of a symmetric positive definite matrix.\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.SPDTVector","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.SPDTVector","text":"SPDTVector <: TVector\n\nA tangent vector\n\nxi in T_xmathcal M =  x^frac12nu x^frac12\nbig nuinmathbb R^nntext with nu=nu^mathrmT\n\nto the SymmetricPositiveDefinite manifold mathcal M = mathcal P(n) at the SPDPoint x represented in the redundant way of a skew symmetric matrix nu, i.e. in the Lie algebra T_Imathcal P(n), where Iinmathbb R^ntimes n denotes the identity matrix.\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.SymmetricPositiveDefinite","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.SymmetricPositiveDefinite","text":"SymmetricPositiveDefinite <: Manifold\n\nThe manifold mathcal M = mathcal P(n) of ntimes n symmetric positive definite matrices.\n\nFields\n\nname – representative String representing the current manifold\nn – size of the matrices of this manifold, i.e. ntimes n matrices\nabbreviation – short descriptor for the manifold.\n\nConstructor\n\nSymmetricPositiveDefinite(n)\n\nconstruct the manifold of n-by-n matrices with affine metric.\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite/#","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"The Symmetric Positive Definite Matrices mathcal P(n)","text":"While there are two Riemannian metrics available, this one focuses on the affine metric. The Log-Euclidean Metric needs at least a new tangent vector type inheriting from <: TVector.","category":"page"},{"location":"manifolds/symmetricpositivedefinite/#","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"The Symmetric Positive Definite Matrices mathcal P(n)","text":"Note that saving the points on the manifold in this format is a little bit rendundant, it' enough to save the upper triangular matrix. For ease of computations this is – for now – adapted from Matlab.","category":"page"},{"location":"manifolds/symmetricpositivedefinite/#Functions-1","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Functions","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite/#","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"The Symmetric Positive Definite Matrices mathcal P(n)","text":"Modules = [Manopt]\nPages = [\"manifolds/SymmetricPositiveDefinite.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite/#Base.exp","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Base.exp","text":"exp(M,x,ξ,[t=1.0])\n\ncompute the exponential map on the SymmetricPositiveDefinite manifold M  M=mathcal P(n) with respect to the SPDPoint x and the SPDTVectorξ, which can be shortened with t to tξ. The formula reads\n\nexp_xxi = x^frac12operatornameExp(x^-frac12xi x^-frac12)x^frac12\n\nwhere operatornameExp denotes the matrix exponential\n\n\n\n","category":"function"},{"location":"manifolds/symmetricpositivedefinite/#Base.log-Tuple{SymmetricPositiveDefinite,SPDPoint,SPDPoint}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Base.log","text":"log(M,x,y)\n\ncompute the logarithmic map on the SymmetricPositiveDefinite manifold mathcal M=mathcal P(n), i.e. the SPDTVector whose corresponding geodesic starting from SPDPoint x reaches the SPDPointy after time 1. The formula reads\n\nlog_x y = x^frac12operatornameLog(x^-frac12 y x^-frac12)x^frac12\n\nwhere operatornameLog denotes the matrix logarithm.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#LinearAlgebra.dot-Tuple{SymmetricPositiveDefinite,SPDPoint,SPDTVector,SPDTVector}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"LinearAlgebra.dot","text":"dot(M,x,ξ,ν)\n\ncompute the innter product of the two SPDTVectors ξ,ν from the tangent space T_xmathcal M of the SPDPoint x on the SymmetricPositiveDefinite manifold M given by the formula\n\n$ \\langle \\xi, \\nu \\rangle_x = \\operatorname{tr}(x^{-1}\\xi x^{-1}\\nu ),$\n\nwhere operatornametr(y) denotes the trace of the matrix y.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#LinearAlgebra.norm-Tuple{SymmetricPositiveDefinite,SPDPoint,SPDTVector}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"LinearAlgebra.norm","text":"norm(M,x,ξ)\n\ncompute the norm of the SPDTVectorξ from the tangent space T_xmathcal M at the SPDPoint x on the SymmetricPositiveDefinite manifold M induced by the inner product dot as lVertxirVert_x = sqrtlanglexixirangle_x.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.distance-Tuple{SymmetricPositiveDefinite,SPDPoint,SPDPoint}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.distance","text":"distance(M,x,y)\n\ncompute the Riemannian distance on the SymmetricPositiveDefinite manifold mathcal M=mathcal P(n), given by\n\nd_mathcal P(n)(xy) = lVert operatornameLog(x^-frac12yx^-frac12)rVert\n\nwhere operatornameLog denotes the matrix logarithm and the Norm is the Frobenius norm in matrices\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.manifoldDimension-Tuple{SPDPoint}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.manifoldDimension","text":"manifoldDimension(x)\n\nreturns the manifold dimension of the SymmetricPositiveDefinite manifold M manifold the SPDPoint x belongs to, i.e. for ntimes n matrices the dimension is fracn(n+1)2.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.manifoldDimension-Tuple{SymmetricPositiveDefinite}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.manifoldDimension","text":"manifoldDimension(M)\n\nreturn the manifold dimension of the SymmetricPositiveDefinite Manifold M, i.e. for ntimes n matrices the dimension is fracn(n+1)2.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.parallelTransport-Tuple{SymmetricPositiveDefinite,SPDPoint,SPDPoint,SPDTVector}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.parallelTransport","text":"parallelTransport(M,x,y,ξ)\n\ncompute the paralllel transport of the SPDTVectorξ from the tangent space T_xmathcal M at SPDPoint x to T_ymathcal M at SPDPointy on the SymmetricPositiveDefinite manifold M along the geodesic g(cdotxy). The formula reads\n\nP_xto y(xi) = x^frac12\noperatornameExpbigl(\nfrac12x^-frac12log_x(y)x^-frac12\nbigr)\nx^-frac12xi x^-frac12\noperatornameExpbigl(\nfrac12x^-frac12log_x(y)x^-frac12\nbigr)\nx^frac12\n\nwhere operatornameExp denotes the matrix exponential and log the logarithmic map.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.project-Tuple{SymmetricPositiveDefinite,SPDPoint,Array{T,2} where T}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.project","text":"project(M,x,v)\n\nproject a ntimes n Matrix v on the tangent space of the SPDPoint x.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.randomMPoint","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.randomMPoint","text":"randomMPoint(M,:Gaussian[, σ=1.0])\n\ngerenate a random symmetric positive definite matrix on the SymmetricPositiveDefinite manifold M.\n\n\n\n","category":"function"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.randomTVector","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.randomTVector","text":"randomTVector(M,x [,:Gaussian,σ = 1.0])\n\ngenerate a random tangent vector in the tangent space of the SPDPoint x on the SymmetricPositiveDefinite manifold M by using a Gaussian distribution with standard deviation σ on an ONB of the tangent space.\n\n\n\n","category":"function"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.randomTVector","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.randomTVector","text":"randomTVector(M,x [,:Gaussian,σ = 1.0])\n\ngenerate a random tangent vector in the tangent space of the SPDPoint x on the SymmetricPositiveDefinite manifold M by using a Rician distribution with standard deviation σ.\n\n\n\n","category":"function"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.tangentONB-Tuple{SymmetricPositiveDefinite,SPDPoint,SPDPoint}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.tangentONB","text":"Ξ,κ = tangentONB(M,x,y)\n\ncompute a ONB in the tangent space of the SPDPoint x on the SymmetricPositiveDefinite manifold M where the first vector is given by the normed log(M,x,y), i.e. the direction to the SPDPoint y.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.tangentONB-Tuple{SymmetricPositiveDefinite,SPDPoint,SPDTVector}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.tangentONB","text":"Ξ,κ = tangentONB(M,x,y)\n\ncompute a ONB in the tangent space of the SPDPoint x on the SymmetricPositiveDefinite manifold M where the first vector is the normed tangent vector of the SPDTVector ξ.\n\nThe basis is computed using the eigenvectors v_i, i=1ldotsn, of ξ and define\n\nxi_ij = begincases\n    frac12 (v_i v_j^mathrmT + v_j v_i^mathrmT)\n     mathrm if  i=j\t\n    frac1sqrt2 (v_i v_j^mathrmT + v_j v_i^mathrmT)\n     mathrm if  i neq j\nendcases qquadtextwhere  i=1ldotsn k=ildotsn\n\nand the correspoinding eigenvalues of the curvature tensor are given using the eigenvalues lambda_i, i=1ldotsn of ξ as\n\nkappa_ij = -frac14(lambda_i-lambda_j)^2qquad\ntextwhere  i=1ldotsn k=ildotsn\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.typicalDistance-Tuple{SymmetricPositiveDefinite}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.typicalDistance","text":"typicalDistance(M)\n\nreturns the typical distance on the SymmetricPositiveDefinite manifold M sqrtfracn(n+1)2.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.validateMPoint-Tuple{SymmetricPositiveDefinite,SPDPoint}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.validateMPoint","text":"validateMPoint(M,x)\n\nvalidate that the SPDPoint x is a valid point on the manifold SymmetricPositiveDefinite manifold M, i.e. the matrix is symmetric and positive definite.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.validateTVector-Tuple{SymmetricPositiveDefinite,SPDPoint,SPDTVector}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.validateTVector","text":"validateTVector(M,x,ξ)\n\nvalidate, that the SPDTVectorξ is a tangent vector at the SPDPoint x on the SymmetricPositiveDefinite M, i.e. all dimensions are corrrect and the matrix is skew symmetric since we only store the corresponding value in the Lie algebra.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite/#Manopt.zeroTVector-Tuple{SymmetricPositiveDefinite,SPDPoint}","page":"The Symmetric Positive Definite Matrices mathcal P(n)","title":"Manopt.zeroTVector","text":"ξ = zeroTVector(M,x)\n\nreturns a zero vector in the tangent space T_xmathcal M of the SPDPoint xinmathcal P(n) on the SymmetricPositiveDefinite manifold M.\n\n\n\n","category":"method"},{"location":"plans/#planSection-1","page":"Plans","title":"Plans for solvers","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"CurrentModule = Manopt","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"In order to start a solver, both a Problem and Options are required. Together they form a plan and these are stored in this folder. For sub-problems there are maybe also only Options, since they than refer to the same problem.","category":"page"},{"location":"plans/#Options-1","page":"Plans","title":"Options","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"For most algorithms a certain set of options can either be generated beforehand of the function with keywords can be used. Generally the type","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"Options\ngetOptions","category":"page"},{"location":"plans/#Manopt.Options","page":"Plans","title":"Manopt.Options","text":"Options\n\nA general super type for all options.\n\nFields\n\nThe following fields are assumed to be default. If you use different ones, provide the access functions accordingly\n\nx an MPoint with the current iterate\nstop a StoppingCriterion.\n\n\n\n\n\n","category":"type"},{"location":"plans/#Manopt.getOptions","page":"Plans","title":"Manopt.getOptions","text":"getOptions(O)\n\nreturn the undecorated Options of the (possibly) decorated O. As long as your decorated options stores the options within o.options and implements the SimpleTrait IsOptionsDecorator, this is behaviour is optained automatically.\n\n\n\n","category":"function"},{"location":"plans/#","page":"Plans","title":"Plans","text":"Since the Options directly relate to a solver, they are documented with the corresponding Solvers. You can always access the options (since they might be decorated) by calling getOptions.","category":"page"},{"location":"plans/#Decorators-for-Options-1","page":"Plans","title":"Decorators for Options","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"Options can be decorated using the following trait and function to initialize","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"IsOptionsDecorator\ndecorateOptions","category":"page"},{"location":"plans/#Manopt.IsOptionsDecorator","page":"Plans","title":"Manopt.IsOptionsDecorator","text":"IsOptionsDecorator{O}\n\nA trait to specify that a certain Option decorates, i.e. internally stores the original Options under consideration.\n\n\n\n\n\n","category":"type"},{"location":"plans/#Manopt.decorateOptions","page":"Plans","title":"Manopt.decorateOptions","text":"decorateOptions(o)\n\ndecorate the Optionso with specific decorators.\n\nOptional Arguments\n\noptional arguments provide necessary details on the decorators. A specific one is used to activate certain decorators.\n\ndebug – (Array{Union{Symbol,DebugAction,String,Int},1}()) a set of symbols representing DebugActions, Strings used as dividers and a subsampling integer. These are passed as a DebugGroup within :All to the DebugOptions decorator dictionary. Only excention is :Stop that is passed to :Stop.\nrecord – (Array{Union{Symbol,RecordAction,Int},1}()) specify recordings  by using Symbols or RecordActions directly. The integer can again be used for only recording every ith iteration.\n\nSee also\n\nDebugOptions, RecordOptions\n\n\n\n","category":"function"},{"location":"plans/#","page":"Plans","title":"Plans","text":"In general decorators often perform actions so we introduce","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"Action","category":"page"},{"location":"plans/#Manopt.Action","page":"Plans","title":"Manopt.Action","text":"Action\n\na common Type for Actions that might be triggered in decoraters, for example DebugOptions or RecordOptions.\n\n\n\n","category":"type"},{"location":"plans/#","page":"Plans","title":"Plans","text":"as well as a helper for storing values using keys, i.e.","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"StoreOptionsAction\ngetStorage\nhasStorage\nupdateStorage!","category":"page"},{"location":"plans/#Manopt.StoreOptionsAction","page":"Plans","title":"Manopt.StoreOptionsAction","text":"StoreTupleAction <: Action\n\ninternal storage for Actions to store a tuple of fields from an Optionss \n\nThis functor posesses the usual interface of functions called during an iteration, i.e. acts on (p,o,i), where p is a Problem, o is an Options and i is the current iteration.\n\nFields\n\nvalues – a dictionary to store interims values based on certain Symbols\nkeys – an NTuple of Symbols to refer to fields of Options\nonce – whether to update the internal values only once per iteration\nlastStored – last iterate, where this Action was called (to determine once\n\nConstructiors\n\nStoreOptionsAction([keys=(), once=true])\n\nInitialize the Functor to an (empty) set of keys, where once determines whether more that one update per iteration are effective\n\nStoreOptionsAction(keys, once=true])\n\nInitialize the Functor to a set of keys, where the dictionary is initialized to be empty. Further, once determines whether more that one update per iteration are effective, otherwise only the first update is stored, all others are ignored.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.getStorage","page":"Plans","title":"Manopt.getStorage","text":"getStorage(a,key)\n\nreturn the internal value of the StoreOptionsAction a at the Symbol key.\n\n\n\n\n\n","category":"function"},{"location":"plans/#Manopt.hasStorage","page":"Plans","title":"Manopt.hasStorage","text":"getStorage(a,key)\n\nreturn whether the StoreOptionsAction a has a value stored at the Symbol key.\n\n\n\n\n\n","category":"function"},{"location":"plans/#Manopt.updateStorage!","page":"Plans","title":"Manopt.updateStorage!","text":"updateStorage!(a,o)\n\nupdate the StoreOptionsAction a internal values to the ones given on the Options o.\n\n\n\n\n\nupdateStorage!(a,o)\n\nupdate the StoreOptionsAction a internal values to the ones given in the dictionary d. The values are merged, where the values from d are preferred.\n\n\n\n\n\n","category":"function"},{"location":"plans/#DebugOptions-1","page":"Plans","title":"Debug Options","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"Modules = [Manopt]\nPages = [\"plans/debugOptions.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"plans/#Manopt.DebugAction","page":"Plans","title":"Manopt.DebugAction","text":"DebugAction\n\nA DebugAction is a small functor to print/issue debug output. The usual call is given by (p,o,i) -> s that performs the debug based on a Problem p, Options o and the current iterate i.\n\nBy convention i=0 is interpreted as \"For Initialization only\", i.e. only debug info that prints initialization reacts, i<0 triggers updates of variables internally but does not trigger any output. Finally typemin(Int) is used to indicate a call from stopSolver! that returns true afterwards.\n\nFields (assumed by subtypes to exist)\n\nprint method to perform the actual print. Can for example be set to a file export,\n\nor to @info. The default is the print function on the default Base.stdout.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugChange","page":"Plans","title":"Manopt.DebugChange","text":"DebugChange(a,prefix,print)\n\ndebug for the amount of change of the iterate (stored in o.x of the Options) during the last iteration. See DebugEntryChange\n\nParameters\n\nx0 – an initial value to already get a Change after the first iterate. Can be left out\na – (StoreOptionsAction( (:x,) )) – the storage of the previous action\nprefix – (\"Last Change:\") prefix of the debug output\nprint – (print) default method to peform the print.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugCost","page":"Plans","title":"Manopt.DebugCost","text":"DebugCost <: DebugAction\n\nprint the current cost function value, see getCost.\n\nConstructors\n\nDebugCost(long,print)\n\nwhere long indicated whether to print F(x): (default) or costFunction:\n\nDebugCost(prefix,print)\n\nset a prefix manually.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugDivider","page":"Plans","title":"Manopt.DebugDivider","text":"DebugDivider <: DebugAction\n\nprint a small divider (default \" | \").\n\nConstructor\n\nDebugDivider(div,print)\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugEntry","page":"Plans","title":"Manopt.DebugEntry","text":"DebugEntry <: RecordAction\n\nprint a certain fields entry of type {T} during the iterates\n\nAddidtional Fields\n\nfield – Symbol the entry can be accessed with within Options\n\nConstructor\n\nDebugEntry(f[, prefix=\"$f:\", print=print])\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugEntryChange","page":"Plans","title":"Manopt.DebugEntryChange","text":"DebugEntryChange{T} <: DebugAction\n\nprint a certain entries change during iterates\n\nAdditional Fields\n\nprint – (print) function to print the result\nprefix – (\"Change of :x\") prefix to the print out\nfield – Symbol the field can be accessed with within Options\ndistance – function (p,o,x1,x2) to compute the change/distance between two values of the entry \nstorage – a StoreOptionsAction to store the previous value of :f\n\nConstructors\n\nDebugEntryChange(f,d[, a, prefix, print])\n\ninitialize the Debug to a field f and a distance d.\n\nDebugEntryChange(v,f,d[, a, prefix=\"Change of $f:\", print])\n\ninitialize the Debug to a field f and a distance d with initial value v for the history of o.field.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugEvery","page":"Plans","title":"Manopt.DebugEvery","text":"DebugEvery <: DebugAction\n\nevaluate and print debug only every ith iteration. Otherwise no print is performed. Whether internal variables are updates is determined by alwaysUpdate.\n\nThis method does not perform any print itself but relies on it's childrens print.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugGroup","page":"Plans","title":"Manopt.DebugGroup","text":"DebugGroup <: DebugAction\n\ngroup a set of DebugActions into one action, where the internal prints are removed by default and the resulting strings are concatenated\n\nConstructor\n\nDebugGroup(g)\n\nconstruct a group consisting of an Array of DebugActions g, that are evaluated en bloque; the method does not perform any print itself, but relies on the internal prints. It still concatenates the result and returns the complete string\n\n\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugIterate","page":"Plans","title":"Manopt.DebugIterate","text":"DebugIterate <: DebugAction\n\ndebug for the current iterate (stored in o.x).\n\nParameters\n\nlong::Bool whether to print x: or current iterate\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugIteration","page":"Plans","title":"Manopt.DebugIteration","text":"DebugIteration <: DebugAction\n\ndebug for the current iteration (prefixed with #)\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugOptions","page":"Plans","title":"Manopt.DebugOptions","text":"DebugOptions <: Options\n\nThe debug options append to any options a debug functionality, i.e. they act as a decorator pattern. Internally a Dictionary is kept that stores a DebugAction for several occasions using a Symbol as reference. The default occasion is :All and for example solvers join this field with :Start, :Step and :Stop at the beginning, every iteration or the end of the algorithm, respectively\n\nThe original options can still be accessed using the getOptions function.\n\nFields (defaults in brackets)\n\noptions – the options that are extended by debug information\ndebugDictionary – a Dict{Symbol,DebugAction} to keep track of Debug for different actions\n\nConstructors\n\nDebugOptions(o,dA)\n\nconstruct debug decorated options, where dD can be\n\na DebugAction, then it is stored within the dictionary at :All\nan Array of DebugActions, then it is stored as a debugDictionary within :All.\na Dict{Symbol,DebugAction}.\nan Array of Symbols, String and an Int for the DebugFactory\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugStoppingCriterion","page":"Plans","title":"Manopt.DebugStoppingCriterion","text":"DebugStoppingCriterion <: DebugAction\n\nprint the Reason provided by the stopping criterion. Usually this should be empty, unless the algorithm stops.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DebugActionFactory-Tuple{String}","page":"Plans","title":"Manopt.DebugActionFactory","text":"DebugActionFactory(s)\n\ncreate a DebugAction where\n\na Stringyields the correspoinding divider\na DebugAction is passed through\na [Symbol] creates DebugEntry of that symbol, with the exceptions of :Change, :Iterate, :Iteration, and :Cost.\n\n\n\n","category":"method"},{"location":"plans/#Manopt.DebugFactory-Tuple{Array{#s12,1} where #s12}","page":"Plans","title":"Manopt.DebugFactory","text":"DebugFactory(a)\n\ngiven an array of Symbols, Strings DebugActions and Ints\n\nThe symbol :Stop creates an entry of to display the stoping criterion at the end (:Stop => DebugStoppingCriterion())\nThe symbol :Cost creates a DebugCost\nThe symbol :iteration creates a DebugIteration\nThe symbol :Change creates a DebugChange\nany other symbol creates debug output of the corresponding field in Options\nany string creates a DebugDivider\nany DebugAction is directly included\nan Integer kintroduces that debug is only printed every kth iteration\n\n\n\n","category":"method"},{"location":"plans/#","page":"Plans","title":"Plans","text":"see DebugSolver for details on the decorated solver.","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"Further specific DebugActions can be found at the specific Options.","category":"page"},{"location":"plans/#RecordOptions-1","page":"Plans","title":"Record Options","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"Modules = [Manopt]\nPages = [\"plans/recordOptions.jl\"]\nOrder = [:type, :function]\nPrivate = false","category":"page"},{"location":"plans/#Manopt.RecordAction","page":"Plans","title":"Manopt.RecordAction","text":"RecordAction\n\nA RecordAction is a small functor to record values. The usual call is given by (p,o,i) -> s that performs the record based on a Problem p, Options o and the current iterate i.\n\nBy convention i<=0 is interpreted as \"For Initialization only\", i.e. only initialize internal values, but not trigger any record, the same holds for i=typemin(Inf) which is used to indicate stop, i.e. that the record is called from within stopSolver! which returns true afterwards.\n\nFields (assumed by subtypes to exist)\n\nrecordedValues an Array of the recorded values.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.RecordChange","page":"Plans","title":"Manopt.RecordChange","text":"RecordChange <: RecordAction\n\ndebug for the amount of change of the iterate (stored in o.x of the Options) during the last iteration.\n\nAdditional Fields\n\nstorage a StoreOptionsAction to store (at least) o.x to use this as the last value (to compute the change)\n\n\n\n","category":"type"},{"location":"plans/#Manopt.RecordCost","page":"Plans","title":"Manopt.RecordCost","text":"RecordCost <: RecordAction\n\nrecord the current cost function value, see getCost.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.RecordEntry","page":"Plans","title":"Manopt.RecordEntry","text":"RecordEntry{T} <: RecordAction\n\nrecord a certain fields entry of type {T} during the iterates\n\nFields\n\nrecordedValues – the recorded Iterates\nfield – Symbol the entry can be accessed with within Options\n\n\n\n","category":"type"},{"location":"plans/#Manopt.RecordEntryChange","page":"Plans","title":"Manopt.RecordEntryChange","text":"RecordEntryChange{T} <: RecordAction\n\nrecord a certain entries change during iterates\n\nAdditional Fields\n\nrecordedValues – the recorded Iterates\nfield – Symbol the field can be accessed with within Options\ndistance – function (p,o,x1,x2) to compute the change/distance between two values of the entry \nstorage – a StoreOptionsAction to store (at least) getproperty(o, d.field)\n\n\n\n","category":"type"},{"location":"plans/#Manopt.RecordEvery","page":"Plans","title":"Manopt.RecordEvery","text":"RecordEvery <: RecordAction\n\nrecord only every ith iteration. Otherwise (optionally, but activated by default) just update internal tracking values.\n\nThis method does not perform any record itself but relies on it's childrens methods\n\n\n\n","category":"type"},{"location":"plans/#Manopt.RecordGroup","page":"Plans","title":"Manopt.RecordGroup","text":"RecordGroup <: RecordAction\n\ngroup a set of RecordActions into one action, where the internal prints are removed by default and the resulting strings are concatenated\n\nConstructor\n\nRecordGroup(g)\n\nconstruct a group consisting of an Array of RecordActions g, that are recording en bloque; the method does not perform any record itself, but keeps an array of records. Accessing these yields a Tuple of the recorded values per iteration\n\n\n\n\n\n","category":"type"},{"location":"plans/#Manopt.RecordIterate","page":"Plans","title":"Manopt.RecordIterate","text":"RecordIterate <: RecordAction\n\nrecord the iterate\n\nConstructors\n\nRecordIterate(x0)\n\ninitialize the iterate record array to the type of x0, e.g. your initial data.\n\nRecordIterate(P)\n\ninitialize the iterate record array to the data type P, where P<:MPointholds.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.RecordIteration","page":"Plans","title":"Manopt.RecordIteration","text":"RecordIteration <: RecordAction\n\nrecord the current iteration\n\n\n\n","category":"type"},{"location":"plans/#Manopt.RecordOptions","page":"Plans","title":"Manopt.RecordOptions","text":"RecordOptions <: Options\n\nappend to any Options the decorator with record functionality, Internally a Dictionary is kept that stores a RecordAction for several occasions using a Symbol as reference. The default occasion is :All and for example solvers join this field with :Start, :Step and :Stop at the beginning, every iteration or the end of the algorithm, respectively\n\nThe original options can still be accessed using the getOptions function.\n\nFields\n\noptions – the options that are extended by debug information\nrecordDictionary – a Dict{Symbol,RecordAction} to keep track of all different recorded values\n\nConstructors\n\nRecordOptions(o,dR)\n\nconstruct record decorated Options, where dR can be\n\na RecordAction, then it is stored within the dictionary at :All\nan Array of RecordActions, then it is stored as a recordDictionary(@ref) within the dictionary at :All.\na Dict{Symbol,RecordAction}.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.RecordActionFactory-Union{Tuple{A}, Tuple{O}, Tuple{O,A}} where A<:RecordAction where O<:Options","page":"Plans","title":"Manopt.RecordActionFactory","text":"RecordActionFactory(s)\n\ncreate a RecordAction where\n\na RecordAction is passed through\na [Symbol] creates RecordEntry of that symbol, with the exceptions of :Change, :Iterate, :Iteration, and :Cost.\n\n\n\n","category":"method"},{"location":"plans/#Manopt.RecordFactory-Union{Tuple{O}, Tuple{O,Array{#s12,1} where #s12}} where O<:Options","page":"Plans","title":"Manopt.RecordFactory","text":"RecordFactory(a)\n\ngiven an array of Symbols and RecordActions and Ints\n\nThe symbol :Cost creates a RecordCost\nThe symbol :iteration creates a RecordIteration\nThe symbol :Change creates a RecordChange\nany other symbol creates a RecordEntry of the corresponding field in Options\nany RecordAction is directly included\nan Integer k introduces that record is only performed every kth iteration\n\n\n\n","category":"method"},{"location":"plans/#Manopt.getRecord","page":"Plans","title":"Manopt.getRecord","text":"getRecord(o[,s=:Step])\n\nreturn the recorded values from within the RecordOptions o that where recorded with respect to the Symbol s as an Array. The default refers to any recordings during an Iteration represented by the Symbol :Step\n\n\n\n","category":"function"},{"location":"plans/#Manopt.getRecord-Union{Tuple{R}, Tuple{R}} where R<:RecordAction","page":"Plans","title":"Manopt.getRecord","text":"getRecord(r)\n\nreturn the recorded values stored within a RecordAction r.\n\n\n\n","category":"method"},{"location":"plans/#Manopt.hasRecord-Tuple{RecordOptions}","page":"Plans","title":"Manopt.hasRecord","text":"hasRecord(o)\n\ncheck whether the Optionso are decorated with RecordOptions\n\n\n\n\n\n","category":"method"},{"location":"plans/#","page":"Plans","title":"Plans","text":"see RecordSolver for details on the decorated solver.","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"Further specific RecordActions can be found at the specific Options.","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"there's one internal helper that might be useful for you own actions, namely","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"recordOrReset!","category":"page"},{"location":"plans/#Manopt.recordOrReset!","page":"Plans","title":"Manopt.recordOrReset!","text":"recordOrReset!(r,v,i)\n\neither record (i>0 and not Inf) the value v within the RecordAction r or reset (i<0) the internal storage, where v has to match the internal value type of the corresponding Recordaction. \n\n\n\n\n\n","category":"function"},{"location":"plans/#Stepsize-1","page":"Plans","title":"Stepsize and Linesearch","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"The step size determination is implemented as a Functor based on","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"Stepsize","category":"page"},{"location":"plans/#Manopt.Stepsize","page":"Plans","title":"Manopt.Stepsize","text":"Stepsize\n\nAn abstract type for the functors representing step sizes, i.e. they are callable structurs. The naming scheme is TypeOfStepSize, e.g. ConstantStepsize.\n\nEvery Stepsize has to provide a constructor and its function has to have the interface (p,o,i) where a Problem as well as Options and the current number of iterations are the arguments and returns a number, namely the stepsize to use.\n\nSee also\n\nLinesearch\n\n\n\n\n\n","category":"type"},{"location":"plans/#","page":"Plans","title":"Plans","text":"in general there are","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"Modules = [Manopt]\nPages = [\"plans/stepsize.jl\"]\nOrder = [:type]","category":"page"},{"location":"plans/#Manopt.ArmijoLinesearch","page":"Plans","title":"Manopt.ArmijoLinesearch","text":"ArmijoLineseach <: Linesearch\n\nA functor representing Armijo line seach including the last runs state, i.e. a last step size.\n\nFields\n\ninitialStepsize – (1.0) and initial step size\nretraction – (exp) the rectraction used in line search\ncontractionFactor – (0.95) exponent for line search reduction\nsufficientDecrease – (0.1) gain within Armijo's rule\nlastStepSize – (initialstepsize) the last step size we start the search with \n\nConstructor\n\nArmijoLineSearch()\n\nwith the Fields above in their order as optional arguments.\n\nThis method returns the functor to perform Armijo line search, where two inter faces are available:\n\nbased on a tuple (p,o,i) of a GradientProblem p, Options o and a current iterate i.\nwith (M,x,F,∇Fx[,η=-∇Fx]) -> s where Manifold M, a current MPoint x a function F, that maps from the manifold to the reals, its gradient (a TVector) ∇F=nabla F(x) at  x and an optional search direction TVector η-∇F are the arguments. \n\n\n\n","category":"type"},{"location":"plans/#Manopt.ConstantStepsize","page":"Plans","title":"Manopt.ConstantStepsize","text":"ConstantStepsize <: Stepsize\n\nA functor that always returns a fixed step size.\n\nFields\n\nlength – constant value for the step size.\n\nConstructor\n\nConstantStepSize(s)\n\ninitialize the stepsie to a constant s\n\n\n\n\n\n","category":"type"},{"location":"plans/#Manopt.DecreasingStepsize","page":"Plans","title":"Manopt.DecreasingStepsize","text":"DecreasingStepsize()\n\nA functor that represents several decreasing step sizes\n\nFields\n\nlength – (1) the initial step size l.\nfactor – (1) a value f to multiply the initial step size with every iteration\nsubtrahend – (0) a value a that is subtracted every iteration\nexponent – (1) a value e the current iteration numbers eth exponential is taken of\n\nIn total the complete formulae reads for the ith iterate as\n\n$ s_i = \\frac{(l-i\\cdot a)f^i}{i^e}$\n\nand hence the default simplifies to just $ s_i = \\frac{l}{i} $\n\nConstructor\n\nConstantStepSize(l,f,a,e)\n\ninitialiszes all fields above, where none of them is mandatory.\n\n\n\n","category":"type"},{"location":"plans/#Manopt.Linesearch","page":"Plans","title":"Manopt.Linesearch","text":"Linesearch <: Stepsize\n\nAn abstract functor to represent line search type step size deteminations, see Stepsize for details. One example is the ArmijoLinesearch functor.\n\nCompared to simple step sizes, the linesearch functors provide an interface of the form (p,o,i,η) -> s with an additional (but optional) fourth parameter to proviade a search direction; this should default to something reasonable, e.g. the negative gradient.\n\n\n\n\n\n","category":"type"},{"location":"plans/#Problems-1","page":"Plans","title":"Problems","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"A problem usually contains its cost function and provides and implementation to access the cost","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"Problem\ngetCost","category":"page"},{"location":"plans/#Manopt.Problem","page":"Plans","title":"Manopt.Problem","text":"Problem\n\nSpecify properties (values) and related functions for computing a certain optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"plans/#Manopt.getCost","page":"Plans","title":"Manopt.getCost","text":"getCost(p,x)\n\nevaluate the cost function F stored within a Problem at the MPoint x.\n\n\n\n\n\n","category":"function"},{"location":"plans/#","page":"Plans","title":"Plans","text":"For any algorithm that involves a cyclic evalutaion, e.g. cyclicProximalPoint, one can specify the EvalOrder as","category":"page"},{"location":"plans/#","page":"Plans","title":"Plans","text":"EvalOrder\nLinearEvalOrder\nRandomEvalOrder\nFixedRandomEvalOrder","category":"page"},{"location":"plans/#Manopt.EvalOrder","page":"Plans","title":"Manopt.EvalOrder","text":"EvalOrder\n\ntype for specifying an evaluation order for any cyclicly evaluated algorithms\n\n\n\n\n\n","category":"type"},{"location":"plans/#Manopt.LinearEvalOrder","page":"Plans","title":"Manopt.LinearEvalOrder","text":"LinearEvalOrder <: EvalOrder\n\nevaluate in a linear order, i.e. for each cycle of length l evaluate in the order 1,2,...,l.\n\n\n\n\n\n","category":"type"},{"location":"plans/#Manopt.RandomEvalOrder","page":"Plans","title":"Manopt.RandomEvalOrder","text":"RandomEvalOrder <: EvalOrder\n\nchoose a random order for each evaluation of the l functionals.\n\n\n\n\n\n","category":"type"},{"location":"plans/#Manopt.FixedRandomEvalOrder","page":"Plans","title":"Manopt.FixedRandomEvalOrder","text":"FixedRandomEvalOrder <: EvalOrder\n\nChoose a random order once and evaluate always in this order, i.e. for l elements there is one chosen permutation used for each iteration cycle.\n\n\n\n\n\n","category":"type"},{"location":"plans/#Cost-based-problem-1","page":"Plans","title":"Cost based problem","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"CostProblem","category":"page"},{"location":"plans/#Manopt.CostProblem","page":"Plans","title":"Manopt.CostProblem","text":"CostProblem <: Problem\n\nspeficy a problem for solvers just based on cost functions, i.e. gradient free ones.\n\nFields\n\nM            – a manifold mathcal M\ncostFunction – a function Fcolonmathcal Mtomathbb R to minimize\n\nSee also\n\nNelderMead\n\n\n\n","category":"type"},{"location":"plans/#Gradient-based-problem-1","page":"Plans","title":"Gradient based problem","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"GradientProblem\ngetGradient","category":"page"},{"location":"plans/#Manopt.GradientProblem","page":"Plans","title":"Manopt.GradientProblem","text":"GradientProblem <: Problem\n\nspecify a problem for gradient based algorithms.\n\nFields\n\nM            – a manifold mathcal M\ncostFunction – a function Fcolonmathcal Mtomathbb R to minimize\ngradient     – the gradient nabla Fcolonmathcal M to mathcal Tmathcal M of the cost function F\n\nSee also\n\nsteepestDescent GradientDescentOptions\n\n\n\n\n\n","category":"type"},{"location":"plans/#Manopt.getGradient","page":"Plans","title":"Manopt.getGradient","text":"getGradient(p,x)\n\nevaluate the gradient of a GradientProblemp at the MPoint x.\n\n\n\n\n\ngetGradient(p,x)\n\nevaluate the gradient of a HessianProblemp at the MPoint x.\n\n\n\n","category":"function"},{"location":"plans/#Subgradient-based-problem-1","page":"Plans","title":"Subgradient based problem","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"SubGradientProblem\ngetSubGradient","category":"page"},{"location":"plans/#Manopt.SubGradientProblem","page":"Plans","title":"Manopt.SubGradientProblem","text":"SubGradientProblem <: Problem\n\nA structure to store information about a subgradient based optimization problem\n\nFields\n\nM – a Manifold\ncostFunction – the function F to be minimized\nsubGradient – a function returning a subgradient partial F of F\n\n\n\n","category":"type"},{"location":"plans/#Manopt.getSubGradient","page":"Plans","title":"Manopt.getSubGradient","text":"getSubGradient(p,x)\n\nevaluate the gradient of a SubGradientProblemp at the MPoint x.\n\n\n\n\n\n","category":"function"},{"location":"plans/#ProximalProblem-1","page":"Plans","title":"Proximal Map(s) based problem","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"ProximalProblem\ngetProximalMap","category":"page"},{"location":"plans/#Manopt.ProximalProblem","page":"Plans","title":"Manopt.ProximalProblem","text":"ProximalProblem <: Problem\n\nspecify a problem for solvers based on the evaluation of proximal map(s).\n\nFields\n\nM            - a Manifold mathcal M\ncostFunction - a function Fcolonmathcal Mtomathbb R to minimize\nproximalMaps - proximal maps operatornameprox_lambdavarphicolonmathcal Mtomathcal M as functions (λ,x) -> y, i.e. the prox parameter λ also belongs to the signature of the proximal map.\nnumberOfProxes - (length(proximalMaps)) number of proxmal Maps, e.g. if one of the maps is a compined one such that the proximal Maps functions return more than one entry per function\n\nSee also\n\ncyclicProximalPoint, getCost, getProximalMap\n\n\n\n","category":"type"},{"location":"plans/#Manopt.getProximalMap","page":"Plans","title":"Manopt.getProximalMap","text":"getProximalMap(p,λ,x,i)\n\nevaluate the ith proximal map of ProximalProblem p at the point x of p.M with parameter λ0.\n\n\n\n","category":"function"},{"location":"plans/#Further-planned-problems-1","page":"Plans","title":"Further planned problems","text":"","category":"section"},{"location":"plans/#","page":"Plans","title":"Plans","text":"HessianProblem\ngetHessian\ngetPreconditioner","category":"page"},{"location":"plans/#Manopt.HessianProblem","page":"Plans","title":"Manopt.HessianProblem","text":"HessianProblem <: Problem\n\nspecify a problem for hessian based algorithms.\n\nFields\n\nM            : a manifold mathcal M\ncostFunction : a function Fcolonmathcal Mtomathbb R to minimize\ngradient     : the gradient nabla Fcolonmathcal M to mathcal Tmathcal M of the cost function F\nhessian      : the hessian operatornameHessF (cdot)_ x colon mathcal T_x mathcal M to mathcal T_x mathcal M of the cost function F\nprecon       : the symmetric, positive deﬁnite   preconditioner (approximation of the inverse of the Hessian of F)\n\nSee also\n\ntruncatedConjugateGradient, trustRegions\n\n\n\n","category":"type"},{"location":"plans/#Manopt.getHessian","page":"Plans","title":"Manopt.getHessian","text":"getHessian(p,x,ξ)\n\nevaluate the Hessian of a HessianProblem p at the MPoint x applied to a TVector ξ.\n\n\n\n","category":"function"},{"location":"plans/#Manopt.getPreconditioner","page":"Plans","title":"Manopt.getPreconditioner","text":"getPreconditioner(p,x,ξ)\n\nevaluate the symmetric, positive deﬁnite preconditioner (approximation of the inverse of the Hessian of the cost function F) of a HessianProblem p at the MPoint xapplied to a TVector ξ.\n\n\n\n","category":"function"},{"location":"solvers/#Solvers-1","page":"Introduction","title":"Solvers","text":"","category":"section"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"CurrentModule = Manopt","category":"page"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"Solvers can be applied to Problems with solver specific Options.","category":"page"},{"location":"solvers/#List-of-Algorithms-1","page":"Introduction","title":"List of Algorithms","text":"","category":"section"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"The following algorithms are currently available","category":"page"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"Solver File Problem & Option\nsteepest Descent steepestDescent.jl GradientProblem, GradientDescentOptions\nCyclic Proximal Point cyclicProximalPoint.jl ProximalProblem, CyclicProximalPointOptions\nDouglas–Rachford DouglasRachford.jl ProximalProblem, DouglasRachfordOptions\nNelder-Mead NelderMead.jl CostProblem, NelderMeadOptions\nSubgradient Method subGradientMethod.jl SubGradientProblem, SubGradientMethodOptions\nSteihaug-Toint Truncated Conjugate-Gradient Method truncatedConjugateGradient.jl HessianProblem,","category":"page"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"TruncatedConjugateGradientOptions The Riemannian Trust-Regions Solver | trustRegions.jl | HessianProblem, TrustRegionsOptions","category":"page"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"Note that the Options can also be decorated to enhance your algorithm by general additional properties.","category":"page"},{"location":"solvers/#StoppingCriteria-1","page":"Introduction","title":"StoppingCriteria","text":"","category":"section"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"Stopping criteria are implemented as a functor, i.e. inherit from the base type","category":"page"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"StoppingCriterion\nStoppingCriterionSet","category":"page"},{"location":"solvers/#Manopt.StoppingCriterion","page":"Introduction","title":"Manopt.StoppingCriterion","text":"StoppingCriterion\n\nAn abstract type for the functors representing stoping criteria, i.e. they are callable structures. The naming Scheme follows functions, see for example stopAfterIteration.\n\nEvery StoppingCriterion has to provide a constructor and its function has to have the interface (p,o,i) where a Problem as well as Options and the current number of iterations are the arguments and returns a Bool whether to stop or not.\n\nBy default each StoppingCriterion should provide a fiels reason to provide details when a criteion is met (and that is empty otherwise).\n\n\n\n","category":"type"},{"location":"solvers/#Manopt.StoppingCriterionSet","page":"Introduction","title":"Manopt.StoppingCriterionSet","text":"StoppingCriterionGroup <: StoppingCriterion\n\nAn abstract type for a Stopping Criterion that itself consists of a set of Stopping criteria. In total it acts as a stopping criterion itself. Examples are stopWhenAny and stopWhenAll that can be used to combine stopping criteria.\n\n\n\n","category":"type"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"Modules = [Manopt]\nPages = [\"plans/stoppingCriterion.jl\"]\nOrder = [:type]","category":"page"},{"location":"solvers/#Manopt.stopAfter","page":"Introduction","title":"Manopt.stopAfter","text":"stopAfter <: StoppingCriterion\n\nstore a threshold when to stop looking at the complete runtime. It uses time_ns() to measure the time and you provide a Period as a time limit, i.e. Minute(15)\n\nConstructor\n\nstopAfter(t)\n\ninitialize the stopping criterion to a Period t to stop after.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#Manopt.stopAfterIteration","page":"Introduction","title":"Manopt.stopAfterIteration","text":"stopAfterIteration <: StoppingCriterion\n\nA functor for an easy stopping criterion, i.e. to stop after a maximal number of iterations.\n\nFields\n\nmaxIter – stores the maximal iteration number where to stop at\nreason – stores a reason of stopping if the stopping criterion has one be reached, see getReason.\n\nConstructor\n\nstopAfterIteration(maxIter)\n\ninitialize the stopafterIteration functor to indicate to stop after maxIter iterations.\n\n\n\n","category":"type"},{"location":"solvers/#Manopt.stopWhenAll","page":"Introduction","title":"Manopt.stopWhenAll","text":"stopWhenAll <: StoppingCriterion\n\nstore an array of StoppingCriterion elements and indicates to stop, when all indicate to stop. The reseason is given by the concatenation of all reasons.\n\nConstructor\n\nstopWhenAll(c::Array{StoppingCriterion,1})\nstopWhenAll(c::StoppingCriterion,...)\n\n\n\n","category":"type"},{"location":"solvers/#Manopt.stopWhenAny","page":"Introduction","title":"Manopt.stopWhenAny","text":"stopWhenAny <: StoppingCriterion\n\nstore an array of StoppingCriterion elements and indicates to stop, when any single one indicates to stop. The reseason is given by the concatenation of all reasons (assuming that all non-indicating return \"\").\n\nConstructor\n\nstopWhenAny(c::Array{StoppingCriterion,1})\nstopWhenAny(c::StoppingCriterion,...)\n\n\n\n","category":"type"},{"location":"solvers/#Manopt.stopWhenChangeLess","page":"Introduction","title":"Manopt.stopWhenChangeLess","text":"stopWhenChangeLess <: StoppingCriterion\n\nstores a threshold when to stop looking at the norm of the change of the optimization variable from within a Options, i.e o.x. For the storage a StoreOptionsAction is used\n\nConstructor\n\nstopWhenChangeLess(ε[, a])\n\ninitialize the stopping criterion to a threshold ε using the StoreOptionsAction a, which is initialized to just store :x by default.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#Manopt.stopWhenCostLess","page":"Introduction","title":"Manopt.stopWhenCostLess","text":"stopWhenCostLess <: StoppingCriterion\n\nstore a threshold when to stop looking at the cost function of the optimization problem from within a Problem, i.e getCost(p,o.x).\n\nConstructor\n\nstopWhenCostLess(ε)\n\ninitialize the stopping criterion to a threshold ε.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#Manopt.stopWhenGradientNormLess","page":"Introduction","title":"Manopt.stopWhenGradientNormLess","text":"stopWhenGradientNormLess <: StoppingCriterion\n\nstores a threshold when to stop looking at the norm of the gradient from within a GradientProblem.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"as well as the functions","category":"page"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"getReason\ngetStoppingCriteriaArray\ngetActiveStoppingCriteria","category":"page"},{"location":"solvers/#Manopt.getReason","page":"Introduction","title":"Manopt.getReason","text":"getReason(o)\n\nreturn the current reason stored within the StoppingCriterion from within the Options This reason is empty if the criterion has never been met.\n\n\n\ngetReason(c)\n\nreturn the current reason stored within a StoppingCriterion c. This reason is empty if the criterion has never been met.\n\n\n\n","category":"function"},{"location":"solvers/#Manopt.getStoppingCriteriaArray","page":"Introduction","title":"Manopt.getStoppingCriteriaArray","text":"getStoppingCriteriaArray(c)\n\nreturn the array of internally stored StoppingCriterions for a StoppingCriterionSet c.\n\n\n\n","category":"function"},{"location":"solvers/#Manopt.getActiveStoppingCriteria","page":"Introduction","title":"Manopt.getActiveStoppingCriteria","text":"getActiveStoppingCriteria(c)\n\nreturns all active stopping criteria, if any, that are within a StoppingCriterion c, and indicated a stop, i.e. their reason is nonempty. To be precise for a simple stopping criterion, this returns either an empty array if no stop is incated or the stopping criterion as the only element of an array. For a StoppingCriterionSet all internal (even nested) criteria that indicate to stop are returned.\n\n\n\n","category":"function"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"further stopping criteria might be available for individual Solvers.","category":"page"},{"location":"solvers/#DecoratedSolvers-1","page":"Introduction","title":"Decorated Solvers","text":"","category":"section"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"The following decorators are available.","category":"page"},{"location":"solvers/#DebugSolver-1","page":"Introduction","title":"Debug Solver","text":"","category":"section"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"The decorator to print debug during the iterations can be activated by decorating the Options with DebugOptions and implementing your own DebugActions. For example printing a gradient from the GradientDescentOptions is automatically available, as explained in the steepestDescent solver.","category":"page"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"initializeSolver!(p::P,o::O) where {P <: Problem, O <: DebugOptions}\ndoSolverStep!(p::P,o::O, iter) where {P <: Problem, O <: DebugOptions}\ngetSolverResult(o::O) where {O <: DebugOptions}\nstopSolver!(p::P,o::O, i::Int) where {P <: Problem, O <: DebugOptions}","category":"page"},{"location":"solvers/#Manopt.initializeSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O<:DebugOptions where P<:Problem","page":"Introduction","title":"Manopt.initializeSolver!","text":"initializeSolver!(p,o)\n\nInitialize the solver to the optimization Problem by initializing all values in the DebugOptionso.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Manopt.doSolverStep!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Any}} where O<:DebugOptions where P<:Problem","page":"Introduction","title":"Manopt.doSolverStep!","text":"doSolverStep!(p,o,iter)\n\nDo one iteration step (the iterth) for Problemp by modifying the values in the Optionso.options and print Debug.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Manopt.getSolverResult-Union{Tuple{O}, Tuple{O}} where O<:DebugOptions","page":"Introduction","title":"Manopt.getSolverResult","text":"getSolverResult(o)\n\nReturn the final result after all iterations that is stored within the (modified during the iterations) Options o.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Manopt.stopSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Int64}} where O<:DebugOptions where P<:Problem","page":"Introduction","title":"Manopt.stopSolver!","text":"stopSolver!(p,o,i)\n\ndetermine whether the solver for Problem p and the DebugOptions o should stop at iteration i. If so, print all debug from :All and :Final.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#RecordSolver-1","page":"Introduction","title":"Record Solver","text":"","category":"section"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"The decorator to record certain values during the iterations can be activated by decorating the Options with RecordOptions and implementing your own RecordActions. For example recording the gradient from the GradientDescentOptions is automatically available, as explained in the steepestDescent solver.","category":"page"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"initializeSolver!(p::P,o::O) where {P <: Problem, O <: RecordOptions}\ndoSolverStep!(p::P,o::O, iter) where {P <: Problem, O <: RecordOptions}\ngetSolverResult(o::O) where {O <: RecordOptions}\nstopSolver!(p::P,o::O, i::Int) where {P <: Problem, O <: RecordOptions}","category":"page"},{"location":"solvers/#Manopt.initializeSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O<:RecordOptions where P<:Problem","page":"Introduction","title":"Manopt.initializeSolver!","text":"initializeSolver!(p,o)\n\nInitialize the solver to the optimization Problem by initializing the encapsulated options from within the RecordOptionso.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Manopt.doSolverStep!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Any}} where O<:RecordOptions where P<:Problem","page":"Introduction","title":"Manopt.doSolverStep!","text":"doSolverStep!(p,o,iter)\n\nDo one iteration step (the iterth) for Problemp by modifying the values in the Optionso.options and record the result(s).\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Manopt.getSolverResult-Union{Tuple{O}, Tuple{O}} where O<:RecordOptions","page":"Introduction","title":"Manopt.getSolverResult","text":"getSolverResult(o)\n\nReturn the final result after all iterations that is stored within the (modified during the iterations) Optionso.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Manopt.stopSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Int64}} where O<:RecordOptions where P<:Problem","page":"Introduction","title":"Manopt.stopSolver!","text":"stopSolver!(p,o,i)\n\ndetermine whether the solver for Problem p and the RecordOptions o should stop at iteration i.  If so, do a (final) record to :All and :Stop.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Technical-Details-1","page":"Introduction","title":"Technical Details","text":"","category":"section"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"The main function a solver calls is","category":"page"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"solve(p::P, o::O) where {P <: Problem, O <: Options}","category":"page"},{"location":"solvers/#Manopt.solve-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O<:Options where P<:Problem","page":"Introduction","title":"Manopt.solve","text":"solve(p,o)\n\nrun the solver implemented for the Problemp and the Optionso employing initializeSolver!, doSolverStep!, as well as the stopSolver! of the solver.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"which is a framework, that you in general should not change or redefine. It uses the following methods, which also need to be implemented on your own algorithm, if you want to provide one.","category":"page"},{"location":"solvers/#","page":"Introduction","title":"Introduction","text":"initializeSolver!(p::P,o::O) where {P <: Problem, O <: Options}\ndoSolverStep!(p::P,o::O, iter) where {P <: Problem, O <: Options}\ngetSolverResult(o::O) where {O <: Options}\nstopSolver!(p::P,o::O, i::Int) where {P <: Problem, O <: Options}","category":"page"},{"location":"solvers/#Manopt.initializeSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O}} where O<:Options where P<:Problem","page":"Introduction","title":"Manopt.initializeSolver!","text":"initializeSolver!(p,o)\n\nInitialize the solver to the optimization Problem by initializing all values in the Optionso.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Manopt.doSolverStep!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Any}} where O<:Options where P<:Problem","page":"Introduction","title":"Manopt.doSolverStep!","text":"doSolverStep!(p,o,iter)\n\nDo one iteration step (the iterth) for Problemp by modifying the values in the Options o.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Manopt.getSolverResult-Union{Tuple{O}, Tuple{O}} where O<:Options","page":"Introduction","title":"Manopt.getSolverResult","text":"getSolverResult(o)\n\nReturn the final result after all iterations that is stored within the (modified during the iterations) Options o.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Manopt.stopSolver!-Union{Tuple{O}, Tuple{P}, Tuple{P,O,Int64}} where O<:Options where P<:Problem","page":"Introduction","title":"Manopt.stopSolver!","text":"stopSolver!(p,o,i)\n\ndepending on the current Problem p, the current state of the solver stored in Options o and the current iterate i this function determines whether to stop the solver by calling the StoppingCriterion.\n\n\n\n\n\n","category":"method"},{"location":"solvers/cyclicProximalPoint/#CPPSolver-1","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"","category":"section"},{"location":"solvers/cyclicProximalPoint/#","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"The Cyclic Proximal Point (CPP) algorithm is a Proximal Problem.","category":"page"},{"location":"solvers/cyclicProximalPoint/#","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"It aims to minimize","category":"page"},{"location":"solvers/cyclicProximalPoint/#","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"F(x) = sum_i=1^c f_i(x)","category":"page"},{"location":"solvers/cyclicProximalPoint/#","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"assuming that the proximal maps operatornameprox_lambda f_i(x) are given in closed form or can be computed efficiently (at least approximately).","category":"page"},{"location":"solvers/cyclicProximalPoint/#","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"The algorithm then cycles through these proximal maps, where the type of cycle might differ and the proximal parameter lambda_k changes after each cycle k.","category":"page"},{"location":"solvers/cyclicProximalPoint/#","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"For a convergence result on Hadamard manifolds see [Bačák, 2014].","category":"page"},{"location":"solvers/cyclicProximalPoint/#","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"cyclicProximalPoint","category":"page"},{"location":"solvers/cyclicProximalPoint/#Manopt.cyclicProximalPoint","page":"Cyclic Proximal Point","title":"Manopt.cyclicProximalPoint","text":"cyclicProximalPoint(M, F, proximalMaps, x)\n\nperform a cyclic proximal point algorithm.\n\nInput\n\nM – a manifold mathcal M\nF – a cost function Fcolonmathcal Mtomathbb R to minimize\nproximalMaps – an Array of proximal maps (Functions) (λ,x) -> y for the summands of F\nx – an initial value xinmathcal M\n\nOptional\n\nthe default values are given in brackets\n\nevaluationOrder – ( LinearEvalOrder ) – whether to use a randomly permuted sequence (FixedRandomEvalOrder), a per cycle permuted sequence (RandomEvalOrder) or the default linear one.\nλ – ( iter -> 1/iter ) a function returning the (square summable but not summable) sequence of λi\nstoppingCriterion – (stopWhenAny(stopAfterIteration(5000),stopWhenChangeLess(10.0^-8))) a StoppingCriterion.\nreturnOptions – (false) – if actiavated, the extended result, i.e. the complete Options are returned. This can be used to access recorded values. If set to false (default) just the optimal value xOpt if returned\n\nand the ones that are passed to decorateOptions for decorators.\n\nOutput\n\nxOpt – the resulting (approximately critical) point of gradientDescent\n\nOR\n\noptions - the options returned by the solver (see returnOptions)\n\n\n\n","category":"function"},{"location":"solvers/cyclicProximalPoint/#","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"CyclicProximalPointOptions","category":"page"},{"location":"solvers/cyclicProximalPoint/#Manopt.CyclicProximalPointOptions","page":"Cyclic Proximal Point","title":"Manopt.CyclicProximalPointOptions","text":"CyclicProximalPointOptions <: Options\n\nstores options for the cyclicProximalPoint algorithm. These are the\n\nFields\n\nx0 – an MPoint to start\nstoppingCriterion – a function @(iter,x,xnew,λ_k) based on the current   iter, x and xnew as well as the current value of λ.\nλ – (@(iter) -> 1/iter) a function for the values of λ_k per iteration/cycle\nevaluationOrder – (LinearEvalOrder()) how to cycle through the proximal maps.   Other values are RandomEvalOrder() that takes a new random order each   iteration, and FixedRandomEvalOrder() that fixes a random cycle for all iterations.\n\nSee also\n\ncyclicProximalPoint\n\n\n\n\n\n","category":"type"},{"location":"solvers/cyclicProximalPoint/#Debug-Functions-1","page":"Cyclic Proximal Point","title":"Debug Functions","text":"","category":"section"},{"location":"solvers/cyclicProximalPoint/#","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"DebugProximalParameter","category":"page"},{"location":"solvers/cyclicProximalPoint/#Manopt.DebugProximalParameter","page":"Cyclic Proximal Point","title":"Manopt.DebugProximalParameter","text":"DebugProximalParameter <: DebugAction\n\nprint the current iterates proximal point algorithm parameter given by Optionss o.λ.\n\n\n\n","category":"type"},{"location":"solvers/cyclicProximalPoint/#Record-Functions-1","page":"Cyclic Proximal Point","title":"Record Functions","text":"","category":"section"},{"location":"solvers/cyclicProximalPoint/#","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"RecordProximalParameter","category":"page"},{"location":"solvers/cyclicProximalPoint/#Manopt.RecordProximalParameter","page":"Cyclic Proximal Point","title":"Manopt.RecordProximalParameter","text":"RecordProximalParameter <: RecordAction\n\nrecoed the current iterates proximal point algorithm parameter given by in Optionss o.λ.\n\n\n\n","category":"type"},{"location":"solvers/cyclicProximalPoint/#Literature-1","page":"Cyclic Proximal Point","title":"Literature","text":"","category":"section"},{"location":"solvers/cyclicProximalPoint/#","page":"Cyclic Proximal Point","title":"Cyclic Proximal Point","text":"<ul>\n<li id=\"Bačák2014\">[<a>Bačák, 2014</a>]\n  Bačák, M: <emph>Computing Medians and Means in Hadamard Spaces.</emph>,\n  SIAM Journal on Optimization, Volume 24, Number 3, pp. 1542–1566,\n  doi: <a href=\"https://doi.org/10.1137/140953393\">10.1137/140953393</a>,\n  arxiv: <a href=\"https://arxiv.org/abs/1210.2145\">1210.2145</a>.\n  </li>\n</ul>","category":"page"},{"location":"solvers/DouglasRachford/#DRSolver-1","page":"Douglas–Rachford","title":"Douglas–Rachford Algorithm","text":"","category":"section"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"The (Parallel) Douglas–Rachford ((P)DR) Algorithm was generalized to Hadamard manifolds in [Bergmann, Persch, Steidl, 2016].","category":"page"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"The aim is to minimize the sum","category":"page"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"F(x) = f(x) + g(x)","category":"page"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"on a manifold, where the two summands have proximal maps operatornameprox_lambda f operatornameprox_lambda g that are easy to evaluate (maybe in closed form or not too costly to approximate). Further define the Reflection operator at the proximal map as","category":"page"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"operatornamerefl_lambda f(x) = exp_operatornameprox_lambda f(x) bigl( -log_operatornameprox_lambda f(x) x bigr)","category":"page"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":".","category":"page"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"Let alpha_kin 01 with sum_kinmathbb N alpha_k(1-alpha_k) = infty and lambda  0 which might depend on iteration k as well) be given.","category":"page"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"Then the (P)DRA algorithm for initial data x_0inmathcal H as","category":"page"},{"location":"solvers/DouglasRachford/#Initialization-1","page":"Douglas–Rachford","title":"Initialization","text":"","category":"section"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"Initialize t_0 = x_0 and k=0","category":"page"},{"location":"solvers/DouglasRachford/#Iteration-1","page":"Douglas–Rachford","title":"Iteration","text":"","category":"section"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"Repeat  until a convergence criterion is reached","category":"page"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"Compute s_k = operatornamerefl_lambda foperatornamerefl_lambda g(t_k)\nwithin that operation store x_k+1 = operatornameprox_lambda g(t_k) which is the prox the inner reflection reflects at.\nCompute t_k+1 = g(alpha_k t_k s_k)\nSet k = k+1","category":"page"},{"location":"solvers/DouglasRachford/#Result-1","page":"Douglas–Rachford","title":"Result","text":"","category":"section"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"The result is given by the last computed x_K.","category":"page"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"For the parallel version, the first proximal map is a vectorial version, where in each component one prox is applied to the corresponding copy of t_k and the second proximal map corresponds to the indicator function of the set, where all copies are equal (in mathcal H^n, where n is the number of copies), leading to the second prox being the Riemannian mean.","category":"page"},{"location":"solvers/DouglasRachford/#Interface-1","page":"Douglas–Rachford","title":"Interface","text":"","category":"section"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"  DouglasRachford","category":"page"},{"location":"solvers/DouglasRachford/#Manopt.DouglasRachford","page":"Douglas–Rachford","title":"Manopt.DouglasRachford","text":" DouglasRachford(M, F, proxMaps, x)\n\nComputes the Douglas-Rachford algorithm on the manifold mathcal M, initial data x_0 and the (two) proximal maps proxMaps.\n\nFor k2 proximal maps the problem is reformulated using the parallelDouglasRachford: a vectorial proximal map on the power manifold mathcal M^k and the proximal map of the set that identifies all entries again, i.e. the Karcher mean. This henve also boild down to two proximal maps, though each evauates proximal maps in parallel, i.e. component wise in a vector.\n\nInput\n\nM – a Riemannian Manifold mathcal M\nF – a cost function consisting of a sum of cost functions\nproxes – functions of the form (λ,x)->... performing a proximal map, where ⁠λ denotes the proximal parameter, for each of the summands of F.\nx0 – initial data x_0inmathcal M\n\nOptional values\n\nthe default parameter is given in brackets\n\nλ – ((iter) -> 1.0) function to provide the value for the proximal parameter during the calls\nα – ((iter) -> 0.9) relaxation of the step from old to new iterate, i.e. t_k+1 = g(α_k t_k s_k), where s_k is the result of the double reflection involved in the DR algorithm\nR – (reflection) method employed in the iteration to perform the reflection of x at the prox p.\nstoppingCriterion – (stopWhenAny(stopAfterIteration(200),stopWhenChangeLess(10.0^-5))) a StoppingCriterion.\nparallel – (false) clarify that we are doing a parallel DR, i.e. on a Power manifold with two proxes. This can be used to trigger parallel Douglas–Rachford if you enter with two proxes. Keep in mind, that a parallel Douglas–Rachford implicitly works on a Power manifold and its first argument is the result then (assuming all are equal after the second prox.\nreturnOptions – (false) – if actiavated, the extended result, i.e. the   complete Options re returned. This can be used to access recorded values.   If set to false (default) just the optimal value xOpt if returned\n\n... and the ones that are passed to decorateOptions for decorators.\n\nOutput\n\nxOpt – the resulting (approximately critical) point of gradientDescent\n\nOR\n\noptions - the options returned by the solver (see returnOptions)\n\n\n\n","category":"function"},{"location":"solvers/DouglasRachford/#Options-1","page":"Douglas–Rachford","title":"Options","text":"","category":"section"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"DouglasRachfordOptions","category":"page"},{"location":"solvers/DouglasRachford/#Manopt.DouglasRachfordOptions","page":"Douglas–Rachford","title":"Manopt.DouglasRachfordOptions","text":"DouglasRachfordOptions <: Options\n\nStore all options required for the DouglasRachford algorithm,\n\nFields\n\nx - the current iterate (result) For the parallel Douglas-Rachford, this is not a value from the Power manifold but the mean.\ns – the last result of the double reflection at the proxes relaxed by α.\nλ – ((iter)->1.0) function to provide the value for the proximal parameter during the calls\nα – ((iter)->0.9) relaxation of the step from old to new iterate, i.e. x^(k+1) = g(α(k) x^(k) t^(k)), where t^(k) is the result of the double reflection involved in the DR algorithm\nR – (reflection) method employed in the iteration to perform the reflection of x at the prox p.\nstop – (stopAfterIteration(300)) a StoppingCriterion\nparallel – (false) inducate whether we are running a pallel Douglas-Rachford or not.\n\n\n\n","category":"type"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"For specific DebugActions and RecordActions see also Cyclic Proximal Point.","category":"page"},{"location":"solvers/DouglasRachford/#Literature-1","page":"Douglas–Rachford","title":"Literature","text":"","category":"section"},{"location":"solvers/DouglasRachford/#","page":"Douglas–Rachford","title":"Douglas–Rachford","text":"<ul>\n<li id=\"BergmannPerschSteidl2016\">[<a>Bergmann, Persch, Steidl, 2016</a>]\n  Bergmann, R; Persch, J.; Steidl, G.: <emph>A Parallel Douglas–Rachford\n  Algorithm for Minimizing ROF-like Functionals on Images with Values in\n  Symmetric Hadamard Manifolds.</emph>\n  SIAM Journal on Imaging Sciences, Volume 9, Number 3, pp. 901–937, 2016.\n  doi: <a href=\"https://doi.org/10.1137/15M1052858\">10.1137/15M1052858</a>,\n  arXiv: <a href=\"https://arxiv.org/abs/1512.02814\">1512.02814</a>.\n</li>\n</ul>","category":"page"},{"location":"solvers/gradientDescent/#GradientDescentSolver-1","page":"Gradient Descent","title":"Gradient Descent","text":"","category":"section"},{"location":"solvers/gradientDescent/#","page":"Gradient Descent","title":"Gradient Descent","text":"CurrentModule = Manopt","category":"page"},{"location":"solvers/gradientDescent/#","page":"Gradient Descent","title":"Gradient Descent","text":"  steepestDescent","category":"page"},{"location":"solvers/gradientDescent/#Manopt.steepestDescent","page":"Gradient Descent","title":"Manopt.steepestDescent","text":"steepestDescent(M, F, ∇F, x)\n\nperform a steepestDescent x_k+1 = mathrmretr_x_k s_knabla f(x_k) with different choices of s_k available (see stepsize option below).\n\nInput\n\nM – a manifold mathcal M\nF – a cost function Fcolonmathcal Mtomathbb R to minimize\n∇F – the gradient nabla Fcolonmathcal Mto Tmathcal M of F\nx – an initial value xinmathcal M\n\nOptional\n\nstepsize – (ConstantStepsize(1.)) specify a Stepsize functor.\nretraction – (exp) a retraction(M,x,ξ) to use.\nstoppingCriterion – ([stopWhenAny](@ref)([stopAfterIteration](@ref)(200), [stopWhenGradientNormLess](@ref)(10.0^-8))) a functor inheriting from [StoppingCriterion`](@ref) indicating when to stop.\nreturnOptions – (false) – if actiavated, the extended result, i.e. the   complete Options re returned. This can be used to access recorded values.   If set to false (default) just the optimal value xOpt if returned\n\n... and the ones that are passed to decorateOptions for decorators.\n\nOutput\n\nxOpt – the resulting (approximately critical) point of gradientDescent\n\nOR\n\noptions - the options returned by the solver (see returnOptions)\n\n\n\n","category":"function"},{"location":"solvers/gradientDescent/#Options-1","page":"Gradient Descent","title":"Options","text":"","category":"section"},{"location":"solvers/gradientDescent/#","page":"Gradient Descent","title":"Gradient Descent","text":"GradientDescentOptions","category":"page"},{"location":"solvers/gradientDescent/#Manopt.GradientDescentOptions","page":"Gradient Descent","title":"Manopt.GradientDescentOptions","text":"GradientDescentOptions{P,T} <: Options where {P <: MPoint, T <: TVector}\n\nDescribes a Gradient based descent algorithm, with\n\nFields\n\na default value is given in brackets if a parameter can be left out in initialization.\n\nx0 – an MPoint as starting point\nstoppingCriterion – (stopAfterIteration(100)) a StoppingCriterion\nstepsize – (ConstantStepsize(1.))a Stepsize\nretraction – (exp) the rectraction to use\n\nConstructor\n\nGradientDescentOptions(x, stop, s [, retr=exp])\n\nconstruct a Gradient Descent Option with the fields and defaults as above\n\nSee also\n\nsteepestDescent, GradientProblem\n\n\n\n\n\n","category":"type"},{"location":"solvers/gradientDescent/#Debug-Actions-1","page":"Gradient Descent","title":"Debug Actions","text":"","category":"section"},{"location":"solvers/gradientDescent/#","page":"Gradient Descent","title":"Gradient Descent","text":"DebugGradient\nDebugGradientNorm\nDebugStepsize","category":"page"},{"location":"solvers/gradientDescent/#Manopt.DebugGradient","page":"Gradient Descent","title":"Manopt.DebugGradient","text":"DebugGradient <: DebugAction\n\ndebug for the gradient evaluated at the current iterate\n\nConstructors\n\nDebugGradient([long=false,p=print])\n\ndisplay the short (false) or long (true) default text for the gradient.\n\nDebugGradient(prefix[, p=print])\n\ndisplay the a prefix in front of the gradient.\n\n\n\n","category":"type"},{"location":"solvers/gradientDescent/#Manopt.DebugGradientNorm","page":"Gradient Descent","title":"Manopt.DebugGradientNorm","text":"DebugGradientNorm <: DebugAction\n\ndebug for gradient evaluated at the current iterate.\n\nConstructors\n\nDebugGradientNorm([long=false,p=print])\n\ndisplay the short (false) or long (true) default text for the gradient norm.\n\nDebugGradientNorm(prefix[, p=print])\n\ndisplay the a prefix in front of the gradientnorm.\n\n\n\n","category":"type"},{"location":"solvers/gradientDescent/#Manopt.DebugStepsize","page":"Gradient Descent","title":"Manopt.DebugStepsize","text":"DebugStepsize <: DebugAction\n\ndebug for the current step size.\n\nConstructors\n\nDebugStepsize([long=false,p=print])\n\ndisplay the short (false) or long (true) default text for the step size.\n\nDebugStepsize(prefix[, p=print])\n\ndisplay the a prefix in front of the step size.\n\n\n\n","category":"type"},{"location":"solvers/gradientDescent/#Record-Actions-1","page":"Gradient Descent","title":"Record Actions","text":"","category":"section"},{"location":"solvers/gradientDescent/#","page":"Gradient Descent","title":"Gradient Descent","text":"RecordGradient\nRecordGradientNorm\nRecordStepsize","category":"page"},{"location":"solvers/gradientDescent/#Manopt.RecordGradient","page":"Gradient Descent","title":"Manopt.RecordGradient","text":"RecordGradient <: RecordAction\n\nrecord the gradient evaluated at the current iterate\n\nConstructors\n\nRecordGradient(ξ)\n\ninitialize the RecordAction to the corresponding type of the TVector.\n\n\n\n","category":"type"},{"location":"solvers/gradientDescent/#Manopt.RecordGradientNorm","page":"Gradient Descent","title":"Manopt.RecordGradientNorm","text":"RecordGradientNorm <: RecordAction\n\nrecord the norm of the current gradient\n\n\n\n","category":"type"},{"location":"solvers/gradientDescent/#Manopt.RecordStepsize","page":"Gradient Descent","title":"Manopt.RecordStepsize","text":"RecordStepsize <: RecordAction\n\nrecord the step size\n\n\n\n","category":"type"},{"location":"solvers/NelderMead/#NelderMeadSolver-1","page":"Nelder–Mead","title":"Nelder Mead Method","text":"","category":"section"},{"location":"solvers/NelderMead/#","page":"Nelder–Mead","title":"Nelder–Mead","text":"CurrentModule = Manopt","category":"page"},{"location":"solvers/NelderMead/#","page":"Nelder–Mead","title":"Nelder–Mead","text":"    NelderMead","category":"page"},{"location":"solvers/NelderMead/#Manopt.NelderMead","page":"Nelder–Mead","title":"Manopt.NelderMead","text":"NelderMead(M, F [, p])\n\nperform a nelder mead minimization problem for the cost funciton F on the manifold M. If the initial population p is not given, a random set of points is chosen.\n\nThis algorithm is adapted from the Euclidean Nelder-Mead method, see https://en.wikipedia.org/wiki/Nelder–Mead_method and http://www.optimization-online.org/DB_FILE/2007/08/1742.pdf.\n\nInput\n\nM – a manifold mathcal M\nF – a cost function Fcolonmathcal Mtomathbb R to minimize\npopulation – (n+1 randomMPoint(M)) an initial population of n+1 points, where n is the dimension of the manifold M.\n\nOptional\n\nstoppingCriterion – (stopAfterIteration(2000)) a StoppingCriterion\nretraction – (exp) a retraction(M,x,ξ) to use.\nα – (1.) reflection parameter (alpha  0)\nγ – (2.) expansion parameter (gamma)\nρ – (1/2) contraction parameter, 0  rho leq frac12,\nσ – (1/2) shrink coefficient, 0  sigma leq 1\n\nand the ones that are passed to decorateOptions for decorators.\n\nOutput\n\neither x the last iterate or the complete options depending on the optional keyword returnOptions, which is false by default (hence then only x is returned).\n\n\n\n","category":"function"},{"location":"solvers/NelderMead/#Options-1","page":"Nelder–Mead","title":"Options","text":"","category":"section"},{"location":"solvers/NelderMead/#","page":"Nelder–Mead","title":"Nelder–Mead","text":"    NelderMeadOptions","category":"page"},{"location":"solvers/NelderMead/#Manopt.NelderMeadOptions","page":"Nelder–Mead","title":"Manopt.NelderMeadOptions","text":"NelderMeadOptions <: Options\n\nDescribes all parameters and the state of a Nealer-Mead heuristic based optimization algorithm.\n\nFields\n\nThe naming of these parameters follows the Wikipedia article of the Euclidean case. The default is given in brackets, the required value range after the description\n\npopulation – an Array{MPoint,1} of n+1 points x_i, i=1ldotsn+1, where n is the dimension of the manifold.\nstoppingCriterion – (stopAfterIteration(2000)) a StoppingCriterion\nretraction – (exp) the rectraction to use\nα – (1.) reflection parameter (alpha  0)\nγ – (2.) expansion parameter (gamma0)\nρ – (1/2) contraction parameter, 0  rho leq frac12,\nσ – (1/2) shrink coefficient, 0  sigma leq 1\nx – (p[1]) - a field to collect the current best value\n\nConstructors\n\nNelderMead(M,stop, retr; α=1. , γ=2., ρ=1/2, σ=1/2)\n\nconstruct a Nelder-Mead Option with a set of dimension(M)+1 random points.\n\nNelderMead(p, stop retr; α=1. , γ=2., ρ=1/2, σ=1/2)\n\nconstruct a Nelder-Mead Option with a set p of MPoints\n\n\n\n","category":"type"},{"location":"solvers/subGradientMethod/#SubgradientSolver-1","page":"Subgradient Method","title":"Subgradient Method","text":"","category":"section"},{"location":"solvers/subGradientMethod/#","page":"Subgradient Method","title":"Subgradient Method","text":"subGradientMethod","category":"page"},{"location":"solvers/subGradientMethod/#Manopt.subGradientMethod","page":"Subgradient Method","title":"Manopt.subGradientMethod","text":"subGradientMethod(M, F, ∂F, x)\n\nperform a subgradient method x_k+1 = mathrmretr(x_k s_kF(x_k)),\n\nwhere mathrmretr is a retraction, s_k can be specified as a function but is usually set to a constant value. Though the subgradient might be set valued, the argument ∂F should always return one element from the subgradient.\n\nInput\n\nM – a manifold mathcal M\nF – a cost function Fcolonmathcal Mtomathbb R to minimize\n∂F: the (sub)gradient partial Fcolonmathcal Mto Tmathcal M of F restricted to always only returning one value/element from the subgradient\nx – an initial value xinmathcal M\n\nOptional\n\nstepsize – (ConstantStepsize(1.)) specify a Stepsize\nretraction – (exp) a retraction(M,x,ξ) to use.\nstoppingCriterion – (stopWhenAny(stopAfterIteration(200),stopWhenGradientNormLess(10.0^-8))) a functor, seeStoppingCriterion, indicating when to stop.\nreturnOptions – (false) – if actiavated, the extended result, i.e. the   complete Options re returned. This can be used to access recorded values.   If set to false (default) just the optimal value xOpt if returned\n\n... and the ones that are passed to decorateOptions for decorators.\n\nOutput\n\nxOpt – the resulting (approximately critical) point of gradientDescent\n\nOR\n\noptions - the options returned by the solver (see returnOptions)\n\n\n\n","category":"function"},{"location":"solvers/subGradientMethod/#Options-1","page":"Subgradient Method","title":"Options","text":"","category":"section"},{"location":"solvers/subGradientMethod/#","page":"Subgradient Method","title":"Subgradient Method","text":"SubGradientMethodOptions","category":"page"},{"location":"solvers/subGradientMethod/#Manopt.SubGradientMethodOptions","page":"Subgradient Method","title":"Manopt.SubGradientMethodOptions","text":"SubGradientMethodOptions <: Options\n\nstories option values for a subGradientMethod solver\n\nFields\n\nretraction – the retration to use within\nstepsize – a Stepsize\nstop – a StoppingCriterion\nx – (initial or current) value the algorithm is at\noptimalX – optimal value\n\n\n\n\n\n","category":"type"},{"location":"solvers/subGradientMethod/#","page":"Subgradient Method","title":"Subgradient Method","text":"For DebugActions and RecordActions to record (sub)gradient, its norm and the stepsizes, see the steepest Descent actions.","category":"page"},{"location":"solvers/truncatedConjugateGradient/#tCG-1","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint Truncated Conjugate-Gradient Method","text":"","category":"section"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"The aim is to solve the trust-region subproblem","category":"page"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"operatorname*argmin_eta in T_xmathcalM m_x(eta) = F(x) +\nlangle nabla F(x) eta rangle_x + frac12 langle\noperatornameHessF(eta)_ x eta rangle_x","category":"page"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"textst  langle eta eta rangle_x leq Delta^2","category":"page"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"on a manifold by using the Steihaug-Toint truncated conjugate-gradient method. All terms involving the trust-region radius use an inner product w.r.t. the preconditioner; this is because the iterates grow in length w.r.t. the preconditioner, guaranteeing that we do not re-enter the trust-region.","category":"page"},{"location":"solvers/truncatedConjugateGradient/#Initialization-1","page":"Steihaug-Toint TCG Method","title":"Initialization","text":"","category":"section"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"Initialize eta_0 = eta if using randomized approach else eta_0=zeroTVector(M,x), r_0 = nabla F(x), z_0 = operatornameP(r_0), delta_0 = z_0 and k=0","category":"page"},{"location":"solvers/truncatedConjugateGradient/#Iteration-1","page":"Steihaug-Toint TCG Method","title":"Iteration","text":"","category":"section"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"Repeat until a convergence criterion is reached","category":"page"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"Set kappa = langle delta_k operatornameHessF (delta_k)_ x rangle_x,  alpha =fraclangle r_k z_k rangle_xkappa and  langle eta_k eta_k rangle_x^*  = langle eta_k operatornameP(eta_k) rangle_x +  2alpha langle eta_k operatornameP(delta_k) rangle_x +  alpha^2  langle delta_k operatornameP(delta_k) rangle_x.\nIf kappa leqq 0 or langle eta_k eta_k rangle_x^*  geqq Delta^2  return eta_k+1 = eta_k + tau delta_k and stop.\nSet eta_k^* = eta_k + alpha delta_k, if  langle eta_k eta_k rangle_x + frac12 langle eta_k  operatornameHessF (eta_k)_ x rangle_x leqq langle eta_k^*   eta_k^*  rangle_x + frac12 langle eta_k^*   operatornameHessF (eta_k)_ x rangle_x  set eta_k+1 = eta_k else set eta_k+1 = eta_k^* .\nSet r_k+1 = r_k + alpha operatornameHessF (delta_k)_ x,   z_k+1 = operatornameP(r_k+1),  beta = fraclangle r_k+1  z_k+1 rangle_xlangle r_k z_k  rangle_x and delta_k+1 = -z_k+1 + beta delta_k.\nSet k=k+1.","category":"page"},{"location":"solvers/truncatedConjugateGradient/#Result-1","page":"Steihaug-Toint TCG Method","title":"Result","text":"","category":"section"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"The result is given by the last computed η_k.","category":"page"},{"location":"solvers/truncatedConjugateGradient/#Remarks-1","page":"Steihaug-Toint TCG Method","title":"Remarks","text":"","category":"section"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"The operatornameP(cdot) denotes the symmetric, positive deﬁnite preconditioner. It is required if a randomized approach is used i.e. using a random tangent vector eta=randomTVector(M,x) as initial vector. The idea behind it is to avoid saddle points. Preconditioning is simply a rescaling of the variables and thus a redeﬁnition of the shape of the trust region. Ideally operatornameP(cdot) is a cheap, positive approximation of the inverse of the Hessian of F at x. On default, the preconditioner is just the identity.","category":"page"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"To step number 2: Obtain tau from the positive root of leftlVert eta_k + tau delta_k rightrVert_operatornameP x = Delta what becomes after the conversion of the equation to","category":"page"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":" tau = frac-langle eta_k operatornameP(delta_k) rangle_x +\n sqrtlangle eta_k operatornameP(delta_k) rangle_x^2 +\n langle delta_k operatornameP(delta_k) rangle_x ( Delta^2 -\n langle eta_k operatornameP(eta_k) rangle_x)\n langle delta_k operatornameP(delta_k) rangle_x","category":"page"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"It can occur that langle delta_k operatornameHessF (delta_k)_ x rangle_x = kappa leqq 0 at iteration k. In this case, the model is not strictly convex, and the stepsize alpha =fraclangle r_k z_k rangle_x kappa computed in step 1. does not give a reduction in the modelfunction m_x(cdot). Indeed, m_x(cdot) is unbounded from below along the line eta_k + alpha delta_k. If our aim is to minimize the model within the trust-region, it makes far more sense to reduce m_x(cdot) along eta_k + alpha delta_k as much as we can while staying within the trust-region, and this means moving to the trust-region boundary along this line. Thus when kappa leqq 0 at iteration k, we replace alpha = fraclangle r_k z_k rangle_xkappa with tau described as above. The other possibility is that eta_k+1 would lie outside the trust-region at iteration k (i.e. langle eta_k eta_k rangle_x^*  geqq Delta^2 what can be identified with the norm of eta_k+1). In particular, when operatornameHessF (cdot)_ x is positive deﬁnite and eta_k+1 lies outside the trust region, the solution to the trust-region problem must lie on the trust-region boundary. Thus, there is no reason to continue with the conjugate gradient iteration, as it stands, as subsequent iterates will move further outside the trust-region boundary. A sensible strategy, just as in the case considered above, is to move to the trust-region boundary by ﬁnding tau.","category":"page"},{"location":"solvers/truncatedConjugateGradient/#Interface-1","page":"Steihaug-Toint TCG Method","title":"Interface","text":"","category":"section"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"  truncatedConjugateGradient","category":"page"},{"location":"solvers/truncatedConjugateGradient/#Manopt.truncatedConjugateGradient","page":"Steihaug-Toint TCG Method","title":"Manopt.truncatedConjugateGradient","text":"truncatedConjugateGradient(M, F, ∇F, x, η, H, Δ)\n\nsolve the trust-region subproblem\n\noperatorname*argmin_eta in T_xM m_x(eta) = F(x) + langle nabla F(x) eta rangle_x + frac12 langle operatornameHessF(eta)_ x eta rangle_x\n\ntextst  langle eta eta rangle_x leqq Delta^2\n\nwith the Steihaug-Toint truncated conjugate-gradient method. For a description of the algorithm and theorems offering convergence guarantees, see the reference:\n\nP.-A. Absil, C.G. Baker, K.A. Gallivan,   Trust-region methods on Riemannian manifolds, FoCM, 2007.   doi: 10.1007/s10208-005-0179-9\nA. R. Conn, N. I. M. Gould, P. L. Toint, Trust-region methods, SIAM,   MPS, 2000. doi: 10.1137/1.9780898719857\n\nInput\n\nM – a manifold mathcal M\nF – a cost function Fcolonmathcal Mtomathbb R to minimize\n∇F – the gradient nabla Fcolonmathcal Mto Tmathcal M of F\nx – a point on the manifold xinmathcal M\nη – an update tangential vector etainmathcalT_xM\nH – the hessian H( mathcal M x xi) of F\nΔ – a trust-region radius\n\nOptional\n\npreconditioner – a preconditioner for the hessian H\nθ – 1+θ is the superlinear convergence target rate. The algorithm will   terminate early if the residual was reduced by a power of 1+theta.\nκ – the linear convergence target rate: algorithm will terminate   early if the residual was reduced by a factor of kappa.\nuseRandom – set to true if the trust-region solve is to be initiated with a   random tangent vector. If set to true, no preconditioner will be   used. This option is set to true in some scenarios to escape saddle   points, but is otherwise seldom activated.\nstoppingCriterion – (stopWhenAny, stopAfterIteration,   stopIfResidualIsReducedByFactor, stopIfResidualIsReducedByPower,   stopWhenCurvatureIsNegative, stopWhenTrustRegionIsExceeded )   a functor inheriting from StoppingCriterion indicating when to stop,   where for the default, the maximal number of iterations is manifoldDimension,   the power factor is θ, the reduction factor is κ.   .\nreturnOptions – (false) – if actiavated, the extended result, i.e. the   complete Options re returned. This can be used to access recorded values.   If set to false (default) just the optimal value xOpt is returned\n\nand the ones that are passed to decorateOptions for decorators.\n\nOutput\n\nη – an approximate solution of the trust-region subproblem in   mathcalT_xM.\n\nOR\n\noptions - the options returned by the solver (see returnOptions)\n\nsee also\n\ntrustRegions\n\n\n\n","category":"function"},{"location":"solvers/truncatedConjugateGradient/#Options-1","page":"Steihaug-Toint TCG Method","title":"Options","text":"","category":"section"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"TruncatedConjugateGradientOptions","category":"page"},{"location":"solvers/truncatedConjugateGradient/#Manopt.TruncatedConjugateGradientOptions","page":"Steihaug-Toint TCG Method","title":"Manopt.TruncatedConjugateGradientOptions","text":"TruncatedConjugateGradientOptions <: HessianOptions\n\ndescribe the Steihaug-Toint truncated conjugate-gradient method, with\n\nFields\n\na default value is given in brackets if a parameter can be left out in initialization.\n\nx : a MPoint, where the trust-region subproblem needs   to be solved\nstop : a function s,r = @(o,iter,ξ,x,xnew) returning a stop   indicator and a reason based on an iteration number, the gradient and the   last and current iterates\nη : a TVector (called update vector), which solves the   trust-region subproblem after successful calculation by the algorithm\nδ : search direction\nΔ : the trust-region radius\nresidual : the gradient\nuseRand : indicates if the trust-region solve and so the algorithm is to be       initiated with a random tangent vector. If set to true, no       preconditioner will be used. This option is set to true in some       scenarios to escape saddle points, but is otherwise seldom activated.\n\nConstructor\n\nTruncatedConjugateGradientOptions(x, stop, eta, delta, Delta, res, uR)\n\nconstruct a truncated conjugate-gradient Option with the fields as above.\n\nSee also\n\ntruncatedConjugateGradient, trustRegions\n\n\n\n","category":"type"},{"location":"solvers/truncatedConjugateGradient/#Additional-Stopping-Criteria-1","page":"Steihaug-Toint TCG Method","title":"Additional Stopping Criteria","text":"","category":"section"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"stopIfResidualIsReducedByPower","category":"page"},{"location":"solvers/truncatedConjugateGradient/#Manopt.stopIfResidualIsReducedByPower","page":"Steihaug-Toint TCG Method","title":"Manopt.stopIfResidualIsReducedByPower","text":"stopIfResidualIsReducedByPower <: StoppingCriterion\n\nA functor for testing if the norm of residual at the current iterate is reduced by a power of 1+θ compared to the norm of the initial residual, i.e. Vert r_k Vert_x leqq  Vert r_0 Vert_x^1+theta. In this case the algorithm reached superlinear convergence.\n\nFields\n\nθ – part of the reduction power\ninitialResidualNorm - stores the norm of the residual at the initial vector   eta of the Steihaug-Toint tcg mehtod truncatedConjugateGradient\nreason – stores a reason of stopping if the stopping criterion has one be   reached, see getReason.\n\nConstructor\n\nstopIfResidualIsReducedByPower(iRN, θ)\n\ninitialize the stopIfResidualIsReducedByFactor functor to indicate to stop after the norm of the current residual is lesser than the norm of the initial residual iRN to the power of 1+θ.\n\nSee also\n\ntruncatedConjugateGradient, trustRegions\n\n\n\n","category":"type"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"stopIfResidualIsReducedByFactor","category":"page"},{"location":"solvers/truncatedConjugateGradient/#Manopt.stopIfResidualIsReducedByFactor","page":"Steihaug-Toint TCG Method","title":"Manopt.stopIfResidualIsReducedByFactor","text":"stopIfResidualIsReducedByFactor <: StoppingCriterion\n\nA functor for testing if the norm of residual at the current iterate is reduced by a factor compared to the norm of the initial residual, i.e. Vert r_k Vert_x leqq kappa Vert r_0 Vert_x. In this case the algorithm reached linear convergence.\n\nFields\n\nκ – the reduction factor\ninitialResidualNorm - stores the norm of the residual at the initial vector   eta of the Steihaug-Toint tcg mehtod truncatedConjugateGradient\nreason – stores a reason of stopping if the stopping criterion has one be reached, see getReason.\n\nConstructor\n\nstopIfResidualIsReducedByFactor(iRN, κ)\n\ninitialize the stopIfResidualIsReducedByFactor functor to indicate to stop after the norm of the current residual is lesser than the norm of the initial residual iRN times κ.\n\nSee also\n\ntruncatedConjugateGradient, trustRegions\n\n\n\n","category":"type"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"stopWhenTrustRegionIsExceeded","category":"page"},{"location":"solvers/truncatedConjugateGradient/#Manopt.stopWhenTrustRegionIsExceeded","page":"Steihaug-Toint TCG Method","title":"Manopt.stopWhenTrustRegionIsExceeded","text":"stopWhenTrustRegionIsExceeded <: StoppingCriterion\n\nA functor for testing if the norm of the next iterate in the  Steihaug-Toint tcg mehtod is larger than the trust-region radius, i.e. Vert η_k^* Vert_x  Δ. terminate the algorithm when the trust region has been left.\n\nFields\n\nreason – stores a reason of stopping if the stopping criterion has one be   reached, see getReason.\nstorage – stores the necessary parameters η, δ, residual to check the   criterion.\n\nConstructor\n\nstopWhenTrustRegionIsExceeded([a])\n\ninitialize the stopWhenTrustRegionIsExceeded functor to indicate to stop after the norm of the next iterate is greater than the trust-region radius using the StoreOptionsAction a, which is initialized to store :η, :δ, :residual by default.\n\nSee also\n\ntruncatedConjugateGradient, trustRegions\n\n\n\n","category":"type"},{"location":"solvers/truncatedConjugateGradient/#","page":"Steihaug-Toint TCG Method","title":"Steihaug-Toint TCG Method","text":"stopWhenCurvatureIsNegative","category":"page"},{"location":"solvers/truncatedConjugateGradient/#Manopt.stopWhenCurvatureIsNegative","page":"Steihaug-Toint TCG Method","title":"Manopt.stopWhenCurvatureIsNegative","text":"stopWhenCurvatureIsNegative <: StoppingCriterion\n\nA functor for testing if the curvature of the model is negative, i.e. langle delta_k operatornameHessF(delta_k)rangle_x leqq 0. In this case, the model is not strictly convex, and the stepsize as computed does not give a reduction of the model.\n\nFields\n\nreason – stores a reason of stopping if the stopping criterion has one be   reached, see getReason.\nstorage – stores the necessary parameter δ to check the   criterion.\n\nConstructor\n\nstopWhenCurvatureIsNegative([a])\n\ninitialize the stopWhenCurvatureIsNegative functor to indicate to stop after the inner product of the search direction and the hessian applied on the search dircetion is less than zero using the StoreOptionsAction a, which is initialized to just store :δ by default.\n\nSee also\n\ntruncatedConjugateGradient, trustRegions\n\n\n\n","category":"type"},{"location":"solvers/trustRegions/#trustRegions-1","page":"Riemannian Trust-Regions Solver","title":"The Riemannian Trust-Regions Solver","text":"","category":"section"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"The aim is to solve an optimization problem on a manifold","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"operatorname*min_x in mathcalM F(x)","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"by using the Riemannian trust-regions solver. It is number one choice for smooth optimization. This trust-region method uses the Steihaug-Toint truncated conjugate-gradient method truncatedConjugateGradient to solve the inner minimization problem called the trust-regions subproblem. This inner solve can be preconditioned by providing a preconditioner (symmetric and positive deﬁnite, an approximation of the inverse of the Hessian of F). If no Hessian of the cost function F is provided, a standard approximation of the Hessian based on the gradient nabla F with approxHessianFD will be computed.","category":"page"},{"location":"solvers/trustRegions/#Initialization-1","page":"Riemannian Trust-Regions Solver","title":"Initialization","text":"","category":"section"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"Initialize x_0 = x with an initial point x on the manifold. It can be given by the caller or set randomly. Set the initial trust-region radius Delta =frac18 barDelta where barDelta is the maximum radius the trust-region can have. Usually one uses the root of the manifold dimension operatornamedim(mathcalM). For accepting the next iterate and evaluating the new trust-region radius one needs an accept/reject threshold rho in 0frac14), which is rho = 01 on default. Set k=0.","category":"page"},{"location":"solvers/trustRegions/#Iteration-1","page":"Riemannian Trust-Regions Solver","title":"Iteration","text":"","category":"section"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"Repeat until a convergence criterion is reached","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"Set eta as a random tangent vector if using randomized approach. Else  set eta as the zero vector in the tangential space T_x_kmathcalM.\nSet eta^*  as the solution of the trust-region subproblem, computed by  the tcg-method with eta as initial vector.\nIf using randomized approach compare eta^*  with the Cauchy point  eta_c^*  = -tau_c fracDeltaoperatornamenorm(operatornameGradf (x_k)) operatornameGradF (x_k) by the model function m_x_k(cdot). If the  model decrease is larger by using the Cauchy point, set  eta^*  = eta_c^* .\nSet x^*  = operatornameRetr_x_k(eta^* ).\nSet rho = fracF(x_k)-F(x^* )m_x_k(eta)-m_x_k(eta^* ), where  m_x_k(cdot) describes the quadratic model function.\nUpdate the trust-region radius:  Delta = begincases frac14 Delta  rho  frac14   textor  m_x_k(eta)-m_x_k(eta^* ) leq 0  textor    rho = pm infty   operatornamemin(2 Delta barDelta)   rho  frac34  textand the tcg-method stopped because of negative  curvature or exceeding the trust-region  Delta   textotherwise  endcases\nIf m_x_k(eta)-m_x_k(eta^* ) geq 0 and rho  rho set  x_k = x^* .\nSet k = k+1.","category":"page"},{"location":"solvers/trustRegions/#Result-1","page":"Riemannian Trust-Regions Solver","title":"Result","text":"","category":"section"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"The result is given by the last computed x_k.","category":"page"},{"location":"solvers/trustRegions/#Remarks-1","page":"Riemannian Trust-Regions Solver","title":"Remarks","text":"","category":"section"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"To the Initialization: A random point on the manifold can be generated with randomMPoint(M).","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"To step number 1: Using randomized approach means using a random tangent vector as initial vector for the approximal solve of the trust-regions subproblem. If this is the case, keep in mind that the vector must be in the trust-region radius. This is achieved by multiplying η =randomTVector(M,x) by sqrt(4,eps(Float64)) as long as its norm is greater than the current trust-region radius Delta. For not using randomized approach, one can get the zero  tangent vector with η =zeroTVector(M,x).","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"To step number 2: Obtain eta^*  by (approximately) solving the trust-regions subproblem","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"operatorname*argmin_eta in T_x_kmathcalM m_x_k(eta) = F(x_k) +\nlangle nabla F(x_k) eta rangle_x_k + frac12 langle\noperatornameHessF(eta)_ x_k eta rangle_x_k","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"textst  langle eta eta rangle_x_k leq Delta^2","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"with the Steihaug-Toint truncated conjugate-gradient (tcg) method. The problem as well as the solution method is described in the truncatedConjugateGradient.","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"To step number 3: If using a random tangent vector as an initial vector, compare the result of the tcg-method with the Cauchy point. Convergence proofs assume that one achieves at least (a fraction of) the reduction of the Cauchy point. The idea is to go in the direction of the gradient to an optimal point. This can be on the edge, but also before. The parameter tau_c for the optimal length is defined by","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"tau_c = begincases 1  langle operatornameGradF (x_k) \noperatornameHessF (eta_k)_ x_krangle_x_k leq 0  \noperatornamemin(fracoperatornamenorm(operatornameGradF (x_k))^3\nDelta langle operatornameGradF (x_k) \noperatornameHessF (eta_k)_ x_krangle_x_k 1)   textotherwise\nendcases","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"To check the model decrease one compares m_x_k(eta_c^* ) = F(x_k) + langle eta_c^*  operatornameGradF (x_k)rangle_x_k + frac12langle eta_c^*  operatornameHessF (eta_c^* )_ x_krangle_x_k with m_x_k(eta^* ) = F(x_k) + langle eta^*  operatornameGradF (x_k)rangle_x_k + frac12langle eta^*  operatornameHessF (eta^* )_ x_krangle_x_k. If m_x_k(eta_c^* )  m_x_k(eta^* ) then is m_x_k(eta_c^* ) the better choice.","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"To step number 4: operatornameRetr_x_k(cdot) denotes the retraction, a mapping operatornameRetr_x_kT_x_kmathcalM rightarrow mathcalM wich approximates the exponential map. In some cases it is cheaper to use this instead of the exponential.","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"To step number 6: One knows that the truncatedConjugateGradient algorithm stopped for these reasons when the stopping criteria stopWhenCurvatureIsNegative, stopWhenTrustRegionIsExceeded are activated.","category":"page"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"To step number 7: The last step is to decide if the new point x^*  is accepted.","category":"page"},{"location":"solvers/trustRegions/#Interface-1","page":"Riemannian Trust-Regions Solver","title":"Interface","text":"","category":"section"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"trustRegions","category":"page"},{"location":"solvers/trustRegions/#Manopt.trustRegions","page":"Riemannian Trust-Regions Solver","title":"Manopt.trustRegions","text":"trustRegions(M, F, ∇F, x, H)\n\nevaluate the Riemannian trust-regions solver for optimization on manifolds. It will attempt to minimize the cost function F on the Manifold M. If no Hessian H is provided, a standard approximation of the Hessian based on the gradient ∇F will be computed. For solving the the inner trust-region subproblem of finding an update-vector, it uses the Steihaug-Toint truncated conjugate-gradient method. For a description of the algorithm and more details see\n\nP.-A. Absil, C.G. Baker, K.A. Gallivan,   Trust-region methods on Riemannian manifolds, FoCM, 2007.   doi: 10.1007/s10208-005-0179-9\nA. R. Conn, N. I. M. Gould, P. L. Toint, Trust-region methods, SIAM,   MPS, 2000. doi: 10.1137/1.9780898719857\n\nInput\n\nM – a manifold mathcal M\nF – a cost function F colon mathcal M to mathbb R to minimize\n∇F- the gradient nabla F colon mathcal M to T mathcal M of F\nx – an initial value x in mathcal M\nH – the hessian H( mathcal M x xi) of F\n\nOptional\n\nretraction – approximation of the exponential map exp\npreconditioner – a preconditioner (a symmetric, positive definite operator that should approximate the inverse of the Hessian)\nstoppingCriterion – (stopWhenAny(stopAfterIteration(1000), stopWhenGradientNormLess(10^(-6))) a functor inheriting from StoppingCriterion indicating when to stop.\nΔ_bar – the maximum trust-region radius\nΔ - the (initial) trust-region radius\nuseRandom – set to true if the trust-region solve is to be initiated with a random tangent vector. If set to true, no preconditioner will be used. This option is set to true in some scenarios to escape saddle points, but is otherwise seldom activated.\nρ_prime – Accept/reject threshold: if ρ (the performance ratio for the iterate) is at least ρ', the outer iteration is accepted. Otherwise, it is rejected. In case it is rejected, the trust-region radius will have been decreased. To ensure this, ρ' >= 0 must be strictly smaller than 1/4. If ρ_prime is negative, the algorithm is not guaranteed to produce monotonically decreasing cost values. It is strongly recommended to set ρ' > 0, to aid convergence.\nρ_regularization – Close to convergence, evaluating the performance ratio ρ is numerically challenging. Meanwhile, close to convergence, the quadratic model should be a good fit and the steps should be accepted. Regularization lets ρ go to 1 as the model decrease and the actual decrease go to zero. Set this option to zero to disable regularization (not recommended). When this is not zero, it may happen that the iterates produced are not monotonically improving the cost when very close to convergence. This is because the corrected cost improvement could change sign if it is negative but very small.\nreturnOptions – (false) – if actiavated, the extended result, i.e. the complete Options are returned. This can be used to access recorded values. If set to false (default) just the optimal value xOpt is returned\n\nOutput\n\nx – the last reached point on the manifold\n\nsee also\n\ntruncatedConjugateGradient\n\n\n\n","category":"function"},{"location":"solvers/trustRegions/#Options-1","page":"Riemannian Trust-Regions Solver","title":"Options","text":"","category":"section"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"TrustRegionsOptions","category":"page"},{"location":"solvers/trustRegions/#Manopt.TrustRegionsOptions","page":"Riemannian Trust-Regions Solver","title":"Manopt.TrustRegionsOptions","text":"TrustRegionsOptions <: HessianOptions\n\ndescribe the trust-regions solver, with\n\nFields\n\na default value is given in brackets if a parameter can be left out in initialization.\n\nx : a MPoint as starting point\nstop : a function s,r = @(o,iter) returning a stop   indicator and a reason based on an iteration number and the gradient\nΔ : the (initial) trust-region radius\nΔ_bar : the maximum trust-region radius\nuseRand : indicates if the trust-region solve is to be initiated with a       random tangent vector. If set to true, no preconditioner will be       used. This option is set to true in some scenarios to escape saddle       points, but is otherwise seldom activated.\nρ_prime : a lower bound of the performance ratio for the iterate that       decides if the iteration will be accepted or not. If not, the       trust-region radius will have been decreased. To ensure this,       ρ'>= 0 must be strictly smaller than 1/4. If ρ' is negative,       the algorithm is not guaranteed to produce monotonically decreasing       cost values. It is strongly recommended to set ρ' > 0, to aid       convergence.\nρ_regularization : Close to convergence, evaluating the performance ratio ρ       is numerically challenging. Meanwhile, close to convergence, the       quadratic model should be a good fit and the steps should be       accepted. Regularization lets ρ go to 1 as the model decrease and       the actual decrease go to zero. Set this option to zero to disable       regularization (not recommended). When this is not zero, it may happen       that the iterates produced are not monotonically improving the cost       when very close to convergence. This is because the corrected cost       improvement could change sign if it is negative but very small.\n\nConstructor\n\nTrustRegionsOptions(x, stop, delta, delta_bar, uR, rho_prime, rho_reg)\n\nconstruct a trust-regions Option with the fields as above.\n\nSee also\n\ntrustRegions\n\n\n\n","category":"type"},{"location":"solvers/trustRegions/#Approximation-of-the-Hessian-1","page":"Riemannian Trust-Regions Solver","title":"Approximation of the Hessian","text":"","category":"section"},{"location":"solvers/trustRegions/#","page":"Riemannian Trust-Regions Solver","title":"Riemannian Trust-Regions Solver","text":"approxHessianFD","category":"page"},{"location":"solvers/trustRegions/#Manopt.approxHessianFD","page":"Riemannian Trust-Regions Solver","title":"Manopt.approxHessianFD","text":"approxHessianFD(p,x,ξ,[stepsize=2.0^(-14)])\n\nreturn an approximated solution of the Hessian of the cost function applied to a TVector ξ by using a generic finite difference approximation based on computations of the gradient.\n\nInput\n\np – a Manopt problem structure (already containing the manifold and enough       information to compute the cost gradient)\nx – a MPoint where the Hessian is ​​to be approximated\nξ – a TVector on which the approximated Hessian is ​​to be applied\n\nOptional\n\nstepsize – the length of the step with which the method should work\n\nOutput\n\na TVector generated by applying the approximated Hessian to the   TVector ξ\n\n\n\n","category":"function"},{"location":"functions/#Functions-1","page":"Introduction","title":"Functions","text":"","category":"section"},{"location":"functions/#","page":"Introduction","title":"Introduction","text":"There are several functions required within optimization, most prominently costFunctions and gradients. This package includes several cost functions and corresponding gradients, but also corresponding proximal maps for variational methods manifold-valued data. Most of these functions require the evaluation of Differentials or their AdjointDifferentials as well as JacobiFields (e.g. easily to evaluate for symmetric manifolds).","category":"page"},{"location":"functions/costFunctions/#CostFunctions-1","page":"cost functions","title":"Cost Functions","text":"","category":"section"},{"location":"functions/costFunctions/#","page":"cost functions","title":"cost functions","text":"The following cost functions are available","category":"page"},{"location":"functions/costFunctions/#","page":"cost functions","title":"cost functions","text":"Modules = [Manopt]\nPages   = [\"costFunctions.jl\"]","category":"page"},{"location":"functions/costFunctions/#Manopt.costIntrICTV12-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P,P,P,Any,Any}} where P<:MPoint where mT<:Manifold","page":"cost functions","title":"Manopt.costIntrICTV12","text":"costIntrICTV12(M,f,u,v,α,β)\n\ncomputes the intrinsic infimal convolution model, where the addition is replaced by a mid point approach and the two functions involved are costTV2 and costTV. The model reads\n\nE(uv) =\n  frac12sum_iinmathcal G\n    d_mathcal Mbigl(g(frac12v_iw_i)f_ibigr)\n  +alphabigl( betamathrmTV(v) + (1-beta)mathrmTV_2(w) bigr)\n\n\n\n","category":"method"},{"location":"functions/costFunctions/#Manopt.costL2TV-Tuple{Power,PowPoint,Number,PowPoint}","page":"cost functions","title":"Manopt.costL2TV","text":"costL2TV(M,f,α,x)\n\ncompute the ell^2-TV functional on the Power manifold M for given (fixed) data f (on M), a nonnegative weight α, and evaluated at x (on M), i.e.\n\nE(x) = d_mathcal M^2(fx) + alpha operatornameTV(x)\n\nSee also\n\ncostTV\n\n\n\n","category":"method"},{"location":"functions/costFunctions/#Manopt.costL2TV2-Tuple{Power,PowPoint,Number,PowPoint}","page":"cost functions","title":"Manopt.costL2TV2","text":"costL2TV2(M,f,β,x)\n\ncompute the ell^2-TV2 functional on the Power manifold M for given data f, nonnegative parameter β, and evaluated at x, i.e.\n\nE(x) = d_mathcal M^2(fx) + betaoperatornameTV_2(x)\n\nSee also\n\ncostTV2\n\n\n\n","category":"method"},{"location":"functions/costFunctions/#Manopt.costL2TVTV2-Tuple{Power,PowPoint,Number,Number,PowPoint}","page":"cost functions","title":"Manopt.costL2TVTV2","text":"costL2TVTV2(M,f,α,β,x)\n\ncompute the ell^2-TV-TV2 functional on the Power manifold M for given (fixed) data f (on M), nonnegative weight α, β, and evaluated at x (on M), i.e.\n\nE(x) = d_mathcal M^2(fx) + alphaoperatornameTV(x)\n  + betaoperatornameTV_2(x)\n\nSee also\n\ncostTV, costTV2\n\n\n\n","category":"method"},{"location":"functions/costFunctions/#Manopt.costTV","page":"cost functions","title":"Manopt.costTV","text":"costTV(M,x [,p=2,q=1])\n\ncompute the operatornameTV^p functional for data xon the Power manifold M, i.e. mathcal M = mathcal N^n, where ninmathbb N^k denotes the dimensions of the data x. Let mathcal I_i denote the forward neighbors, i.e. with mathcal G as all indices from mathbf1inmathbb N^k to n we have mathcal I_i = i+e_j j=1ldotskcap mathcal G. The formula reads\n\nE^q(x) = sum_iinmathcal G\n  bigl( sum_jin mathcal I_i d^p_mathcal M(x_ix_j) bigr)^qp\n\nSee also\n\ngradTV, proxTV\n\n\n\n","category":"function"},{"location":"functions/costFunctions/#Manopt.costTV-Union{Tuple{P}, Tuple{mT}, Tuple{mT,Tuple{P,P}}, Tuple{mT,Tuple{P,P},Int64}} where P<:MPoint where mT<:Manifold","page":"cost functions","title":"Manopt.costTV","text":"costTV(M,x,p)\n\ncompute the operatornameTV^p functional for a tuple pT of MPoints on a Manifold M, i.e.\n\nE(x_1x_2) = d_mathcal M^p(x_1x_2) quad x_1x_2inmathcal M\n\nSee also\n\ngradTV, proxTV\n\n\n\n","category":"method"},{"location":"functions/costFunctions/#Manopt.costTV2","page":"cost functions","title":"Manopt.costTV2","text":"costTV2(M,x [,p=1])\n\ncompute the operatornameTV_2^p functional for data x on the Power manifoldmanifold M, i.e. mathcal M = mathcal N^n, where ninmathbb N^k denotes the dimensions of the data x. Let mathcal I_i^pm denote the forward and backward neighbors, respectively, i.e. with mathcal G as all indices from mathbf1inmathbb N^k to n we have mathcal I^pm_i = ipm e_j j=1ldotskcap mathcal I. The formula then reads\n\nE(x) = sum_iinmathcal I j_1in mathcal I^+_i j_2in mathcal I^-_i\nd^p_mathcal M(c_i(x_j_1x_j_2) x_i)\n\nwhere c_i(cdotcdot) denotes the mid point between its two arguments that is nearest to x_i.\n\nSee also\n\ngradTV2, proxTV2\n\n\n\n","category":"function"},{"location":"functions/costFunctions/#Manopt.costTV2-Union{Tuple{P}, Tuple{mT}, Tuple{mT,Tuple{P,P,P}}, Tuple{mT,Tuple{P,P,P},Int64}} where P<:MPoint where mT<:Manifold","page":"cost functions","title":"Manopt.costTV2","text":"costTV2(M,(x1,x2,x3) [,p=1])\n\ncompute the operatornameTV_2^p functional for the 3-tuple of points (x1,x2,x3)on the Manifold M. Denote by\n\n  mathcal C = bigl cin mathcal M   g(tfrac12x_1x_3) text for some geodesic gbigr\n\nthe set of mid points between x_1 and x_3. Then the functionr reads\n\nd_2^p(x_1x_2x_3) = min_cinmathcal C d_mathcal M(cx_2)\n\nSee also\n\ngradTV2, proxTV2\n\n\n\n","category":"method"},{"location":"functions/differentials/#DifferentialFunctions-1","page":"Differentials","title":"Differentials","text":"","category":"section"},{"location":"functions/differentials/#","page":"Differentials","title":"Differentials","text":"Modules = [Manopt]\nPages   = [\"differentials.jl\"]","category":"page"},{"location":"functions/differentials/#Manopt.DforwardLogs-Tuple{Power,PowPoint,PowTVector}","page":"Differentials","title":"Manopt.DforwardLogs","text":"ν = DforwardLogs(M,x,ξ)\n\ncompute the differenital of forwardLogs F on the Power manifold M at x and direction ξ , in the power manifold array, the differential of the function\n\nF_i(x) = sum_jinmathcal I_i log_x_i x_j quad i in mathcal G\n\nwhere mathcal G is the set of indices of the Power manifold M and mathcal I_i denotes the forward neighbors of i.\n\nInput\n\nM     – a Power manifold\nx     – a PowPoint.\nξ     – a PowTVector.\n\nOuput\n\nν – resulting tangent vector in T_xmathcal N representing the differentials of the logs, where mathcal N is thw power manifold with the number of dimensions added to size(x).\n\n\n\n","category":"method"},{"location":"functions/differentials/#Manopt.DxExp-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Differentials","title":"Manopt.DxExp","text":"DxExp(M,x,ξ,η)\n\ncomputes D_xexp_xxieta.\n\nSee also\n\nDξExp, jacobiField\n\n\n\n","category":"method"},{"location":"functions/differentials/#Manopt.DxGeo-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,P,Number,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Differentials","title":"Manopt.DxGeo","text":"DxGeo(M,x,y,t,η)\n\ncomputes D_xg(txy)eta.\n\nSee also\n\nDyGeo, jacobiField\n\n\n\n","category":"method"},{"location":"functions/differentials/#Manopt.DxLog-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,P,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Differentials","title":"Manopt.DxLog","text":"DxLog(M,x,y,η)\n\ncomputes D_xlog_xyeta.\n\nSee also\n\nDyLog, jacobiField\n\n\n\n","category":"method"},{"location":"functions/differentials/#Manopt.DyGeo-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,P,Number,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Differentials","title":"Manopt.DyGeo","text":"DyGeo(M,x,y,t,η)\n\ncomputes D_yg(txy)eta.\n\nSee also\n\nDxGeo, jacobiField\n\n\n\n","category":"method"},{"location":"functions/differentials/#Manopt.DyLog-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,P,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Differentials","title":"Manopt.DyLog","text":"DyLog(M,x,y,η)\n\ncomputes D_ylog_xyeta.\n\nSee also\n\nDxLog, jacobiField\n\n\n\n","category":"method"},{"location":"functions/differentials/#Manopt.DξExp-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Differentials","title":"Manopt.DξExp","text":"DξExp(M,x,ξ,η)\n\ncomputes D_xiexp_xxieta. Note that xiin T_xi(T_xmathcal M) = T_xmathcal M is still a tangent vector.\n\nSee also\n\nDxExp, jacobiField\n\n\n\n","category":"method"},{"location":"functions/adjointDifferentials/#adjointDifferentialFunctions-1","page":"Adjoint Differentials","title":"Adjoint Differentials","text":"","category":"section"},{"location":"functions/adjointDifferentials/#","page":"Adjoint Differentials","title":"Adjoint Differentials","text":"Modules = [Manopt]\nPages   = [\"adjointDifferentials.jl\"]","category":"page"},{"location":"functions/adjointDifferentials/#Manopt.AdjDforwardLogs-Tuple{Power,PowPoint,PowTVector}","page":"Adjoint Differentials","title":"Manopt.AdjDforwardLogs","text":"ξ = AdjDforwardLogs(M,x,ν)\n\ncompute the adjoibnt differential of forwardLogs F orrucirng, in the power manifold array, the differential of the function\n\nF_i(x) = sum_jinmathcal I_i log_x_i x_j\n\nwhere i runs over all indices of the Power manifold M and mathcal I_i denotes the forward neighbors of i Let n be the number dimensions of the Power manifold (i.e. length(size(x))). Then the input tangent vector lies on the manifold mathcal M = mathcal M^n.\n\nInput\n\nM     – a Power manifold\nx     – a PowPoint.\nν     – a PowTVector from T_Xmathcal M, where X = (xx)inmathcal M is an n-fold copy of x where \\mathcal N (x,...,x)N.\n\nOuput\n\nξ – resulting tangent vector in T_xmathcal M representing the adjoint differentials of the logs.\n\n\n\n","category":"method"},{"location":"functions/adjointDifferentials/#Manopt.AdjDxExp-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Adjoint Differentials","title":"Manopt.AdjDxExp","text":"AdjDxExp(M,x,ξ,η)\n\ncomputes the adjoint of D_xexp_xxieta.\n\nSee also\n\nDxExp, adjointJacobiField\n\n\n\n","category":"method"},{"location":"functions/adjointDifferentials/#Manopt.AdjDxGeo-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,P,Float64,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Adjoint Differentials","title":"Manopt.AdjDxGeo","text":"AdjDxGeo(M,x,y,t,η)\n\ncomputes the adjoint of D_xg(txy)eta.\n\nSee also\n\nDxGeo, adjointJacobiField\n\n\n\n","category":"method"},{"location":"functions/adjointDifferentials/#Manopt.AdjDxLog-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,P,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Adjoint Differentials","title":"Manopt.AdjDxLog","text":"AdjDxLog(M,x,y,η)\n\ncomputes the adjoint of D_xlog_xyeta.\n\nSee also\n\nDxLog, adjointJacobiField\n\n\n\n","category":"method"},{"location":"functions/adjointDifferentials/#Manopt.AdjDyGeo-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,P,Float64,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Adjoint Differentials","title":"Manopt.AdjDyGeo","text":"AdjDyGeo(M,x,y,t,η)\n\ncomputes the adjoint of D_yg(txy)eta.\n\nSee also\n\nDyGeo, adjointJacobiField\n\n\n\n","category":"method"},{"location":"functions/adjointDifferentials/#Manopt.AdjDyLog-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,P,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Adjoint Differentials","title":"Manopt.AdjDyLog","text":"AdjDyLog(M,x,y,η)\n\ncomputes the adjoint of D_ylog_xyeta.\n\nSee also\n\nDyLog, adjointJacobiField\n\n\n\n","category":"method"},{"location":"functions/adjointDifferentials/#Manopt.AdjDξExp-Union{Tuple{T}, Tuple{P}, Tuple{mT}, Tuple{mT,P,T,T}} where T<:TVector where P<:MPoint where mT<:Manifold","page":"Adjoint Differentials","title":"Manopt.AdjDξExp","text":"AdjDξExp(M,x,ξ,η)\n\ncomputes the adjoint of D_xiexp_xxieta. Note that xiin T_xi(T_xmathcal M) = T_xmathcal M is still a tangent vector.\n\nSee also\n\nDξExp, adjointJacobiField\n\n\n\n","category":"method"},{"location":"functions/gradients/#GradientFunctions-1","page":"Gradients","title":"Gradients","text":"","category":"section"},{"location":"functions/gradients/#","page":"Gradients","title":"Gradients","text":"For a function fcolonmathcal Mtomathbb R the Riemannian gradient nabla f(x) at xinmathcal M is given by the unique tangent vector fulfilling","category":"page"},{"location":"functions/gradients/#","page":"Gradients","title":"Gradients","text":"langle nabla f(x) xirangle_x = D_xfxiquad\nforall xi in T_xmathcal M","category":"page"},{"location":"functions/gradients/#","page":"Gradients","title":"Gradients","text":"where D_xfxi denotes the differential of f at x with respect to the tangent direction (vector) xi or in other words the directional derivative.","category":"page"},{"location":"functions/gradients/#","page":"Gradients","title":"Gradients","text":"This page collects the available gradients.","category":"page"},{"location":"functions/gradients/#","page":"Gradients","title":"Gradients","text":"Modules = [Manopt]\nPages   = [\"gradients.jl\"]","category":"page"},{"location":"functions/gradients/#Manopt.forwardLogs-Union{Tuple{Nt}, Tuple{P}, Tuple{Power,PowPoint{P,Nt}}} where Nt where P<:MPoint","page":"Gradients","title":"Manopt.forwardLogs","text":"ξ = forwardLogs(M,x)\n\ncompute the forward logs F (generalizing forward differences) orrucirng, in the power manifold array, the function\n\nF_i(x) = sum_jinmathcal I_i log_x_i x_jquad i in mathcal G\n\nwhere mathcal G is the set of indices of the Power manifold M and mathcal I_i denotes the forward neighbors of i.\n\nInput\n\nM – a Power manifold\nx – a PowPoint.\n\nOuput\n\nξ – resulting tangent vector in T_xmathcal M representing the logs, where mathcal N is thw power manifold with the number of dimensions added to size(x).\n\n\n\n","category":"method"},{"location":"functions/gradients/#Manopt.gradDistance","page":"Gradients","title":"Manopt.gradDistance","text":"gradDistance(M,y,x[, p=2])\n\ncompute the (sub)gradient of the distance (squared) \n\nf(x) = frac12 d^p_mathcal M(xy)\n\nto a fixed MPointy on the Manifold M and p is an integer. The gradient reads\n\n  nabla f(x) = -d_mathcal M^p-2(xy)log_xy\n\nfor pneq 1 or xneq  y. Note that for the remaining case p=1, x=y the function is not differentiable. This function returns then the zeroTVector(M,x), since this is an element of the subdifferential.\n\nOptional\n\np – (2) the exponent of the distance,  i.e. the default is the squared distance\n\n\n\n","category":"function"},{"location":"functions/gradients/#Manopt.gradIntrICTV12-Union{Tuple{P}, Tuple{mT}, Tuple{mT,P,P,P,Any,Any}} where P<:MPoint where mT<:Manifold","page":"Gradients","title":"Manopt.gradIntrICTV12","text":"∇u,⁠∇v = gradIntrICTV12(M,f,u,v,α,β)\n\ncompute (sub)gradient of the intrinsic infimal convolution model using the mid point model of second order differences, see costTV2, i.e. for some finmathcal M on a Power manifold mathcal M this function computes the (sub)gradient of\n\nE(uv) =\nfrac12sum_iinmathcal G d_mathcal M(g(frac12v_iw_i)f_i)\n+ alpha\nbigl(\nbetamathrmTV(v) + (1-beta)mathrmTV_2(w)\nbigr)\n\nwhere both total variations refer to the intrinsic ones, gradTV and gradTV2, respectively.\n\n\n\n","category":"method"},{"location":"functions/gradients/#Manopt.gradTV","page":"Gradients","title":"Manopt.gradTV","text":"gradTV(M,(x,y),[p=1])\n\ncompute the (sub) gradient of frac1pd^p_mathcal M(xy) with respect to both x and y.\n\n\n\n","category":"function"},{"location":"functions/gradients/#Manopt.gradTV","page":"Gradients","title":"Manopt.gradTV","text":"ξ = gradTV(M,λ,x,[p])\n\nCompute the (sub)gradient partial F of all forward differences orrucirng, in the power manifold array, i.e. of the function\n\nF(x) = sum_isum_jinmathcal I_i d^p(x_ix_j)\n\nwhere i runs over all indices of the Power manifold M and mathcal I_i denotes the forward neighbors of i.\n\nInput\n\nM – a Power manifold\nx – a PowPoint.\n\nOuput\n\nξ – resulting tangent vector in T_xmathcal M.\n\n\n\n","category":"function"},{"location":"functions/gradients/#Manopt.gradTV2","page":"Gradients","title":"Manopt.gradTV2","text":"gradTV2(M,x [,p=1])\n\ncomputes the (sub) gradient of frac1pd_2^p(x_1x_2x_3) with respect to all x_1x_2x_3 occuring along any array dimension in the PowPoint x, where M is the corresponding Power manifold.\n\n\n\n","category":"function"},{"location":"functions/gradients/#Manopt.gradTV2","page":"Gradients","title":"Manopt.gradTV2","text":"gradTV2(M,(x,y,z),p)\n\ncomputes the (sub) gradient of frac1pd_2^p(xyz) with respect to x, y, and z, where d_2 denotes the second order absolute difference using the mid point model, i.e. let\n\n  mathcal C = bigl cin mathcal M   g(tfrac12x_1x_3) text for some geodesic gbigr\n\ndenote the mid points between x and z on the manifold mathcal M. Then the absolute second order difference is defined as\n\nd_2(xyz) = min_cinmathcal C_xz d(cy)\n\nWhile the (sub)gradient with respect to y is easy, the other two require the evaluation of an adjointJacobiField. See Illustration of the Gradient of a Second Order Difference for its derivation.\n\n\n\n","category":"function"},{"location":"functions/jacobiFields/#JacobiFieldFunctions-1","page":"JacobiFields","title":"Jacobi Fields","text":"","category":"section"},{"location":"functions/jacobiFields/#","page":"JacobiFields","title":"JacobiFields","text":"A smooth tangent vector field Jcolon 01 to Tmathcal M along a geodesic g(cdotxy) is called Jacobi field if it fulfills the ODE","category":"page"},{"location":"functions/jacobiFields/#","page":"JacobiFields","title":"JacobiFields","text":"displaystyle 0 = fracDdtJ + R(Jdot g)dot g","category":"page"},{"location":"functions/jacobiFields/#","page":"JacobiFields","title":"JacobiFields","text":"where R is the Riemannian curvature tensor. Such Jacobi fields can be used to derive closed forms for the exponential map, the logarithmic map and the geodesic, all of them with respect to both arguments: Let Fcolonmathcal N to mathcal M be given (for the exp_xcdot   we have mathcal N = T_xmathcal M, otherwise mathcal N=mathcal M) and denote by Xi_1ldotsXi_d an orthonormal frame along g(cdotxy) that diagonalizes the curvature tensor with corresponding eigenvalues kappa_1ldotskappa_d. Note that on symmetric manifolds such a frame always exists.","category":"page"},{"location":"functions/jacobiFields/#","page":"JacobiFields","title":"JacobiFields","text":"Then DF(x)eta = sum_k=1^d langle etaXi_k(0)rangle_xbeta(kappa_k)Xi_k(T) holds, where T also depends on the function F as the weights beta. The values stem from solving the corresponding system of (decoupled) ODEs.","category":"page"},{"location":"functions/jacobiFields/#","page":"JacobiFields","title":"JacobiFields","text":"Note that in different references some factors might be a little different, for example when using unit speed geodesics.","category":"page"},{"location":"functions/jacobiFields/#","page":"JacobiFields","title":"JacobiFields","text":"The following weights functions are available","category":"page"},{"location":"functions/jacobiFields/#","page":"JacobiFields","title":"JacobiFields","text":"βDgx\nβDexpx\nβDexpξ\nβDlogx\nβDlogy","category":"page"},{"location":"functions/jacobiFields/#Manopt.βDgx","page":"JacobiFields","title":"Manopt.βDgx","text":"βDgx(κ,t,d)\n\nweights for the jacobiField corresponding to the differential of the geodesic with respect to its start point D_x g(txy)eta. They are\n\nbeta(kappa) = begincases\nfracsinh(d(1-t)sqrt-kappa)sinh(dsqrt-kappa)\ntext if kappa  0\n1-t  text if  kappa = 0\nfracsin((1-t)dsqrtkappa)sinh(dsqrtkappa)\ntext if kappa  0\nendcases\n\nDue to a symmetry agrument, these are also used to compute D_y g(t xy)eta\n\nSee also\n\nDyGeo, DxGeo, jacobiField\n\n\n\n","category":"function"},{"location":"functions/jacobiFields/#Manopt.βDexpx","page":"JacobiFields","title":"Manopt.βDexpx","text":"βDexpx(κ,t,d)\n\nweights for the jacobiField corresponding to the differential of the geodesic with respect to its start point D_x exp_x(xi)eta. They are\n\nbeta(kappa) = begincases\ncosh(sqrt-kappa)text if kappa  0\n1  text if  kappa = 0\ncos(sqrtkappa) text if kappa  0\nendcases\n\nSee also\n\nDxExp, jacobiField\n\n\n\n","category":"function"},{"location":"functions/jacobiFields/#Manopt.βDexpξ","page":"JacobiFields","title":"Manopt.βDexpξ","text":"βDexpξ(κ,t,d)\n\nweights for the jacobiField corresponding to the differential of the geodesic with respect to its start point D_xi exp_x(xi)eta. They are\n\nbeta(kappa) = begincases\nfracsinh(dsqrt-kappa)dsqrt-kappatext if kappa  0\n1  text if  kappa = 0\nfracsin(dsqrtkappa)sqrtdkappatext if kappa  0\nendcases\n\nSee also\n\nDξExp, jacobiField\n\n\n\n","category":"function"},{"location":"functions/jacobiFields/#Manopt.βDlogx","page":"JacobiFields","title":"Manopt.βDlogx","text":"βDlogx(κ,t,d)\n\nweights for thejacobiField corresponding to the differential of the geodesic with respect to its start point D_x log_xyeta. They are\n\nbeta(kappa) = begincases\n-sqrt-kappadfraccosh(dsqrt-kappa)sinh(dsqrt-kappa)text if kappa  0\n-1  text if  kappa = 0\n-sqrtkappadfraccos(dsqrtkappa)sin(dsqrtkappa)text if kappa  0\nendcases\n\nSee also\n\nDxLog, DyLog, jacobiField\n\n\n\n","category":"function"},{"location":"functions/jacobiFields/#Manopt.βDlogy","page":"JacobiFields","title":"Manopt.βDlogy","text":"βDlogy(κ,t,d)\n\nweights for the JacobiField corresponding to the differential of the logarithmic map with respect to its argument D_y log_xyeta. They are\n\nbeta(kappa) = begincases\nfrac dsqrt-kappa sinh(dsqrt-kappa)text if kappa  0\n1  text if  kappa = 0\nfrac dsqrtkappa sin(dsqrtkappa)text if kappa  0\nendcases\n\nSee also\n\nDyLog, jacobiField\n\n\n\n","category":"function"},{"location":"functions/proximalMaps/#proximalMapFunctions-1","page":"Proximal Maps","title":"Proximal Maps","text":"","category":"section"},{"location":"functions/proximalMaps/#","page":"Proximal Maps","title":"Proximal Maps","text":"For a function varphicolonmathcal M tomathbb R the proximal map is defined as","category":"page"},{"location":"functions/proximalMaps/#","page":"Proximal Maps","title":"Proximal Maps","text":"displaystyleoperatornameprox_lambdavarphi(x)\n= operatorname*argmin_yinmathcal M d_mathcal M^2(xy) + varphi(y)\nquad lambda  0","category":"page"},{"location":"functions/proximalMaps/#","page":"Proximal Maps","title":"Proximal Maps","text":"where d_mathcal Mcolon mathcal M times mathcal M to mathbb R denotes the geodesic distance on (\\mathcal M). While it might still be difficult to compute the minimizer, there are several proximal maps known (locally) in closed form. Furthermore if x^star inmathcal M is a minimizer of varphi, then","category":"page"},{"location":"functions/proximalMaps/#","page":"Proximal Maps","title":"Proximal Maps","text":"displaystyleoperatornameprox_lambdavarphi(x^star) = x^star","category":"page"},{"location":"functions/proximalMaps/#","page":"Proximal Maps","title":"Proximal Maps","text":"i.e. a minimizer is a fixed point of the proximal map.","category":"page"},{"location":"functions/proximalMaps/#","page":"Proximal Maps","title":"Proximal Maps","text":"This page lists all proximal maps available within Manopt. To add you own, just extend the functions/proximalMaps.jl file.","category":"page"},{"location":"functions/proximalMaps/#","page":"Proximal Maps","title":"Proximal Maps","text":"Modules = [Manopt]\nPages   = [\"proximalMaps.jl\"]","category":"page"},{"location":"functions/proximalMaps/#Manopt.proxCollaborativeTV","page":"Proximal Maps","title":"Manopt.proxCollaborativeTV","text":"proxCollaborativeTV(M,λ,x [,p=2,q=1])\n\ncompute the prox of the collaborative TV prox for x on the Power manifold, i.e. of the function\n\nF^q(x) = sum_iinmathcal G\n  Bigl( sum_jinmathcal I_i\n    sum_k=1^d lVert X_ijrVert_x^pBigr)^fracqp\n\nwhere mathcal G is the set of indices for xinmathcal M and mathcal I_i is the set of its forward neighbors. This is adopted from the paper by Duran, Möller, Sbert, Cremers: Collaborative Total Variation: A General Framework for Vectorial TV Models (arxiv: 1508.01308), where the most inner norm is not on a manifold but on a vector space, see their Example 3 for details.\n\n\n\n","category":"function"},{"location":"functions/proximalMaps/#Manopt.proxDistance-Union{Tuple{T}, Tuple{mT}, Tuple{mT,Number,T,T}, Tuple{mT,Number,T,T,Int64}} where T<:MPoint where mT<:Manifold","page":"Proximal Maps","title":"Manopt.proxDistance","text":"y = proxDistance(M,λ,f,x [,p=2])\n\ncompute the proximal map operatornameprox_lambdavarphi with parameter λ of varphi(x) = frac1pd_mathcal M^p(fx).\n\nInput\n\nM – a Manifold mathcal M\nλ – the prox parameter\nf – an MPoint finmathcal M (the data)\nx – the argument of the proximal map\n\nOptional argument\n\np – (2) exponent of the distance.\n\nOuput\n\ny – the result of the proximal map of varphi\n\n\n\n","category":"method"},{"location":"functions/proximalMaps/#Manopt.proxParallelTV-Union{Tuple{N}, Tuple{P}, Tuple{Power,Number,Array{PowPoint{P,N},1}}, Tuple{Power,Number,Array{PowPoint{P,N},1},Int64}} where N where P<:MPoint","page":"Proximal Maps","title":"Manopt.proxParallelTV","text":"ξ = proxParallelTV(M,λ,x [,p=1])\n\ncompute the proximal maps operatornameprox_lambdavarphi of all forward differences orrucirng in the power manifold array, i.e. varphi(xixj) = d_mathcal M^p(xixj) with xi and xj are array elemets of x and j = i+e_k, where e_k is the kth unitvector. The parameter λ is the prox parameter.\n\nInput\n\nM     – a Power manifold\nλ     – a real value, parameter of the proximal map\nx     – a PowPoint.\n\nOptional\n\n(default is given in brackets)\n\np – (1) exponent of the distance of the TV term\n\nOuput\n\ny  – resulting of Array PowPoints with all mentioned proximal points evaluated (in a parallel within the arrays elements).\n\nSee also proxTV\n\n\n\n","category":"method"},{"location":"functions/proximalMaps/#Manopt.proxTV","page":"Proximal Maps","title":"Manopt.proxTV","text":"ξ = proxTV(M,λ,x [,p=1])\n\ncompute the proximal maps operatornameprox_lambdavarphi of all forward differences orrucirng in the power manifold array, i.e. varphi(xixj) = d_mathcal M^p(xixj) with xi and xj are array elemets of x and j = i+e_k, where e_k is the kth unitvector. The parameter λ is the prox parameter.\n\nInput\n\nM – a Manifold\nλ – a real value, parameter of the proximal map\nx – a PowPoint.\n\nOptional\n\n(default is given in brackets)\n\np – (1) exponent of the distance of the TV term\n\nOuput\n\ny – resulting of PowPoint with all mentioned proximal points evaluated (in a cylic order).\n\n\n\n","category":"function"},{"location":"functions/proximalMaps/#Manopt.proxTV-Union{Tuple{P}, Tuple{mT}, Tuple{mT,Number,Tuple{P,P}}, Tuple{mT,Number,Tuple{P,P},Int64}} where P<:MPoint where mT<:Manifold","page":"Proximal Maps","title":"Manopt.proxTV","text":"(y1,y2) = proxTV(M,λ,(x1,x2) [,p=1])\n\nCompute the proximal map operatornameprox_lambdavarphi of varphi(xy) = d_mathcal M^p(xy) with parameter λ.\n\nInput\n\nM – a Manifold\nλ – a real value, parameter of the proximal map\n(x1,x2) – a tuple of two MPoints,\n\nOptional\n\n(default is given in brackets)\n\np – (1) exponent of the distance of the TV term\n\nOuput\n\n(y1,y2) – resulting tuple of MPoint of the operatornameprox_lambdavarphi( (x1,x2) )\n\n\n\n","category":"method"},{"location":"functions/proximalMaps/#Manopt.proxTV2","page":"Proximal Maps","title":"Manopt.proxTV2","text":"ξ = proxTV2(M,λ,x,[p])\n\ncompute the proximal maps operatornameprox_lambdavarphi of all centered second order differences orrucirng in the power manifold array, i.e. varphi(x_kx_ix_j) = d_2(x_kx_ix_j), where kj are backward and forward neighbors (along any dimension in the array of x). The parameter λ is the prox parameter.\n\nInput\n\nM – a Manifold\nλ – a real value, parameter of the proximal map\nx – a PowPoint.\n\nOptional\n\n(default is given in brackets)\n\np – (1) exponent of the distance of the TV term\n\nOuput\n\ny – resulting of PowPoint with all mentioned proximal points evaluated (in a cylic order).\n\n\n\n","category":"function"},{"location":"functions/proximalMaps/#Manopt.proxTV2-Union{Tuple{P}, Tuple{mT}, Tuple{mT,Any,Tuple{P,P,P}}, Tuple{mT,Any,Tuple{P,P,P},Int64}} where P<:MPoint where mT<:Manifold","page":"Proximal Maps","title":"Manopt.proxTV2","text":"(y1,y2,y3) = proxTV2(M,λ,(x1,x2,x3),[p=1], kwargs...)\n\nCompute the proximal map operatornameprox_lambdavarphi of varphi(x_1x_2x_3) = d_mathcal M^p(c(x_1x_3)x_2) with parameter λ>0, where c(xz) denotes the mid point of a shortest geodesic from x1 to x3 that is closest to x2.\n\nInput\n\nM          – a manifold\nλ          – a real value, parameter of the proximal map\n(x1,x2,x3) – a tuple of three MPoints\np – (1) exponent of the distance of the TV term\n\nOptional\n\nkwargs... – parameters for the internal subGradientMethod     (if M is neither Euclidean nor Circle, since for these a closed form     is given)\n\nOutput\n\n(y1,y2,y3) – resulting tuple of MPoints of the proximal map\n\n\n\n","category":"method"},{"location":"helpers/data/#Data-1","page":"Data","title":"Data","text":"","category":"section"},{"location":"helpers/data/#","page":"Data","title":"Data","text":"For some manifolds there are artificial or real application data available that can be loaded using the following data functions","category":"page"},{"location":"helpers/data/#","page":"Data","title":"Data","text":"  artificialS1Signal\n  artificialS1SlopeSignal\n  artificialInSARImage\n  artificialS2Lemniscate\n  artificialS2WhirlPatch\n  artificialS2WhirlImage\n  artificialS2RotationsImage\n  artificialSPDImage\n  artificialSPDImage2","category":"page"},{"location":"helpers/data/#Manopt.artificialS1Signal","page":"Data","title":"Manopt.artificialS1Signal","text":"artificialS1Signal([pts=500,pointType=S1Point])\n\ngenerate a real-valued signal having piecewise constant, linear and quadratic intervals with jumps in between. If the resulting manifold the data lives on, is the Circle (the default S1Point) the data is also wrapped to -pipi).\n\nOptional\n\npts – (500) number of points to sample the function\npointType – (S1Point) provide the point type, i.e. manifold the data lives on. Possible values: S1Point, SnPoint, RnPoint, where for the second type, the data is embeypeded (point wise) in mathbb R^2.\n\n\n\nartificialS1Signal(x)\n\nevaluate the example signal f(x) xin 01, of phase-valued data introduces in Sec. 5.1 of\n\nBergmann, Laus, Steidl, Weinmann, Second Order Differences of Cyclic Data and Applications in Variational Denoising, SIAM J. Imaging Sci., 7(4), 2916–2953, 2014. doi: 10.1137/140969993\n\nfor values outside that intervall, this Signal is missing.\n\n\n\n","category":"function"},{"location":"helpers/data/#Manopt.artificialS1SlopeSignal","page":"Data","title":"Manopt.artificialS1SlopeSignal","text":"artificialS1SlopeSignal([pts=500, slope=4.])\n\nCreates a Signal of (phase-valued) data represented on the CircleManifold with increasing slope.\n\nOptional\n\npts – (500) number of points to sample the function.\nslope – (4.0) initial slope that gets increased afterwards\n\n\n\n","category":"function"},{"location":"helpers/data/#Manopt.artificialInSARImage","page":"Data","title":"Manopt.artificialInSARImage","text":"artificialInSARImage([pts=500, pointType=S1Point])\n\ngenerate an artificial InSAR image, i.e. phase valued data, of size pts x pts points. The pointType – (S1Point) provide the point type, i.e. manifold the data lives   on. Possible values: S1Point, SnPoint, RnPoint,   where for the second type, the data is embeded (point wise) in mathbb R^2.\n\n\n\n","category":"function"},{"location":"helpers/data/#Manopt.artificialS2Lemniscate","page":"Data","title":"Manopt.artificialS2Lemniscate","text":"artificialS2Lemniscate(p [,pts=128,a=π/2,interval=[0,2π])\n\ngenerate a Signal on the Sphere(2) mathbb S^2 by creating the Lemniscate of Bernoulli in the tangent space of p sampled at pts points and use exp to get a signal on the Sphere(2). \n\nInput\n\np – the tangent space the Lemniscate is created in\npts – (128) number of points to sample the Lemniscate\na – (π/2) defines a half axis of the Lemniscate to cover a  half sphere.\ninterval – ([0,2*π]) range to sample the lemniscate at, the default value refers to one closed curve\n\n\n\nartificialS2Lemniscate(p,t; a=π/2)\n\ngenerate a point from the signal on the Sphere(2) mathbb S^2 by creating the Lemniscate of Bernoulli in the tangent space of p sampled at t and use èxpto obtain a point on the [Sphere](@ref)(2)`. \n\nInput\n\np – the tangent space the Lemniscate is created in\nt – value to sample the Lemniscate at\n\nOptional Values\n\na – (π/2) defines a half axis of the Lemniscate to cover a half sphere.\n\n\n\n","category":"function"},{"location":"helpers/data/#Manopt.artificialS2WhirlPatch","page":"Data","title":"Manopt.artificialS2WhirlPatch","text":"artificialS2WhirlPatch([pts=5])\n\ncreate a whirl within the ptstimespts patch of Sphere(2)-valued image data.\n\nOptional Parameters\n\npts – (5) size of the patch. If the number is odd, the center is the north pole.\n\n\n\n","category":"function"},{"location":"helpers/data/#Manopt.artificialS2WhirlImage","page":"Data","title":"Manopt.artificialS2WhirlImage","text":"artificialS2WhirlImage([pts=64])\n\ngenerate an artificial image of data on the 2 sphere,\n\nArguments\n\npts – (64) size of the image in ptstimespts pixel.\n\n\n\n","category":"function"},{"location":"helpers/data/#Manopt.artificialS2RotationsImage","page":"Data","title":"Manopt.artificialS2RotationsImage","text":"artificialS2Rot([pts=64, rotations=(.5,.5)])\n\ncreates an image with a rotation on each axis as a parametrization.\n\nOptional Parameters\n\npts – (64) number of pixels along one dimension\nrotations – ((.5,.5)) number of total rotations performed on the axes.\n\n\n\n","category":"function"},{"location":"helpers/data/#Manopt.artificialSPDImage","page":"Data","title":"Manopt.artificialSPDImage","text":"artificialSPDImage([pts=64, stepsize=1.5])\n\ncreate an artificial image of symmetric positive definite matrices of size ptstimespts pixel with a jump of size stepsize.\n\n\n\n","category":"function"},{"location":"helpers/data/#Manopt.artificialSPDImage2","page":"Data","title":"Manopt.artificialSPDImage2","text":"artificialSPDImage2([pts=64, fraction=.66])\n\ncreate an artificial image of symmetric positive definite matrices of size ptstimespts pixel with right hand side fraction is moved upwards.\n\n\n\n","category":"function"},{"location":"helpers/errorMeasures/#ErrorMeasures-1","page":"Error Measures","title":"Error Measures","text":"","category":"section"},{"location":"helpers/errorMeasures/#","page":"Error Measures","title":"Error Measures","text":"meanSquaredError\nmeanAverageError","category":"page"},{"location":"helpers/errorMeasures/#Manopt.meanSquaredError","page":"Error Measures","title":"Manopt.meanSquaredError","text":"meanSquaredError(M,x,y)\n\nComputes the (mean) squared error between the two MPoints x and y on the (Power) manifold M.\n\n\n\n","category":"function"},{"location":"helpers/errorMeasures/#Manopt.meanAverageError","page":"Error Measures","title":"Manopt.meanAverageError","text":"meanSquaredError(M,x,y)\n\nComputes the (mean) squared error between the two MPoints x and y on the (Power) manifold M.\n\n\n\n","category":"function"},{"location":"helpers/exports/#Exports-1","page":"Exports","title":"Exports","text":"","category":"section"},{"location":"helpers/exports/#","page":"Exports","title":"Exports","text":"Exports aim to provide a consistent generation of images of your results. For example if you record the trace your algorithm walks on the Sphere(2), you yan easily export this trace to a rendered image using asyExportS2Signals and render the result with Asymptote. Despite these, you can always record values during your iterations, and export these, for example to csv. ","category":"page"},{"location":"helpers/exports/#Asymptote-1","page":"Exports","title":"Asymptote","text":"","category":"section"},{"location":"helpers/exports/#","page":"Exports","title":"Exports","text":"The following functions provide exports both in graphics and/or raw data using Asymptote.","category":"page"},{"location":"helpers/exports/#","page":"Exports","title":"Exports","text":"renderAsymptote","category":"page"},{"location":"helpers/exports/#Manopt.renderAsymptote","page":"Exports","title":"Manopt.renderAsymptote","text":"renderAsymptote(filename, exportFct=missing; render=4, format=\"png\", ...)\n\nrender an exported asy. The export function can be provided but might also be infered by the optional arguments, i.e. type of data (or curves, points and tVectors) provided.\n\nInput\n\nfilename – filename of the exported asy and rendered image\nexportFct: (missing) a function creating an asy file with kwargs as optional arguments and the filename string as its only mandatory argument. If this function is not given, we infere it from kwargs, i.e. data indicates that asyExportXData is used. points, curves or tVectors indicate, that asyExportS2Signals is infered.\n\nKeyword Arguments\n\nthe default values are given in brackets\n\nrender – (4) render level of asymptote, i.e. its -render option\nformat – (\"png\") final rendered format, i.e. asymptote's -f option\n\nall further keyword arguments are passed down to the exportFct call.\n\nSee also\n\nasyExportS2Signals\n\n\n\n\n\n","category":"function"},{"location":"helpers/exports/#Exports-for-specific-Manifolds-1","page":"Exports","title":"Exports for specific Manifolds","text":"","category":"section"},{"location":"helpers/exports/#","page":"Exports","title":"Exports","text":"asyExportS2Signals\nasyExportS2Data\nasyExportSPDData","category":"page"},{"location":"helpers/exports/#Manopt.asyExportS2Signals","page":"Exports","title":"Manopt.asyExportS2Signals","text":"asyExportS2Signals(filename; points, curves, tVectors, colors, options...)\n\nExport given points, curves, and tVectors on the sphere mathbb S^2 to Asymptote.\n\nInput\n\nfilename – a file to store the Asymptote code in.\n\nOptional Arguments (Data)\n\ncolors - dictionary of color arrays (indexed by symbols :points, :curves and :tvector) where each entry has to provide as least as many colors as the length of the corresponding sets.\ncurves – an Array of Arrays of SnPoints where each inner array is interpreted as a curve and is accompanied by an entry within colors\npoints – an Array of Arrays of SnPoints where each inner array is itnerpreted as a set of points and is accompanied by an entry within colors\ntVectors – an Array of Arrays of extended SnTVectors (TVectorE{SnTVector}) where each set of vectors is accompanied by an entry from within colors\n\nOptional Arguments (Asymptote)\n\narrowHeadSize - (6.0) size of the arrowheads of the tangent vectors\ncameraPosition - ((1., 1., 0.)) position of the camera in the Asymptote szene\nlineWidth – (1.0) size of the lines used to draw the curves.\nlineWidths – overrides the previous value to specify a value per curve and tVector set.\ndotSize – (1.0) size of the dots used to draw the points.\ndotSizes – overrides the previous value to specify a value per point set.\nsphereColor – (RGBA{Float64}(0.85, 0.85, 0.85, 0.6)) color of the sphere the data is drawn on\nsphereLineColor –  (RGBA{Float64}(0.75, 0.75, 0.75, 0.6)) color of the lines on the sphere\nsphereLineWidth – (0.5) line width of the lines on the sphere\ntarget – ((0.,0.,0.)) position the camera points at\n\n\n\n","category":"function"},{"location":"helpers/exports/#Manopt.asyExportS2Data","page":"Exports","title":"Manopt.asyExportS2Data","text":"asyExportS2Data(filename)\n\nExport given data as a point on a Power{SnPoint} manifold, i.e. one-, two- or three-dimensional data with points on the Sphere(2) mathbb S^2.\n\nInput\n\nfilename – a file to store the Asymptote code in.\n\nOptional Arguments (Data)\n\ndata – a PowPoint representing the 1-,2-, or 3-D array of SnPoints\nelevationColorScheme - A ColorScheme for elevation\nscaleAxes - ((1/3,1/3,1/3)) move spheres closer to each other by a factor per direction\n\nOptional Arguments (Asymptote)\n\narrowHeadSize - (1.8) size of the arrowheads of the vectors (in mm)\ncameraPosition - position of the camrea (default: centered above xy-plane) szene\ntarget - position the camera points at (default: center of xy-plane within data).\n\n\n\n","category":"function"},{"location":"helpers/exports/#Manopt.asyExportSPDData","page":"Exports","title":"Manopt.asyExportSPDData","text":"asyExportSPDData(filename)\n\nexport given data as a point on a Power{SPDPoint} manifold, i.e. one-, two- or three-dimensional data with points on the manifold of symmetric positive definite matrices.\n\nInput\n\nfilename – a file to store the Asymptote code in.\n\nOptional Arguments (Data)\n\ndata – a PowPoint representing the 1-,2-, or 3-D array of SPDPoints\ncolorScheme - A ColorScheme for Geometric Anisotropy Index\nscaleAxes - ((1/3,1/3,1/3)) move symmetric positive definite matrices closer to each other by a factor per direction compared to the distance esimated by the maximal eigenvalue of all involved SPD points\n\nOptional Arguments (Asymptote)\n\ncameraPosition - position of the camrea (default: centered above xy-plane) szene.\ntarget - position the camera points at (default: center of xy-plane within data).\n\nBoth values cameraPosition and target are scaled by scaledAxes*EW, where EW is the maximal eigenvalue in the data.\n\n\n\n","category":"function"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"EditURL = \"https://github.com/kellertuer/Manopt.jl/blob/master/src/tutorials/MeanAndMedian.jl\"","category":"page"},{"location":"tutorials/MeanAndMedian/#Optimize-1","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"","category":"section"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"This example illustrates how to set up and solve optimization problems and how to further get data from the algorithm using DebugOptions and RecordOptions","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"To start from the quite general case: A Solver is an algorithm that aims to solve","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"operatorname*argmin_xinmathcal M f(x)","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"where mathcal M is a Manifold and fcolonmathcal M to mathbb R is the cost function.","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"In Manopt.jl a Solver is an algorithm that requires a Problem p and Options o. While former contains static data, most prominently the manifold mathcal M (usually as p.M) and the cost function f (usually as p.costFunction), the latter contains dynamic data, i.e. things that usually change during the algorithm, are allowed to change, or specify the details of the algorithm to use. Together they form a plan. A plan uniquely determines the algorithm to use and provide all necessary information to run the algorithm.","category":"page"},{"location":"tutorials/MeanAndMedian/#Example-1","page":"Getting Started: Optimize!","title":"Example","text":"","category":"section"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"A gradient plan consists of a GradientProblem with the fields M, cost function f as well as gradient storing the gradient function corresponding to f. Accessing both functions can be done directly but should be encapsulated using getCost(p,x) and getGradient(p,x), where in both cases x is an MPoint on the Manifold M. Second, the GradientDescentOptions specify that the algorithm to solve the GradientProblem will be the gradient descent algorithm. It requires an initial value o.x0, a StoppingCriterion o.stop, a Stepsize o.stepsize and a retraction o.retraction and it internally stores the last evaluation of the gradient at o.∇ for convenience. The only mandatory parameter is the initial value x0, though the defaults for both the stopping criterion (stopAfterIteration(100)) as well as the stepsize (ConstantStepsize(1.) are quite conservative, but are chosen to be as simple as possible.","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"With these two at hand, running the algorithm just requires to call xOpt = solve(p,o).","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"In the following two examples we will see, how to use a higher level interface that allows to more easily activate for example a debug output or record values during the iterations","category":"page"},{"location":"tutorials/MeanAndMedian/#The-given-Dataset-1","page":"Getting Started: Optimize!","title":"The given Dataset","text":"","category":"section"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"using Manopt\nusing Random, Colors","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"For a persistent random set we use","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"n = 100\nσ = π/8\nM = Sphere(2)\nx = SnPoint(1/sqrt(2)*[1., 0., 1.])\nRandom.seed!(42)\ndata = addNoise.(Ref(M), repeat([x],n),Ref(σ))\nnothing #hide","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"and we define some colors from Paul Tol","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"black = RGBA{Float64}(colorant\"#000000\")\nTolVibrantOrange = RGBA{Float64}(colorant\"#EE7733\")\nTolVibrantBlue = RGBA{Float64}(colorant\"#0077BB\")\nTolVibrantTeal = RGBA{Float64}(colorant\"#009988\")\nTolVibrantMagenta = RGBA{Float64}(colorant\"#EE3377\")\nnothing #hide","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"Then our data looks like","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"asyResolution = 2\nnothing #hide","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"renderAsymptote(\"startDataAndCenter.asy\",asyExportS2Signals;\n    render = asyResolution,\n    points = [ [x], data],\n    colors=Dict(:points => [TolVibrantBlue, TolVibrantTeal]),\n    dotSize = 3.5, cameraPosition = (1.,.5,.5)\n)","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"(Image: The data of noisy versions of $x$)","category":"page"},{"location":"tutorials/MeanAndMedian/#Computing-the-Mean-1","page":"Getting Started: Optimize!","title":"Computing the Mean","text":"","category":"section"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"To compute the mean on the manifold we use the characterization, that the Euclidean mean minimizes the sum of squared distances, and end up with the following cost function. Its minimizer is called Riemannian Center of Mass.","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"F = y -> sum(1/(2*n) * distance.(Ref(M),Ref(y),data).^2)\n∇F = y -> sum(1/n*gradDistance.(Ref(M),data,Ref(y)))\nnothing #hide","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"note that the gradDistance defaults to the case p=2, i.e. the gradient of the squared distance. For details on convergence of the gradient descent for this problem, see [Afsari, Tron, Vidal, 2013]","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"The easiest way to call the gradient descent is now to call steepestDescent","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"xMean = steepestDescent(M,F,∇F,data[1])\nnothing; #hide\nnothing #hide","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"but in order to get more details, we further add the debug= options, which act as a decorator pattern using the DebugOptions and DebugActions. The latter store values if that's necessary, for example for the DebugChange that prints the change during the last iteration. The following debug prints","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"# i | x: | Last Change: | F(x):`","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"as well as the reason why the algorithm stopped at the end. Here, the format shorthand and the [DebugFactory] are used, which returns a DebugGroup of DebugAction performed each iteration and the stop, respectively.","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"xMean = steepestDescent(M,F,∇F,data[1];\n   debug = [:Iteration,\" | \", :x, \" | \", :Change, \" | \", :Cost, \"\\n\", :Stop]\n)\nnothing #hide","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"renderAsymptote(\"startDataCenterMean.asy\",asyExportS2Signals;\n    render = asyResolution,\n    points = [ [x], data, [xMean] ],\n    colors=Dict(:points => [TolVibrantBlue, TolVibrantTeal, TolVibrantOrange]),\n    dotSize = 3.5, cameraPosition = (1.,.5,.5)\n)","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"(Image: The resulting mean (orange))","category":"page"},{"location":"tutorials/MeanAndMedian/#Computing-the-Median-1","page":"Getting Started: Optimize!","title":"Computing the Median","text":"","category":"section"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"Similar to the mean you can also define the median as the minimizer of the distances, see for example [Bačák, 2014], but since this problem is not differentiable, we employ the Cyclic Proximal Point (CPP) algorithm, described in the same reference. We define","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"F2 = y -> sum( 1/(2*n) * distance.(Ref(M),Ref(y),data))\nproxes = Function[ (λ,y) -> proxDistance(M,λ/n,di,y,1) for di in data ]\nnothing #hide","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"where the Function is a helper for global scope to infer the correct type.","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"We then call the cyclicProximalPoint as","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"o = cyclicProximalPoint(M,F2,proxes,data[1];\n    debug = [:Iteration,\" | \", :x, \" | \", :Change, \" | \", :Cost, \"\\n\", 50, :Stop],\n    record = [:Iteration, :Change, :Cost],\n    returnOptions = true\n)\nxMedian = getSolverResult(o)\nvalues = getRecord(o)\nnothing # hide","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"where the differences to steepestDescent are as follows","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"the third parameter is now an Array of proximal maps\ndebug is reduces to only every 50th iteration\nwe further activated a RecordAction using the record= optional parameter. These work very similar to those in debug, but they collect their data in an array. The high level interface then returns two variables; the values do contain an array of recorded datum per iteration. Here a Tuple containing the iteration, last change and cost respectively; see RecordGroup, RecordIteration, RecordChange, RecordCost as well as the RecordFactory for details. The values contains hence a tuple per iteration, that itself consists of (by order of specification) the iteration number, the last change and the cost function value.","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"These recorded entries read","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"values","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"The resulting median and mean for the data hence are","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"renderAsymptote(\"startDataCenterMean.asy\",asyExportS2Signals;\n    render = asyResolution,\n    points = [ [x], data, [xMean], [xMedian] ],\n    colors=Dict(:points => [TolVibrantBlue, TolVibrantTeal, TolVibrantOrange, TolVibrantMagenta]),\n    dotSize = 3.5, cameraPosition = (1.,.5,.5)\n)","category":"page"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"(Image: The resulting mean (orange) and median (magenta))","category":"page"},{"location":"tutorials/MeanAndMedian/#Literature-1","page":"Getting Started: Optimize!","title":"Literature","text":"","category":"section"},{"location":"tutorials/MeanAndMedian/#","page":"Getting Started: Optimize!","title":"Getting Started: Optimize!","text":"<ul>\n<li id=\"Bačák2014\">[<a>Bačák, 2014</a>]\n  Bačák, M: <emph>Computing Medians and Means in Hadamard Spaces.</emph>,\n  SIAM Journal on Optimization, Volume 24, Number 3, pp. 1542–1566,\n  doi: <a href=\"https://doi.org/10.1137/140953393\">10.1137/140953393</a>,\n  arxiv: <a href=\"https://arxiv.org/abs/1210.2145\">1210.2145</a>.</li>\n  <li id=\"AfsariTronVidal2013\">[<a>Afsari, Tron, Vidal, 2013</a>]\n   Afsari, B; Tron, R.; Vidal, R.: <emph>On the Convergence of Gradient\n   Descent for Finding the Riemannian Center of Mass</emph>,\n   SIAM Journal on Control and Optimization, Volume 51, Issue 3,\n   pp. 2230–2260.\n   doi: <a href=\"https://doi.org/10.1137/12086282X\">10.1137/12086282X</a>,\n   arxiv: <a href=\"https://arxiv.org/abs/1201.0925\">1201.0925</a></li>\n</ul>","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"EditURL = \"https://github.com/kellertuer/Manopt.jl/blob/master/src/tutorials/GradientOfSecondOrderDifference.jl\"","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#secondOrderDifferenceGrad-1","page":"Gradient of d_2","title":"Illustration of the Gradient of a Second Order Difference","text":"","category":"section"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"This example explains how to compute the gradient of the second order difference mid point model using adjointJacobiFields.","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"This example also illustrates the Power manifold as well as ArmijoLinesearch.","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"We first initialize the manifold","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"using Manopt","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"and we define some colors from Paul Tol","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"using Colors\nblack = RGBA{Float64}(colorant\"#000000\")\nTolVibrantBlue = RGBA{Float64}(colorant\"#0077BB\") # points\nTolVibrantOrange = RGBA{Float64}(colorant\"#EE7733\") # results\nTolVibrantCyan = RGBA{Float64}(colorant\"#33BBEE\") # vectors\nTolVibrantTeal = RGBA{Float64}(colorant\"#009988\") # geo\nasyResolution = 2\nnothing #hide","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"Assume we have two SnPoints xy on the equator of the Sphere(2) mathcal M = mathbb S^2 and a point y near the north pole","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"M = Sphere(2)\nx = SnPoint([1., 0., 0.])\nz = SnPoint([0., 1., 0.])\nc = midPoint(M,x,z)\ny = geodesic(M, SnPoint([0., 0., 1.]), c, 0.1)\n[c,y]","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"Now the second order absolute difference can be stated as (see [Bačák, Bergmann, Steidl, Weinmann, 2016])","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"d_2(xyz) = min_cinmathcal C_xz d_mathcal M(cy)qquad xyzinmathcal M","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"where mathcal C_xz is the set of all mid points g(frac12xz), where g is a (not necessarily minimizing) geodesic connecting x and z.","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"For illustration we further define the point opposite of","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"c2 = opposite(M,c)","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"and draw the geodesic connecting y and the nearest mid point c, namely","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"T = [0:0.1:1.0...]\ngeoPts_yc = geodesic(M,y,c,T)\nnothing #hide","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"looks as follows using renderAsymptote with the asyExportS2Signals export","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"renderAsymptote(\"secondOrderData.asy\",asyExportS2Signals;\n    render = asyResolution,\n    curves = [ geoPts_yc ],\n    points = [ [x,y,z], [c,c2] ],\n    colors=Dict(:curves => [TolVibrantTeal], :points => [black, TolVibrantBlue]),\n    dotSize = 3.5, lineWidth = 0.75, cameraPosition = (1.2,1.,.5)\n)","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"(Image: Three points $x,y,z$ and the midpoint $c=c(x,z)$ (blue))","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"Since we moved y 10% along the geodesic from the north pole to c, the distance to c is frac9pi20approx 14137, and this is also what","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"costTV2(M, (x,y,z) )","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"returns, see costTV2 for reference. But also its gradient can be easily computed since it is just a distance with respect to y and a concatenation of a geodesic, where the start or end point is the argument, respectively, with a distance. Hence the adjoint differentials AdjDxGeo and AdjDyGeo can be employed, see gradTV2 for details. we obtain","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"(ξx, ξy, ξz) = gradTV2(M, (x,y,z) )","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"When we aim to minimize this, we look at the negative gradient, i.e. we can draw this as","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"renderAsymptote(\"SecondOrderGradient.asy\",asyExportS2Signals;\n   render = asyResolution,\n   points = [ [x,y,z], [c,c2] ],\n   tVectors = [TVectorE.( [-ξx, -ξy, -ξz], [x, y, z] )],\n   colors=Dict(:tvectors => [TolVibrantCyan], :points => [black, TolVibrantBlue]),\n   dotSize = 3.5, lineWidth = 0.75, cameraPosition = (1.2,1.,.5)\n)","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"(Image: Three points $x,y,z$ and the negative gradient of the second order absolute difference)","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"If we now perform a gradient step, we obtain the three points","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"xn, yn, zn = exp.(Ref(M), [x,y,z], [-ξx,-ξy,-ξz])","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"as well we the new mid point","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"cn = midPoint(M,xn,zn)\ngeoPts_yncn = geodesic(M,yn,cn,T)\nnothing #hide","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"and obtain the new situation","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"renderAsymptote(\"SecondOrderMin1.asy\",asyExportS2Signals;\n    render = asyResolution,\n    points = [ [x,y,z], [c,c2,cn], [xn,yn,zn] ],\n    curves = [ geoPts_yncn ] ,\n    tVectors = [TVectorE.( [-ξx, -ξy, -ξz], [x, y, z] )],\n    colors=Dict(:tvectors => [TolVibrantCyan],\n        :points => [black, TolVibrantBlue, TolVibrantOrange],\n        :curves => [TolVibrantTeal]\n    ),\n    dotSize = 3.5, lineWidth = 0.75, cameraPosition = (1.2,1.,.5)\n)","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"(Image: A gradient Step)","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"One can see, that this step slightly “overshoots”, i.e. y is now even below c. and the cost function is still at","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"costTV2(M, (xn, yn, zn) )","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"But we can also search for the best step size using ArmijoLinesearch on the Power manifold mathcal N = mathcal M^3 = (mathbb S^2)^3","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"p = PowPoint([x,y,z])\nN = Power(M,3)\ns = ArmijoLinesearch(1.0,exp,0.999,0.96)(N, p,\n    x -> costTV2(M, Tuple(getValue(x))),\n    PowTVector( [ gradTV2(M, (x,y,z))... ] ) # transform from tuple to PowTVector\n)","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"and for the new points","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"xm, ym, zm = exp.(Ref(M), [x,y,z], s*[-ξx,-ξy,-ξz])\ncm = midPoint(M,xm,zm)\ngeoPts_xmzm = geodesic(M,xm,zm,T)\nnothing #hide","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"we obtain again with","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"renderAsymptote(\"SecondOrderMin2.asy\",asyExportS2Signals;\n    render = asyResolution,\n    points = [ [x,y,z], [c,c2,cm], [xm,ym,zm] ],\n    curves = [ geoPts_xmzm ] ,\n    tVectors = [TVectorE.( [-ξx, -ξy, -ξz], [x, y, z] )],\n    colors=Dict(:tvectors => [TolVibrantCyan],\n                :points => [black, TolVibrantBlue, TolVibrantOrange],\n                :curves => [TolVibrantTeal]\n                ),\n    dotSize = 3.5, lineWidth = 0.75, cameraPosition = (1.2,1.,.5)\n)","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"(Image: A gradient Step)","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"Here, the cost function yields","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"costTV2( M, (xm, ym, zm) )","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"which is nearly zero, as one can also see, since the new center c and y are quite close.","category":"page"},{"location":"tutorials/GradientOfSecondOrderDifference/#Literature-1","page":"Gradient of d_2","title":"Literature","text":"","category":"section"},{"location":"tutorials/GradientOfSecondOrderDifference/#","page":"Gradient of d_2","title":"Gradient of d_2","text":"<ul>\n<li id=\"BačákBergmannSteidlWeinmann2016\">[<a>Bačák, Bergmann, Steidl, Weinmann, 2016</a>]\n  Bačák, M; Bergmann, R.; Steidl, G; Weinmann, A.: <emph>A second order nonsmooth\n  variational model for restoring manifold-valued images.</emph>,\n  SIAM Journal on Scientific Computations, Volume 38, Number 1, pp. A567–597,\n  doi: <a href=\"https://doi.org/10.1137/15M101988X\">10.1137/15M101988X</a></li>\n</ul>","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"EditURL = \"https://github.com/kellertuer/Manopt.jl/blob/master/src/tutorials/JacobiFields.jl\"","category":"page"},{"location":"tutorials/JacobiFields/#Illustration-of-Jacobi-Fields-1","page":"Jacobi Fields","title":"Illustration of Jacobi Fields","text":"","category":"section"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"This tutorial illustrates the usage of Jacobi Fields within Manopt.jl. For this tutorial you should be familiar with the basic terminology on a manifold like the exponential and logarithmic map as well as geodesics.","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"We first initialize the manifold","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"using Manopt","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"and we define some colors from Paul Tol","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"using Colors\nblack = RGBA{Float64}(colorant\"#000000\")\nTolVibrantOrange = RGBA{Float64}(colorant\"#EE7733\")\nTolVibrantCyan = RGBA{Float64}(colorant\"#33BBEE\")\nTolVibrantTeal = RGBA{Float64}(colorant\"#009988\")\nnothing #hide","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"Assume we have two SnPoints on the equator of the Sphere(2) mathcal M = mathbb S^2","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"M = Sphere(2)\nx,y = [ SnPoint([1.,0.,0.]), SnPoint([0.,1.,0.])]","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"their connecting geodesic (sampled at 100 points)","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"geodesicCurve = geodesic(M,x,y,100);\nasyResolution = 2\nnothing #hide","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"looks as follows using renderAsymptote with the asyExportS2Signals export","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"renderAsymptote(\"jacobiGeodesic.asy\",asyExportS2Signals;\n    render = asyResolution,\n    curves=[geodesicCurve], points = [ [x,y] ],\n    colors=Dict(:curves => [black], :points => [TolVibrantOrange]),\n    dotSize = 3.5, lineWidth = 0.75, cameraPosition = (1.,1.,.5)\n)","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"(Image: A geodesic connecting two points on the equator)","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"where x is on the left. Then this tutorial solves the following task:","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"Given a direction xi_xin T_xmathcal M, for example the SnTVector","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"ξx = SnTVector([0.,0.4,0.5])","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"we move the start point x into, how does any point on the geodesic move?","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"Or mathematically: Compute D_x g(t xy) for some fixed tin01 and a given direction xi_x. Of course two cases are quite easy: For t=0 we are in x and how x “moves” is already known, so D_x g(0xy) = xi. On the other side, for t=1, g(1 xy) = y which is fixed, so D_x g(1 xy) is the zero tangent vector (in T_ymathcal M).","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"For all other cases we employ a jacobiField, which is a (tangent) vector field along the geodesic given as follows: The geodesic variation Gamma_gxi(st) is defined for some varepsilon  0 as","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"Gamma_gxi(st)=expgamma_xxi(s)tlog_g(sxxi)yqquad sin(-varepsilonvarepsilon) tin01","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"Intuitively we make a small step s into direction xi using the geodesic g(cdot xxi) and from z=g(s xxi) we follow (in t) the geodesic g(cdot zy). The corresponding Jacobi field~(J_{g,\\xi}) along~(g(\\cdot; x,y) is given","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"J_gxi(t)=fracDpartial sGamma_gxi(st)Biglrvert_s=0","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"which is an ODE and we know the boundary conditions J_gxi(0)=xi and J_gxi(t) = 0. In symmetric spaces we can compute the solution, since the system of ODEs decouples, see for example do Carmo, Chapter 4.2. Within Manopt.jl this is implemented as jacobiField(M,x,y,t,ξ[,β]), where the optional parameter (function) β specifies, which Jacobi field we want to evaluate and the one used here is the default.","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"We can hence evaluate that on the points on the geodesic at","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"T = [0:0.1:1.0...]\nnothing #hide","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"namely","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"Z = geodesic(M,x,y,T)\nnothing #hide","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"the geodesic moves as","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"ηx = jacobiField.(Ref(M), Ref(x), Ref(y), T, Ref(ξx) )","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"which can also be called using DxGeo. We can add to the image above by creating extended tangent vectors TVectorE the include their base points","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"Vx = TVectorE.(ηx,Z)","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"and add that as one further set to the Asymptote export.","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"renderAsymptote(\"jacobiGeodesicDxGeo.asy\",asyExportS2Signals;\n    render = asyResolution,\n    curves=[geodesicCurve], points = [ [x,y], Z], tVectors = [Vx],\n    colors=Dict(\n        :curves => [black],\n        :points => [TolVibrantOrange,TolVibrantCyan],\n        :tvectors => [TolVibrantCyan]\n    ),\n    dotSizes = [3.5,2.], lineWidth = 0.75, cameraPosition = (1.,1.,.5)\n)","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"(Image: A Jacobi field for $D_xg(t,x,y)[\\eta]$)","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"If we further move the end point, too, we can derive that Differential in direction","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"ξy = SnTVector([0.2,0.,-0.5])\nηy = DyGeo.(Ref(M),Ref(x),Ref(y),T,Ref(ξy))\nVy = TVectorE.(ηy,Z)","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"and we can look at the total effect, where the TVectorEs even verify that only tangent vectors are added that have a common base point","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"Vb = Vx .+ Vy","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"renderAsymptote(\"jacobiGeodesicResult.asy\",asyExportS2Signals;\n   render = asyResolution,\n   curves=[geodesicCurve], points = [ [x,y], Z], tVectors = [Vx,Vy,Vb],\n   colors=Dict(\n       :curves => [black],\n       :points => [TolVibrantOrange,TolVibrantCyan],\n       :tvectors => [TolVibrantCyan,TolVibrantCyan,TolVibrantTeal]\n  ),\n  dotSizes = [3.5,2.], lineWidth = 0.75, cameraPosition = (1.,1.,0.)\n)","category":"page"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"(Image: A Jacobi field for the effect of two differentials (blue) in sum (teal))","category":"page"},{"location":"tutorials/JacobiFields/#Literature-1","page":"Jacobi Fields","title":"Literature","text":"","category":"section"},{"location":"tutorials/JacobiFields/#","page":"Jacobi Fields","title":"Jacobi Fields","text":"<ul><li id=\"doCarmo1992\">[<a>doCarmo1992</a>] do Carmo, M. P.:\n   <emph>Riemannian Geometry</emph>, Mathematics: Theory & Applications,\n   Birkhäuser Basel, 1992, ISBN: 0-8176-3490-8</li>\n<li id=\"BergmannGousenbourger2018\">[<a>BergmannGousenbourger2018</a>]\n  Bergmann, R.; Gousenbourger, P.-Y.: <emph>A variational model for data\n  fitting on manifolds by minimizing the acceleration of a Bézier curve</emph>,\n  Frontiers in Applied Mathematics and Statistics, 2018.\n  doi: <a href=\"https://dx.doi.org/10.3389/fams.2018.00059\">10.3389/fams.2018.00059</a></li>\n</ul>","category":"page"},{"location":"list/#Table-of-Contents,-Types-and-Functions-1","page":"Function Index","title":"Table of Contents, Types and Functions","text":"","category":"section"},{"location":"list/#","page":"Function Index","title":"Function Index","text":"This page lists all pages of this documentations, all available types and functions.","category":"page"},{"location":"list/#Complete-List-of-Contents-1","page":"Function Index","title":"Complete List of Contents","text":"","category":"section"},{"location":"list/#","page":"Function Index","title":"Function Index","text":"Depth = 3","category":"page"},{"location":"list/#Available-Types-1","page":"Function Index","title":"Available Types","text":"","category":"section"},{"location":"list/#","page":"Function Index","title":"Function Index","text":"Modules = [Manopt]\nOrder   = [:type]","category":"page"},{"location":"list/#Manifold-Functions-1","page":"Function Index","title":"Manifold Functions","text":"","category":"section"},{"location":"list/#","page":"Function Index","title":"Function Index","text":"Modules = [Manopt]\nPages = [\"manifolds/index.md\"]\nOrder   = [:function]","category":"page"},{"location":"list/#Solver-Functions-1","page":"Function Index","title":"Solver Functions","text":"","category":"section"},{"location":"list/#","page":"Function Index","title":"Function Index","text":"Modules = [Manopt]\nPages = [\"plans/index.md\", \"solvers/index.md\"]","category":"page"},{"location":"list/#Functions-1","page":"Function Index","title":"Functions","text":"","category":"section"},{"location":"list/#","page":"Function Index","title":"Function Index","text":"Modules = [Manopt]\nPages = [\"functions/adjointDifferentials.md\", \"functions/costFunctions.md\", \"functions/differentials.md\", \"functions/gradients.md\", \"functions/jacobiFields.md\", \"functions/proximalMaps.md\"]","category":"page"}]
}
