<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimize on your own manifold · Manopt.jl</title><meta name="title" content="Optimize on your own manifold · Manopt.jl"/><meta property="og:title" content="Optimize on your own manifold · Manopt.jl"/><meta property="twitter:title" content="Optimize on your own manifold · Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../Optimize/">🏔️ Get started: optimize.</a></li><li><a class="tocitem" href="../InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../HowToRecord/">Record values</a></li><li><a class="tocitem" href="../ImplementASolver/">Implement a solver</a></li><li class="is-active"><a class="tocitem" href>Optimize on your own manifold</a><ul class="internal"><li><a class="tocitem" href="#An-example-problem"><span>An example problem</span></a></li><li><a class="tocitem" href="#Define-the-cost-and-gradient"><span>Define the cost and gradient</span></a></li><li><a class="tocitem" href="#Defining-the-necessary-functions-to-run-a-solver"><span>Defining the necessary functions to run a solver</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../ConstrainedOptimization/">Do constrained optimization</a></li><li><a class="tocitem" href="../GeodesicRegression/">Do geodesic regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">Introduction</a></li><li><a class="tocitem" href="../../solvers/adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/convex_bundle_method/">Convex bundle method</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas—Rachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg–Marquardt</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder–Mead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/proximal_bundle_method/">Proximal bundle method</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../../plans/problem/">Problem</a></li><li><a class="tocitem" href="../../plans/objective/">Objective</a></li><li><a class="tocitem" href="../../plans/state/">Solver State</a></li><li><a class="tocitem" href="../../plans/stepsize/">Stepsize</a></li><li><a class="tocitem" href="../../plans/stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../../plans/debug/">Debug Output</a></li><li><a class="tocitem" href="../../plans/record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to...</a></li><li class="is-active"><a href>Optimize on your own manifold</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimize on your own manifold</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/tutorials/ImplementOwnManifold.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimize-on-your-own-manifold"><a class="docs-heading-anchor" href="#Optimize-on-your-own-manifold">Optimize on your own manifold</a><a id="Optimize-on-your-own-manifold-1"></a><a class="docs-heading-anchor-permalink" href="#Optimize-on-your-own-manifold" title="Permalink"></a></h1><p>Ronny Bergmann</p><p>When you have used a few solvers from <a href="https://manoptjl.org/"><code>Manopt.jl</code></a> for example like in the opening tutorial <a href="https://manoptjl.org/stable/tutorials/Optimize!.html">🏔️ Get started: optimize!</a> and also familiarized yourself with how to work with manifolds in general at <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/tutorials/getstarted.html">🚀 Get Started with <code>Manifolds.jl</code></a>, you might come across the point that you want to <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/tutorials/implement-a-manifold/">implementing a manifold</a> yourself and use it within <a href="https://manoptjl.org/"><code>Manopt.jl</code></a>. A challenge might be, which functions are necessary, since the overall interface of <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/">ManifoldsBase.jl</a> is maybe not completely necessary.</p><p>This tutorial aims to help you through these steps to implement necessary parts of a manifold to get started with the <a href="../../solvers/">solver</a> you have in mind.</p><h2 id="An-example-problem"><a class="docs-heading-anchor" href="#An-example-problem">An example problem</a><a id="An-example-problem-1"></a><a class="docs-heading-anchor-permalink" href="#An-example-problem" title="Permalink"></a></h2><p>We get started by loading the packages we need.</p><pre><code class="language-julia hljs">using LinearAlgebra, Manifolds, ManifoldsBase, Random
using Manopt
Random.seed!(42)</code></pre><p>We also define the same manifold as in the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/tutorials/implement-a-manifold/">implementing a manifold</a> tutorial.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    ScaledSphere &lt;: AbstractManifold{ℝ}

Define a sphere of fixed radius

# Fields

* `dimension` dimension of the sphere
* `radius` the radius of the sphere

# Constructor

    ScaledSphere(dimension,radius)

Initialize the manifold to a certain `dimension` and `radius`,
which by default is set to `1.0`
&quot;&quot;&quot;
struct ScaledSphere &lt;: AbstractManifold{ℝ}
    dimension::Int
    radius::Float64
end</code></pre><p>We would like to compute a mean and/or median similar to <a href="https://manoptjl.org/stable/tutorials/Optimize!.html">🏔️ Get started: optimize!</a>. For given a set of points <span>$q_1,\ldots,q_n$</span> we want to compute [<a href="../../references/#Karcher:1977">Kar77</a>]</p><p class="math-container">\[  \operatorname*{arg\,min}_{p∈\mathcal M}
  \frac{1}{2n} \sum_{i=1}^n d_{\mathcal M}^2(p, q_i)\]</p><p>On the <code>ScaledSphere</code> we just defined above. We define a few parameters first</p><pre><code class="language-julia hljs">d = 5  # dimension of the sphere - embedded in R^{d+1}
r = 2.0 # radius of the sphere
N = 100 # data set size

M = ScaledSphere(d,r)</code></pre><pre><code class="nohighlight hljs">ScaledSphere(5, 2.0)</code></pre><p>If we generate a few points</p><pre><code class="language-julia hljs"># generate 100 points around the north pole
pts = [ [zeros(d)..., M.radius] .+ 0.5.*([rand(d)...,0.5] .- 0.5) for _=1:N]
# project them onto the r-sphere
pts = [ r/norm(p) .* p for p in pts]</code></pre><p>Then, before starting with optimization, we need the distance on the manifold, to define the cost function, as well as the logarithmic map to defined the gradient. For both, we here use the “lazy” approach of using the <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/sphere.html">Sphere</a> as a fallback. Finally, we have to provide information about how points and tangent vectors are stored on the manifold by implementing their <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.representation_size-Tuple%7BAbstractManifold%7D"><code>representation_size</code></a> function, which is often required when allocating memory. While we could</p><pre><code class="language-julia hljs">import ManifoldsBase: distance, log, representation_size
function distance(M::ScaledSphere, p, q)
    return M.radius * distance(Sphere(M.dimension), p ./ M.radius, q ./ M.radius)
end
function log(M::ScaledSphere, p, q)
    return M.radius * log(Sphere(M.dimension), p ./ M.radius, q ./ M.radius)
end
representation_size(M::ScaledSphere) = (M.dimension+1,)</code></pre><h2 id="Define-the-cost-and-gradient"><a class="docs-heading-anchor" href="#Define-the-cost-and-gradient">Define the cost and gradient</a><a id="Define-the-cost-and-gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-cost-and-gradient" title="Permalink"></a></h2><pre><code class="language-julia hljs">f(M, q) = sum(distance(M, q, p)^2 for p in pts)
grad_f(M,q) = sum( - log(M, q, p) for p in pts)</code></pre><h2 id="Defining-the-necessary-functions-to-run-a-solver"><a class="docs-heading-anchor" href="#Defining-the-necessary-functions-to-run-a-solver">Defining the necessary functions to run a solver</a><a id="Defining-the-necessary-functions-to-run-a-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-necessary-functions-to-run-a-solver" title="Permalink"></a></h2><p>The documentation usually lists the necessary functions in a section “Technical Details” close to the end of the documentation of a solver, for our case that is <a href="https://manoptjl.org/stable/solvers/gradient_descent.html#Technical-Details">The gradient descent’s Technical Details</a>,</p><p>They list all details, but we can start even step by step here if we are a bit careful.</p><h3 id="A-retraction"><a class="docs-heading-anchor" href="#A-retraction">A retraction</a><a id="A-retraction-1"></a><a class="docs-heading-anchor-permalink" href="#A-retraction" title="Permalink"></a></h3><p>We first implement a <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">retract</a>ion. Informally, given a current point and a direction to “walk into” we need a function that performs that walk. Since we take an easy one that just projects onto the sphere, we use the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.ProjectionRetraction"><code>ProjectionRetraction</code></a> type. To be precise, we have to implement the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/design/#inplace-and-noninplace">in-place variant</a> <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.inverse_retract_project%21-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%2C%20Any%7D"><code>retract_project!</code></a></p><pre><code class="language-julia hljs">import ManifoldsBase: retract_project!
function retract_project!(M::ScaledSphere, q, p, X, t::Number)
    q .= p .+ t .* X
    q .*= M.radius / norm(q)
    return q
end</code></pre><pre><code class="nohighlight hljs">retract_project! (generic function with 18 methods)</code></pre><p>The other two technical remarks refer to the step size and the stopping criterion, so if we set these to something simpler, we should already be able to do a first run.</p><p>We have to specify</p><ul><li>that we want to use the new retraction,</li><li>a simple step size and stopping criterion</li></ul><p>We start with a certain point of cost</p><pre><code class="language-julia hljs">p0 = [zeros(d)...,1.0]
f(M,p0)</code></pre><pre><code class="nohighlight hljs">444.60374551157634</code></pre><p>Then we can run our first solver, where we have to overwrite a few defaults, which would use functions we do not (yet) have. We will discuss these in the next steps.</p><pre><code class="language-julia hljs">q1 = gradient_descent(M, f, grad_f, p0;
    retraction_method = ProjectionRetraction(),   # state, that we use the retraction from above
    stepsize = DecreasingStepsize(M; length=1.0), # A simple step size
    stopping_criterion = StopAfterIteration(10),  # A simple stopping crtierion
    X = zeros(d+1),                               # how we define/represent tangent vectors
)
f(M,q1)</code></pre><pre><code class="nohighlight hljs">162.4000287847332</code></pre><p>We at least see, that the function value decreased.</p><h3 id="Norm-and-maximal-step-size."><a class="docs-heading-anchor" href="#Norm-and-maximal-step-size.">Norm and maximal step size.</a><a id="Norm-and-maximal-step-size.-1"></a><a class="docs-heading-anchor-permalink" href="#Norm-and-maximal-step-size." title="Permalink"></a></h3><p>To use more advanced stopping criteria and step sizes we first need an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.inner-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%2C%20Any%7D"><code>inner</code></a><code>(M, p, X)</code>. We also need a <a href="../../extensions/#Manopt.max_stepsize-Tuple{FiberBundle{𝔽, ManifoldsBase.TangentSpaceType, M} where {𝔽, M&lt;:AbstractManifold{𝔽}}, Any}"><code>max_stepsize</code></a><code>(M)</code>, to avoid having too large steps on positively curved manifolds like our scaled sphere in this example</p><pre><code class="language-julia hljs">import ManifoldsBase: inner
import Manopt: max_stepsize
inner(M::ScaledSphere, p, X,Y) = dot(X,Y) # inherited from the embedding
 # set the maximal allowed stepsize to injectivity radius.
Manopt.max_stepsize(M::ScaledSphere) = M.radius*π</code></pre><p>Then we can use the default step size (<a href="../../plans/stepsize/#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a>) and the default stopping criterion, which checks for a small gradient Norm</p><pre><code class="language-julia hljs">q2 = gradient_descent(M, f, grad_f, p0;
    retraction_method = ProjectionRetraction(), # as before
    X = zeros(d+1), # as before
)
f(M, q2)</code></pre><pre><code class="nohighlight hljs">9.772830131357024</code></pre><h3 id="Making-life-easier:-default-retraction-and-zero-vector"><a class="docs-heading-anchor" href="#Making-life-easier:-default-retraction-and-zero-vector">Making life easier: default retraction and zero vector</a><a id="Making-life-easier:-default-retraction-and-zero-vector-1"></a><a class="docs-heading-anchor-permalink" href="#Making-life-easier:-default-retraction-and-zero-vector" title="Permalink"></a></h3><p>To initialize tangent vector memory, the function <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M,p)</code> is called. Similarly, the most-used retraction is returned by <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a></p><p>We can use both here, to make subsequent calls to the solver less verbose. We define</p><pre><code class="language-julia hljs">import ManifoldsBase: zero_vector, default_retraction_method
zero_vector(M::ScaledSphere, p) = zeros(M.dimension+1)
default_retraction_method(M::ScaledSphere) = ProjectionRetraction()</code></pre><pre><code class="nohighlight hljs">default_retraction_method (generic function with 20 methods)</code></pre><p>and now we can even just call</p><pre><code class="language-julia hljs">q3 = gradient_descent(M, f, grad_f, p0)
f(M, q3)</code></pre><pre><code class="nohighlight hljs">9.772830131357024</code></pre><p>But we for example automatically also get the possibility to obtain debug information like</p><pre><code class="language-julia hljs">gradient_descent(M, f, grad_f, p0; debug = [:Iteration, :Cost, :Stepsize, 25, :GradientNorm, :Stop, &quot;\n&quot;]);</code></pre><pre><code class="nohighlight hljs">Initial f(x): 444.603746
# 25    f(x): 9.772836s:0.01851892669284175|grad f(p)|:0.027709997662907597
# 50    f(x): 9.772830s:0.01851892669284175|grad f(p)|:0.00035050862606229735
# 75    f(x): 9.772830s:0.01671333134028968|grad f(p)|:3.5186467891885363e-6
The algorithm reached approximately critical point after 81 iterations; the gradient norm (8.510619620990863e-9) is less than 1.0e-8.</code></pre><p>see <a href="https://manoptjl.org/stable/tutorials/HowToDebug.html">How to Print Debug Output</a> for more details.</p><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[Kar77]</dt><dd><div>H. Karcher. <em>Riemannian center of mass and mollifier smoothing</em>. <a href="https://doi.org/10.1002/cpa.3160300502">Communications on Pure and Applied Mathematics <strong>30</strong>, 509–541</a> (1977).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ImplementASolver/">« Implement a solver</a><a class="docs-footer-nextpage" href="../ConstrainedOptimization/">Do constrained optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Friday 15 March 2024 21:32">Friday 15 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
