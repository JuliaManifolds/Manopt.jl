<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Objective ¬∑ Manopt.jl</title><meta name="title" content="Objective ¬∑ Manopt.jl"/><meta property="og:title" content="Objective ¬∑ Manopt.jl"/><meta property="twitter:title" content="Objective ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/Optimize/">üèîÔ∏è Get started: optimize.</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../../tutorials/EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../../tutorials/HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../../tutorials/ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do constrained optimization</a></li><li><a class="tocitem" href="../../tutorials/GeodesicRegression/">Do geodesic regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">Introduction</a></li><li><a class="tocitem" href="../../solvers/adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../">Specify a Solver</a></li><li><a class="tocitem" href="../problem/">Problem</a></li><li class="is-active"><a class="tocitem" href>Objective</a><ul class="internal"><li><a class="tocitem" href="#Decorators-for-objectives"><span>Decorators for objectives</span></a></li><li><a class="tocitem" href="#Specific-Objective-typed-and-their-access-functions"><span>Specific Objective typed and their access functions</span></a></li></ul></li><li><a class="tocitem" href="../state/">Solver State</a></li><li><a class="tocitem" href="../stepsize/">Stepsize</a></li><li><a class="tocitem" href="../stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../debug/">Debug Output</a></li><li><a class="tocitem" href="../record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plans</a></li><li class="is-active"><a href>Objective</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Objective</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/plans/objective.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ObjectiveSection"><a class="docs-heading-anchor" href="#ObjectiveSection">A manifold objective</a><a id="ObjectiveSection-1"></a><a class="docs-heading-anchor-permalink" href="#ObjectiveSection" title="Permalink"></a></h1><p>The Objective describes that actual cost function and all its properties.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractManifoldObjective" href="#Manopt.AbstractManifoldObjective"><code>Manopt.AbstractManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldObjective{E&lt;:AbstractEvaluationType}</code></pre><p>Describe the collection of the optimization function `<code>f\colon \mathcal M ‚Üí \bbR</code> (or even a vectorial range) and its corresponding elements, which might for example be a gradient or (one or more) proximal maps.</p><p>All these elements should usually be implemented as functions <code>(M, p) -&gt; ...</code>, or <code>(M, X, p) -&gt; ...</code> that is</p><ul><li>the first argument of these functions should be the manifold <code>M</code> they are defined on</li><li>the argument <code>X</code> is present, if the computation is performed inplace of <code>X</code> (see <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>)</li><li>the argument <code>p</code> is the place the function (<span>$f$</span> or one of its elements) is evaluated <strong>at</strong>.</li></ul><p>the type <code>T</code> indicates the global <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/objective.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractDecoratedManifoldObjective" href="#Manopt.AbstractDecoratedManifoldObjective"><code>Manopt.AbstractDecoratedManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDecoratedManifoldObjective{E&lt;:AbstractEvaluationType,O&lt;:AbstractManifoldObjective}</code></pre><p>A common supertype for all decorators of <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a>s to simplify dispatch.     The second parameter should refer to the undecorated objective (i.e. the most inner one).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/objective.jl#L25-L30">source</a></section></article><p>Which has two main different possibilities for its containing functions concerning the evaluation mode, not necessarily the cost, but for example gradient in an <a href="#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractEvaluationType" href="#Manopt.AbstractEvaluationType"><code>Manopt.AbstractEvaluationType</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractEvaluationType</code></pre><p>An abstract type to specify the kind of evaluation a <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> supports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/objective.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AllocatingEvaluation" href="#Manopt.AllocatingEvaluation"><code>Manopt.AllocatingEvaluation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AllocatingEvaluation &lt;: AbstractEvaluationType</code></pre><p>A parameter for a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> indicating that the problem uses functions that allocate memory for their result, i.e. they work out of place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/objective.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InplaceEvaluation" href="#Manopt.InplaceEvaluation"><code>Manopt.InplaceEvaluation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InplaceEvaluation &lt;: AbstractEvaluationType</code></pre><p>A parameter for a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> indicating that the problem uses functions that do not allocate memory but work on their input, i.e. in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/objective.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.evaluation_type" href="#Manopt.evaluation_type"><code>Manopt.evaluation_type</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluation_type(mp::AbstractManoptProblem)</code></pre><p>Get the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> of the objective in <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>mp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/problem.jl#L32-L37">source</a></section><section><div><pre><code class="language-julia hljs">evaluation_type(::AbstractManifoldObjective{Teval})</code></pre><p>Get the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> of the objective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/problem.jl#L39-L43">source</a></section></article><h2 id="Decorators-for-objectives"><a class="docs-heading-anchor" href="#Decorators-for-objectives">Decorators for objectives</a><a id="Decorators-for-objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Decorators-for-objectives" title="Permalink"></a></h2><p>An objective can be decorated using the following trait and function to initialize</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.dispatch_objective_decorator" href="#Manopt.dispatch_objective_decorator"><code>Manopt.dispatch_objective_decorator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dispatch_objective_decorator(o::AbstractManoptSolverState)</code></pre><p>Indicate internally, whether an <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>o</code> to be of decorating type, i.e. it stores (encapsulates) an object in itself, by default in the field <code>o.objective</code>.</p><p>Decorators indicate this by returning <code>Val{true}</code> for further dispatch.</p><p>The default is <code>Val{false}</code>, i.e. by default an state is not decorated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/objective.jl#L78-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.is_objective_decorator" href="#Manopt.is_objective_decorator"><code>Manopt.is_objective_decorator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_object_decorator(s::AbstractManifoldObjective)</code></pre><p>Indicate, whether <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>s</code> are of decorator type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/objective.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.decorate_objective!" href="#Manopt.decorate_objective!"><code>Manopt.decorate_objective!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decorate_objective!(M, o::AbstractManifoldObjective)</code></pre><p>decorate the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a><code>o</code> with specific decorators.</p><p><strong>Optional Arguments</strong></p><p>optional arguments provide necessary details on the decorators. A specific one is used to activate certain decorators.</p><ul><li><code>cache</code>         ‚Äì (<code>missing</code>) specify a cache. Currently <code>:Simple</code> is supported and <code>:LRU</code> if you load <code>LRUCache.jl</code>. For this case a tuple specifying what to cache and how many can be provided, i.e. <code>(:LRU, [:Cost, :Gradient], 10)</code>, where the number specifies the size of each cache. and 10 is the default if one omits the last tuple entry</li><li><code>count</code>          ‚Äì (<code>missing</code>) specify calls to the objective to be called, see <a href="#Manopt.ManifoldCountObjective"><code>ManifoldCountObjective</code></a> for the full list</li><li><code>objective_type</code> ‚Äì (<code>:Riemannian</code>) specify that an objective is <code>:Riemannian</code> or <code>:Euclidean</code>.               The <code>:Euclidean</code> symbol is equivalent to specifying it as <code>:Embedded</code>,               since in the end, both refer to converting an objective from the embedding (whether its Euclidean or not)               to the Riemannian one.</li></ul><p><strong>See also</strong></p><p><a href="#Manopt.objective_cache_factory"><code>objective_cache_factory</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/solvers/solver.jl#L57-L80">source</a></section></article><h3 id="ManifoldEmbeddedObjective"><a class="docs-heading-anchor" href="#ManifoldEmbeddedObjective">Embedded objectives</a><a id="ManifoldEmbeddedObjective-1"></a><a class="docs-heading-anchor-permalink" href="#ManifoldEmbeddedObjective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.EmbeddedManifoldObjective" href="#Manopt.EmbeddedManifoldObjective"><code>Manopt.EmbeddedManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EmbeddedManifoldObjective{P, T, E, O2, O1&lt;:AbstractManifoldObjective{E}} &lt;:
   AbstractDecoratedManifoldObjective{O2, O1}</code></pre><p>Declare an objective to be defined in the embedding. This also declares the gradient to be defined in the embedding, and especially being the Riesz representer with respect to the metric in the embedding. The types can be used to still dispatch on also the undecorated objective type <code>O2</code>.</p><p><strong>Fields</strong></p><ul><li><code>objective</code> ‚Äì the objective that is defined in the embedding</li><li><code>p</code>         - (<code>nothing</code>) a point in the embedding.</li><li><code>X</code>         - (<code>nothing</code>) a tangent vector in the embedding</li></ul><p>When a point in the embedding <code>p</code> is provided, <code>embed!</code> is used in place of this point to reduce memory allocations. Similarly <code>X</code> is used when embedding tangent vectors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L1-L17">source</a></section></article><h3 id="CacheSection"><a class="docs-heading-anchor" href="#CacheSection">Cache objective</a><a id="CacheSection-1"></a><a class="docs-heading-anchor-permalink" href="#CacheSection" title="Permalink"></a></h3><p>Since single function calls, for example to the cost or the gradient, might be expensive, a simple cache objective exists as a decorator, that caches one cost value or gradient.</p><p>It can be activated/used with the <code>cache=</code> keyword argument available for every solver.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.reset_counters!" href="#Manopt.reset_counters!"><code>Manopt.reset_counters!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_counters(co::ManifoldCountObjective, value::Integer=0)</code></pre><p>Reset all values in the count objective to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/count.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.objective_cache_factory" href="#Manopt.objective_cache_factory"><code>Manopt.objective_cache_factory</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">objective_cache_factory(M::AbstractManifold, o::AbstractManifoldObjective, cache::Symbol)</code></pre><p>Generate a cached variant of the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>o</code> on the <code>AbstractManifold M</code> based on the symbol <code>cache</code>.</p><p>The following caches are available</p><ul><li><code>:Simple</code> generates a <a href="#Manopt.SimpleManifoldCachedObjective"><code>SimpleManifoldCachedObjective</code></a></li><li><code>:LRU</code> generates a <a href="#Manopt.ManifoldCachedObjective"><code>ManifoldCachedObjective</code></a> where you should use the form <code>(:LRU, [:Cost, :Gradient])</code> to specify what should be cached or <code>(:LRU, [:Cost, :Gradient], 100)</code> to specify the cache size. Here this variant defaults to <code>(:LRU, [:Cost, :Gradient], 100)</code>, i.e. to cache up to 100 cost and gradient values.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/cache.jl#L777-L794">source</a></section><section><div><pre><code class="language-julia hljs">objective_cache_factory(M::AbstractManifold, o::AbstractManifoldObjective, cache::Tuple{Symbol, Array, Array})
objective_cache_factory(M::AbstractManifold, o::AbstractManifoldObjective, cache::Tuple{Symbol, Array})</code></pre><p>Generate a cached variant of the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>o</code> on the <code>AbstractManifold M</code> based on the symbol <code>cache[1]</code>, where the second element <code>cache[2]</code> are further arguments to the cache and the optional third is passed down as keyword arguments.</p><p>For all available caches see the simpler variant with symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/cache.jl#L802-L812">source</a></section></article><h4 id="A-simple-cache"><a class="docs-heading-anchor" href="#A-simple-cache">A simple cache</a><a id="A-simple-cache-1"></a><a class="docs-heading-anchor-permalink" href="#A-simple-cache" title="Permalink"></a></h4><p>A first generic cache is always available, but it only caches one gradient and one cost function evaluation (for the same point).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.SimpleManifoldCachedObjective" href="#Manopt.SimpleManifoldCachedObjective"><code>Manopt.SimpleManifoldCachedObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> SimpleManifoldCachedObjective{O&lt;:AbstractManifoldGradientObjective{E,TC,TG}, P, T,C} &lt;: AbstractManifoldGradientObjective{E,TC,TG}</code></pre><p>Provide a simple cache for an <a href="#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective</code></a> that is for a given point <code>p</code> this cache stores a point <code>p</code> and a gradient <span>$\operatorname{grad} f(p)$</span> in <code>X</code> as well as a cost value <span>$f(p)$</span> in <code>c</code>.</p><p>Both <code>X</code> and <code>c</code> are accompanied by booleans to keep track of their validity.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SimpleManifoldCachedObjective(M::AbstractManifold, obj::AbstractManifoldGradientObjective; kwargs...)</code></pre><p><strong>Keyword</strong></p><ul><li><code>p</code> (<code>rand(M)</code>) ‚Äì a point on the manifold to initialize the cache with</li><li><code>X</code> (<code>get_gradient(M, obj, p)</code> or <code>zero_vector(M,p)</code>) ‚Äì a tangent vector to store the gradient in, see also <code>initialize</code></li><li><code>c</code> (<code>get_cost(M, obj, p)</code> or <code>0.0</code>) ‚Äì a value to store the cost function in <code>initialize</code></li><li><code>initialized</code> (<code>true</code>) ‚Äì whether to initialize the cached <code>X</code> and <code>c</code> or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/cache.jl#L4-L21">source</a></section></article><h4 id="A-generic-cache"><a class="docs-heading-anchor" href="#A-generic-cache">A generic cache</a><a id="A-generic-cache-1"></a><a class="docs-heading-anchor-permalink" href="#A-generic-cache" title="Permalink"></a></h4><p>For the more advanced cache, you need to implement some type of cache yourself, that provides a <code>get!</code> and implement <a href="#Manopt.init_caches"><code>init_caches</code></a>. This is for example provided if you load <a href="https://github.com/JuliaCollections/LRUCache.jl"><code>LRUCache.jl</code></a>. Then you obtain</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldCachedObjective" href="#Manopt.ManifoldCachedObjective"><code>Manopt.ManifoldCachedObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldCachedObjective{E,P,O&lt;:AbstractManifoldObjective{&lt;:E},C&lt;:NamedTuple{}} &lt;: AbstractDecoratedManifoldObjective{E,P}</code></pre><p>Create a cache for an objective, based on a <code>NamedTuple</code> that stores some kind of cache.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldCachedObjective(M, o::AbstractManifoldObjective, caches::Vector{Symbol}; kwargs...)</code></pre><p>Create a cache for the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> where the Symbols in <code>caches</code> indicate, which function evaluations to cache.</p><p><strong>Supported Symbols</strong></p><table><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Caches calls to (incl. <code>!</code> variants)</th><th style="text-align: left">Comment</th></tr><tr><td style="text-align: left"><code>:Constraints</code></td><td style="text-align: left"><a href="#Manopt.get_constraints"><code>get_constraints</code></a></td><td style="text-align: left">vector of numbers</td></tr><tr><td style="text-align: left"><code>:Cost</code></td><td style="text-align: left"><a href="#Manopt.get_cost"><code>get_cost</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:EqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraint"><code>get_equality_constraint</code></a></td><td style="text-align: left">numbers per (p,i)</td></tr><tr><td style="text-align: left"><code>:EqualityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraints"><code>get_equality_constraints</code></a></td><td style="text-align: left">vector of numbers</td></tr><tr><td style="text-align: left"><code>:GradEqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_grad_equality_constraint"><code>get_grad_equality_constraint</code></a></td><td style="text-align: left">tangent vector per (p,i)</td></tr><tr><td style="text-align: left"><code>:GradEqualityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_grad_equality_constraints"><code>get_grad_equality_constraints</code></a></td><td style="text-align: left">vector of tangent vectors</td></tr><tr><td style="text-align: left"><code>:GradInequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">tangent vector per (p,i)</td></tr><tr><td style="text-align: left"><code>:GradInequalityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a></td><td style="text-align: left">vector of tangent vectors</td></tr><tr><td style="text-align: left"><code>:Gradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M,p)</code></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:Hessian</code></td><td style="text-align: left"><a href="#Manopt.get_hessian"><code>get_hessian</code></a></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:InequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">numbers per (p,j)</td></tr><tr><td style="text-align: left"><code>:InequalityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a></td><td style="text-align: left">vector of numbers</td></tr><tr><td style="text-align: left"><code>:Preconditioner</code></td><td style="text-align: left"><a href="#Manopt.get_preconditioner"><code>get_preconditioner</code></a></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:ProximalMap</code></td><td style="text-align: left"><a href="#Manopt.get_proximal_map"><code>get_proximal_map</code></a></td><td style="text-align: left">point per <code>(p,Œª,i)</code></td></tr><tr><td style="text-align: left"><code>:StochasticGradients</code></td><td style="text-align: left"><a href="#Manopt.get_gradients"><code>get_gradients</code></a></td><td style="text-align: left">vector of tangent vectors</td></tr><tr><td style="text-align: left"><code>:StochasticGradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M, p, i)</code></td><td style="text-align: left">tangent vector per (p,i)</td></tr><tr><td style="text-align: left"><code>:SubGradient</code></td><td style="text-align: left"><a href="#Manopt.get_subgradient"><code>get_subgradient</code></a></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:SubtrahendGradient</code></td><td style="text-align: left"><a href="../../solvers/difference_of_convex/#Manopt.get_subtrahend_gradient"><code>get_subtrahend_gradient</code></a></td><td style="text-align: left">tangent vectors</td></tr></table><p><strong>Keyword Arguments</strong></p><ul><li><code>p</code>           - (<code>rand(M)</code>) the type of the keys to be used in the caches. Defaults to the default representation on <code>M</code>.</li><li><code>value</code>       - (<code>get_cost(M, objective, p)</code>) the type of values for numeric values in the cache, e.g. the cost</li><li><code>X</code>           - (<code>zero_vector(M,p)</code>) the type of values to be cached for gradient and Hessian calls.</li><li><code>cache</code>       - (<code>[:Cost]</code>) a vector of symbols indicating which function calls should be cached.</li><li><code>cache_size</code>  - (<code>10</code>) number of (least recently used) calls to cache</li><li><code>cache_sizes</code> ‚Äì (<code>Dict{Symbol,Int}()</code>) a named tuple or dictionary specifying the sizes individually for each cache.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/cache.jl#L205-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.init_caches" href="#Manopt.init_caches"><code>Manopt.init_caches</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_caches(M::AbstractManifold, caches, T; kwargs...)</code></pre><p>Given a vector of symbols <code>caches</code>, this function sets up the <code>NamedTuple</code> of caches for points/vectors on <code>M</code>, where <code>T</code> is the type of cache to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/cache.jl#L287-L293">source</a></section><section><div><pre><code class="language-julia hljs">init_caches(caches, T::Type{LRU}; kwargs...)</code></pre><p>Given a vector of symbols <code>caches</code>, this function sets up the <code>NamedTuple</code> of caches, where <code>T</code> is the type of cache to use.</p><p><strong>Keyword arguments</strong></p><ul><li><code>p</code>   - (<code>rand(M)</code>) a point on a manifold, to both infer its type for keys and initialize caches</li><li><code>value</code>   - (<code>0.0</code>) a value both typing and initialising number-caches, eg. for caching a cost.</li><li><code>X</code>   - (<code>zero_vector(M, p)</code> a tangent vector at <code>p</code> to both type and initialize tangent vector caches</li><li><code>cache_size</code> - (<code>10</code>)  a default cache size to use</li><li><code>cache_sizes</code> ‚Äì (<code>Dict{Symbol,Int}()</code>) a dictionary of sizes for the <code>caches</code> to specify different (non-default) sizes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/ext/ManoptLRUCacheExt.jl#L22-L35">source</a></section></article><h3 id="ManifoldCountObjective"><a class="docs-heading-anchor" href="#ManifoldCountObjective">Count objective</a><a id="ManifoldCountObjective-1"></a><a class="docs-heading-anchor-permalink" href="#ManifoldCountObjective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldCountObjective" href="#Manopt.ManifoldCountObjective"><code>Manopt.ManifoldCountObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldCountObjective{E,P,O&lt;:AbstractManifoldObjective,I&lt;:Integer} &lt;: AbstractDecoratedManifoldObjective{E,P}</code></pre><p>A wrapper for any <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> of type <code>O</code> to count different calls to parts of the objective.</p><p><strong>Fields</strong></p><ul><li><code>counts</code> a dictionary of symbols mapping to integers keeping the counted values</li><li><code>objective</code> the wrapped objective</li></ul><p><strong>Supported Symbols</strong></p><table><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Counts calls to (incl. <code>!</code> variants)</th><th style="text-align: left">Comment</th></tr><tr><td style="text-align: left"><code>:Constraints</code></td><td style="text-align: left"><a href="#Manopt.get_constraints"><code>get_constraints</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:Cost</code></td><td style="text-align: left"><a href="#Manopt.get_cost"><code>get_cost</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:EqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraint"><code>get_equality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:EqualityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraints"><code>get_equality_constraints</code></a></td><td style="text-align: left">does not count single access</td></tr><tr><td style="text-align: left"><code>:GradEqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_grad_equality_constraint"><code>get_grad_equality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:GradEqualityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_grad_equality_constraints"><code>get_grad_equality_constraints</code></a></td><td style="text-align: left">does not count single access</td></tr><tr><td style="text-align: left"><code>:GradInequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:GradInequalityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a></td><td style="text-align: left">does not count single access</td></tr><tr><td style="text-align: left"><code>:Gradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M,p)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:Hessian</code></td><td style="text-align: left"><a href="#Manopt.get_hessian"><code>get_hessian</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:InequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:InequalityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a></td><td style="text-align: left">does not count single access</td></tr><tr><td style="text-align: left"><code>:Preconditioner</code></td><td style="text-align: left"><a href="#Manopt.get_preconditioner"><code>get_preconditioner</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:ProximalMap</code></td><td style="text-align: left"><a href="#Manopt.get_proximal_map"><code>get_proximal_map</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:StochasticGradients</code></td><td style="text-align: left"><a href="#Manopt.get_gradients"><code>get_gradients</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:StochasticGradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M, p, i)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:SubGradient</code></td><td style="text-align: left"><a href="#Manopt.get_subgradient"><code>get_subgradient</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:SubtrahendGradient</code></td><td style="text-align: left"><a href="../../solvers/difference_of_convex/#Manopt.get_subtrahend_gradient"><code>get_subtrahend_gradient</code></a></td><td style="text-align: left"></td></tr></table><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldCountObjective(objective::AbstractManifoldObjective, counts::Dict{Symbol, &lt;:Integer})</code></pre><p>Initialise the <code>ManifoldCountObjective</code> to wrap <code>objective</code> initializing the set of counts</p><pre><code class="nohighlight hljs">ManifoldCountObjective(M::AbtractManifold, objective::AbstractManifoldObjective, count::AbstractVecor{Symbol}, init=0)</code></pre><p>Count function calls on <code>objective</code> using the symbols in <code>count</code> initialising all entries to <code>init</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/count.jl#L1-L44">source</a></section></article><h3 id="Internal-decorators"><a class="docs-heading-anchor" href="#Internal-decorators">Internal decorators</a><a id="Internal-decorators-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-decorators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ReturnManifoldObjective" href="#Manopt.ReturnManifoldObjective"><code>Manopt.ReturnManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReturnManifoldObjective{E,O2,O1&lt;:AbstractManifoldObjective{E}} &lt;:
   AbstractDecoratedManifoldObjective{E,O2}</code></pre><p>A wrapper to indicate that <code>get_solver_result</code> should return the inner objective.</p><p>The types are such that one can still dispatch on the undecorated type <code>O2</code> of the original objective as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/objective.jl#L50-L58">source</a></section></article><h2 id="Specific-Objective-typed-and-their-access-functions"><a class="docs-heading-anchor" href="#Specific-Objective-typed-and-their-access-functions">Specific Objective typed and their access functions</a><a id="Specific-Objective-typed-and-their-access-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-Objective-typed-and-their-access-functions" title="Permalink"></a></h2><h3 id="Cost-objective"><a class="docs-heading-anchor" href="#Cost-objective">Cost objective</a><a id="Cost-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Cost-objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractManifoldCostObjective" href="#Manopt.AbstractManifoldCostObjective"><code>Manopt.AbstractManifoldCostObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldCostObjective{T&lt;:AbstractEvaluationType} &lt;: AbstractManifoldObjective{T}</code></pre><p>Representing objectives on manifolds with a cost function implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/cost_plan.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldCostObjective" href="#Manopt.ManifoldCostObjective"><code>Manopt.ManifoldCostObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldCostObjective{T, TC} &lt;: AbstractManifoldCostObjective{T, TC}</code></pre><p>specify an <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> that does only have information about the cost function <span>$f\colon \mathbb M ‚Üí ‚Ñù$</span> implemented as a function <code>(M, p) -&gt; c</code> to compute the cost value <code>c</code> at <code>p</code> on the manifold <code>M</code>.</p><ul><li><code>cost</code> ‚Äì a function <span>$f: \mathcal M ‚Üí ‚Ñù$</span> to minimize</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldCostObjective(f)</code></pre><p>Generate a problem. While this Problem does not have any allocating functions, the type <code>T</code> can be set for consistency reasons with other problems.</p><p><strong>Used with</strong></p><p><a href="../../solvers/NelderMead/#Manopt.NelderMead"><code>NelderMead</code></a>, <a href="../../solvers/particle_swarm/#Manopt.particle_swarm"><code>particle_swarm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/cost_plan.jl#L9-L27">source</a></section></article><h4 id="Access-functions"><a class="docs-heading-anchor" href="#Access-functions">Access functions</a><a id="Access-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Access-functions" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_cost" href="#Manopt.get_cost"><code>Manopt.get_cost</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_cost(amp::AbstractManoptProblem, p)</code></pre><p>evaluate the cost function <code>f</code> stored within the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at the point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/problem.jl#L67-L72">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(M::AbstractManifold, obj::AbstractManifoldObjective, p)</code></pre><p>evaluate the cost function <code>f</code> defined on <code>M</code> stored within the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> at the point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/problem.jl#L77-L81">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(M::AbstractManifold, mco::AbstractManifoldCostObjective, p)</code></pre><p>Evaluate the cost function from within the <a href="#Manopt.AbstractManifoldCostObjective"><code>AbstractManifoldCostObjective</code></a> on <code>M</code> at <code>p</code>.</p><p>By default this implementation assumed that the cost is stored within <code>mco.cost</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/cost_plan.jl#L35-L42">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(TpM, trmo::TrustRegionModelObjective, X)</code></pre><p>Evaluate the tangent space <a href="../../solvers/truncated_conjugate_gradient_descent/#Manopt.TrustRegionModelObjective"><code>TrustRegionModelObjective</code></a></p><p class="math-container">\[m(X) = f(p) + ‚ü®\operatorname{grad} f(p), X ‚ü©_p + \frac{1}{2} ‚ü®\operatorname{Hess} f(p)[X], X‚ü©_p.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/trust_regions_plan.jl#L37-L45">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(TpM, trmo::AdaptiveRagularizationWithCubicsModelObjective, X)</code></pre><p>Evaluate the tangent space <a href="../../solvers/adaptive-regularization-with-cubics/#Manopt.AdaptiveRagularizationWithCubicsModelObjective"><code>AdaptiveRagularizationWithCubicsModelObjective</code></a></p><p class="math-container">\[m(X) = f(p) + ‚ü®\operatorname{grad} f(p), X ‚ü©_p + \frac{1}{2} ‚ü®\operatorname{Hess} f(p)[X], X‚ü©_p
       +  \frac{œÉ}{3} \lVert X \rVert^3,\]</p><p>at <code>X</code>, cf. Eq. (33) in [<a href="../../references/#AgarwalBoumalBullinsCartis:2020">ABBC20</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/adabtive_regularization_with_cubics_plan.jl#L50-L61">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p, i)</code></pre><p>Evaluate the <code>i</code>th summand of the cost.</p><p>If you use a single function for the stochastic cost, then only the index <code>√¨=1</code>` is available to evaluate the whole cost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/stochastic_gradient_plan.jl#L60-L67">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(M::AbstractManifold,emo::EmbeddedManifoldObjective, p)</code></pre><p>Evaluate the cost function of an objective defined in the embedding, i.e. embed <code>p</code> before calling the cost function stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L59-L64">source</a></section></article><p>and internally</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_cost_function" href="#Manopt.get_cost_function"><code>Manopt.get_cost_function</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_cost_function(amco::AbstractManifoldCostObjective)</code></pre><p>return the function to evaluate (just) the cost <span>$f(p)=c$</span> as a function <code>(M,p) -&gt; c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/cost_plan.jl#L50-L54">source</a></section></article><h3 id="Gradient-objectives"><a class="docs-heading-anchor" href="#Gradient-objectives">Gradient objectives</a><a id="Gradient-objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-objectives" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractManifoldGradientObjective" href="#Manopt.AbstractManifoldGradientObjective"><code>Manopt.AbstractManifoldGradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldGradientObjective{E&lt;:AbstractEvaluationType, TC, TG} &lt;: AbstractManifoldCostObjective{E, TC}</code></pre><p>An abstract type for all objectives that provide a (full) gradient, where <code>T</code> is a <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> for the gradient function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/gradient_plan.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldGradientObjective" href="#Manopt.ManifoldGradientObjective"><code>Manopt.ManifoldGradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldGradientObjective{T&lt;:AbstractEvaluationType} &lt;: AbstractManifoldGradientObjective{T}</code></pre><p>specify an objective containing a cost and its gradient</p><p><strong>Fields</strong></p><ul><li><code>cost</code>       ‚Äì a function <span>$f\colon\mathcal M ‚Üí ‚Ñù$</span></li><li><code>gradient!!</code> ‚Äì the gradient <span>$\operatorname{grad}f\colon\mathcal M ‚Üí \mathcal T\mathcal M$</span> of the cost function <span>$f$</span>.</li></ul><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>T</code> the gradient can have to forms</p><ul><li>as a function <code>(M, p) -&gt; X</code> that allocates memory for <code>X</code>, i.e. an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a></li><li>as a function <code>(M, X, p) -&gt; X</code> that work in place of <code>X</code>, i.e. an <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a></li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldGradientObjective(cost, gradient; evaluation=AllocatingEvaluation())</code></pre><p><strong>Used with</strong></p><p><a href="../../solvers/gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a>, <a href="../../solvers/conjugate_gradient_descent/#Manopt.conjugate_gradient_descent"><code>conjugate_gradient_descent</code></a>, <a href="../../solvers/quasi_Newton/#Manopt.quasi_Newton"><code>quasi_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/gradient_plan.jl#L31-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldAlternatingGradientObjective" href="#Manopt.ManifoldAlternatingGradientObjective"><code>Manopt.ManifoldAlternatingGradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldAlternatingGradientObjective{E&lt;:AbstractEvaluationType,TCost,TGradient} &lt;: AbstractManifoldGradientObjective{E}</code></pre><p>An alternating gradient objective consists of</p><ul><li>a cost function <span>$F(x)$</span></li><li>a gradient <span>$\operatorname{grad}F$</span> that is either<ul><li>given as one function <span>$\operatorname{grad}F$</span> returning a tangent vector <code>X</code> on <code>M</code> or</li><li>an array of gradient functions <span>$\operatorname{grad}F_i$</span>, <code>√¨=1,‚Ä¶,n</code> s each returning a component of the gradient</li></ul>which might be allocating or mutating variants, but not a mix of both.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This Objective is usually defined using the <code>ProductManifold</code> from <code>Manifolds.jl</code>, so <code>Manifolds.jl</code> to be loaded.</p></div></div><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldAlternatingGradientObjective(F, gradF::Function;
    evaluation=AllocatingEvaluation()
)
ManifoldAlternatingGradientObjective(F, gradF::AbstractVector{&lt;:Function};
    evaluation=AllocatingEvaluation()
)</code></pre><p>Create a alternating gradient problem with an optional <code>cost</code> and the gradient either as one function (returning an array) or a vector of functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/alternating_gradient_plan.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldStochasticGradientObjective" href="#Manopt.ManifoldStochasticGradientObjective"><code>Manopt.ManifoldStochasticGradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldStochasticGradientObjective{T&lt;:AbstractEvaluationType} &lt;: AbstractManifoldGradientObjective{T}</code></pre><p>A stochastic gradient objective consists of</p><ul><li>a(n optional) cost function ``f(p) = \displaystyle\sum<em>{i=1}^n f</em>i(p)</li><li>an array of gradients, <span>$\operatorname{grad}f_i(p), i=1,\ldots,n$</span> which can be given in two forms<ul><li>as one single function <span>$(\mathcal M, p) ‚Ü¶ (X_1,‚Ä¶,X_n) \in (T_p\mathcal M)^n$</span></li><li>as a vector of functions <span>$\bigl( (\mathcal M, p) ‚Ü¶ X_1, ‚Ä¶, (\mathcal M, p) ‚Ü¶ X_n\bigr)$</span>.</li></ul></li></ul><p>Where both variants can also be provided as <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> functions, i.e. <code>(M, X, p) -&gt; X</code>, where <code>X</code> is the vector of <code>X1,...Xn</code> and <code>(M, X1, p) -&gt; X1, ..., (M, Xn, p) -&gt; Xn</code>, respectively.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldStochasticGradientObjective(
    grad_f::Function;
    cost=Missing(),
    evaluation=AllocatingEvaluation()
)
ManifoldStochasticGradientObjective(
    grad_f::AbstractVector{&lt;:Function};
    cost=Missing(), evaluation=AllocatingEvaluation()
)</code></pre><p>Create a Stochastic gradient problem with the gradient either as one function (returning an array of tangent vectors) or a vector of functions (each returning one tangent vector).</p><p>The optional cost can also be given as either a single function (returning a number) pr a vector of functions, each returning a value.</p><p><strong>Used with</strong></p><p><a href="../../solvers/stochastic_gradient_descent/#Manopt.stochastic_gradient_descent"><code>stochastic_gradient_descent</code></a></p><p>Note that this can also be used with a <a href="../../solvers/gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a>, since the (complete) gradient is just the sums of the single gradients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/stochastic_gradient_plan.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.NonlinearLeastSquaresObjective" href="#Manopt.NonlinearLeastSquaresObjective"><code>Manopt.NonlinearLeastSquaresObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonlinearLeastSquaresObjective{T&lt;:AbstractEvaluationType} &lt;: AbstractManifoldObjective{T}</code></pre><p>A type for nonlinear least squares problems. <code>T</code> is a <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> for the <code>F</code> and Jacobian functions.</p><p>Specify a nonlinear least squares problem</p><p><strong>Fields</strong></p><ul><li><code>f</code>        ‚Äì a function <span>$f: \mathcal M ‚Üí ‚Ñù^d$</span> to minimize</li><li><code>jacobian!!</code>   ‚Äì Jacobian of the function <span>$f$</span></li><li><code>jacobian_tangent_basis</code>     ‚Äì the basis of tangent space used for computing the Jacobian.</li><li><code>num_components</code> ‚Äì number of values returned by <code>f</code> (equal to <code>d</code>).</li></ul><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>T</code> the function <span>$F$</span> has to be provided:</p><ul><li>as a functions <code>(M::AbstractManifold, p) -&gt; v</code> that allocates memory for <code>v</code> itself for an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>,</li><li>as a function <code>(M::AbstractManifold, v, p) -&gt; v</code> that works in place of <code>v</code> for a <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>.</li></ul><p>Also the Jacobian <span>$jacF!!$</span> is required:</p><ul><li>as a functions <code>(M::AbstractManifold, p; basis_domain::AbstractBasis) -&gt; v</code> that allocates memory for <code>v</code> itself for an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>,</li><li>as a function <code>(M::AbstractManifold, v, p; basis_domain::AbstractBasis) -&gt; v</code> that works in place of <code>v</code> for an <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">NonlinearLeastSquaresProblem(M, F, jacF, num_components; evaluation=AllocatingEvaluation(), jacobian_tangent_basis=DefaultOrthonormalBasis())</code></pre><p><strong>See also</strong></p><p><a href="../../solvers/LevenbergMarquardt/#Manopt.LevenbergMarquardt"><code>LevenbergMarquardt</code></a>, <a href="../../solvers/LevenbergMarquardt/#Manopt.LevenbergMarquardtState"><code>LevenbergMarquardtState</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/nonlinear_least_squares_plan.jl#L2-L37">source</a></section></article><p>There is also a second variant, if just one function is responsible for computing the cost <em>and</em> the gradient</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldCostGradientObjective" href="#Manopt.ManifoldCostGradientObjective"><code>Manopt.ManifoldCostGradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldCostGradientObjective{T} &lt;: AbstractManifoldObjective{T}</code></pre><p>specify an objective containing one function to perform a combined computation of cost and its gradient</p><p><strong>Fields</strong></p><ul><li><code>costgrad!!</code> ‚Äì a function that computes both the cost <span>$f\colon\mathcal M ‚Üí ‚Ñù$</span> and its gradient <span>$\operatorname{grad}f\colon\mathcal M ‚Üí \mathcal T\mathcal M$</span></li></ul><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>T</code> the gradient can have to forms</p><ul><li>as a function <code>(M, p) -&gt; (c, X)</code> that allocates memory for the gradient <code>X</code>, i.e. an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a></li><li>as a function <code>(M, X, p) -&gt; (c, X)</code> that work in place of <code>X</code>, i.e. an <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a></li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldCostGradientObjective(costgrad; evaluation=AllocatingEvaluation())</code></pre><p><strong>Used with</strong></p><p><a href="../../solvers/gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a>, <a href="../../solvers/conjugate_gradient_descent/#Manopt.conjugate_gradient_descent"><code>conjugate_gradient_descent</code></a>, <a href="../../solvers/quasi_Newton/#Manopt.quasi_Newton"><code>quasi_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/gradient_plan.jl#L64-L85">source</a></section></article><h4 id="Access-functions-2"><a class="docs-heading-anchor" href="#Access-functions-2">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_gradient" href="#Manopt.get_gradient"><code>Manopt.get_gradient</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">X = get_gradient(M::ProductManifold, ago::ManifoldAlternatingGradientObjective, p)
get_gradient!(M::ProductManifold, P::ManifoldAlternatingGradientObjective, X, p)</code></pre><p>Evaluate all summands gradients at a point <code>p</code> on the <code>ProductManifold M</code> (in place of <code>X</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/ext/ManoptManifoldsExt/alternating_gradient.jl#L2-L7">source</a></section><section><div><pre><code class="language-julia hljs">X = get_gradient(M::AbstractManifold, p::ManifoldAlternatingGradientObjective, p, k)
get_gradient!(M::AbstractManifold, p::ManifoldAlternatingGradientObjective, X, p, k)</code></pre><p>Evaluate one of the component gradients <span>$\operatorname{grad}f_k$</span>, <span>$k‚àà\{1,‚Ä¶,n\}$</span>, at <code>x</code> (in place of <code>Y</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/ext/ManoptManifoldsExt/alternating_gradient.jl#L18-L23">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(s::AbstractManoptSolverState)</code></pre><p>return the (last stored) gradient within <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a><code></code>s`. By default also undecorates the state beforehand</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/solver_state.jl#L159-L164">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(amp::AbstractManoptProblem, p)
get_gradient!(amp::AbstractManoptProblem, X, p)</code></pre><p>evaluate the gradient of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at the point <code>p</code>.</p><p>The evaluation is done in place of <code>X</code> for the <code>!</code>-variant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/gradient_plan.jl#L133-L140">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, mgo::AbstractManifoldGradientObjective{T}, p)
get_gradient!(M::AbstractManifold, X, mgo::AbstractManifoldGradientObjective{T}, p)</code></pre><p>evaluate the gradient of a <a href="#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective{T}</code></a> <code>mgo</code> at <code>p</code>.</p><p>The evaluation is done in place of <code>X</code> for the <code>!</code>-variant. The <code>T=</code><a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a> problem might still allocate memory within. When the non-mutating variant is called with a <code>T=</code><a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> memory for the result is allocated.</p><p>Note that the order of parameters follows the philosophy of <code>Manifolds.jl</code>, namely that even for the mutating variant, the manifold is the first parameter and the (inplace) tangent vector <code>X</code> comes second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/gradient_plan.jl#L148-L162">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(agst::AbstractGradientSolverState)</code></pre><p>return the gradient stored within gradient options. THe default returns <code>agst.X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/gradient_plan.jl#L213-L218">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(TpM, trmo::TrustRegionModelObjective, X)</code></pre><p>Evaluate the gradient of the <a href="../../solvers/truncated_conjugate_gradient_descent/#Manopt.TrustRegionModelObjective"><code>TrustRegionModelObjective</code></a></p><p class="math-container">\[\operatorname{grad} m(X) = \operatorname{grad} f(p) + \operatorname{Hess} f(p)[X].\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/trust_regions_plan.jl#L54-L62">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(TpM, trmo::AdaptiveRagularizationWithCubicsModelObjective, X)</code></pre><p>Evaluate the gradient of the <a href="../../solvers/adaptive-regularization-with-cubics/#Manopt.AdaptiveRagularizationWithCubicsModelObjective"><code>AdaptiveRagularizationWithCubicsModelObjective</code></a></p><p class="math-container">\[\operatorname{grad} m(X) = \operatorname{grad} f(p) + \operatorname{Hess} f(p)[X]
       + œÉ\lVert X \rVert X,\]</p><p>at <code>X</code>, cf. Eq. (37) in [<a href="../../references/#AgarwalBoumalBullinsCartis:2020">ABBC20</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/adabtive_regularization_with_cubics_plan.jl#L75-L86">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p, k)
get_gradient!(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, Y, p, k)</code></pre><p>Evaluate one of the summands gradients <span>$\operatorname{grad}f_k$</span>, <span>$k‚àà\{1,‚Ä¶,n\}$</span>, at <code>x</code> (in place of <code>Y</code>).</p><p>If you use a single function for the stochastic gradient, that works inplace, then <code>get_gradient</code> is not available, since the length (or number of elements of the gradient required for allocation) can not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/stochastic_gradient_plan.jl#L177-L185">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p)
get_gradient!(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, X, p)</code></pre><p>Evaluate the complete gradient <span>$\operatorname{grad} f = \displaystyle\sum_{i=1}^n \operatorname{grad} f_i(p)$</span> at <code>p</code> (in place of <code>X</code>).</p><p>If you use a single function for the stochastic gradient, that works inplace, then <code>get_gradient</code> is not available, since the length (or number of elements of the gradient required for allocation) can not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/stochastic_gradient_plan.jl#L269-L277">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, emo::EmbeddedManifoldObjective, p)
get_gradient!(M::AbstractManifold, X, emo::EmbeddedManifoldObjective, p)</code></pre><p>Evaluate the gradient function of an objective defined in the embedding, that is embed <code>p</code> before calling the gradient function stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p><p>The returned gradient is then converted to a Riemannian gradient calling <a href="https://juliamanifolds.github.io/ManifoldDiff.jl/stable/library.html#ManifoldDiff.riemannian_gradient-Tuple{AbstractManifold,%20Any,%20Any}"><code>riemannian_gradient</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L74-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_gradients" href="#Manopt.get_gradients"><code>Manopt.get_gradients</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_gradients(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p)
get_gradients!(M::AbstractManifold, X, sgo::ManifoldStochasticGradientObjective, p)</code></pre><p>Evaluate all summands gradients <span>$\{\operatorname{grad}f_i\}_{i=1}^n$</span> at <code>p</code> (in place of <code>X</code>).</p><p>If you use a single function for the stochastic gradient, that works inplace, then <code>get_gradient</code> is not available, since the length (or number of elements of the gradient) can not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/stochastic_gradient_plan.jl#L82-L90">source</a></section></article><p>and internally</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_gradient_function" href="#Manopt.get_gradient_function"><code>Manopt.get_gradient_function</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_gradient_function(amgo::AbstractManifoldGradientObjective, recursive=false)</code></pre><p>return the function to evaluate (just) the gradient <span>$\operatorname{grad} f(p)$</span>, where either the gradient function using the decorator or without the decorator is used.</p><p>By default <code>recursive</code> is set to <code>false</code>, since usually to just pass the gradient function somewhere, you still want e.g. the cached one or the one that still counts calls.</p><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code> this is a function</p><ul><li><code>(M, p) -&gt; X</code> for the <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a> case</li><li><code>(M, X, p) -&gt; X</code> for the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>, i.e. working inplace of <code>X</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/gradient_plan.jl#L10-L23">source</a></section></article><h4 id="Internal-helpers"><a class="docs-heading-anchor" href="#Internal-helpers">Internal helpers</a><a id="Internal-helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-helpers" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_gradient_from_Jacobian!" href="#Manopt.get_gradient_from_Jacobian!"><code>Manopt.get_gradient_from_Jacobian!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_gradient_from_Jacobian!(
    M::AbstractManifold,
    X,
    nlso::NonlinearLeastSquaresObjective{InplaceEvaluation},
    p,
    Jval=zeros(nlso.num_components, manifold_dimension(M)),
)</code></pre><p>Compute gradient of <a href="#Manopt.NonlinearLeastSquaresObjective"><code>NonlinearLeastSquaresObjective</code></a> <code>nlso</code> at point <code>p</code> in place of <code>X</code>, with temporary Jacobian stored in the optional argument <code>Jval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/nonlinear_least_squares_plan.jl#L73-L84">source</a></section></article><h3 id="Subgradient-objective"><a class="docs-heading-anchor" href="#Subgradient-objective">Subgradient objective</a><a id="Subgradient-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Subgradient-objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldSubgradientObjective" href="#Manopt.ManifoldSubgradientObjective"><code>Manopt.ManifoldSubgradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldSubgradientObjective{T&lt;:AbstractEvaluationType,C,S} &lt;:AbstractManifoldCostObjective{T, C}</code></pre><p>A structure to store information about a objective for a subgradient based optimization problem</p><p><strong>Fields</strong></p><ul><li><code>cost</code> ‚Äì the function <span>$f$</span> to be minimized</li><li><code>subgradient</code> ‚Äì a function returning a subgradient <span>$\partial f$</span> of <span>$f$</span></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldSubgradientObjective(f, ‚àÇf)</code></pre><p>Generate the <a href="#Manopt.ManifoldSubgradientObjective"><code>ManifoldSubgradientObjective</code></a> for a subgradient objective, i.e. a (cost) function <code>f(M, p)</code> and a function <code>‚àÇf(M, p)</code> that returns a not necessarily deterministic element from the subdifferential at <code>p</code> on a manifold <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/subgradient_plan.jl#L1-L17">source</a></section></article><h4 id="Access-functions-3"><a class="docs-heading-anchor" href="#Access-functions-3">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-3" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_subgradient" href="#Manopt.get_subgradient"><code>Manopt.get_subgradient</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_subgradient(amp::AbstractManoptProblem, p)
get_subgradient!(amp::AbstractManoptProblem, X, p)</code></pre><p>evaluate the subgradient of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at point <code>p</code>.</p><p>The evaluation is done in place of <code>X</code> for the <code>!</code>-variant. The result might not be deterministic, <em>one</em> element of the subdifferential is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/subgradient_plan.jl#L29-L37">source</a></section><section><div><pre><code class="language-julia hljs">X = get_subgradient(M;;AbstractManifold, sgo::ManifoldSubgradientObjective, p)
get_subgradient!(M;;AbstractManifold, X, sgo::ManifoldSubgradientObjective, p)</code></pre><p>Evaluate the (sub)gradient of a <a href="#Manopt.ManifoldSubgradientObjective"><code>ManifoldSubgradientObjective</code></a> <code>sgo</code> at the point <code>p</code>.</p><p>The evaluation is done in place of <code>X</code> for the <code>!</code>-variant. The result might not be deterministic, <em>one</em> element of the subdifferential is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/subgradient_plan.jl#L45-L54">source</a></section></article><h3 id="Proximal-map-objective"><a class="docs-heading-anchor" href="#Proximal-map-objective">Proximal map objective</a><a id="Proximal-map-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Proximal-map-objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldProximalMapObjective" href="#Manopt.ManifoldProximalMapObjective"><code>Manopt.ManifoldProximalMapObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldProximalMapObjective{E&lt;:AbstractEvaluationType, TC, TP, V &lt;: Vector{&lt;:Integer}} &lt;: AbstractManifoldCostObjective{E, TC}</code></pre><p>specify a problem for solvers based on the evaluation of proximal map(s).</p><p><strong>Fields</strong></p><ul><li><code>cost</code> - a function <span>$F:\mathcal M‚Üí‚Ñù$</span> to minimize</li><li><code>proxes</code> - proximal maps <span>$\operatorname{prox}_{Œª\varphi}:\mathcal M‚Üí\mathcal M$</span> as functions <code>(M, Œª, p) -&gt; q</code>.</li><li><code>number_of_proxes</code> - (<code>ones(length(proxes))</code>` number of proximal Maps per function, e.g. if one of the maps is a combined one such that the proximal Maps functions return more than one entry per function, you have to adapt this value. if not specified, it is set to one prox per function.</li></ul><p><strong>See also</strong></p><p><a href="../../solvers/cyclic_proximal_point/#Manopt.cyclic_proximal_point"><code>cyclic_proximal_point</code></a>, <a href="#Manopt.get_cost"><code>get_cost</code></a>, <a href="#Manopt.get_proximal_map"><code>get_proximal_map</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/proximal_plan.jl#L6-L23">source</a></section></article><h4 id="Access-functions-4"><a class="docs-heading-anchor" href="#Access-functions-4">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-4" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_proximal_map" href="#Manopt.get_proximal_map"><code>Manopt.get_proximal_map</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = get_proximal_map(M::AbstractManifold, mpo::ManifoldProximalMapObjective, Œª, p)
get_proximal_map!(M::AbstractManifold, q, mpo::ManifoldProximalMapObjective, Œª, p)
q = get_proximal_map(M::AbstractManifold, mpo::ManifoldProximalMapObjective, Œª, p, i)
get_proximal_map!(M::AbstractManifold, q, mpo::ManifoldProximalMapObjective, Œª, p, i)</code></pre><p>evaluate the (<code>i</code>th) proximal map of <code>ManifoldProximalMapObjective p</code> at the point <code>p</code> of <code>p.M</code> with parameter <span>$Œª&gt;0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/proximal_plan.jl#L60-L67">source</a></section></article><h3 id="Hessian-objective"><a class="docs-heading-anchor" href="#Hessian-objective">Hessian objective</a><a id="Hessian-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Hessian-objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractManifoldHessianObjective" href="#Manopt.AbstractManifoldHessianObjective"><code>Manopt.AbstractManifoldHessianObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldHessianObjective{T&lt;:AbstractEvaluationType,TC,TG,TH} &lt;: AbstractManifoldGradientObjective{T,TC,TG}</code></pre><p>An abstract type for all objectives that provide a (full) Hessian, where <code>T</code> is a <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> for the gradient and Hessian functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/hessian_plan.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldHessianObjective" href="#Manopt.ManifoldHessianObjective"><code>Manopt.ManifoldHessianObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldHessianObjective{T&lt;:AbstractEvaluationType,C,G,H,Pre} &lt;: AbstractManifoldHessianObjective{T,C,G,H}</code></pre><p>specify a problem for hessian based algorithms.</p><p><strong>Fields</strong></p><ul><li><code>cost</code> : a function <span>$f:\mathcal M‚Üí‚Ñù$</span> to minimize</li><li><code>gradient</code>     : the gradient <span>$\operatorname{grad}f:\mathcal M ‚Üí \mathcal T\mathcal M$</span> of the cost function <span>$f$</span></li><li><code>hessian</code>      : the hessian <span>$\operatorname{Hess}f(x)[‚ãÖ]: \mathcal T_{x} \mathcal M ‚Üí \mathcal T_{x} \mathcal M$</span> of the cost function <span>$f$</span></li><li><code>preconditioner</code> : the symmetric, positive definite preconditioner   as an approximation of the inverse of the Hessian of <span>$f$</span>, i.e. as a map with the same   input variables as the <code>hessian</code> to numerically stabilize iterations when the Hessian is   ill-conditioned</li></ul><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>T</code> the gradient and can have to forms</p><ul><li>as a function <code>(M, p) -&gt; X</code>  and <code>(M, p, X) -&gt; Y</code>, resp. i.e. an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a></li><li>as a function <code>(M, X, p) -&gt; X</code> and (M, Y, p, X), resp., i.e. an <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldHessianObjective(f, grad_f, Hess_f, preconditioner = (M, p, X) -&gt; X;
    evaluation=AllocatingEvaluation())</code></pre><p><strong>See also</strong></p><p><a href="../../solvers/truncated_conjugate_gradient_descent/#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a>, <a href="../../solvers/trust_regions/#Manopt.trust_regions"><code>trust_regions</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/hessian_plan.jl#L18-L47">source</a></section></article><h4 id="Access-functions-5"><a class="docs-heading-anchor" href="#Access-functions-5">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-5" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_hessian" href="#Manopt.get_hessian"><code>Manopt.get_hessian</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Y = get_hessian(amp::AbstractManoptProblem{T}, p, X)
get_hessian!(amp::AbstractManoptProblem{T}, Y, p, X)</code></pre><p>evaluate the Hessian of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at <code>p</code> applied to a tangent vector <code>X</code>, i.e. compute <span>$\operatorname{Hess}f(q)[X]$</span>, which can also happen in-place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/hessian_plan.jl#L72-L79">source</a></section><section><div><pre><code class="language-julia hljs">get_hessian(TpM, trmo::TrustRegionModelObjective, X)</code></pre><p>Evaluate the Hessian of the <a href="../../solvers/truncated_conjugate_gradient_descent/#Manopt.TrustRegionModelObjective"><code>TrustRegionModelObjective</code></a></p><p class="math-container">\[\operatorname{Hess} m(X)[Y] = \operatorname{Hess} f(p)[Y].\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/trust_regions_plan.jl#L75-L83">source</a></section><section><div><pre><code class="language-julia hljs">get_hessian(M::AbstractManifold, emo::EmbeddedManifoldObjective, p, X)
get_hessian!(M::AbstractManifold, Y, emo::EmbeddedManifoldObjective, p, X)</code></pre><p>Evaluate the Hessian of an objective defined in the embedding, that is embed <code>p</code> and <code>X</code> before calling the Hessian function stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p><p>The returned Hessian is then converted to a Riemannian Hessian calling  <a href="https://juliamanifolds.github.io/ManifoldDiff.jl/stable/library/#ManifoldDiff.riemannian_Hessian-Tuple{AbstractManifold,%20Any,%20Any,%20Any,%20Any}"><code>riemannian_Hessian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L128-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_preconditioner" href="#Manopt.get_preconditioner"><code>Manopt.get_preconditioner</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_preconditioner(amp::AbstractManoptProblem, p, X)</code></pre><p>evaluate the symmetric, positive definite preconditioner (approximation of the inverse of the Hessian of the cost function <code>f</code>) of a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>s objective at the point <code>p</code> applied to a tangent vector <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/hessian_plan.jl#L134-L141">source</a></section><section><div><pre><code class="language-julia hljs">get_preconditioner(M::AbstractManifold, mho::ManifoldHessianObjective, p, X)</code></pre><p>evaluate the symmetric, positive definite preconditioner (approximation of the inverse of the Hessian of the cost function <code>F</code>) of a <a href="#Manopt.ManifoldHessianObjective"><code>ManifoldHessianObjective</code></a> <code>mho</code> at the point <code>p</code> applied to a tangent vector <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/hessian_plan.jl#L149-L156">source</a></section></article><p>and internally</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_hessian_function" href="#Manopt.get_hessian_function"><code>Manopt.get_hessian_function</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_gradient_function(amgo::AbstractManifoldGradientObjective{E&lt;:AbstractEvaluationType})</code></pre><p>return the function to evaluate (just) the hessian <span>$\operatorname{Hess} f(p)$</span>. Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code> this is a function</p><ul><li><code>(M, p, X) -&gt; Y</code> for the <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a> case</li><li><code>(M, Y, p, X) -&gt; X</code> for the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>, i.e. working inplace of <code>Y</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/hessian_plan.jl#L120-L128">source</a></section></article><h3 id="Primal-dual-based-objectives"><a class="docs-heading-anchor" href="#Primal-dual-based-objectives">Primal-dual based objectives</a><a id="Primal-dual-based-objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-dual-based-objectives" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractPrimalDualManifoldObjective" href="#Manopt.AbstractPrimalDualManifoldObjective"><code>Manopt.AbstractPrimalDualManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>AbstractPrimalDualManifoldObjective{E&lt;:AbstractEvaluationType,C,P} &lt;: AbstractManifoldCostObjective{E,C}</p><p>A common abstract super type for objectives that consider primal-dual problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/primal_dual_plan.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.PrimalDualManifoldObjective" href="#Manopt.PrimalDualManifoldObjective"><code>Manopt.PrimalDualManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrimalDualManifoldObjective{E&lt;:AbstractEvaluationType} &lt;: AbstractPrimalDualManifoldObjective{E}</code></pre><p>Describes an Objective linearized or exact Chambolle-Pock algorithm, cf. <a href="../../references/#BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez:2021">Bergmann et al., Found. Comput. Math., 2021</a>, <a href="../../references/#ChambollePock:2011">Chambolle, Pock, JMIV, 201</a></p><p><strong>Fields</strong></p><p>All fields with !! can either be mutating or nonmutating functions, which should be set depending on the parameter <code>T &lt;: AbstractEvaluationType</code>.</p><ul><li><code>cost</code> <span>$F + G(Œõ(‚ãÖ))$</span> to evaluate interims cost function values</li><li><code>linearized_forward_operator!!</code> linearized operator for the forward operation in the algorithm <span>$DŒõ$</span></li><li><code>linearized_adjoint_operator!!</code> The adjoint differential <span>$(DŒõ)^* : \mathcal N ‚Üí T\mathcal M$</span></li><li><code>prox_f!!</code> the proximal map belonging to <span>$f$</span></li><li><code>prox_G_dual!!</code> the proximal map belonging to <span>$g_n^*$</span></li><li><code>Œõ!!</code> ‚Äì (<code>fordward_operator</code>) the  forward operator (if given) <span>$Œõ: \mathcal M ‚Üí \mathcal N$</span></li></ul><p>Either the linearized operator <span>$DŒõ$</span> or <span>$Œõ$</span> are required usually.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PrimalDualManifoldObjective(cost, prox_f, prox_G_dual, adjoint_linearized_operator;
    linearized_forward_operator::Union{Function,Missing}=missing,
    Œõ::Union{Function,Missing}=missing,
    evaluation::AbstractEvaluationType=AllocatingEvaluation()
)</code></pre><p>The last optional argument can be used to provide the 4 or 5 functions as allocating or mutating (in place computation) ones. Note that the first argument is always the manifold under consideration, the mutated one is the second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/primal_dual_plan.jl#L30-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.PrimalDualManifoldSemismoothNewtonObjective" href="#Manopt.PrimalDualManifoldSemismoothNewtonObjective"><code>Manopt.PrimalDualManifoldSemismoothNewtonObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrimalDualManifoldSemismoothNewtonObjective{E&lt;:AbstractEvaluationType, TC, LO, ALO, PF, DPF, PG, DPG, L} &lt;: AbstractPrimalDualManifoldObjective{E, TC, PF}</code></pre><p>Describes a Problem for the Primal-dual Riemannian semismooth Newton algorithm. <a href="../../references/#DiepeveenLellmann:2021">Diepeveen, Lellmann, SIAM J. Imag. Sci., 2021</a></p><p><strong>Fields</strong></p><ul><li><code>cost</code> <span>$F + G(Œõ(‚ãÖ))$</span> to evaluate interims cost function values</li><li><code>linearized_operator</code> the linearization <span>$DŒõ(‚ãÖ)[‚ãÖ]$</span> of the operator <span>$Œõ(‚ãÖ)$</span>.</li><li><code>linearized_adjoint_operator</code> The adjoint differential <span>$(DŒõ)^* \colon \mathcal N \to T\mathcal M$</span></li><li><code>prox_F</code> the proximal map belonging to <span>$F$</span></li><li><code>diff_prox_F</code> the (Clarke Generalized) differential of the proximal maps of <span>$F$</span></li><li><code>prox_G_dual</code> the proximal map belonging to <span>$g_n^*$</span></li><li><code>diff_prox_dual_G</code> the (Clarke Generalized) differential of the proximal maps of <span>$G^\ast_n$</span></li><li><code>Œõ</code> ‚Äì the exact forward operator. This operator is required if <code>Œõ(m)=n</code> does not hold.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PrimalDualManifoldSemismoothNewtonObjective(cost, prox_F, prox_G_dual, forward_operator, adjoint_linearized_operator,Œõ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/higher_order_primal_dual_plan.jl#L1-L21">source</a></section></article><h4 id="Access-functions-6"><a class="docs-heading-anchor" href="#Access-functions-6">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-6" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.adjoint_linearized_operator" href="#Manopt.adjoint_linearized_operator"><code>Manopt.adjoint_linearized_operator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">X = adjoint_linearized_operator(N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, m, n, Y)
adjoint_linearized_operator(N::AbstractManifold, X, apdmo::AbstractPrimalDualManifoldObjective, m, n, Y)</code></pre><p>Evaluate the adjoint of the linearized forward operator of <span>$(DŒõ(m))^*[Y]$</span> stored within the <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a> (in place of <code>X</code>). Since <span>$Y‚ààT_n\mathcal N$</span>, both <span>$m$</span> and <span>$n=Œõ(m)$</span> are necessary arguments, mainly because the forward operator <span>$Œõ$</span> might be <code>missing</code> in <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/primal_dual_plan.jl#L405-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.forward_operator" href="#Manopt.forward_operator"><code>Manopt.forward_operator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = forward_operator(M::AbstractManifold, N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, p)
forward_operator!(M::AbstractManifold, N::AbstractManifold, q, apdmo::AbstractPrimalDualManifoldObjective, p)</code></pre><p>Evaluate the forward operator of <span>$Œõ(x)$</span> stored within the <a href="../problem/#Manopt.TwoManifoldProblem"><code>TwoManifoldProblem</code></a> (in place of <code>q</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/primal_dual_plan.jl#L335-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_differential_dual_prox" href="#Manopt.get_differential_dual_prox"><code>Manopt.get_differential_dual_prox</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Œ∑ = get_differential_dual_prox(N::AbstractManifold, pdsno::PrimalDualManifoldSemismoothNewtonObjective, n, œÑ, X, Œæ)
get_differential_dual_prox!(N::AbstractManifold, pdsno::PrimalDualManifoldSemismoothNewtonObjective, Œ∑, n, œÑ, X, Œæ)</code></pre><p>Evaluate the differential proximal map of <span>$G_n^*$</span> stored within <a href="#Manopt.PrimalDualManifoldSemismoothNewtonObjective"><code>PrimalDualManifoldSemismoothNewtonObjective</code></a></p><p class="math-container">\[D\operatorname{prox}_{œÑG_n^*}(X)[Œæ]\]</p><p>which can also be computed in place of <code>Œ∑</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/higher_order_primal_dual_plan.jl#L268-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_differential_primal_prox" href="#Manopt.get_differential_primal_prox"><code>Manopt.get_differential_primal_prox</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = get_differential_primal_prox(M::AbstractManifold, pdsno::PrimalDualManifoldSemismoothNewtonObjective œÉ, x)
get_differential_primal_prox!(p::TwoManifoldProblem, y, œÉ, x)</code></pre><p>Evaluate the differential proximal map of <span>$F$</span> stored within <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a></p><p class="math-container">\[D\operatorname{prox}_{œÉF}(x)[X]\]</p><p>which can also be computed in place of <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/higher_order_primal_dual_plan.jl#L187-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_dual_prox" href="#Manopt.get_dual_prox"><code>Manopt.get_dual_prox</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Y = get_dual_prox(N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, n, œÑ, X)
get_dual_prox!(N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, Y, n, œÑ, X)</code></pre><p>Evaluate the proximal map of <span>$g_n^*$</span> stored within <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a></p><p class="math-container">\[  Y = \operatorname{prox}_{œÑG_n^*}(X)\]</p><p>which can also be computed in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/primal_dual_plan.jl#L167-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_primal_prox" href="#Manopt.get_primal_prox"><code>Manopt.get_primal_prox</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = get_primal_prox(M::AbstractManifold, p::AbstractPrimalDualManifoldObjective, œÉ, p)
get_primal_prox!(M::AbstractManifold, p::AbstractPrimalDualManifoldObjective, q, œÉ, p)</code></pre><p>Evaluate the proximal map of <span>$F$</span> stored within <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a></p><p class="math-container">\[\operatorname{prox}_{œÉF}(x)\]</p><p>which can also be computed in place of <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/primal_dual_plan.jl#L99-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.linearized_forward_operator" href="#Manopt.linearized_forward_operator"><code>Manopt.linearized_forward_operator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Y = linearized_forward_operator(M::AbstractManifold, N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, m, X, n)
linearized_forward_operator!(M::AbstractManifold, N::AbstractManifold, Y, apdmo::AbstractPrimalDualManifoldObjective, m, X, n)</code></pre><p>Evaluate the linearized operator (differential) <span>$DŒõ(m)[X]$</span> stored within the <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a> (in place of <code>Y</code>), where <code>n = Œõ(m)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/primal_dual_plan.jl#L243-L249">source</a></section></article><h3 id="Constrained-objective"><a class="docs-heading-anchor" href="#Constrained-objective">Constrained objective</a><a id="Constrained-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-objective" title="Permalink"></a></h3><p>Besides the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> there is one further property to distinguish among constraint functions, especially the gradients of the constraints.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ConstraintType" href="#Manopt.ConstraintType"><code>Manopt.ConstraintType</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstraintType</code></pre><p>An abstract type to represent different forms of representing constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.FunctionConstraint" href="#Manopt.FunctionConstraint"><code>Manopt.FunctionConstraint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FunctionConstraint &lt;: ConstraintType</code></pre><p>A type to indicate that constraints are implemented one whole functions, e.g. <span>$g(p) ‚àà \mathbb R^m$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.VectorConstraint" href="#Manopt.VectorConstraint"><code>Manopt.VectorConstraint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorConstraint &lt;: ConstraintType</code></pre><p>A type to indicate that constraints are implemented a  vector of functions, e.g. <span>$g_i(p) ‚àà \mathbb R, i=1,‚Ä¶,m$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L16-L21">source</a></section></article><p>The <a href="#Manopt.ConstraintType"><code>ConstraintType</code></a> is a parameter of the corresponding Objective.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ConstrainedManifoldObjective" href="#Manopt.ConstrainedManifoldObjective"><code>Manopt.ConstrainedManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstrainedManifoldObjective{T&lt;:AbstractEvaluationType, C &lt;: ConstraintType Manifold} &lt;: AbstractManifoldObjective{T}</code></pre><p>Describes the constrained objective</p><p class="math-container">\[\begin{aligned}
 \operatorname*{arg\,min}_{p ‚àà\mathcal{M}} &amp; f(p)\\
 \text{subject to } &amp;g_i(p)\leq0 \quad \text{ for all } i=1,‚Ä¶,m,\\
 \quad &amp;h_j(p)=0 \quad \text{ for all } j=1,‚Ä¶,n.
\end{aligned}\]</p><p>It consists of</p><ul><li>an cost function <span>$f(p)$</span></li><li>the gradient of <span>$f$</span>, <span>$\operatorname{grad}f(p)$</span> <a href="#Manopt.AbstractManifoldGradientObjective"><code>AbstractManifoldGradientObjective</code></a></li><li>inequality constraints <span>$g(p)$</span>, either a function <code>g</code> returning a vector or a vector <code>[g1, g2,...,gm]</code> of functions.</li><li>equality constraints <span>$h(p)$</span>, either a function <code>h</code> returning a vector or a vector <code>[h1, h2,...,hn]</code> of functions.</li><li>gradient(s) of the inequality constraints <span>$\operatorname{grad}g(p) ‚àà (T_p\mathcal M)^m$</span>, either a function or a vector of functions.</li><li>gradient(s) of the equality constraints <span>$\operatorname{grad}h(p) ‚àà (T_p\mathcal M)^n$</span>, either a function or a vector of functions.</li></ul><p>There are two ways to specify the constraints <span>$g$</span> and <span>$h$</span>.</p><ol><li>as one <code>Function</code> returning a vector in <span>$\mathbb R^m$</span> and <span>$\mathbb R^n$</span> respectively. This might be easier to implement but requires evaluating <em>all</em> constraints even if only one is needed.</li><li>as a <code>AbstractVector{&lt;:Function}</code> where each function returns a real number. This requires each constraint to be implemented as a single function, but it is possible to evaluate also only a single constraint.</li></ol><p>The gradients <span>$\operatorname{grad}g$</span>, <span>$\operatorname{grad}h$</span> have to follow the same form. Additionally they can be implemented as in-place functions or as allocating ones. The gradient <span>$\operatorname{grad}F$</span> has to be the same kind. This difference is indicated by the <code>evaluation</code> keyword.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConstrainedManifoldObjective(f, grad_f, g, grad_g, h, grad_h;
    evaluation=AllocatingEvaluation()
)</code></pre><p>Where <code>f, g, h</code> describe the cost, inequality and equality constraints, respectively, as described above and <code>grad_f, grad_g, grad_h</code> are the corresponding gradient functions in one of the 4 formats. If the objective does not have inequality constraints, you can set <code>G</code> and <code>gradG</code> no <code>nothing</code>. If the problem does not have equality constraints, you can set <code>H</code> and <code>gradH</code> no <code>nothing</code> or leave them out.</p><pre><code class="nohighlight hljs">ConstrainedManifoldObjective(M::AbstractManifold, F, gradF;
    G=nothing, gradG=nothing, H=nothing, gradH=nothing;
    evaluation=AllocatingEvaluation()
)</code></pre><p>A keyword argument variant of the constructor above, where you can leave out either <code>G</code> and <code>gradG</code> <em>or</em> <code>H</code> and <code>gradH</code> but not both.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L24-L74">source</a></section></article><h4 id="Access-functions-7"><a class="docs-heading-anchor" href="#Access-functions-7">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-7" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_constraints" href="#Manopt.get_constraints"><code>Manopt.get_constraints</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_constraints(M::AbstractManifold, co::ConstrainedManifoldObjective, p)</code></pre><p>Return the vector <span>$(g_1(p),...g_m(p),h_1(p),...,h_n(p))$</span> from the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>P</code> containing the values of all constraints at <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L265-L270">source</a></section><section><div><pre><code class="language-julia hljs">get_constraints(M::AbstractManifold, emo::EmbeddedManifoldObjective, p)</code></pre><p>Return the vector <span>$(g_1(p),...g_m(p),h_1(p),...,h_n(p))$</span> defined in the embedding, that is embed <code>p</code> before calling the constraint function(s) stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_equality_constraint" href="#Manopt.get_equality_constraint"><code>Manopt.get_equality_constraint</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_equality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, j)</code></pre><p>evaluate the <code>j</code>th equality constraint <span>$(h(p))_j$</span> or <span>$h_j(p)$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> representation this still evaluates all constraints.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L307-L314">source</a></section><section><div><pre><code class="language-julia hljs">get_equality_constraint(M::AbstractManifold, emo::EmbeddedManifoldObjective, p, j)</code></pre><p>evaluate the <code>j</code>s equality constraint <span>$h_j(p)$</span> defined in the embedding, that is embed <code>p</code> before calling the constraint function(s) stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L224-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_equality_constraints" href="#Manopt.get_equality_constraints"><code>Manopt.get_equality_constraints</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_equality_constraints(M::AbstractManifold, co::ConstrainedManifoldObjective, p)</code></pre><p>evaluate all equality constraints <span>$h(p)$</span> of <span>$\bigl(h_1(p), h_2(p),\ldots,h_p(p)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <span>$P$</span> at <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L281-L286">source</a></section><section><div><pre><code class="language-julia hljs">get_equality_constraints(M::AbstractManifold, emo::EmbeddedManifoldObjective, p)</code></pre><p>Evaluate all equality constraints <span>$h(p)$</span> of <span>$\bigl(h_1(p), h_2(p),\ldots,h_p(p)\bigr)$</span> defined in the embedding, that is embed <code>p</code> before calling the constraint function(s) stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L213-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_inequality_constraint" href="#Manopt.get_inequality_constraint"><code>Manopt.get_inequality_constraint</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_inequality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, i)</code></pre><p>evaluate one equality constraint <span>$(g(p))_i$</span> or <span>$g_i(p)$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> representation this still evaluates all constraints.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L363-L370">source</a></section><section><div><pre><code class="language-julia hljs">get_inequality_constraint(M::AbstractManifold, ems::EmbeddedManifoldObjective, p, i)</code></pre><p>Evaluate the <code>i</code>s inequality constraint <span>$g_i(p)$</span> defined in the embedding, that is embed <code>p</code> before calling the constraint function(s) stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L246-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_inequality_constraints" href="#Manopt.get_inequality_constraints"><code>Manopt.get_inequality_constraints</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_inequality_constraints(M::AbstractManifold, co::ConstrainedManifoldObjective, p)</code></pre><p>Evaluate all inequality constraints <span>$g(p)$</span> or <span>$\bigl(g_1(p), g_2(p),\ldots,g_m(p)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <span>$P$</span> at <span>$p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L335-L340">source</a></section><section><div><pre><code class="language-julia hljs">get_inequality_constraints(M::AbstractManifold, ems::EmbeddedManifoldObjective, p)</code></pre><p>Evaluate all inequality constraints <span>$g(p)$</span> of <span>$\bigl(g_1(p), g_2(p),\ldots,g_m(p)\bigr)$</span> defined in the embedding, that is embed <code>p</code> before calling the constraint function(s) stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L234-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_grad_equality_constraint" href="#Manopt.get_grad_equality_constraint"><code>Manopt.get_grad_equality_constraint</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_equality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, j)</code></pre><p>evaluate the gradient of the <code>j</code> th equality constraint <span>$(\operatorname{grad} h(p))_j$</span> or <span>$\operatorname{grad} h_j(x)$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem, this function still evaluates the full gradient. For the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> and <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> of the problem, this function currently also calls <a href="#Manopt.get_equality_constraints"><code>get_equality_constraints</code></a>, since this is the only way to determine the number of constraints. It also allocates a full tangent vector.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L391-L400">source</a></section><section><div><pre><code class="language-julia hljs">X = get_grad_equality_constraint(M::AbstractManifold, emo::EmbeddedManifoldObjective, p, j)
get_grad_equality_constraint!(M::AbstractManifold, X, emo::EmbeddedManifoldObjective, p, j)</code></pre><p>evaluate the gradient of the <code>j</code>th equality constraint <span>$\operatorname{grad} h_j(p)$</span> defined in the embedding, that is embed <code>p</code> before calling the gradient function stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p><p>The returned gradient is then converted to a Riemannian gradient calling <a href="https://juliamanifolds.github.io/ManifoldDiff.jl/stable/library.html#ManifoldDiff.riemannian_gradient-Tuple{AbstractManifold,%20Any,%20Any}"><code>riemannian_gradient</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L258-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_grad_equality_constraints" href="#Manopt.get_grad_equality_constraints"><code>Manopt.get_grad_equality_constraints</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_equality_constraints(M::AbstractManifold, co::ConstrainedManifoldObjective, p)</code></pre><p>evaluate all gradients of the equality constraints <span>$\operatorname{grad} h(x)$</span> or <span>$\bigl(\operatorname{grad} h_1(x), \operatorname{grad} h_2(x),\ldots, \operatorname{grad}h_n(x)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>P</code> at <code>p</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> and <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem, this function currently also calls <a href="#Manopt.get_equality_constraints"><code>get_equality_constraints</code></a>, since this is the only way to determine the number of constraints.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L511-L521">source</a></section><section><div><pre><code class="language-julia hljs">X = get_grad_equality_constraints(M::AbstractManifold, emo::EmbeddedManifoldObjective, p)
get_grad_equality_constraints!(M::AbstractManifold, X, emo::EmbeddedManifoldObjective, p)</code></pre><p>evaluate the gradients of the the equality constraints <span>$\operatorname{grad} h(p)$</span> defined in the embedding, that is embed <code>p</code> before calling the gradient function stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p><p>The returned gradients are then converted to a Riemannian gradient calling <a href="https://juliamanifolds.github.io/ManifoldDiff.jl/stable/library.html#ManifoldDiff.riemannian_gradient-Tuple{AbstractManifold,%20Any,%20Any}"><code>riemannian_gradient</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L298-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_grad_equality_constraints!" href="#Manopt.get_grad_equality_constraints!"><code>Manopt.get_grad_equality_constraints!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_equality_constraints!(M::AbstractManifold, X, co::ConstrainedManifoldObjective, p)</code></pre><p>evaluate all gradients of the equality constraints <span>$\operatorname{grad} h(p)$</span> or <span>$\bigl(\operatorname{grad} h_1(p), \operatorname{grad} h_2(p),\ldots,\operatorname{grad} h_n(p)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <span>$P$</span> at <span>$p$</span> in place of <code>X</code><code>, which is a vector of</code><code>n</code>` tangent vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L564-L569">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_grad_equality_constraint!" href="#Manopt.get_grad_equality_constraint!"><code>Manopt.get_grad_equality_constraint!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_equality_constraint!(M::AbstractManifold, X, co::ConstrainedManifoldObjective, p, j)</code></pre><p>Evaluate the gradient of the <code>j</code>th equality constraint <span>$(\operatorname{grad} h(x))_j$</span> or <span>$\operatorname{grad} h_j(x)$</span> in place of <span>$X$</span></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem, this function still evaluates the full gradient. For the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> of the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> of the problem, this function currently also calls <a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a>, since this is the only way to determine the number of constraints and allocates a full vector of tangent vectors</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L447-L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_grad_inequality_constraint" href="#Manopt.get_grad_inequality_constraint"><code>Manopt.get_grad_inequality_constraint</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_inequality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, i)</code></pre><p>Evaluate the gradient of the <code>i</code> th inequality constraints <span>$(\operatorname{grad} g(x))_i$</span> or <span>$\operatorname{grad} g_i(x)$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem, this function still evaluates the full gradient. For the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> and <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> of the problem, this function currently also calls <a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a>, since this is the only way to determine the number of constraints.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L619-L628">source</a></section><section><div><pre><code class="language-julia hljs">X = get_grad_inequality_constraint(M::AbstractManifold, emo::EmbeddedManifoldObjective, p, i)
get_grad_inequality_constraint!(M::AbstractManifold, X, emo::EmbeddedManifoldObjective, p, i)</code></pre><p>evaluate the gradient of the <code>i</code>th inequality constraint <span>$\operatorname{grad} g_i(p)$</span> defined in the embedding, that is embed <code>p</code> before calling the gradient function stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p><p>The returned gradient is then converted to a Riemannian gradient calling <a href="https://juliamanifolds.github.io/ManifoldDiff.jl/stable/library.html#ManifoldDiff.riemannian_gradient-Tuple{AbstractManifold,%20Any,%20Any}"><code>riemannian_gradient</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L325-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_grad_inequality_constraint!" href="#Manopt.get_grad_inequality_constraint!"><code>Manopt.get_grad_inequality_constraint!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_inequality_constraint!(P, X, p, i)</code></pre><p>Evaluate the gradient of the <code>i</code>th inequality constraints <span>$(\operatorname{grad} g(x))_i$</span> or <span>$\operatorname{grad} g_i(x)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>P</code> in place of <span>$X$</span></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem, this function still evaluates the full gradient. For the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> and <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> of the problem, this function currently also calls <a href="#Manopt.get_inequality_constraints"><code>get_inequality_constraints</code></a>,</p></div></div><p>since this is the only way to determine the number of constraints. evaluate all gradients of the inequality constraints <span>$\operatorname{grad} h(x)$</span> or <span>$\bigl(g_1(x), g_2(x),\ldots,g_m(x)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <span>$p$</span> at <span>$x$</span> in place of <code>X</code><code>, which is a vector of</code><code>m</code>` tangent vectors .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L675-L687">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_grad_inequality_constraints" href="#Manopt.get_grad_inequality_constraints"><code>Manopt.get_grad_inequality_constraints</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_inequality_constraints(M::AbstractManifold, co::ConstrainedManifoldObjective, p)</code></pre><p>evaluate all gradients of the inequality constraints <span>$\operatorname{grad} g(p)$</span> or <span>$\bigl(\operatorname{grad} g_1(p), \operatorname{grad} g_2(p),‚Ä¶,\operatorname{grad} g_m(p)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <span>$P$</span> at <span>$p$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>for the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> and <a href="#Manopt.FunctionConstraint"><code>FunctionConstraint</code></a> variant of the problem,    this function currently also calls <a href="#Manopt.get_equality_constraints"><code>get_equality_constraints</code></a>,    since this is the only way to determine the number of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L739-L749">source</a></section><section><div><pre><code class="language-julia hljs">X = get_grad_inequality_constraints(M::AbstractManifold, emo::EmbeddedManifoldObjective, p)
get_grad_inequality_constraints!(M::AbstractManifold, X, emo::EmbeddedManifoldObjective, p)</code></pre><p>evaluate the gradients of the the inequality constraints <span>$\operatorname{grad} g(p)$</span> defined in the embedding, that is embed <code>p</code> before calling the gradient function stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p><p>The returned gradients are then converted to a Riemannian gradient calling <a href="https://juliamanifolds.github.io/ManifoldDiff.jl/stable/library.html#ManifoldDiff.riemannian_gradient-Tuple{AbstractManifold,%20Any,%20Any}"><code>riemannian_gradient</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/embedded_objective.jl#L365-L374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_grad_inequality_constraints!" href="#Manopt.get_grad_inequality_constraints!"><code>Manopt.get_grad_inequality_constraints!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_grad_inequality_constraints!(M::AbstractManifold, X, co::ConstrainedManifoldObjective, p)</code></pre><p>evaluate all gradients of the inequality constraints <span>$\operatorname{grad} g(x)$</span> or <span>$\bigl(\operatorname{grad} g_1(x), \operatorname{grad} g_2(x),\ldots,\operatorname{grad} g_m(x)\bigr)$</span> of the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>P</code> at <code>p</code> in place of <code>X</code>, which is a vector of <span>$m$</span> tangent vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/constrained_plan.jl#L792-L797">source</a></section></article><h3 id="Subproblem-objective"><a class="docs-heading-anchor" href="#Subproblem-objective">Subproblem objective</a><a id="Subproblem-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Subproblem-objective" title="Permalink"></a></h3><p>This objective can be use when the objective of a sub problem solver still needs access to the (outer/main) objective.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractManifoldSubObjective" href="#Manopt.AbstractManifoldSubObjective"><code>Manopt.AbstractManifoldSubObjective</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>AbstractManifoldSubObjective{O&lt;:AbstractManifoldObjective} &lt;: AbstractManifoldObjective</p><p>An abstract type for objectives of sub problems within a solver but still store the original objective internally to generate generic objectives for sub solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/subsolver_plan.jl#L8-L13">source</a></section></article><h4 id="Access-functions-8"><a class="docs-heading-anchor" href="#Access-functions-8">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-8" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_objective_cost" href="#Manopt.get_objective_cost"><code>Manopt.get_objective_cost</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_objective_cost(M, amso::AbstractManifoldSubObjective, p)</code></pre><p>Evaluate the cost of the (original) objective stored within the subobjective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/subsolver_plan.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_objective_gradient" href="#Manopt.get_objective_gradient"><code>Manopt.get_objective_gradient</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">X = get_objective_gradient(M, amso::AbstractManifoldSubObjective, p)
get_objective_gradient!(M, X, amso::AbstractManifoldSubObjective, p)</code></pre><p>Evaluate the gradient of the (original) objective stored within the subobjective <code>amso</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/subsolver_plan.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_objective_hessian" href="#Manopt.get_objective_hessian"><code>Manopt.get_objective_hessian</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Y = get_objective_Hessian(M, amso::AbstractManifoldSubObjective, p, X)
get_objective_Hessian!(M, Y, amso::AbstractManifoldSubObjective, p, X)</code></pre><p>Evaluate the Hessian of the (original) objective stored within the subobjective <code>amso</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/subsolver_plan.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_objective_preconditioner" href="#Manopt.get_objective_preconditioner"><code>Manopt.get_objective_preconditioner</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Y = get_objective_preconditioner(M, amso::AbstractManifoldSubObjective, p, X)
get_objective_preconditioner(M, Y, amso::AbstractManifoldSubObjective, p, X)</code></pre><p>Evaluate the Hessian of the (original) objective stored within the subobjective <code>amso</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/898f3d91d30a715028dadb99365e9afce2cf1124/src/plans/subsolver_plan.jl#L75-L80">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>This cache requires <a href="https://github.com/JuliaCollections/LRUCache.jl"><code>LRUCache.jl</code></a> to be loaded as well.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problem/">¬´ Problem</a><a class="docs-footer-nextpage" href="../state/">Solver State ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 18 January 2024 17:36">Thursday 18 January 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
