<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stepsize ¬∑ Manopt.jl</title><meta name="title" content="Stepsize ¬∑ Manopt.jl"/><meta property="og:title" content="Stepsize ¬∑ Manopt.jl"/><meta property="twitter:title" content="Stepsize ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/getstarted/">üèîÔ∏è Get started with Manopt.jl</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../../tutorials/EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../../tutorials/HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../../tutorials/ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do constrained optimization</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">List of Solvers</a></li><li><a class="tocitem" href="../../solvers/adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/cma_es/">CMA-ES</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/conjugate_residual/">Conjugate Residual</a></li><li><a class="tocitem" href="../../solvers/convex_bundle_method/">Convex bundle method</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/interior_point_Newton/">Interior Point Newton</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="../../solvers/mesh_adaptive_direct_search/">Mesh Adaptive Direct Search</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/projected_gradient_method/">Projected Gradient Method</a></li><li><a class="tocitem" href="../../solvers/proximal_bundle_method/">Proximal bundle method</a></li><li><a class="tocitem" href="../../solvers/proximal_gradient_method/">Proximal Gradient Method</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li><li><a class="tocitem" href="../../solvers/vectorbundle_newton/">Vector Bundle Newton Method</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../">Specify a Solver</a></li><li><a class="tocitem" href="../problem/">Problem</a></li><li><a class="tocitem" href="../objective/">Objective</a></li><li><a class="tocitem" href="../state/">Solver State</a></li><li class="is-active"><a class="tocitem" href>Stepsize</a><ul class="internal"><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../debug/">Debug Output</a></li><li><a class="tocitem" href="../record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li><li><a class="tocitem" href="../../helpers/test/">Test</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plans</a></li><li class="is-active"><a href>Stepsize</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stepsize</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/plans/stepsize.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sec-Stepsize"><a class="docs-heading-anchor" href="#Sec-Stepsize">Stepsize and line search</a><a id="Sec-Stepsize-1"></a><a class="docs-heading-anchor-permalink" href="#Sec-Stepsize" title="Permalink"></a></h1><p>Most iterative algorithms determine a direction along which the algorithm shall proceed and determine a step size to find the next iterate. How advanced the step size computation can be implemented depends (among others) on the properties the corresponding problem provides.</p><p>Within <code>Manopt.jl</code>, the step size determination is implemented as a <code>functor</code> which is a subtype of <a href="#Manopt.Stepsize"><code>Stepsize</code></a> based on</p><article><details class="docstring" open="true"><summary id="Manopt.Stepsize"><a class="docstring-binding" href="#Manopt.Stepsize"><code>Manopt.Stepsize</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Stepsize</code></pre><p>An abstract type for the functors representing step sizes. These are callable structures. The naming scheme is <code>TypeOfStepSize</code>, for example <code>ConstantStepsize</code>.</p><p>Every Stepsize has to provide a constructor and its function has to have the interface <code>(p,o,i)</code> where a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> as well as <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> and the current number of iterations are the arguments and returns a number, namely the stepsize to use.</p><p>The functor usually should accept arbitrary keyword arguments. Common ones used are</p><ul><li><code>gradient=nothing</code>: to pass a pre-calculated gradient, otherwise it is computed.</li></ul><p>For most it is advisable to employ a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a>. Then the function creating the factory should either be called <code>TypeOf</code> or if that is confusing or too generic, <code>TypeOfLength</code></p><p><strong>See also</strong></p><p><a href="#Manopt.Linesearch"><code>Linesearch</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/linesearch.jl#L1-L21">source</a></section></details></article><p>Usually, a constructor should take the manifold <code>M</code> as its first argument, for consistency, to allow general step size functors to be set up based on default values that might depend on the manifold currently under consideration.</p><p>Currently, the following step sizes are available</p><article><details class="docstring" open="true"><summary id="Manopt.AdaptiveWNGradient"><a class="docstring-binding" href="#Manopt.AdaptiveWNGradient"><code>Manopt.AdaptiveWNGradient</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AdaptiveWNGradient(; kwargs...)
AdaptiveWNGradient(M::AbstractManifold; kwargs...)</code></pre><p>A stepsize based on the adaptive gradient method introduced by [<a href="../../references/#GrapigliaStella_2023">GS23</a>].</p><p>Given a positive threshold <span>$\hat{c} ‚àà ‚Ñï$</span>, an minimal bound <span>$b_{\text{min}} &gt; 0$</span>, an initial <span>$b_0 ‚â• b_{\text{min}}$</span>, and a gradient reduction factor threshold <span>$Œ± ‚àà [0,1)$</span>.</p><p>Set <span>$c_0=0$</span> and use <span>$œâ_0 = \lVert \operatorname{grad} f(p_0) \rVert_{p_0}$</span>.</p><p>For the first iterate use the initial step size <span>$s_0 = \frac{1}{b_0}$</span>.</p><p>Then, given the last gradient <span>$X_{k-1} = \operatorname{grad} f(x_{k-1})$</span>, and a previous <span>$œâ_{k-1}$</span>, the values <span>$(b_k, œâ_k, c_k)$</span> are computed using <span>$X_k = \operatorname{grad} f(p_k)$</span> and the following cases</p><p>If <span>$\lVert X_k \rVert_{p_k} ‚â§ Œ±œâ_{k-1}$</span>, then let <span>$\hat{b}_{k-1} ‚àà [b_{\text{min}},b_{k-1}]$</span> and set</p><p class="math-container">\[(b_k, œâ_k, c_k) = \begin{cases}   \bigl(\hat{b}_{k-1}, \lVert X_k \rVert_{p_k}, 0 \bigr) &amp; \text{ if } c_{k-1}+1 = \hat{c}\\\\    \bigl( b_{k-1} + \frac{\lVert X_k \rVert_{p_k}^2}{b_{k-1}}, œâ_{k-1}, c_{k-1}+1 \Bigr) &amp; \text{ if } c_{k-1}+1&lt;\hat{c}\end{cases}\]</p><p>If <span>$\lVert X_k \rVert_{p_k} &gt; Œ±œâ_{k-1}$</span>, the set</p><p class="math-container">\[(b_k, œâ_k, c_k) = \Bigl( b_{k-1} + \frac{\lVert X_k \rVert_{p_k}^2}{b_{k-1}}, œâ_{k-1}, 0 \Bigr)\]</p><p>and return the step size <span>$s_k = \frac{1}{b_k}$</span>.</p><p>Note that for <span>$Œ±=0$</span> this is the Riemannian variant of <code>WNGRad</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>adaptive=true</code>: switches the <code>gradient_reduction</code><code>Œ±</code><code>(if</code>true<code>) to</code>0`.</li><li><code>alternate_bound = (bk, hat_c) -&gt;  min(gradient_bound == 0 ? 1.0 : gradient_bound, max(minimal_bound, bk / (3 * hat_c))</code>: how to determine <span>$\hat{k}_k$</span> as a function of <code>(bmin, bk, hat_c) -&gt; hat_bk</code></li><li><code>count_threshold=4</code>:  an <code>Integer</code> for <span>$\hat{c}$</span></li><li><code>gradient_reduction::R=adaptive ? 0.9 : 0.0</code>: the gradient reduction factor threshold <span>$Œ± ‚àà [0,1)$</span></li><li><code>gradient_bound=norm(M, p, X)</code>: the bound <span>$b_k$</span>.</li><li><code>minimal_bound=1e-4</code>: the value <span>$b_{\text{min}}$</span></li><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>only used to define the <code>gradient_bound</code></li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>only used to define the <code>gradient_bound</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L350-L397">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.ArmijoLinesearch"><a class="docstring-binding" href="#Manopt.ArmijoLinesearch"><code>Manopt.ArmijoLinesearch</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ArmijoLinesearch(; kwargs...)
ArmijoLinesearch(M::AbstractManifold; kwargs...)</code></pre><p>Specify a step size that performs an Armijo line search. Given a Function <span>$f:\mathcal M‚Üí‚Ñù$</span> and its Riemannian Gradient <span>$\operatorname{grad}f: \mathcal M‚ÜíT\mathcal M$</span>, the curent point <span>$p‚àà\mathcal M$</span> and a search direction <span>$X‚ààT_{p}\mathcal M$</span>.</p><p>Then the step size <span>$s$</span> is found by reducing the initial step size <span>$s$</span> until</p><p class="math-container">\[f(\operatorname{retr}_p(sX)) ‚â§ f(p) - œÑs ‚ü® X, \operatorname{grad}f(p) ‚ü©_p\]</p><p>is fulfilled. for a sufficient decrease value <span>$œÑ ‚àà (0,1)$</span>.</p><p>To be a bit more optimistic, if <span>$s$</span> already fulfils this, a first search is done, <strong>increasing</strong> the given <span>$s$</span> until for a first time this step does not hold.</p><p>Overall, we look for step size, that provides <em>enough decrease</em>, see [<a href="../../references/#Boumal_2023">Bou23</a>, p. 58] for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><code>additional_decrease_condition=(M, p) -&gt; true</code>: specify an additional criterion that has to be met to accept a step size in the decreasing loop</li><li><code>additional_increase_condition::IF=(M, p) -&gt; true</code>: specify an additional criterion that has to be met to accept a step size in the (initial) increase loop</li><li><code>candidate_point=allocate_result(M, rand)</code>: specify a point to be used as memory for the candidate points.</li><li><code>contraction_factor=0.95</code>: how to update <span>$s$</span> in the decrease step</li><li><code>initial_stepsize=1.0</code>: specify an initial step size</li><li><code>initial_guess=</code><a href="#Manopt.ArmijoInitialGuess"><code>ArmijoInitialGuess</code></a><code>()</code>: Compute the initial step size of a line search based on this function. See <a href="#Manopt.AbstractInitialLinesearchGuess"><code>AbstractInitialLinesearchGuess</code></a> for details.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less=0.0</code>: a safeguard, stop when the decreasing step is below this (nonnegative) bound.</li><li><code>stop_when_stepsize_exceeds=max_stepsize(M)</code>: a safeguard to not choose a too long step size when initially increasing</li><li><code>stop_increasing_at_step=100</code>: stop the initial increasing loop after this amount of steps. Set to <code>0</code> to never increase in the beginning</li><li><code>stop_decreasing_at_step=1000</code>: maximal number of Armijo decreases / tests to perform</li><li><code>sufficient_decrease=0.1</code>: the sufficient decrease parameter <span>$œÑ$</span></li></ul><p>For the stop safe guards you can pass <code>:Messages</code> to a <code>debug=</code> to see <code>@info</code> messages when these happen.</p><div class="admonition is-info" id="Info-963724cbadf3623a"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-963724cbadf3623a" title="Permalink"></a></header><div class="admonition-body"><p>This function generates a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.ArmijoLinesearchStepsize"><code>ArmijoLinesearchStepsize</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L179-L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.ConstantLength"><a class="docstring-binding" href="#Manopt.ConstantLength"><code>Manopt.ConstantLength</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ConstantLength(s; kwargs...)
ConstantLength(M::AbstractManifold, s; kwargs...)</code></pre><p>Specify a <a href="#Manopt.Stepsize"><code>Stepsize</code></a> that is constant.</p><p><strong>Input</strong></p><ul><li><code>M</code> (optional)</li><li><code>s=min( injectivity_radius(M)/2, 1.0)</code> : the length to use.</li></ul><p><strong>Keyword argument</strong></p><ul><li><code>type::Symbol=:relative</code> specify the type of constant step size. Possible values are<ul><li><code>:relative</code> ‚Äì scale the gradient tangent vector <span>$X$</span> to <span>$s*X$</span></li><li><code>:absolute</code> ‚Äì scale the gradient to an absolute step length <span>$s$</span>, that is <span>$\frac{s}{\lVert X \rVert_{}}X$</span></li></ul></li></ul><div class="admonition is-info" id="Info-b9b9aabe89650732"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-b9b9aabe89650732" title="Permalink"></a></header><div class="admonition-body"><p>This function generates a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.ConstantStepsize"><code>ConstantStepsize</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L463-L481">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.CubicBracketingLinesearch"><a class="docstring-binding" href="#Manopt.CubicBracketingLinesearch"><code>Manopt.CubicBracketingLinesearch</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">CubicBracketingLinesearch(; kwargs...)
CubicBracketingLinesearch(M::AbstractManifold; kwargs...)</code></pre><p>A functor representing the curvature minimizing cubic bracketing scheme introduced in [<a href="../../references/#Hager_1989">Hag89</a>]. Firstly, a bracket <span>$[a,b]$</span> is generated by multiplying <span>$t_0$</span> chosen as <code>last_stepsize</code> (or in case of the first iteration <code>initial_stepsize</code>) repeatedly with the <code>stepsize_increase &gt; 1</code> until the bracket conditions</p><p class="math-container">\[    œï&#39;(a)(b-a) &lt; 0  \quad \text{and} \quad œï(a) ‚â§ œï(b).\]</p><p>is satisfied by either <span>$[a,b] = [t_{k-1},t_k]$</span>, <span>$[a,b] = [t_k,t_{k-1}]$</span>, <span>$[a,b] = [0,t_k]$</span>, or <span>$[a,b] = [t_k,0]$</span>. Here, <span>$œï(t)$</span> denotes the cost function when performing a step with size <span>$t$</span> into direction <span>$Œ∑$</span>. Over the iteration, the bracket <span>$[a,b]$</span> is repeatedly updated using a cubic polynomial using values of <span>$œï, œï&#39;$</span> at <span>$a,b$</span>. The update value <span>$c$</span> is the local minimum of the polynomial, and the bracket coindition ensures that it lies inbetween <span>$a$</span> and <span>$b$</span>. We note that the update strategy taken from [<a href="../../references/#Hager_1989">Hag89</a>] ensures that the updated bracket satsifies the bracket condtion.</p><p>If the parameter <code>hybrid</code> is set to <code>true</code>, the hybrid approach from [<a href="../../references/#Hager_1989">Hag89</a>] is activated, which prevents slow convergence in edge cases.</p><p>The algorithm terminates if at any point the found candidate stepsize suffices the curvature condition induced by <code>sufficient_curvature</code><code>or the bracket</code><code>[a,b]</code><code>is smaller than the</code>min<em>bracket</em>width`.</p><p><strong>Keyword arguments</strong></p><ul><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>to store an interim result</li><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.allocate_result-Tuple%7BAbstractManifold%2C%20Any%2C%20Vararg%7BAny%7D%7D"><code>allocate_result</code></a><code>(M, rand)</code>: to store an interim result</li><li><code>initial_stepsize=1.0</code>: the step size to start the search with</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stepsize_increase=1.1</code>:  step size increase factor <span>$&gt;1$</span></li><li><code>max_iterations=100</code>: maximum number of iterations</li><li><code>sufficient_curvature=0.2</code>: target reduction of the curvature <span>$(0,1)$</span></li><li><code>min_bracket_width=1e-4</code>: minimal size of the bracket <span>$[a,b]$</span></li><li><code>hybrid=true</code>: use the hybrid strategy</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><div class="admonition is-info" id="Info-85199f7594d46a55"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-85199f7594d46a55" title="Permalink"></a></header><div class="admonition-body"><p>This function generates a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.CubicBracketingLinesearch"><code>CubicBracketingLinesearch</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L805-L848">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.DecreasingLength"><a class="docstring-binding" href="#Manopt.DecreasingLength"><code>Manopt.DecreasingLength</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DegreasingLength(; kwargs...)
DecreasingLength(M::AbstractManifold; kwargs...)</code></pre><p>Specify a [<code>Stepsize</code>]  that is decreasing as ``s_k = \frac{(l - ak)f^i}{(k+s)^e} with the following</p><p><strong>Keyword arguments</strong></p><ul><li><code>exponent=1.0</code>:   the exponent <span>$e$</span> in the denominator</li><li><code>factor=1.0</code>:     the factor <span>$f$</span> in the nominator</li><li><code>length=min(injectivity_radius(M)/2, 1.0)</code>: the initial step size <span>$l$</span>.</li><li><code>subtrahend=0.0</code>: a value <span>$a$</span> that is subtracted every iteration</li><li><code>shift=0.0</code>:      shift the denominator iterator <span>$k$</span> by <span>$s$</span>.</li><li><code>type::Symbol=relative</code> specify the type of constant step size.</li><li><code>:relative</code> ‚Äì scale the gradient tangent vector <span>$X$</span> to <span>$s_k*X$</span></li><li><code>:absolute</code> ‚Äì scale the gradient to an absolute step length <span>$s_k$</span>, that is <span>$\frac{s_k}{\lVert X \rVert_{}}X$</span></li></ul><div class="admonition is-info" id="Info-7d2a029036dbe076"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-7d2a029036dbe076" title="Permalink"></a></header><div class="admonition-body"><p>This function generates a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.DecreasingStepsize"><code>DecreasingStepsize</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L930-L949">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.DistanceOverGradients"><a class="docstring-binding" href="#Manopt.DistanceOverGradients"><code>Manopt.DistanceOverGradients</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DistanceOverGradients(; kwargs...)
DistanceOverGradients(M::AbstractManifold; kwargs...)</code></pre><p>Create a factory for the <a href="#Manopt.DistanceOverGradientsStepsize"><code>DistanceOverGradientsStepsize</code></a>, the Riemannian Distance over Gradients (RDoG) learning-rate-free stepsize from [<a href="../../references/#DoddSharrockNemeth_2024">DSN24</a>]. It adapts via the maximum distance from the start point and the accumulated gradient norms, optionally corrected by the geometric curvature term <span>$Œ∂_Œ∫$</span>. It adapts without manual tuning by combining a distance proxy from the start point with accumulated gradient norms.</p><p>Definitions used by the implementation:</p><ul><li><span>$\bar r_t := \max(\,œµ,\, \max_{0\le s\le t} d(p_0, p_s)\,)$</span> tracks the maximum geodesic distance from the initial point <span>$p_0$</span> using the current iterate <span>$p_t$</span>.</li><li><span>$G_t := \displaystyle\sum_{s=0}^t \lVert g_s \rVert^2$</span>, where <span>$g_s = \operatorname{grad} f(p_s)$</span>.</li></ul><p>At iteration <span>$t$</span> the stepsize used here is</p><p class="math-container">\[Œ∑_t =
\begin{cases}
\frac{\bar r_t}{\sqrt{G_t}}, &amp; \text{if we do not use curvature,}\\
\frac{\bar r_t}{\sqrt{\,Œ∂_Œ∫(\bar r_t)\,}\,\sqrt{G_t}}, &amp; \text{if we use curvature.}
\end{cases}\]</p><p>with the geometric curvature function <span>$Œ∂_Œ∫(d)$</span> defined in <a href="#Manopt.geometric_curvature_function-Tuple{Real, Real}"><code>geometric_curvature_function</code></a>. The initialization in this implementation follows the paper: on the first call (<span>$t=0$</span>), we set <span>$G_0=\lVert g_0\rVert^2$</span>, <span>$\bar r_0 = œµ$</span> and take</p><p class="math-container">\[Œ∑_0 =
\begin{cases}
\frac{œµ}{\lVert g_0\rVert}, &amp; \text{if we do not use curvature,}\\
\frac{œµ}{\sqrt{\,Œ∂_Œ∫(œµ)\,}\,\lVert g_0\rVert}, &amp; \text{if we use curvature.}
\end{cases}\]</p><p>On subsequent calls, the state is updated as implemented: <span>$G_t ‚Üê G_{t-1} + \lVert g_t\rVert^2$</span> and <span>$\bar r_t ‚Üê \max(\bar r_{t-1}, d(p_0,p_t))$</span>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>initial_distance=1e-3</code>: initial distance estimate <span>$œµ$</span></li><li><code>use_curvature=false</code>: whether to include <span>$Œ∂_Œ∫$</span></li><li><code>sectional_curvature_bound=0.0</code>: curvature lower bound <span>$Œ∫$</span> (if known)</li></ul><div class="admonition is-info" id="Info-8f9493521c773caf"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-8f9493521c773caf" title="Permalink"></a></header><div class="admonition-body"><p>This function generates a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.DistanceOverGradientsStepsize"><code>DistanceOverGradientsStepsize</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L1160-L1213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.NonmonotoneLinesearch"><a class="docstring-binding" href="#Manopt.NonmonotoneLinesearch"><code>Manopt.NonmonotoneLinesearch</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">NonmonotoneLinesearch(; kwargs...)
NonmonotoneLinesearch(M::AbstractManifold; kwargs...)</code></pre><p>A functor representing a nonmonotone line search using the Barzilai-Borwein step size [<a href="../../references/#IannazzoPorcelli_2017">IP17</a>].</p><p>This method first computes</p><p>(x -&gt; p, F-&gt; f)</p><p class="math-container">\[y_{k} = \operatorname{grad}f(p_{k}) - \mathcal T_{p_k‚Üêp_{k-1}}\operatorname{grad}f(p_{k-1})\]</p><p>and</p><p class="math-container">\[s_{k} = - Œ±_{k-1} ‚ãÖ \mathcal T_{p_k‚Üêp_{k-1}}\operatorname{grad}f(p_{k-1}),\]</p><p>where <span>$Œ±_{k-1}$</span> is the step size computed in the last iteration and <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> is a vector transport. Then the Barzilai‚ÄîBorwein step size is</p><p class="math-container">\[Œ±_k^{\text{BB}} = \begin{cases}   \min(Œ±_{\text{max}}, \max(Œ±_{\text{min}}, œÑ_{k})), &amp; \text{if} ‚ü®s_{k}, y_{k}‚ü©_{p_k} &gt; 0,\\\\    Œ±_{\text{max}}, &amp; \text{else,}\end{cases}\]</p><p>where</p><p class="math-container">\[œÑ_{k} = \frac{‚ü®s_{k}, s_{k}‚ü©_{p_k}}{‚ü®s_{k}, y_{k}‚ü©_{p_k}},\]</p><p>if the direct strategy is chosen, or</p><p class="math-container">\[œÑ_{k} =  \frac{‚ü®s_{k}, y_{k}‚ü©_{p_k}}{‚ü®y_{k}, y_{k}‚ü©_{p_k}},\]</p><p>in case of the inverse strategy or an alternation between the two in cases for the alternating strategy. Then find the smallest <span>$h = 0, 1, 2, ‚Ä¶$</span> such that</p><p class="math-container">\[f(\operatorname{retr}_{p_k}(- œÉ^h Œ±_k^{\text{BB}} \operatorname{grad}f(p_k)))  ‚â§
\max_{1 ‚â§ j ‚â§ \max(k+1,m)} f(p_{k+1-j}) - Œ≥ œÉ^h Œ±_k^{\text{BB}} ‚ü®\operatorname{grad}F(p_k), \operatorname{grad}F(p_k)‚ü©_{p_k},\]</p><p>where <span>$œÉ ‚àà (0,1)$</span> is a step length reduction factor , <span>$m$</span> is the number of iterations after which the function value has to be lower than the current one and <span>$Œ≥ ‚àà (0,1)$</span> is the sufficient decrease parameter. Finally the step size is computed as</p><p class="math-container">\[Œ±_k = œÉ^h Œ±_k^{\text{BB}}.\]</p><p><strong>Keyword arguments</strong></p><ul><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>to store an interim result</li><li><code>p=allocate_result(M, rand)</code>: to store an interim result</li><li><code>initial_stepsize=1.0</code>: the step size to start the search with</li><li><code>memory_size=10</code>: number of iterations after which the cost value needs to be lower than the current one</li><li><code>bb_min_stepsize=1e-3</code>: lower bound for the Barzilai-Borwein step size greater than zero</li><li><code>bb_max_stepsize=1e3</code>: upper bound for the Barzilai-Borwein step size greater than min_stepsize</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>strategy=direct</code>: defines if the new step size is computed using the <code>:direct</code>, <code>:indirect</code> or <code>:alternating</code> strategy</li><li><code>storage=</code><a href="../state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a><code>(M; store_fields=[:Iterate, :Gradient])</code>: increase efficiency by using a <a href="../state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a> for <code>:Iterate</code> and <code>:Gradient</code>.</li><li><code>stepsize_reduction=0.5</code>:  step size reduction factor contained in the interval <span>$(0,1)$</span></li><li><code>sufficient_decrease=1e-4</code>: sufficient decrease parameter contained in the interval <span>$(0,1)$</span></li><li><code>stop_when_stepsize_less=0.0</code>: smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_when_stepsize_exceeds=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>): largest stepsize when to stop to avoid leaving the injectivity radius</li><li><code>stop_increasing_at_step=100</code>:  last step to increase the stepsize (phase 1),</li><li><code>stop_decreasing_at_step=1000</code>: last step size to decrease the stepsize (phase 2),</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L1453-L1518">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.Polyak"><a class="docstring-binding" href="#Manopt.Polyak"><code>Manopt.Polyak</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Polyak(; kwargs...)
Polyak(M::AbstractManifold; kwargs...)</code></pre><p>Compute a step size according to a method propsed by Polyak, cf. the Dynamic step size discussed in Section 3.2 of [<a href="../../references/#Bertsekas_2015">Ber15</a>]. This has been generalised here to both the Riemannian case and to approximate the minimum cost value.</p><p>Let <span>$f_{\text{best}$</span> be the best cost value seen until now during some iterative optimisation algorithm and let <span>$Œ≥_k$</span> be a sequence of numbers that is square summable, but not summable.</p><p>Then the step size computed here reads</p><p class="math-container">\[s_k = \frac{f(p^{(k)}) - f_{\text{best} + Œ≥_k}{\lVert ‚àÇf(p^{(k)})} \rVert_{}},\]</p><p>where <span>$‚àÇf$</span> denotes a nonzero-subgradient of <span>$f$</span> at the current iterate <span>$p^{(k)}$</span>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Polyak(; Œ≥ = k -&gt; 1/k, initial_cost_estimate=0.0)</code></pre><p>initialize the Polyak stepsize to a certain sequence and an initial estimate of <span>$f_{	ext{best}}$</span>.</p><div class="admonition is-info" id="Info-63a96c75b50e9aba"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-63a96c75b50e9aba" title="Permalink"></a></header><div class="admonition-body"><p>This function generates a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a> for <a href="#Manopt.PolyakStepsize"><code>PolyakStepsize</code></a>. For default values, that depend on the manifold, this factory postpones the construction until the manifold from for example a corresponding <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> is available.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L1585-L1612">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.WolfePowellLinesearch"><a class="docstring-binding" href="#Manopt.WolfePowellLinesearch"><code>Manopt.WolfePowellLinesearch</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">WolfePowellLinesearch(; kwargs...)
WolfePowellLinesearch(M::AbstractManifold; kwargs...)</code></pre><p>Perform a lineseach to fulfull both the Armijo-Goldstein conditions</p><p class="math-container">\[f\bigl( \operatorname{retr}_{p}(Œ±X) \bigr) ‚â§ f(p) + c_1 Œ±_k ‚ü®\operatorname{grad} f(p), X‚ü©_{p}\]</p><p>as well as the Wolfe conditions</p><p class="math-container">\[\frac{\mathrm{d}}{\mathrm{d}t} f\bigl(\operatorname{retr}_{p}(tX)\bigr)
\Big\vert_{t=Œ±}
‚â• c_2 \frac{\mathrm{d}}{\mathrm{d}t} f\bigl(\operatorname{retr}_{p}(tX)\bigr)\Big\vert_{t=0}.\]</p><p>for some given sufficient decrease coefficient <span>$c_1$</span> and some sufficient curvature condition coefficient<span>$c_2$</span>.</p><p>This is adopted from [<a href="../../references/#NocedalWright_2006">NW06</a>, Section 3.1]</p><p><strong>Keyword arguments</strong></p><ul><li><code>sufficient_decrease=10^(-4)</code></li><li><code>sufficient_curvature=0.999</code></li><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>as temporary storage for candidates</li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>as type of memory allocated for the candidates direction and tangent</li><li><code>max_stepsize=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>: largest stepsize allowed here.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less=0.0</code>: smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_increasing_at_step=100</code>: for the initial increase test (s_plus), stop after these many steps</li><li><code>stop_decreasing_at_step=1000</code>: for the initial decrease test (s_minus), stop after these many steps</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L1813-L1845">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.WolfePowellBinaryLinesearch"><a class="docstring-binding" href="#Manopt.WolfePowellBinaryLinesearch"><code>Manopt.WolfePowellBinaryLinesearch</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">WolfePowellBinaryLinesearch(; kwargs...)
WolfePowellBinaryLinesearch(M::AbstractManifold; kwargs...)</code></pre><p>Perform a lineseach to fulfull both the Armijo-Goldstein conditions for some given sufficient decrease coefficient <span>$c_1$</span> and some sufficient curvature condition coefficient<span>$c_2$</span>. Compared to <a href="#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a> which tries a simpler method, this linesearch performs the following algorithm</p><p>With</p><p class="math-container">\[A(t) = f(p_+) ‚â§ c_1 t ‚ü®\operatorname{grad}f(p), X‚ü©_{x}
\quad\text{ and }\quad
W(t) = ‚ü®\operatorname{grad}f(x_+), \mathcal T_{p_+‚Üêp}X‚ü©_{p_+} ‚â• c_2 ‚ü®X, \operatorname{grad}f(x)‚ü©_x,\]</p><p>where <span>$p_+ =\operatorname{retr}_p(tX)$</span> is the current trial point, and <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> denotes a vector transport. Then the following Algorithm is performed similar to Algorithm 7 from [<a href="../../references/#Huang_2014">Hua14</a>]</p><ol><li>set <span>$Œ±=0$</span>, <span>$Œ≤=‚àû$</span> and <span>$t=1$</span>.</li><li>While either <span>$A(t)$</span> does not hold or <span>$W(t)$</span> does not hold do steps 3-5.</li><li>If <span>$A(t)$</span> fails, set <span>$Œ≤=t$</span>.</li><li>If <span>$A(t)$</span> holds but <span>$W(t)$</span> fails, set <span>$Œ±=t$</span>.</li><li>If <span>$Œ≤&lt;‚àû$</span> set <span>$t=\frac{Œ±+Œ≤}{2}$</span>, otherwise set <span>$t=2Œ±$</span>.</li></ol><p><strong>Keyword arguments</strong></p><ul><li><code>sufficient_decrease=10^(-4)</code></li><li><code>sufficient_curvature=0.999</code></li><li><code>max_stepsize=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>: largest stepsize allowed here.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less=0.0</code>: smallest stepsize when to stop (the last one before is taken)</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L1987-L2005">source</a></section></details></article><p>Additionally, initial stepsize guesses are handled by subtypes of <code>AbstractInitialLinesearchGuess</code>:</p><article><details class="docstring" open="true"><summary id="Manopt.AbstractInitialLinesearchGuess"><a class="docstring-binding" href="#Manopt.AbstractInitialLinesearchGuess"><code>Manopt.AbstractInitialLinesearchGuess</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractInitialLinesearchGuess</code></pre><p>An abstract type for initial line search guess strategies. These are functors that map <code>(problem, state, k, last_stepsize, Œ∑) -&gt; Œ±_0</code>, where <code>Œ±_0</code> is the initial step size, based on</p><ul><li>an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>problem</code></li><li>an <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>state</code></li><li>the current iterate <code>k</code></li><li>the last step size <code>last_stepsize</code></li><li>the search direction <code>Œ∑</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/initial_guess.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.ConstantInitialGuess"><a class="docstring-binding" href="#Manopt.ConstantInitialGuess"><code>Manopt.ConstantInitialGuess</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConstantInitialGuess{TF} &lt;: AbstractInitialLinesearchGuess</code></pre><p>Implement a constant initial guess for line searches.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">ConstantInitialGuess(Œ±::TF)</code></pre><p>where <code>Œ±</code> is the constant initial step size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/initial_guess.jl#L16-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.ArmijoInitialGuess"><a class="docstring-binding" href="#Manopt.ArmijoInitialGuess"><code>Manopt.ArmijoInitialGuess</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ArmijoInitialGuess &lt;: AbstractInitialLinesearchGuess</code></pre><p>Implement the initial guess for an Armijo line search.</p><p>The initial step size is chosen as <code>min(l, max_stepsize(M, p) / norm(M, p, Œ∑))</code>, where <code>l</code> is the last step size used, <code>p</code> the current point and <code>Œ∑</code> the search direction.</p><p>The default provided is based on the <a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M)</code>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">ArmijoInitialGuess()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/initial_guess.jl#L38-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.HagerZhangInitialGuess"><a class="docstring-binding" href="#Manopt.HagerZhangInitialGuess"><code>Manopt.HagerZhangInitialGuess</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HagerZhangInitialGuess{TF &lt;: Real, TPN, TVN} &lt;: AbstractInitialLinesearchGuess</code></pre><p>Initial line search guess from the paper [<a href="../../references/#HagerZhang_2006_2">HZ06b</a>], following the procedure <code>initial</code>. The line search was adapted to the Riemannian setting by introducing customizable norms for point and tangent vectors and maximum stepsize <code>alphamax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/initial_guess.jl#L106-L112">source</a></section></details></article><p>Onw implementations can also (just) be functions.</p><p>Some step sizes use <a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a> function as a rough upper estimate for the trust region size. It is by default equal to injectivity radius of the exponential map but in some cases a different value is used. For the <code>FixedRankMatrices</code> manifold an estimate from Manopt is used. Tangent bundle with the Sasaki metric has 0 injectivity radius, so the maximum stepsize of the underlying manifold is used instead. <code>Hyperrectangle</code> also has 0 injectivity radius and an estimate based on maximum of dimensions along each index is used instead. For manifolds with corners, however, a line search capable of handling break points along the projected search direction should be used, and such algorithms do not call <code>max_stepsize</code>.</p><p>Internally these step size functions create a <a href="../#Manopt.ManifoldDefaultsFactory"><code>ManifoldDefaultsFactory</code></a>. Internally these use</p><article><details class="docstring" open="true"><summary id="Manopt.reset_messages!-Tuple{NamedTuple}"><a class="docstring-binding" href="#Manopt.reset_messages!-Tuple{NamedTuple}"><code>Manopt.reset_messages!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset_messages!(messages::NamedTuple)</code></pre><p>Given a named tuple of <code>[StepsizeMessage</code>](@ref)s, reset all messages to default values, i.e. <code>at_iteration = -1</code>, <code>bound = 0</code>, <code>value = 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize_message.jl#L42-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.set_message!-Tuple{NamedTuple, Symbol}"><a class="docstring-binding" href="#Manopt.set_message!-Tuple{NamedTuple, Symbol}"><code>Manopt.set_message!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_message!(messages::NamedTuple, key::Symbol; at=nothing, bound=nothing, value=nothing)</code></pre><p>Given a named tuple of <code>[StepsizeMessage</code>](@ref)s, set the message identified by <code>key</code> to the provided values, i.e. if they are not <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize_message.jl#L57-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.set_message!-Union{Tuple{Manopt.StepsizeMessage{TBound, TS}}, Tuple{TS}, Tuple{TBound}, Tuple{Manopt.StepsizeMessage{TBound, TS}, Union{Nothing, Int64}}, Tuple{Manopt.StepsizeMessage{TBound, TS}, Union{Nothing, Int64}, Union{Nothing, TBound}}, Tuple{Manopt.StepsizeMessage{TBound, TS}, Union{Nothing, Int64}, Union{Nothing, TBound}, Union{Nothing, TS}}} where {TBound&lt;:Real, TS&lt;:Real}"><a class="docstring-binding" href="#Manopt.set_message!-Union{Tuple{Manopt.StepsizeMessage{TBound, TS}}, Tuple{TS}, Tuple{TBound}, Tuple{Manopt.StepsizeMessage{TBound, TS}, Union{Nothing, Int64}}, Tuple{Manopt.StepsizeMessage{TBound, TS}, Union{Nothing, Int64}, Union{Nothing, TBound}}, Tuple{Manopt.StepsizeMessage{TBound, TS}, Union{Nothing, Int64}, Union{Nothing, TBound}, Union{Nothing, TS}}} where {TBound&lt;:Real, TS&lt;:Real}"><code>Manopt.set_message!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_message!(message::StepsizeMessage, at=nothing, bound=nothing, value=nothing)</code></pre><p>Given a named tuple of <code>[StepsizeMessage</code>](@ref)s, set the message identified by <code>key</code> to the provided values, i.e. if they are not <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize_message.jl#L72-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.StepsizeMessage"><a class="docstring-binding" href="#Manopt.StepsizeMessage"><code>Manopt.StepsizeMessage</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StepsizeMessage{TBound, TS}</code></pre><p>A message struct to hold stepsize information, when e.g. a step size underflow happens at a certain iteration</p><p><strong>Fields</strong></p><ul><li><code>at_iteration::Int</code>: The iteration at which the message was set</li><li><code>bound::TBound</code>: The bound that was hit</li><li><code>value::TS</code>: The corresponding value that either caused the message or provides additional information</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">StepsizeMessage(; bound::TBound = 0.0, value::TS = 0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize_message.jl#L1-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}"><a class="docstring-binding" href="#Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}"><code>Manopt.default_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">default_stepsize(M::AbstractManifold, ams::AbstractManoptSolverState)</code></pre><p>Returns the default <a href="#Manopt.Stepsize"><code>Stepsize</code></a> functor used when running the solver specified by the <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> running with an objective on the <code>AbstractManifold M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/linesearch.jl#L26-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.linesearch_backtrack!-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, Any, TF, Any, Any, Any, Any, T}} where {TF, T}"><a class="docstring-binding" href="#Manopt.linesearch_backtrack!-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, Any, TF, Any, Any, Any, Any, T}} where {TF, T}"><code>Manopt.linesearch_backtrack!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">s = linesearch_backtrack(M, F, p, s, decrease, contract, Œ∑; kwargs...)
s = linesearch_backtrack!(M, q, F, p, s, decrease, contract, Œ∑; kwargs...)</code></pre><p>perform a line search along <span>$ll_f(s) = f(\operatorname{retr}_p(sŒ∑)$</span> to find a stepsize <code>s</code>. See [<a href="../../references/#NocedalWright_2006">NW06</a>, Section 3] for details.</p><p>The linesearch starts with a first phase where the stepsize is increased as <span>$s ‚Ü¶ s / œÉ$</span> until</p><p class="math-container">\[f(\operatorname{retr}_p(sŒ∑)) ‚â• f(p) + a * s * Df(p)[Œ∑]
````

where ``a`` is the `decrease` parameter, and ``Df(p)[Œ∑]`` is the directional derivative.

Then the actual backtracking phase starts, where the stepsize is decreased as ``s ‚Ü¶ œÉ s``
until\]</p><p>math f(\operatorname{retr}_p(sŒ∑)) ‚â§ f(p) + b * s * Df(p)[Œ∑] ```</p><p>where <span>$b$</span> is the <code>decrease</code> parameter.</p><p>This can be done in-place, where <code>q</code> is the point to store the point reached in.</p><p>Both phases have a safeguard on the maximal number of steps to perform as well as an upper and lower bound for the stepsize, respectively. The upper bound is a special case on manifolds to avoid exceeding the injectivity radius. Furthermore, both phases can be equipped with additional conditions to be fulfilled in order to accept the current stepsize.</p><p><strong>Arguments</strong></p><ul><li>on manifold <code>M</code></li><li>for the cost function <code>f</code>,</li><li>at the current point <code>p</code></li><li>an initial stepsize <code>s</code></li><li>a sufficient <code>decrease</code></li><li>a <code>contract</code>ion factor <span>$œÉ$</span></li><li>a search direction <span>$Œ∑$</span></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></p></li><li><p><code>additional_increase_condition=(M,p) -&gt; true</code>: impose an additional condition for an increased step size to be accepted</p></li><li><p><code>additional_decrease_condition=(M,p) -&gt; true</code>: impose an additional condition for an decreased step size to be accepted</p></li><li><p><code>Dlf0</code>: precomputed directional derivative at point <code>p</code> in direction <code>Œ∑</code> if the <code>gradient</code> is specified, this is computed as the real part of <code>inner(M, p, gradient, Œ∑)</code>, otherwise it it nothing</p></li><li><p><code>lf0 = f(M, p)</code>: the function value at the initial point <code>p</code></p></li><li><p><code>gradient = nothing</code>: precomputed gradient at point <code>p</code></p></li><li><p><code>report_messages_in::NamedTuple = (; )</code>: a named tuple of <a href="#Manopt.StepsizeMessage"><code>StepsizeMessage</code></a>s to report messages in. currently supported keywords are <code>:non_descent_direction</code>, <code>:stepsize_exceeds</code>, <code>:stepsize_less</code>, <code>:stop_increasing</code>, <code>:stop_decreasing</code></p></li><li><p><code>stop_when_stepsize_less=0.0</code>: to avoid numerical underflow</p></li><li><p><code>stop_when_stepsize_exceeds=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p) / norm(M, p, Œ∑)</code>) to avoid leaving the injectivity radius on a manifold</p></li><li><p><code>stop_increasing_at_step=100</code>: stop the initial increase of step size after these many steps</p></li><li><p><code>stop_decreasing_at_step=</code>1000`: stop the decreasing search after these many steps</p><p>These keywords are used as safeguards, where only the max stepsize is a very manifold specific one.</p></li></ul><p><strong>Return value</strong></p><p>A stepsize <code>s</code> and a message <code>msg</code> (in case any of the 4 criteria hit)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/linesearch.jl#L152-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.linesearch_backtrack-Tuple{AbstractManifold, Vararg{Any, 6}}"><a class="docstring-binding" href="#Manopt.linesearch_backtrack-Tuple{AbstractManifold, Vararg{Any, 6}}"><code>Manopt.linesearch_backtrack</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">s = linesearch_backtrack(M, F, p, s, decrease, contract, Œ∑; kwargs...)
s = linesearch_backtrack!(M, q, F, p, s, decrease, contract, Œ∑; kwargs...)</code></pre><p>perform a line search along <span>$ll_f(s) = f(\operatorname{retr}_p(sŒ∑)$</span> to find a stepsize <code>s</code>. See [<a href="../../references/#NocedalWright_2006">NW06</a>, Section 3] for details.</p><p>The linesearch starts with a first phase where the stepsize is increased as <span>$s ‚Ü¶ s / œÉ$</span> until</p><p class="math-container">\[f(\operatorname{retr}_p(sŒ∑)) ‚â• f(p) + a * s * Df(p)[Œ∑]
````

where ``a`` is the `decrease` parameter, and ``Df(p)[Œ∑]`` is the directional derivative.

Then the actual backtracking phase starts, where the stepsize is decreased as ``s ‚Ü¶ œÉ s``
until\]</p><p>math f(\operatorname{retr}_p(sŒ∑)) ‚â§ f(p) + b * s * Df(p)[Œ∑] ```</p><p>where <span>$b$</span> is the <code>decrease</code> parameter.</p><p>This can be done in-place, where <code>q</code> is the point to store the point reached in.</p><p>Both phases have a safeguard on the maximal number of steps to perform as well as an upper and lower bound for the stepsize, respectively. The upper bound is a special case on manifolds to avoid exceeding the injectivity radius. Furthermore, both phases can be equipped with additional conditions to be fulfilled in order to accept the current stepsize.</p><p><strong>Arguments</strong></p><ul><li>on manifold <code>M</code></li><li>for the cost function <code>f</code>,</li><li>at the current point <code>p</code></li><li>an initial stepsize <code>s</code></li><li>a sufficient <code>decrease</code></li><li>a <code>contract</code>ion factor <span>$œÉ$</span></li><li>a search direction <span>$Œ∑$</span></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></p></li><li><p><code>additional_increase_condition=(M,p) -&gt; true</code>: impose an additional condition for an increased step size to be accepted</p></li><li><p><code>additional_decrease_condition=(M,p) -&gt; true</code>: impose an additional condition for an decreased step size to be accepted</p></li><li><p><code>Dlf0</code>: precomputed directional derivative at point <code>p</code> in direction <code>Œ∑</code> if the <code>gradient</code> is specified, this is computed as the real part of <code>inner(M, p, gradient, Œ∑)</code>, otherwise it it nothing</p></li><li><p><code>lf0 = f(M, p)</code>: the function value at the initial point <code>p</code></p></li><li><p><code>gradient = nothing</code>: precomputed gradient at point <code>p</code></p></li><li><p><code>report_messages_in::NamedTuple = (; )</code>: a named tuple of <a href="#Manopt.StepsizeMessage"><code>StepsizeMessage</code></a>s to report messages in. currently supported keywords are <code>:non_descent_direction</code>, <code>:stepsize_exceeds</code>, <code>:stepsize_less</code>, <code>:stop_increasing</code>, <code>:stop_decreasing</code></p></li><li><p><code>stop_when_stepsize_less=0.0</code>: to avoid numerical underflow</p></li><li><p><code>stop_when_stepsize_exceeds=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p) / norm(M, p, Œ∑)</code>) to avoid leaving the injectivity radius on a manifold</p></li><li><p><code>stop_increasing_at_step=100</code>: stop the initial increase of step size after these many steps</p></li><li><p><code>stop_decreasing_at_step=</code>1000`: stop the decreasing search after these many steps</p><p>These keywords are used as safeguards, where only the max stepsize is a very manifold specific one.</p></li></ul><p><strong>Return value</strong></p><p>A stepsize <code>s</code> and a message <code>msg</code> (in case any of the 4 criteria hit)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/linesearch.jl#L144-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.max_stepsize-Tuple{AbstractManifold, Any}"><a class="docstring-binding" href="#Manopt.max_stepsize-Tuple{AbstractManifold, Any}"><code>Manopt.max_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">max_stepsize(M::AbstractManifold, p)
max_stepsize(M::AbstractManifold)</code></pre><p>Get the maximum stepsize (at point <code>p</code>) on manifold <code>M</code>. It should be used to limit the distance an algorithm is trying to move in a single step.</p><p>By default, this returns <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.injectivity_radius-Tuple%7BAbstractManifold%7D"><code>injectivity_radius</code></a><code>(M)</code>, if this exists. If this is not available on the the method returns <code>Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/linesearch.jl#L34-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.Linesearch"><a class="docstring-binding" href="#Manopt.Linesearch"><code>Manopt.Linesearch</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Linesearch &lt;: Stepsize</code></pre><p>An abstract functor to represent line search type step size determinations, see <a href="#Manopt.Stepsize"><code>Stepsize</code></a> for details. One example is the <a href="#Manopt.ArmijoLinesearchStepsize"><code>ArmijoLinesearchStepsize</code></a> functor.</p><p>Compared to simple step sizes, the line search functors provide an interface of the form <code>(p,o,i,X) -&gt; s</code> with an additional (but optional) fourth parameter to provide a search direction; this should default to something reasonable, most prominently the negative gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/linesearch.jl#L65-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.cubic_polynomial_argmin-Union{Tuple{R}, Tuple{Manopt.UnivariateTriple{R}, Manopt.UnivariateTriple{R}}} where R"><a class="docstring-binding" href="#Manopt.cubic_polynomial_argmin-Union{Tuple{R}, Tuple{Manopt.UnivariateTriple{R}, Manopt.UnivariateTriple{R}}} where R"><code>Manopt.cubic_polynomial_argmin</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cubic_polynomial_argmin(a::UnivariateTriple, b::UnivariateTriple; warn::Bool = true)</code></pre><p>Returns the local minimizer of the cubic polynomial <span>$p$</span> with <span>$p(a.t)=a.f$</span>, <span>$p(b.t)=b.f$</span>, <span>$p&#39;(a.t)=a.df$</span>, <span>$p&#39;(b.t)=b.df$</span>.</p><p><strong>Input</strong></p><ul><li><code>a::UnivariateTriple{R}</code>: triple of bracket value <code>a</code></li><li><code>b::UnivariateTriple{R}</code>: triple bracket value <code>b</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>warn::Bool</code>: Boolean value if warnings should be displayed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L620-L632">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.cubic_stepsize_update_step-NTuple{4, Real}"><a class="docstring-binding" href="#Manopt.cubic_stepsize_update_step-NTuple{4, Real}"><code>Manopt.cubic_stepsize_update_step</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cubic_stepsize_update_step(a::Real, b::Real, c::Real, œÑ::Real)</code></pre><p>Step function to determine the stepsize update <code>c</code> described in [<a href="../../references/#Hager_1989">Hag89</a>].</p><p><strong>Input</strong></p><ul><li><code>a::Real</code>: first value of the bracket</li><li><code>b::Real</code>: second value of the bracket</li><li><code>c::Real</code>: update value</li><li><code>œÑ::Real</code>: minimal step tolerance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L666-L678">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.geometric_curvature_function-Tuple{Real, Real}"><a class="docstring-binding" href="#Manopt.geometric_curvature_function-Tuple{Real, Real}"><code>Manopt.geometric_curvature_function</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">geometric_curvature_function(Œ∫::Real, d::Real)</code></pre><p>Compute the geometric curvature function <span>$Œ∂_Œ∫(d)$</span> used by the RDoG stepsize:</p><p class="math-container">\[Œ∂_Œ∫(d) =
\begin{cases}
1, &amp; \text{if } Œ∫ \ge 0,\\[4pt]
\dfrac{\sqrt{|Œ∫|}\,d}{\tanh(\sqrt{|Œ∫|}\,d)}, &amp; \text{if } Œ∫ &lt; 0.
\end{cases}\]</p><p>For small arguments, a Taylor approximation is used for numerical stability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L1014-L1028">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.get_last_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}"><a class="docstring-binding" href="#Manopt.get_last_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}"><code>Manopt.get_last_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_last_stepsize(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, vars...)</code></pre><p>return the last computed stepsize stored within <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> when solving the <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>.</p><p>This method takes into account that <code>ams</code> might be decorated. In case this returns <code>NaN</code>, a concrete call to the stored stepsize is performed. For this, usually, the first of the <code>vars...</code> should be the current iterate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L2064-L2073">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.get_last_stepsize-Tuple{Stepsize, Vararg{Any}}"><a class="docstring-binding" href="#Manopt.get_last_stepsize-Tuple{Stepsize, Vararg{Any}}"><code>Manopt.get_last_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_last_stepsize(::Stepsize, vars...)</code></pre><p>return the last computed stepsize from within the stepsize. If no last step size is stored, this returns <code>NaN</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L2092-L2097">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.get_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}"><a class="docstring-binding" href="#Manopt.get_stepsize-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Vararg{Any}}"><code>Manopt.get_stepsize</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_stepsize(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, vars...)</code></pre><p>return the stepsize stored within <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> when solving the <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>. This method also works for decorated options and the <a href="#Manopt.Stepsize"><code>Stepsize</code></a> function within the options, by default stored in <code>ams.stepsize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L2010-L2017">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.get_univariate_triple!-Tuple{AbstractManoptProblem, Manopt.CubicBracketingLinesearchStepsize, Any, Any, Any}"><a class="docstring-binding" href="#Manopt.get_univariate_triple!-Tuple{AbstractManoptProblem, Manopt.CubicBracketingLinesearchStepsize, Any, Any, Any}"><code>Manopt.get_univariate_triple!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Get the <code>UnivariateTriple</code> of the problem <code>mp</code> related to the step with stepsize <span>$t$</span> from <span>$p$</span> in direction <span>$Œ∑$</span>.</p><p><strong>Input</strong></p><ul><li><code>mp::AbstractManoptProblem</code></li><li><code>cbls:::CubicBracketingLinesearchStepsize</code>: containing <code>retraction_method</code>, <code>vector_transport</code> and the temporary <code>candidate_point</code> and <code>candidate_direction</code></li><li><code>p</code>: point in the manifold of <code>mp</code></li><li><code>Œ∑</code>: search direction at <code>p</code></li><li><code>t::Real</code>: step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L692-L702">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.secant-Union{Tuple{R}, Tuple{Manopt.UnivariateTriple{R}, Manopt.UnivariateTriple{R}}} where R"><a class="docstring-binding" href="#Manopt.secant-Union{Tuple{R}, Tuple{Manopt.UnivariateTriple{R}, Manopt.UnivariateTriple{R}}} where R"><code>Manopt.secant</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">secant(a::UnivariateTriple, b::UnivariateTriple)</code></pre><p>Returns the extremal of the quadratic polynomial <span>$p$</span> with <span>$p&#39;(a.t)=a.df$</span>, <span>$p&#39;(b.t)=b.df$</span>.</p><p><strong>Input</strong></p><ul><li><code>a::UnivariateTriple{R}</code>: triple of bracket value <code>a</code></li><li><code>b::UnivariateTriple{R}</code>: triple bracket value <code>b</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L652-L661">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.update_bracket-Union{Tuple{R}, Tuple{Manopt.UnivariateTriple{R}, Manopt.UnivariateTriple{R}, Manopt.UnivariateTriple{R}}} where R"><a class="docstring-binding" href="#Manopt.update_bracket-Union{Tuple{R}, Tuple{Manopt.UnivariateTriple{R}, Manopt.UnivariateTriple{R}, Manopt.UnivariateTriple{R}}} where R"><code>Manopt.update_bracket</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_bracket(a::UnivariateTriple, b::UnivariateTriple, c::UnivariateTriple)</code></pre><p>Updates bracket w.r.t. the bracketing strategy in [<a href="../../references/#Hager_1989">Hag89</a>] (R3) - (R5).</p><p><strong>Input</strong></p><ul><li><code>a::UnivariateTriple{R}</code>: triple of bracket value <code>a</code></li><li><code>b::UnivariateTriple{R}</code>: triple bracket value <code>b</code></li><li><code>c::UnivariateTriple{R}</code>: triple of update value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L578-L587">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.AdaptiveWNGradientStepsize"><a class="docstring-binding" href="#Manopt.AdaptiveWNGradientStepsize"><code>Manopt.AdaptiveWNGradientStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AdaptiveWNGradientStepsize{I&lt;:Integer,R&lt;:Real,F&lt;:Function} &lt;: Stepsize</code></pre><p>A functor <code>problem, state, k, X) -&gt; s to an adaptive gradient method introduced by [GrapigliaStella:2023](@cite). See [</code>AdaptiveWNGradient`](@ref) for the mathematical details.</p><p><strong>Fields</strong></p><ul><li><code>count_threshold::I</code>: an <code>Integer</code> for <span>$\hat{c}$</span></li><li><code>minimal_bound::R</code>: the value for <span>$b_{\text{min}}$</span></li><li><code>alternate_bound::F</code>: how to determine <span>$\hat{k}_k$</span> as a function of <code>(bmin, bk, hat_c) -&gt; hat_bk</code></li><li><code>gradient_reduction::R</code>: the gradient reduction factor threshold <span>$Œ± ‚àà [0,1)$</span></li><li><code>gradient_bound::R</code>: the bound <span>$b_k$</span>.</li><li><code>weight::R</code>: <span>$œâ_k$</span> initialised to <span>$œâ_0 =$</span><code>norm(M, p, X)</code> if this is not zero, <code>1.0</code> otherwise.</li><li><code>count::I</code>: <span>$c_k$</span>, initialised to <span>$c_0 = 0$</span>.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">AdaptiveWNGrad(M::AbstractManifold; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>adaptive=true</code>: switches the <code>gradient_reduction</code><code>Œ±</code><code>(if</code>true<code>) to</code>0`.</li><li><code>alternate_bound = (bk, hat_c) -&gt;  min(gradient_bound == 0 ? 1.0 : gradient_bound, max(minimal_bound, bk / (3 * hat_c))</code></li><li><code>count_threshold=4</code></li><li><code>gradient_reduction::R=adaptive ? 0.9 : 0.0</code></li><li><code>gradient_bound=norm(M, p, X)</code></li><li><code>minimal_bound=1e-4</code></li><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>only used to define the <code>gradient_bound</code></li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>only used to define the <code>gradient_bound</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L228-L258">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.ArmijoLinesearchStepsize"><a class="docstring-binding" href="#Manopt.ArmijoLinesearchStepsize"><code>Manopt.ArmijoLinesearchStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ArmijoLinesearchStepsize &lt;: Linesearch</code></pre><p>A functor <code>problem, state, k, X; kwargs...) -&gt; s to provide an Armijo line search to compute step size, based on the search direction</code>X`.</p><p>This functor accepts the following keyword arguments:</p><p><strong>Fields</strong></p><ul><li><p><code>additional_decrease_condition</code>: specify a condition a new point has to additionally fulfill. The default accepts all points.</p></li><li><p><code>additional_increase_condition</code>: specify a condtion that additionally to checking a valid increase has to be fulfilled. The default accepts all points.</p></li><li><p><code>candidate_point</code>:               to store an interim result</p></li><li><p><code>initial_stepsize</code>:              and initial step size</p></li><li><p><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></p></li><li><p><code>contraction_factor</code>:            exponent for line search reduction</p></li><li><p><code>sufficient_decrease</code>:           gain within Armijo&#39;s rule</p></li><li><p><code>last_stepsize</code>:                 the last step size to start the search with</p></li><li><ul><li><code>initial_guess</code>: a function to provide an initial guess for the step size,</li></ul><p>it maps <code>(problem, state, k, last_stepsize, Œ∑) -&gt; Œ±_0</code> based on</p><ul><li>a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>problem</code></li><li>a <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>state</code></li><li>the current iterate <code>k</code></li><li>the last step size <code>last_stepsize</code></li><li>the search direction <code>Œ∑</code></li></ul><p>and should at least accept the keywords</p><ul><li><code>lf0 =</code><a href="../objective/#Manopt.get_cost"><code>get_cost</code></a><code>(problem, get_iterate(state))</code> the current cost at ^p<code>here interpreted as the initial point of</code>f<code>along the line search direction</code></li><li><code>Dlf0 =</code><a href="../objective/#Manopt.get_differential"><code>get_differential</code></a><code>(problem, get_iterate(state), Œ∑)</code> the directional derivative at point <code>p</code> in direction <code>Œ∑</code></li></ul></li><li><p><code>messages::NamedTuple</code>:          a named tuple to store possible <a href="#Manopt.StepsizeMessage"><code>StepsizeMessage</code></a> about the stepsize search.</p></li><li><p><code>stop_when_stepsize_less</code>:       smallest stepsize when to stop (the last one before is taken)</p></li><li><p><code>stop_when_stepsize_exceeds</code>:    largest stepsize when to stop.</p></li><li><p><code>stop_increasing_at_step</code>:       last step to increase the stepsize (phase 1),</p></li><li><p><code>stop_decreasing_at_step</code>:       last step size to decrease the stepsize (phase 2),</p></li></ul><p>Pass <code>:Messages</code> to a <code>debug=</code> to see <code>@info</code>s when these happen.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">ArmijoLinesearchStepsize(M::AbstractManifold; kwarg...)</code></pre><p>with the fields keyword arguments and the retraction is set to the default retraction on <code>M</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>candidate_point=</code>(<code>allocate_result(M, rand)</code>)</li><li><code>initial_stepsize=1.0</code></li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>contraction_factor=0.95</code></li><li><code>sufficient_decrease=0.1</code></li><li><code>last_stepsize=initialstepsize</code></li><li><code>initial_guess=</code><a href="#Manopt.ArmijoInitialGuess"><code>ArmijoInitialGuess</code></a><code>()</code></li><li><code>stop_when_stepsize_less=0.0</code>: stop when the stepsize decreased below this version.</li><li><code>stop_when_stepsize_exceeds=[</code>max_step<code>](@ref)</code>(M)`: provide an absolute maximal step size.</li><li><code>stop_increasing_at_step=100</code>: for the initial increase test, stop after these many steps</li><li><code>stop_decreasing_at_step=1000</code>: in the backtrack, stop after these many steps</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L1-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.ConstantStepsize"><a class="docstring-binding" href="#Manopt.ConstantStepsize"><code>Manopt.ConstantStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConstantStepsize &lt;: Stepsize</code></pre><p>A functor <code>(problem, state, ...) -&gt; s</code> to provide a constant step size <code>s</code>.</p><p><strong>Fields</strong></p><ul><li><code>length</code>: constant value for the step size</li><li><code>type</code>:   a symbol that indicates whether the stepsize is relatively (:relative),   with respect to the gradient norm, or absolutely (:absolute) constant.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ConstantStepsize(s::Real, t::Symbol=:relative)</code></pre><p>initialize the stepsize to a constant <code>s</code> of type <code>t</code>.</p><pre><code class="language-julia hljs">ConstantStepsize(
    M::AbstractManifold=DefaultManifold(),
    s=min(1.0, injectivity_radius(M)/2);
    type::Symbol=:relative
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L408-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.CubicBracketingLinesearchStepsize"><a class="docstring-binding" href="#Manopt.CubicBracketingLinesearchStepsize"><code>Manopt.CubicBracketingLinesearchStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CubicBracketingLinesearchStepsize{P,T,R&lt;:Real} &lt;: Linesearch</code></pre><p>Do a bracketing line search to find a step size <span>$Œ±$</span> that finds a local minimum along the  search direction <span>$X$</span> starting from <span>$p$</span>, utilizing cubic polynomial interpolation. See <a href="#Manopt.CubicBracketingLinesearch"><code>CubicBracketingLinesearch</code></a> for the mathematical details.</p><p><strong>Fields</strong></p><ul><li><code>candidate_point::P</code>: a point on the manifold <span>$\mathcal M$</span> as temporary storage for candidates</li><li><code>initial_stepsize::R</code>: the step size to start the search with</li><li><code>last_stepsize::R</code></li><li><code>retraction_method::AbstractRetractionMethod</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stepsize_increase::R</code>:  step size increase factor <span>$&gt;1$</span></li><li><code>max_iterations::I</code>: maximum number of iterations</li><li><code>sufficient_curvature::R</code>: target reduction of the curvature <span>$(0,1)$</span></li><li><code>min_bracket_width::R</code>: minimal size of the bracket <span>$[a,b]$</span></li><li><code>hybrid::Bool</code>: use the hybrid strategy</li><li><code>max_stepsize::R</code>: maximal stepsize</li><li><code>vector_transport_method::AbstractVectorTransportMethodP</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">CubicBracketingLinesearchStepsize(M::AbstractManifold; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>candidate_point=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span> as temporary storage for candidates</li><li><code>initial_stepsize=1.0</code>: the step size to start the search with</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stepsize_increase=1.1</code>:  step size increase factor <span>$&gt;1$</span></li><li><code>max_iterations=100</code>: maximum number of iterations</li><li><code>sufficient_curvature=0.2</code>: target reduction of the curvature <span>$(0,1)$</span></li><li><code>min_bracket_width=1e-4</code>: minimal size of the bracket <span>$[a,b]$</span></li><li><code>hybrid=true</code>: use the hybrid strategy</li><li><code>max_stepsize= max_stepsize(M)</code>: maximal stepsize</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L486-L523">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.DecreasingStepsize"><a class="docstring-binding" href="#Manopt.DecreasingStepsize"><code>Manopt.DecreasingStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DecreasingStepsize()</code></pre><p>A functor <code>(problem, state, ...) -&gt; s</code> to provide a constant step size <code>s</code>.</p><p><strong>Fields</strong></p><ul><li><code>exponent</code>:   a value <span>$e$</span> the current iteration numbers <span>$e$</span>th exponential is taken of</li><li><code>factor</code>:     a value <span>$f$</span> to multiply the initial step size with every iteration</li><li><code>length</code>:     the initial step size <span>$l$</span>.</li><li><code>subtrahend</code>: a value <span>$a$</span> that is subtracted every iteration</li><li><code>shift</code>:      shift the denominator iterator <span>$i$</span> by <span>$s$</span>`.</li><li><code>type</code>:       a symbol that indicates whether the stepsize is relatively (:relative),   with respect to the gradient norm, or absolutely (:absolute) constant.</li></ul><p>In total the complete formulae reads for the <span>$i$</span>th iterate as</p><p class="math-container">\[s_i = \frac{(l - i a)f^i}{(i+s)^e}\]</p><p>and hence the default simplifies to just <span>$s_i = rac{l}{i}$</span></p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DecreasingStepsize(M::AbstractManifold;
    length=min(injectivity_radius(M)/2, 1.0),
    factor=1.0,
    subtrahend=0.0,
    exponent=1.0,
    shift=0.0,
    type=:relative,
)</code></pre><p>initializes all fields, where none of them is mandatory and the length is set to half and to <span>$1$</span> if the injectivity radius is infinite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L854-L891">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.DistanceOverGradientsStepsize"><a class="docstring-binding" href="#Manopt.DistanceOverGradientsStepsize"><code>Manopt.DistanceOverGradientsStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DistanceOverGradientsStepsize{R&lt;:Real} &lt;: Stepsize</code></pre><p><strong>Fields</strong></p><ul><li><code>initial_distance::R</code>: initial distance estimate <span>$œµ&gt;0$</span></li><li><code>max_distance::R</code>: tracked maximum distance <span>$\bar r_t$</span></li><li><code>gradient_sum::R</code>: accumulated sum <span>$G_t$</span></li><li><code>initial_point</code>: stored start point <span>$p_0$</span></li><li><code>use_curvature::Bool</code>: toggle curvature correction <span>$Œ∂_Œ∫$</span></li><li><code>sectional_curvature_bound::R</code>: lower bound <span>$Œ∫$</span> used in <span>$Œ∂_Œ∫$</span> when <code>use_curvature=true</code></li><li><code>last_stepsize::R</code>: last computed stepsize</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DistanceOverGradientsStepsize(M::AbstractManifold; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>initial_distance=1e-3</code>: initial estimate <span>$œµ$</span></li><li><code>use_curvature=false</code>: whether to use <span>$Œ∂_Œ∫$</span></li><li><code>sectional_curvature_bound=0.0</code>: lower curvature bound <span>$Œ∫$</span> (if known)</li><li><code>p</code>: initial point, used to track distance</li></ul><p><strong>References</strong></p><p>[<a href="../../references/#DoddSharrockNemeth_2024">DSN24</a>]: Learning-Rate-Free Stochastic Optimization over Riemannian Manifolds (RDoG).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L954-L982">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.NonmonotoneLinesearchStepsize"><a class="docstring-binding" href="#Manopt.NonmonotoneLinesearchStepsize"><code>Manopt.NonmonotoneLinesearchStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonmonotoneLinesearchStepsize{P,T,R&lt;:Real} &lt;: Linesearch</code></pre><p>A functor representing a nonmonotone line search using the Barzilai-Borwein step size [<a href="../../references/#IannazzoPorcelli_2017">IP17</a>].</p><p><strong>Fields</strong></p><ul><li><ul><li><code>initial_guess</code>: a function to provide an initial guess for the step size,</li></ul><p>it maps <code>(problem, state, k, last_stepsize, Œ∑) -&gt; Œ±_0</code> based on</p><ul><li>a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>problem</code></li><li>a <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>state</code></li><li>the current iterate <code>k</code></li><li>the last step size <code>last_stepsize</code></li><li>the search direction <code>Œ∑</code></li></ul><p>and should at least accept the keywords</p><ul><li><code>lf0 =</code><a href="../objective/#Manopt.get_cost"><code>get_cost</code></a><code>(problem, get_iterate(state))</code> the current cost at ^p<code>here interpreted as the initial point of</code>f<code>along the line search direction</code></li><li><code>Dlf0 =</code><a href="../objective/#Manopt.get_differential"><code>get_differential</code></a><code>(problem, get_iterate(state), Œ∑)</code> the directional derivative at point <code>p</code> in direction <code>Œ∑</code></li></ul></li><li><p><code>memory_size</code>:           number of iterations after which the cost value needs to be lower than the current one</p></li><li><p><code>bb_min_stepsize=1e-3</code>:     lower bound for the Barzilai-Borwein step size greater than zero</p></li><li><p><code>bb_max_stepsize=1e3</code>:      upper bound for the Barzilai-Borwein step size greater than min_stepsize</p></li><li><p><code>last_stepsize</code>:     the last computed stepsize</p></li><li><p><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></p></li><li><p><code>strategy=direct</code>:          defines if the new step size is computed using the <code>:direct</code>, <code>:indirect</code> or <code>:alternating</code> strategy</p></li><li><p><code>storage</code>:                  (for <code>:Iterate</code> and <code>:Gradient</code>) a <a href="../state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a></p></li><li><p><code>stepsize_reduction</code>:       step size reduction factor contained in the interval (0,1)</p></li><li><p><code>sufficient_decrease</code>:     sufficient decrease parameter contained in the interval (0,1)</p></li><li><p><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></p></li><li><p><code>candidate_point</code>:          to store an interim result</p></li><li><p><code>stop_when_stepsize_less</code>:    smallest stepsize when to stop (the last one before is taken)</p></li><li><p><code>stop_when_stepsize_exceeds</code>: largest stepsize when to stop.</p></li><li><p><code>stop_increasing_at_step</code>:    last step to increase the stepsize (phase 1),</p></li><li><p><code>stop_decreasing_at_step</code>:    last step size to decrease the stepsize (phase 2),</p></li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">NonmonotoneLinesearchStepsize(M::AbstractManifold; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>p=allocate_result(M, rand)</code>: to store an interim result</li><li><code>initial_guess = (problem, state, k, last_stepsize, Œ∑) -&gt; k == 0 ? 1.0 : last_stepsize</code>  function to provide an initial guess for the stepsize</li><li><code>memory_size=10</code></li><li><code>bb_min_stepsize=1e-3</code></li><li><code>bb_max_stepsize=1e3</code></li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>strategy=direct</code></li><li><code>storage=</code><a href="../state/#Manopt.StoreStateAction"><code>StoreStateAction</code></a><code>(M; store_fields=[:Iterate, :Gradient])</code></li><li><code>stepsize_reduction=0.5</code></li><li><code>sufficient_decrease=1e-4</code></li><li><code>stop_when_stepsize_less=0.0</code></li><li><code>stop_when_stepsize_exceeds=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>)</li><li><code>stop_increasing_at_step=100</code></li><li><code>stop_decreasing_at_step=1000</code></li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L1169-L1215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.PolyakStepsize"><a class="docstring-binding" href="#Manopt.PolyakStepsize"><code>Manopt.PolyakStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolyakStepsize &lt;: Stepsize</code></pre><p>A functor <code>(problem, state, ...) -&gt; s</code> to provide a step size due to Polyak, cf. Section 3.2 of [<a href="../../references/#Bertsekas_2015">Ber15</a>].</p><p><strong>Fields</strong></p><ul><li><code>Œ≥</code>               : a function <code>k -&gt; ...</code> representing a seuqnce.</li><li><code>best_cost_value</code> : storing the best cost value</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">PolyakStepsize(;
    Œ≥ = i -&gt; 1/i,
    initial_cost_estimate=0.0
)</code></pre><p>Construct a stepsize of Polyak type.</p><p><strong>See also</strong></p><p><a href="#Manopt.Polyak"><code>Polyak</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L1534-L1555">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.UnivariateTriple"><a class="docstring-binding" href="#Manopt.UnivariateTriple"><code>Manopt.UnivariateTriple</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnivariateTriple{R &lt;: Real}</code></pre><p>Triple of stepsize, function value und derivative value</p><p><strong>Fields</strong></p><ul><li><code>t::R</code>: stepsize</li><li><code>f::R</code>: cost at stepsize <code>t</code></li><li><code>df::R</code>: derivative of the cost at stepsize <code>t</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L562-L571">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.WolfePowellBinaryLinesearchStepsize"><a class="docstring-binding" href="#Manopt.WolfePowellBinaryLinesearchStepsize"><code>Manopt.WolfePowellBinaryLinesearchStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WolfePowellBinaryLinesearchStepsize{R} &lt;: Linesearch</code></pre><p>Do a backtracking line search to find a step size <span>$Œ±$</span> that fulfils the Wolfe conditions along a search direction <span>$X$</span> starting from <span>$p$</span>. See <a href="#Manopt.WolfePowellBinaryLinesearch"><code>WolfePowellBinaryLinesearch</code></a> for the math details.</p><p><strong>Fields</strong></p><ul><li><code>sufficient_decrease::R</code>, <code>sufficient_curvature::R</code> two constants in the line search</li><li><code>last_stepsize::R</code></li><li><code>max_stepsize::R</code></li><li><code>retraction_method::AbstractRetractionMethod</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less::R</code>: a safeguard to stop when the stepsize gets too small</li><li><code>vector_transport_method::AbstractVectorTransportMethodP</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">WolfePowellBinaryLinesearchStepsize(M::AbstractManifold; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>sufficient_decrease=10^(-4)</code></li><li><code>sufficient_curvature=0.999</code></li><li><code>max_stepsize=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>: largest stepsize allowed here.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less=0.0</code>: smallest stepsize when to stop (the last one before is taken)</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L1851-L1880">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.WolfePowellLinesearchStepsize"><a class="docstring-binding" href="#Manopt.WolfePowellLinesearchStepsize"><code>Manopt.WolfePowellLinesearchStepsize</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WolfePowellLinesearchStepsize{R&lt;:Real} &lt;: Linesearch</code></pre><p>Do a backtracking line search to find a step size <span>$Œ±$</span> that fulfils the Wolfe conditions along a search direction <span>$X$</span> starting from <span>$p$</span>. See <a href="#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a> for the math details</p><p><strong>Fields</strong></p><ul><li><code>sufficient_decrease::R</code>, <code>sufficient_curvature::R</code> two constants in the line search</li><li><code>candidate_direction::T</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span></li><li><code>candidate_point::P</code>: a point on the manifold <span>$\mathcal M$</span>as temporary storage for candidates</li><li><code>candidate_tangent::T</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span></li><li><code>last_stepsize::R</code></li><li><code>max_stepsize::R</code></li><li><code>retraction_method::AbstractRetractionMethod</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less::R</code>: a safeguard to stop when the stepsize gets too small</li><li><code>vector_transport_method::AbstractVectorTransportMethodP</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">WolfePowellLinesearchStepsize(M::AbstractManifold; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>sufficient_decrease=10^(-4)</code></li><li><code>sufficient_curvature=0.999</code></li><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold <span>$\mathcal M$</span>as temporary storage for candidates</li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>as type of memory allocated for the candidates direction and tangent</li><li><code>max_stepsize=</code><a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M, p)</code>: largest stepsize allowed here.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stop_when_stepsize_less=0.0</code>: smallest stepsize when to stop (the last one before is taken)</li><li><code>stop_increasing_at_step=100</code>: for the initial increase test (s_plus), stop after these many steps</li><li><code>stop_decreasing_at_step=1000</code>: for the initial decrease test (s_minus), stop after these many steps</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/stepsize.jl#L1619-L1654">source</a></section></details></article><p>Some solvers have a different iterate from the one used for the line search. Then the following state can be used to wrap these locally</p><article><details class="docstring" open="true"><summary id="Manopt.StepsizeState"><a class="docstring-binding" href="#Manopt.StepsizeState"><code>Manopt.StepsizeState</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StepsizeState{P,T} &lt;: AbstractManoptSolverState</code></pre><p>A state to store a point and a descent direction used within a linesearch, if these are different from the iterate and search direction of the main solver.</p><p><strong>Fields</strong></p><ul><li><code>p::P</code>: a point on a manifold</li><li><code>X::T</code>: a tangent vector at <code>p</code>.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">StepsizeState(p,X)
StepsizeState(M::AbstractManifold; p=rand(M), x=zero_vector(M,p)</code></pre><p><strong>See also</strong></p><p><a href="../../solvers/interior_point_Newton/#Manopt.interior_point_Newton"><code>interior_point_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/interior_point_Newton_plan.jl#L1-L20">source</a></section></details></article><p>The Hager-Zhang initial guess uses two helper functions to determine initial stepsize in the first iteration on manifolds which have &quot;expected minimizer&quot;, for example the zero point on the Euclidean manifold:</p><article><details class="docstring" open="true"><summary id="Manopt.default_vector_norm"><a class="docstring-binding" href="#Manopt.default_vector_norm"><code>Manopt.default_vector_norm</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_point_distance(::AbstractManifold, p)</code></pre><p>The default Hager-Zhang guess for distance between <code>p</code> the solution to the optimization problem along the descent direction. There is no default implementation because it is only needed for manifolds with a specific <code>default_point_distance</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/initial_guess.jl#L95-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Manopt.default_point_distance"><a class="docstring-binding" href="#Manopt.default_point_distance"><code>Manopt.default_point_distance</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_point_distance(::DefaultManifold, p)</code></pre><p>Following [<a href="../../references/#HagerZhang_2006_2">HZ06b</a>], the expected distance to the optimal solution from <code>p</code> on <code>DefaultManifold</code> is the <code>Inf</code> norm of <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/ext/ManoptManifoldsExt/manifold_functions.jl#L1-L6">source</a></section><section><div><pre><code class="language-julia hljs">default_point_distance(::AbstractManifold, p)</code></pre><p>The default Hager-Zhang guess for distance between <code>p</code> the solution to the optimization problem. The default is 0, which deactivates heuristic I0 (a). On each manifold with <code>default_point_distance</code>, you need to also implement <code>default_vector_norm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/initial_guess.jl#L78-L84">source</a></section><section><div><pre><code class="language-julia hljs">default_point_distance(::DefaultManifold, p)</code></pre><p>Following [<a href="../../references/#HagerZhang_2006_2">HZ06b</a>], the expected distance to the optimal solution from <code>p</code> on <code>DefaultManifold</code> is the <code>Inf</code> norm of <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/16321d7dd3f0cc05059f003497d03af22e2a3924/src/plans/stepsize/initial_guess.jl#L87-L92">source</a></section></details></article><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[Ber15]</dt><dd><div>D.¬†P.¬†Bertsekas. <em>Convex Optimization Algorithms</em> (Athena Scientific, 2015); p.¬†576.</div></dd><dt>[Bou23]</dt><dd><div>N.¬†Boumal. <a href="https://www.nicolasboumal.net/book/index.html"><em>An Introduction to Optimization on Smooth Manifolds</em></a>. First¬†Edition (<a href="https://doi.org/10.1017/9781009166164">Cambridge University Press, 2023</a>).</div></dd><dt>[DSN24]</dt><dd><div>D.¬†Dodd, L.¬†Sharrock and C.¬†Nemeth. <em>Learning-rate-free stochastic optimization over Riemannian manifolds</em>, arXiv¬†preprint¬†arXiv:2406.02296 (2024).</div></dd><dt>[GS23]</dt><dd><div>G.¬†N.¬†Grapiglia and G.¬†F.¬†Stella. <a href="https://optimization-online.org/wp-content/uploads/2022/04/8864.pdf"><em>An Adaptive Riemannian Gradient Method Without Function Evaluations</em></a>. <a href="https://doi.org/10.1007/s10957-023-02227-y">Journal¬†of¬†Optimization¬†Theory¬†and¬†Applications <strong>197</strong>, 1140‚Äì1160</a> (2023).</div></dd><dt>[HZ06b]</dt><dd><div>W.¬†W.¬†Hager and H.¬†Zhang. <em>Algorithm 851: CG_DESCENT, a conjugate gradient method with guaranteed descent</em>. <a href="https://doi.org/10.1145/1132973.1132979">ACM¬†Transactions¬†on¬†Mathematical¬†Software <strong>32</strong>, 113‚Äì137</a> (2006).</div></dd><dt>[Hag89]</dt><dd><div>W.¬†W.¬†Hager. <em>A derivative-based bracketing scheme for univariate minimization and the conjugate gradient method</em>. <a href="https://doi.org/10.1016/0898-1221(89)90177-6">Computers¬†&amp;¬†Mathematics¬†with¬†Applications <strong>18</strong>, 779‚Äì795</a> (1989).</div></dd><dt>[Hua14]</dt><dd><div>W.¬†Huang. <a href="https://www.math.fsu.edu/~whuang2/pdf/Huang_W_Dissertation_2013.pdf"><em>Optimization algorithms on Riemannian manifolds with applications</em></a>. Ph.D. Thesis, Flordia State University (2014).</div></dd><dt>[IP17]</dt><dd><div>B.¬†Iannazzo and M.¬†Porcelli. <em>The Riemannian Barzilai‚ÄìBorwein method with nonmonotone line search and the matrix geometric mean computation</em>. <a href="https://doi.org/10.1093/imanum/drx015">IMA¬†Journal¬†of¬†Numerical¬†Analysis <strong>38</strong>, 495‚Äì517</a> (2017).</div></dd><dt>[NW06]</dt><dd><div>J.¬†Nocedal and S.¬†J.¬†Wright. <a href="https://doi.org/10.1007/978-0-387-40065-5"><em>Numerical Optimization</em></a>. 2¬†Edition (Springer, New York, 2006).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../state/">¬´ Solver State</a><a class="docs-footer-nextpage" href="../stopping_criteria/">Stopping Criteria ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 08:04">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
