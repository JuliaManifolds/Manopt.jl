<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quasi-Newton ¬∑ Manopt.jl</title><meta name="title" content="Quasi-Newton ¬∑ Manopt.jl"/><meta property="og:title" content="Quasi-Newton ¬∑ Manopt.jl"/><meta property="twitter:title" content="Quasi-Newton ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/getstarted/">üèîÔ∏è Get started with Manopt.jl</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../../tutorials/EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../../tutorials/HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../../tutorials/ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do constrained optimization</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../">List of Solvers</a></li><li><a class="tocitem" href="../adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../cma_es/">CMA-ES</a></li><li><a class="tocitem" href="../conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../conjugate_residual/">Conjugate Residual</a></li><li><a class="tocitem" href="../convex_bundle_method/">Convex bundle method</a></li><li><a class="tocitem" href="../cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="../exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../interior_point_Newton/">Interior Point Newton</a></li><li><a class="tocitem" href="../LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="../mesh_adaptive_direct_search/">Mesh Adaptive Direct Search</a></li><li><a class="tocitem" href="../NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="../particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../projected_gradient_method/">Projected Gradient Method</a></li><li><a class="tocitem" href="../proximal_bundle_method/">Proximal bundle method</a></li><li><a class="tocitem" href="../proximal_gradient_method/">Proximal Gradient Method</a></li><li class="is-active"><a class="tocitem" href>Quasi-Newton</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Direction-updates"><span>Direction updates</span></a></li><li><a class="tocitem" href="#Hessian-update-rules"><span>Hessian update rules</span></a></li><li><a class="tocitem" href="#State"><span>State</span></a></li><li><a class="tocitem" href="#sec-qn-technical-details"><span>Technical details</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../../plans/problem/">Problem</a></li><li><a class="tocitem" href="../../plans/objective/">Objective</a></li><li><a class="tocitem" href="../../plans/state/">Solver State</a></li><li><a class="tocitem" href="../../plans/stepsize/">Stepsize</a></li><li><a class="tocitem" href="../../plans/stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../../plans/debug/">Debug Output</a></li><li><a class="tocitem" href="../../plans/record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>Quasi-Newton</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quasi-Newton</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/solvers/quasi_Newton.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Riemannian-quasi-Newton-methods"><a class="docs-heading-anchor" href="#Riemannian-quasi-Newton-methods">Riemannian quasi-Newton methods</a><a id="Riemannian-quasi-Newton-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Riemannian-quasi-Newton-methods" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.quasi_Newton" href="#Manopt.quasi_Newton"><code>Manopt.quasi_Newton</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quasi_Newton(M, f, grad_f, p; kwargs...)
quasi_Newton!(M, f, grad_f, p; kwargs...)</code></pre><p>Perform a quasi Newton iteration to solve</p><p class="math-container">\[\operatorname*{arg\,min}_{p ‚àà \mathcal M} f(p)\]</p><p>with start point <code>p</code>. The iterations can be done in-place of <code>p</code><span>$=p^{(0)}$</span>. The <span>$k$</span>th iteration consists of</p><ol><li>Compute the search direction <span>$Œ∑^{(k)} = -\mathcal B_k [\operatorname{grad}f (p^{(k)})]$</span> or solve <span>$\mathcal H_k [Œ∑^{(k)}] = -\operatorname{grad}f (p^{(k)})]$</span>.</li><li>Determine a suitable stepsize <span>$Œ±_k$</span> along the curve <span>$Œ≥(Œ±) = R_{p^{(k)}}(Œ± Œ∑^{(k)})$</span>, usually by using <a href="../../plans/stepsize/#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a>.</li><li>Compute <span>$p^{(k+1)} = R_{p^{(k)}}(Œ±_k Œ∑^{(k)})$</span>.</li><li>Define <span>$s_k = \mathcal T_{p^{(k)}, Œ±_k Œ∑^{(k)}}(Œ±_k Œ∑^{(k)})$</span> and <span>$y_k = \operatorname{grad}f(p^{(k+1)}) - \mathcal T_{p^{(k)}, Œ±_k Œ∑^{(k)}}(\operatorname{grad}f(p^{(k)}))$</span>, where <span>$\mathcal T$</span> denotes a vector transport.</li><li>Compute the new approximate Hessian <span>$H_{k+1}$</span> or its inverse <span>$B_{k+1}$</span>.</li></ol><p><strong>Input</strong></p><ul><li><code>M::</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code></code>: a Riemannian manifold <span>$\mathcal M$</span></li><li><code>f</code>: a cost function <span>$f: \mathcal M‚Üí ‚Ñù$</span> implemented as <code>(M, p) -&gt; v</code></li><li><code>grad_f</code>: the (Riemannian) gradient <span>$\operatorname{grad}f: \mathcal M ‚Üí T_{p}\mathcal M$</span> of f as a function <code>(M, p) -&gt; X</code> or a function <code>(M, X, p) -&gt; X</code> computing <code>X</code> in-place</li><li><code>p</code>: a point on the manifold <span>$\mathcal M$</span></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>basis=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.DefaultOrthonormalBasis"><code>DefaultOrthonormalBasis</code></a><code>()</code>: basis to use within each of the the tangent spaces to represent the Hessian (inverse) for the cases where it is stored in full (matrix) form.</li><li><code>cautious_update=false</code>:  whether or not to use the <a href="#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>QuasiNewtonCautiousDirectionUpdate</code></a>  which wraps the <code>direction_upate</code>.</li><li><code>cautious_function=(x) -&gt; x * 1e-4</code>: a monotone increasing function for the cautious update that is zero at <span>$x=0$</span> and strictly increasing at <span>$0$</span></li><li><code>differential=</code><code>nothing</code>: specify a specific function to evaluate the differential. By default, <span>$Df(p)[X] = ‚ü®\operatorname{grad}f(p),X‚ü©$</span>. is used</li><li><code>direction_update=</code><a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a><code>()</code>: the <a href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a> to use.</li><li><code>evaluation=</code><a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.For example <code>grad_f(M,p)</code> allocates, but <code>grad_f!(M, X, p)</code> computes the result in-place of <code>X</code>.</li><li><code>initial_operator= initial_scale*Matrix{Float64}(I, n, n)</code>:  initial matrix to use in case the Hessian (inverse) approximation is stored as a full matrix,  that is <code>n=manifold_dimension(M)</code>. This matrix is only allocated for the full matrix case.  See also <code>initial_scale</code>.</li><li><code>initial_scale=1.0</code>: scale initial <code>s</code> to use in with <span>$\frac{s‚ü®s_k,y_k‚ü©_{p_k}}{\lVert y_k\rVert_{p_k}}$</span> in the computation of the limited memory approach. see also <code>initial_operator</code></li><li><code>memory_size=20</code>: limited memory, number of <span>$s_k, y_k$</span> to store.  Set to a negative value to use a full memory (matrix) representation</li><li><code>nondescent_direction_behavior=:reinitialize_direction_update</code>: specify how non-descent direction is handled. This can be<ul><li><code>:step_towards_negative_gradient</code>: the direction is replaced with negative gradient, a message is stored.</li><li><code>:ignore</code>: the verification is not performed, so any computed direction is accepted. No message is stored.</li><li><code>:reinitialize_direction_update</code>: discards operator state stored in direction update rules.</li><li>any other value performs the verification, keeps the direction but stores a message.</li></ul>A stored message can be displayed using <a href="../../plans/debug/#Manopt.DebugMessages"><code>DebugMessages</code></a>.</li><li><code>preconditioner=nothing</code> specify a preconditioner, either<ul><li>the default <code>nothing</code> does not activate a preconditioning</li><li>a function of the form <code>(M, p, X) -&gt; Y</code> or mutating <code>(M, Y, p, X) -&gt; Y</code> depending on the <code>evaluation</code></li><li>a <a href="../gradient_descent/#Manopt.PreconditionedDirection"><code>PreconditionedDirection</code></a>. See also their docs for mor details on the preconditioner.</li></ul>Note that the preconditioner is applied to the gradient, i.e. the right hand side <em>before</em> solving the linear system.</li><li><code>project!=copyto!</code>: for numerical stability it is possible to project onto the tangent space after every iteration. the function has to work inplace of <code>Y</code>, that is <code>(M, Y, p, X) -&gt; Y</code>, where <code>X</code> and <code>Y</code> can be the same memory.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stepsize=</code><a href="../../plans/stepsize/#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a><code>(retraction_method, vector_transport_method)</code>: a functor inheriting from <a href="../../plans/stepsize/#Manopt.Stepsize"><code>Stepsize</code></a> to determine a step size</li><li><code>stopping_criterion=</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(max(1000, memory_size))</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenAny"><code>|</code></a><a href="../../plans/stopping_criteria/#Manopt.StopWhenGradientNormLess"><code>StopWhenGradientNormLess</code></a><code>(1e-6)</code>: a functor indicating that the stopping criterion is fulfilled</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><p>All other keyword arguments are passed to <a href="../../plans/state/#Manopt.decorate_state!"><code>decorate_state!</code></a> for state decorators or <a href="../../plans/objective/#Manopt.decorate_objective!"><code>decorate_objective!</code></a> for objective decorators, respectively.</p><p><strong>Output</strong></p><p>The obtained approximate minimizer <span>$p^*$</span>. To obtain the whole final state of the solver, see <a href="../#Manopt.get_solver_return"><code>get_solver_return</code></a> for details, especially the <code>return_state=</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/solvers/quasi_Newton.jl#L258-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.quasi_Newton!" href="#Manopt.quasi_Newton!"><code>Manopt.quasi_Newton!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quasi_Newton(M, f, grad_f, p; kwargs...)
quasi_Newton!(M, f, grad_f, p; kwargs...)</code></pre><p>Perform a quasi Newton iteration to solve</p><p class="math-container">\[\operatorname*{arg\,min}_{p ‚àà \mathcal M} f(p)\]</p><p>with start point <code>p</code>. The iterations can be done in-place of <code>p</code><span>$=p^{(0)}$</span>. The <span>$k$</span>th iteration consists of</p><ol><li>Compute the search direction <span>$Œ∑^{(k)} = -\mathcal B_k [\operatorname{grad}f (p^{(k)})]$</span> or solve <span>$\mathcal H_k [Œ∑^{(k)}] = -\operatorname{grad}f (p^{(k)})]$</span>.</li><li>Determine a suitable stepsize <span>$Œ±_k$</span> along the curve <span>$Œ≥(Œ±) = R_{p^{(k)}}(Œ± Œ∑^{(k)})$</span>, usually by using <a href="../../plans/stepsize/#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a>.</li><li>Compute <span>$p^{(k+1)} = R_{p^{(k)}}(Œ±_k Œ∑^{(k)})$</span>.</li><li>Define <span>$s_k = \mathcal T_{p^{(k)}, Œ±_k Œ∑^{(k)}}(Œ±_k Œ∑^{(k)})$</span> and <span>$y_k = \operatorname{grad}f(p^{(k+1)}) - \mathcal T_{p^{(k)}, Œ±_k Œ∑^{(k)}}(\operatorname{grad}f(p^{(k)}))$</span>, where <span>$\mathcal T$</span> denotes a vector transport.</li><li>Compute the new approximate Hessian <span>$H_{k+1}$</span> or its inverse <span>$B_{k+1}$</span>.</li></ol><p><strong>Input</strong></p><ul><li><code>M::</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code></code>: a Riemannian manifold <span>$\mathcal M$</span></li><li><code>f</code>: a cost function <span>$f: \mathcal M‚Üí ‚Ñù$</span> implemented as <code>(M, p) -&gt; v</code></li><li><code>grad_f</code>: the (Riemannian) gradient <span>$\operatorname{grad}f: \mathcal M ‚Üí T_{p}\mathcal M$</span> of f as a function <code>(M, p) -&gt; X</code> or a function <code>(M, X, p) -&gt; X</code> computing <code>X</code> in-place</li><li><code>p</code>: a point on the manifold <span>$\mathcal M$</span></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>basis=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.DefaultOrthonormalBasis"><code>DefaultOrthonormalBasis</code></a><code>()</code>: basis to use within each of the the tangent spaces to represent the Hessian (inverse) for the cases where it is stored in full (matrix) form.</li><li><code>cautious_update=false</code>:  whether or not to use the <a href="#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>QuasiNewtonCautiousDirectionUpdate</code></a>  which wraps the <code>direction_upate</code>.</li><li><code>cautious_function=(x) -&gt; x * 1e-4</code>: a monotone increasing function for the cautious update that is zero at <span>$x=0$</span> and strictly increasing at <span>$0$</span></li><li><code>differential=</code><code>nothing</code>: specify a specific function to evaluate the differential. By default, <span>$Df(p)[X] = ‚ü®\operatorname{grad}f(p),X‚ü©$</span>. is used</li><li><code>direction_update=</code><a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a><code>()</code>: the <a href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a> to use.</li><li><code>evaluation=</code><a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.For example <code>grad_f(M,p)</code> allocates, but <code>grad_f!(M, X, p)</code> computes the result in-place of <code>X</code>.</li><li><code>initial_operator= initial_scale*Matrix{Float64}(I, n, n)</code>:  initial matrix to use in case the Hessian (inverse) approximation is stored as a full matrix,  that is <code>n=manifold_dimension(M)</code>. This matrix is only allocated for the full matrix case.  See also <code>initial_scale</code>.</li><li><code>initial_scale=1.0</code>: scale initial <code>s</code> to use in with <span>$\frac{s‚ü®s_k,y_k‚ü©_{p_k}}{\lVert y_k\rVert_{p_k}}$</span> in the computation of the limited memory approach. see also <code>initial_operator</code></li><li><code>memory_size=20</code>: limited memory, number of <span>$s_k, y_k$</span> to store.  Set to a negative value to use a full memory (matrix) representation</li><li><code>nondescent_direction_behavior=:reinitialize_direction_update</code>: specify how non-descent direction is handled. This can be<ul><li><code>:step_towards_negative_gradient</code>: the direction is replaced with negative gradient, a message is stored.</li><li><code>:ignore</code>: the verification is not performed, so any computed direction is accepted. No message is stored.</li><li><code>:reinitialize_direction_update</code>: discards operator state stored in direction update rules.</li><li>any other value performs the verification, keeps the direction but stores a message.</li></ul>A stored message can be displayed using <a href="../../plans/debug/#Manopt.DebugMessages"><code>DebugMessages</code></a>.</li><li><code>preconditioner=nothing</code> specify a preconditioner, either<ul><li>the default <code>nothing</code> does not activate a preconditioning</li><li>a function of the form <code>(M, p, X) -&gt; Y</code> or mutating <code>(M, Y, p, X) -&gt; Y</code> depending on the <code>evaluation</code></li><li>a <a href="../gradient_descent/#Manopt.PreconditionedDirection"><code>PreconditionedDirection</code></a>. See also their docs for mor details on the preconditioner.</li></ul>Note that the preconditioner is applied to the gradient, i.e. the right hand side <em>before</em> solving the linear system.</li><li><code>project!=copyto!</code>: for numerical stability it is possible to project onto the tangent space after every iteration. the function has to work inplace of <code>Y</code>, that is <code>(M, Y, p, X) -&gt; Y</code>, where <code>X</code> and <code>Y</code> can be the same memory.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stepsize=</code><a href="../../plans/stepsize/#Manopt.WolfePowellLinesearch"><code>WolfePowellLinesearch</code></a><code>(retraction_method, vector_transport_method)</code>: a functor inheriting from <a href="../../plans/stepsize/#Manopt.Stepsize"><code>Stepsize</code></a> to determine a step size</li><li><code>stopping_criterion=</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(max(1000, memory_size))</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenAny"><code>|</code></a><a href="../../plans/stopping_criteria/#Manopt.StopWhenGradientNormLess"><code>StopWhenGradientNormLess</code></a><code>(1e-6)</code>: a functor indicating that the stopping criterion is fulfilled</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><p>All other keyword arguments are passed to <a href="../../plans/state/#Manopt.decorate_state!"><code>decorate_state!</code></a> for state decorators or <a href="../../plans/objective/#Manopt.decorate_objective!"><code>decorate_objective!</code></a> for objective decorators, respectively.</p><p><strong>Output</strong></p><p>The obtained approximate minimizer <span>$p^*$</span>. To obtain the whole final state of the solver, see <a href="../#Manopt.get_solver_return"><code>get_solver_return</code></a> for details, especially the <code>return_state=</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/solvers/quasi_Newton.jl#L286-L362">source</a></section></article><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>The aim is to minimize a real-valued function on a Riemannian manifold, that is</p><p class="math-container">\[\min f(p), \quad p ‚àà \mathcal{M}.\]</p><p>Riemannian quasi-Newtonian methods are as generalizations of their Euclidean counterparts Riemannian line search methods. These methods determine a search direction <span>$Œ∑_k ‚àà T_{p_k} \mathcal{M}$</span> at the current iterate <span>$p_k$</span> and a suitable stepsize <span>$Œ±_k$</span> along <span>$\gamma(Œ±) = R_{p_k}(Œ± Œ∑_k)$</span>, where <span>$R: T \mathcal{M} ‚Üí\mathcal{M}$</span> is a retraction. The next iterate is obtained by</p><p class="math-container">\[p_{k+1} = R_{p_k}(Œ±_k Œ∑_k).\]</p><p>In quasi-Newton methods, the search direction is given by</p><p class="math-container">\[Œ∑_k = -{\mathcal{H}_k}^{-1}[\operatorname{grad}f (p_k)] = -\mathcal{B}_k [\operatorname{grad} (p_k)],\]</p><p>where <span>$\mathcal{H}_k : T_{p_k} \mathcal{M} ‚ÜíT_{p_k} \mathcal{M}$</span> is a positive definite self-adjoint operator, which approximates the action of the Hessian <span>$\operatorname{Hess} f (p_k)[‚ãÖ]$</span> and <span>$\mathcal{B}_k = {\mathcal{H}_k}^{-1}$</span>. The idea of quasi-Newton methods is instead of creating a complete new approximation of the Hessian operator <span>$\operatorname{Hess} f(p_{k+1})$</span> or its inverse at every iteration, the previous operator <span>$\mathcal{H}_k$</span> or <span>$\mathcal{B}_k$</span> is updated by a convenient formula using the obtained information about the curvature of the objective function during the iteration. The resulting operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> acts on the tangent space <span>$T_{p_{k+1}} \mathcal{M}$</span> of the freshly computed iterate <span>$p_{k+1}$</span>. In order to get a well-defined method, the following requirements are placed on the new operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> that is created by an update. Since the Hessian <span>$\operatorname{Hess} f(p_{k+1})$</span> is a self-adjoint operator on the tangent space <span>$T_{p_{k+1}} \mathcal{M}$</span>, and <span>$\mathcal{H}_{k+1}$</span> approximates it, one requirement is, that <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> is also self-adjoint on <span>$T_{p_{k+1}} \mathcal{M}$</span>. In order to achieve a steady descent, the next requirement is that <span>$Œ∑_k$</span> is a descent direction in each iteration. Hence a further requirement is that <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> is a positive definite operator on <span>$T_{p_{k+1}} \mathcal{M}$</span>. In order to get information about the curvature of the objective function into the new operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span>, the last requirement is a form of a Riemannian quasi-Newton equation:</p><p class="math-container">\[\mathcal{H}_{k+1} [T_{p_k \rightarrow p_{k+1}}({R_{p_k}}^{-1}(p_{k+1}))] = \operatorname{grad}(p_{k+1}) - T_{p_k \rightarrow p_{k+1}}(\operatorname{grad}f(p_k))\]</p><p>or</p><p class="math-container">\[\mathcal{B}_{k+1} [\operatorname{grad}f(p_{k+1}) - T_{p_k \rightarrow p_{k+1}}(\operatorname{grad}f(p_k))] = T_{p_k \rightarrow p_{k+1}}({R_{p_k}}^{-1}(p_{k+1}))\]</p><p>where <span>$T_{p_k \rightarrow p_{k+1}} : T_{p_k} \mathcal{M} ‚ÜíT_{p_{k+1}} \mathcal{M}$</span> and the chosen retraction <span>$R$</span> is the associated retraction of <span>$T$</span>. Note that, of course, not all updates in all situations meet these conditions in every iteration. For specific quasi-Newton updates, the fulfilment of the Riemannian curvature condition, which requires that</p><p class="math-container">\[g_{p_{k+1}}(s_k, y_k) &gt; 0\]</p><p>holds, is a requirement for the inheritance of the self-adjointness and positive definiteness of the <span>$\mathcal{H}_k$</span> or <span>$\mathcal{B}_k$</span> to the operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span>. Unfortunately, the fulfilment of the Riemannian curvature condition is not given by a step size <span>$\alpha_k &gt; 0$</span> that satisfies the generalized Wolfe conditions. However, to create a positive definite operator <span>$\mathcal{H}_{k+1}$</span> or <span>$\mathcal{B}_{k+1}$</span> in each iteration, the so-called locking condition was introduced in [<a href="../../references/#HuangGallivanAbsil_2015">HGA15</a>], which requires that the isometric vector transport <span>$T^S$</span>, which is used in the update formula, and its associate retraction <span>$R$</span> fulfil</p><p class="math-container">\[T^{S}{p, Œæ_p}(Œæ_p) = Œ≤ T^{R}{p, Œæ_p}(Œæ_p), \quad Œ≤ = \frac{\lVert Œæ_p \rVert_p}{\lVert T^{R}{p, Œæ_p}(Œæ_p) \rVert_{R_{p}(Œæ_p)}},\]</p><p>where <span>$T^R$</span> is the vector transport by differentiated retraction. With the requirement that the isometric vector transport <span>$T^S$</span> and its associated retraction <span>$R$</span> satisfies the locking condition and using the tangent vector</p><p class="math-container">\[y_k = {Œ≤_k}^{-1} \operatorname{grad}f(p_{k+1}) - T^{S}{p_k, Œ±_k Œ∑_k}(\operatorname{grad}f(p_k)),\]</p><p>where</p><p class="math-container">\[Œ≤_k = \frac{\lVert Œ±_k Œ∑_k \rVert_{p_k}}{\lVert T^{R}{p_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \rVert_{p_{k+1}}},\]</p><p>in the update, it can be shown that choosing a stepsize <span>$Œ±_k &gt; 0$</span> that satisfies the Riemannian Wolfe conditions leads to the fulfilment of the Riemannian curvature condition, which in turn implies that the operator generated by the updates is positive definite. In the following the specific operators are denoted in matrix notation and hence use <span>$H_k$</span> and <span>$B_k$</span>, respectively.</p><h2 id="Direction-updates"><a class="docs-heading-anchor" href="#Direction-updates">Direction updates</a><a id="Direction-updates-1"></a><a class="docs-heading-anchor-permalink" href="#Direction-updates" title="Permalink"></a></h2><p>In general there are different ways to compute a fixed <a href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a>. In general these are represented by</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractQuasiNewtonDirectionUpdate" href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>Manopt.AbstractQuasiNewtonDirectionUpdate</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractQuasiNewtonDirectionUpdate</code></pre><p>An abstract representation of an Quasi Newton Update rule to determine the next direction given current <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>.</p><p>All subtypes should be functors, they should be callable as <code>H(M,x,d)</code> to compute a new direction update.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonMatrixDirectionUpdate" href="#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>Manopt.QuasiNewtonMatrixDirectionUpdate</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonMatrixDirectionUpdate &lt;: AbstractQuasiNewtonDirectionUpdate</code></pre><p>The <code>QuasiNewtonMatrixDirectionUpdate</code> represent a quasi-Newton update rule, where the operator is stored as a matrix. A distinction is made between the update of the approximation of the Hessian, <span>$H_k ‚Ü¶ H_{k+1}$</span>, and the update of the approximation of the Hessian inverse, <span>$B_k ‚Ü¶ B_{k+1}$</span>. For the first case, the coordinates of the search direction <span>$Œ∑_k$</span> with respect to a basis <span>$\{b_i\}_{i=1}^{n}$</span> are determined by solving a linear system of equations</p><p class="math-container">\[\text{Solve}\quad\hat{Œ∑_k} = - H_k \widehat{\operatorname{grad}f(x_k)},\]</p><p>where <span>$H_k$</span> is the matrix representing the operator with respect to the basis <span>$\{b_i\}_{i=1}^{n}$</span> and <span>$\widehat{\operatorname{grad}} f(p_k)$</span> represents the coordinates of the gradient of the objective function <span>$f$</span> in <span>$x_k$</span> with respect to the basis <span>$\{b_i\}_{i=1}^{n}$</span>. If a method is chosen where Hessian inverse is approximated, the coordinates of the search direction <span>$Œ∑_k$</span> with respect to a basis <span>$\{b_i\}_{i=1}^{n}$</span> are obtained simply by matrix-vector multiplication</p><p class="math-container">\[\hat{Œ∑_k} = - B_k \widehat{\operatorname{grad}f(x_k)},\]</p><p>where <span>$B_k$</span> is the matrix representing the operator with respect to the basis <span>$\{b_i\}_{i=1}^{n}$</span> and <span>$\widehat{\operatorname{grad}} f(p_k)$</span>. In the end, the search direction <span>$Œ∑_k$</span> is generated from the coordinates <span>$\hat{eta_k}$</span> and the vectors of the basis <span>$\{b_i\}_{i=1}^{n}$</span> in both variants. The <a href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a> indicates which quasi-Newton update rule is used. In all of them, the Euclidean update formula is used to generate the matrix <span>$H_{k+1}$</span> and <span>$B_{k+1}$</span>, and the basis <span>$\{b_i\}_{i=1}^{n}$</span> is transported into the upcoming tangent space <span>$T_{p_{k+1}} \mathcal M$</span>, preferably with an isometric vector transport, or generated there.</p><p><strong>Provided functors</strong></p><ul><li><code>(mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction</li><li><code>(Œ∑, mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction in-place of <code>Œ∑</code></li></ul><p><strong>Fields</strong></p><ul><li><code>basis</code>:                  an <code>AbstractBasis</code> to use in the tangent spaces</li><li><code>matrix</code>:                 the matrix which represents the approximating operator.</li><li><code>initial_scale</code>:          when initialising the update, a unit matrix is used as initial approximation, scaled by this factor</li><li><code>update</code>:                 a <a href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a>.</li><li><code>vector_transport_method::AbstractVectorTransportMethodP</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonMatrixDirectionUpdate(
    M::AbstractManifold,
    update,
    basis::B=default_basis(M),
    m=Matrix{Float64}(I, manifold_dimension(M), manifold_dimension(M));
    kwargs...
)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>initial_scale=1.0</code> ‚Äì this can also be deactivated by passing <code>nothing</code>.</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li></ul><p>Generate the Update rule with defaults from a manifold and the names corresponding to the fields.</p><p><strong>See also</strong></p><p><a href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a>, <a href="#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>QuasiNewtonCautiousDirectionUpdate</code></a>, <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L372-L437">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonLimitedMemoryDirectionUpdate" href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>Manopt.QuasiNewtonLimitedMemoryDirectionUpdate</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonLimitedMemoryDirectionUpdate &lt;: AbstractQuasiNewtonDirectionUpdate</code></pre><p>This <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> represents the limited-memory Riemannian BFGS update, where the approximating operator is represented by <span>$m$</span> stored pairs of tangent vectors <span>$\{\widehat{s}_i\}_{i=k-m}^{k-1}$</span> and <span>$\{\widehat{y}_i\}_{i=k-m}^{k-1}$</span> in the <span>$k$</span>-th iteration. For the calculation of the search direction <span>$X_k$</span>, the generalisation of the two-loop recursion is used (see [<a href="../../references/#HuangGallivanAbsil_2015">HGA15</a>]), since it only requires inner products and linear combinations of tangent vectors in <span>$T_{p_k}\mathcal M$</span>. For that the stored pairs of tangent vectors <span>$\widehat{s}_i,  \widehat{y}_i$</span>, the gradient <span>$\operatorname{grad} f(p_k)$</span> of the objective function <span>$f$</span> in <span>$p_k$</span> and the positive definite self-adjoint operator</p><p class="math-container">\[\mathcal B_k^{(0)}[‚ãÖ]
= \frac{‚ü®s_{k-1},y_{k-1}‚ü©_{p_k}}{‚ü®y_{k-1},y_{k-1}‚ü©_{p_k}}\mathrm{Id}_{T_{p}\mathcal M&quot;[‚ãÖ]\]</p><p>are used. The two-loop recursion can be understood as that the <a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a> update is executed <span>$m$</span> times in a row on <span>$\mathcal B^{(0)}_k[‚ãÖ]$</span> using the tangent vectors <span>$\widehat{s}_i,\widehat{y}_i$</span>, and in the same time the resulting operator <span>$\mathcal B^{LRBFGS}_k [‚ãÖ]$</span> is directly applied on <span>$\operatorname{grad}f(x_k)$</span>. When updating there are two cases: if there is still free memory, <span>$k &lt; m$</span>, the previously stored vector pairs <span>$\widehat{s}_i,\widehat{y}_i$</span> have to be transported into the upcoming tangent space <span>$T_{p_{k+1}}\mathcal M$</span>. If there is no free memory, the oldest pair <span>$\widehat{s}_i,\widehat{y}_i$</span> has to be discarded and then all the remaining vector pairs <span>$\widehat{s}_i,\widehat{y}_i$</span> are transported into the tangent space <span>$T_{p_{k+1}}\mathcal M$</span>. After that the new values <span>$s_k = \widehat{s}_k = T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k)$</span> and <span>$y_k = \widehat{y}_k$</span> are stored at the beginning. This process ensures that new information about the objective function is always included and the old, probably no longer relevant, information is discarded.</p><p><strong>Provided functors</strong></p><ul><li><code>(mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction</li><li><code>(Œ∑, mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction in-place of <code>Œ∑</code></li></ul><p><strong>Fields</strong></p><ul><li><code>memory_s</code>:                the set of the stored (and transported) search directions times step size <span>$\{\widehat{s}_i\}_{i=k-m}^{k-1}$</span>.</li><li><code>memory_y</code>:                set of the stored gradient differences <span>$\{\widehat{y}_i\}_{i=k-m}^{k-1}$</span>.</li><li><code>Œæ</code>:                       a variable used in the two-loop recursion.</li><li><code>œÅ</code>L                       a variable used in the two-loop recursion.</li><li><code>initial_scale</code>:           initial scaling of the Hessian, deactivate (e.g. when using a preconditioner) by passing <code>nothing</code></li><li><code>vector_transport_method::AbstractVectorTransportMethodP</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li><li><code>message</code>:                 a string containing a potential warning that might have appeared</li><li><code>project!</code>:                a function to stabilize the update by projecting on the tangent space</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonLimitedMemoryDirectionUpdate(
    M::AbstractManifold,
    x,
    update::AbstractQuasiNewtonUpdateRule,
    memory_size::Int;
    initial_vector=zero_vector(M,x),
    initial_scale::Real=1.0
    project!=copyto!
)</code></pre><p><strong>See also</strong></p><p><a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a> <a href="#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>QuasiNewtonCautiousDirectionUpdate</code></a> <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L514-L575">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonCautiousDirectionUpdate" href="#Manopt.QuasiNewtonCautiousDirectionUpdate"><code>Manopt.QuasiNewtonCautiousDirectionUpdate</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonCautiousDirectionUpdate &lt;: AbstractQuasiNewtonDirectionUpdate</code></pre><p>These <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a>s represent any quasi-Newton update rule, which are based on the idea of a so-called cautious update. The search direction is calculated as given in <a href="#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> or <a href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a>, butut the update  then is only executed if</p><p class="math-container">\[\frac{g_{x_{k+1}}(y_k,s_k)}{\lVert s_k \rVert_{x_{k+1}}^{2}} ‚â• Œ∏ \lVert \operatorname{grad}f(x_k) \rVert_{x_k},\]</p><p>is satisfied, where <span>$Œ∏$</span> is a monotone increasing function satisfying <span>$Œ∏(0) = 0$</span> and <span>$Œ∏$</span> is strictly increasing at <span>$0$</span>. If this is not the case, the corresponding update is skipped, which means that for <a href="#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> the matrix <span>$H_k$</span> or <span>$B_k$</span> is not updated. The basis <span>$\{b_i\}_{i=1}^{n}$</span> is nevertheless transported into the upcoming tangent space <span>$T_{x_{k+1}} \mathcal M$</span>, and for <a href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a> neither the oldest vector pair <span>$\widetilde_{k‚àím}$</span>, <span>$\widetilde_{k‚àím}$</span> is discarded nor the newest vector pair <span>$\widetilde_k, \widetilde_k$</span> is added into storage, but all stored vector pairs <span>$\{\widetilde_i, \widetilde_i\}_{i=k-m}^{k-1}$</span> are transported into the tangent space <span>$T_{x_{k+1}} \mathcal M$</span>. If <a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a> or <a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a> is chosen as update, then the resulting method follows the method of [<a href="../../references/#HuangAbsilGallivan_2018">HAG18</a>], taking into account that the corresponding step size is chosen.</p><p><strong>Provided functors</strong></p><ul><li><code>(mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction</li><li><code>(Œ∑, mp::AbstractManoptproblem, st::QuasiNewtonState) -&gt; Œ∑</code> to compute the update direction in-place of <code>Œ∑</code></li></ul><p><strong>Fields</strong></p><ul><li><code>update</code>: an <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a></li><li><code>Œ∏</code>:      a monotone increasing function satisfying <span>$Œ∏(0) = 0$</span> and <span>$Œ∏$</span> is strictly increasing at <span>$0$</span>.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonCautiousDirectionUpdate(U::QuasiNewtonMatrixDirectionUpdate; Œ∏ = identity)
QuasiNewtonCautiousDirectionUpdate(U::QuasiNewtonLimitedMemoryDirectionUpdate; Œ∏ = identity)</code></pre><p>Generate a cautious update for either a matrix based or a limited memory based update rule.</p><p><strong>See also</strong></p><p><a href="#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> <a href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L721-L768">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.initialize_update!" href="#Manopt.initialize_update!"><code>Manopt.initialize_update!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_update!(s::AbstractQuasiNewtonDirectionUpdate)</code></pre><p>Initialize direction update. By default no change is made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L13-L17">source</a></section><section><div><pre><code class="language-julia hljs">initialize_update!(d::QuasiNewtonLimitedMemoryDirectionUpdate)</code></pre><p>Initialize the limited memory direction update by emptying the memory buffers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L708-L712">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonPreconditioner" href="#Manopt.QuasiNewtonPreconditioner"><code>Manopt.QuasiNewtonPreconditioner</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonPreconditioner{E&lt;:AbstractEvaluationType, F}</code></pre><p>Add a preconditioning</p><p><strong>Fields</strong></p><ul><li><code>preconditioner::F</code>: the preconditioner function</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">QuasiNewtonPreconditioner(
    preconditioner;
    evaluation::AbstractEvaluationType=AllocatingEvaluation()
)</code></pre><p>Add preconditioning to a gradient problem.</p><p><strong>Input</strong></p><ul><li><code>preconditioner</code>:   preconditioner function, either as a <code>(M, p, X) -&gt; Y</code> allocating or <code>(M, Y, p, X) -&gt; Y</code> mutating function</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>evaluation=</code><a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="../../plans/objective/#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="../../plans/objective/#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L318-L343">source</a></section></article><h2 id="Hessian-update-rules"><a class="docs-heading-anchor" href="#Hessian-update-rules">Hessian update rules</a><a id="Hessian-update-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Hessian-update-rules" title="Permalink"></a></h2><p>Using</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.update_hessian!" href="#Manopt.update_hessian!"><code>Manopt.update_hessian!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_hessian!(d::AbstractQuasiNewtonDirectionUpdate, amp, st, p_old, k)</code></pre><p>update the Hessian within the <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a> <code>st</code> given a <a href="../../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> as well as the an <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> <code>d</code> and the last iterate <code>p_old</code>. Note that the current (<code>k</code>th) iterate is already stored in <a href="../../plans/state/#Manopt.get_iterate"><code>get_iterate</code></a><code>(st)</code>.</p><p>See also <a href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>AbstractQuasiNewtonUpdateRule</code></a> and its subtypes for the different rules that are available within <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/solvers/quasi_Newton.jl#L449-L458">source</a></section></article><p>the following update formulae for either <span>$H_{k+1}$</span> or <span>$B_{k+1}$</span> are available.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractQuasiNewtonUpdateRule" href="#Manopt.AbstractQuasiNewtonUpdateRule"><code>Manopt.AbstractQuasiNewtonUpdateRule</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractQuasiNewtonUpdateRule</code></pre><p>Specify a type for the different <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a>s, that is for a <a href="#Manopt.QuasiNewtonMatrixDirectionUpdate"><code>QuasiNewtonMatrixDirectionUpdate</code></a> there are several different updates to the matrix, while the default for <a href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a> the most prominent is <a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.BFGS" href="#Manopt.BFGS"><code>Manopt.BFGS</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BFGS &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian BFGS update is used in the Riemannian quasi-Newton method.</p><p>Denote by <span>$\widetilde_k^\mathrm{BFGS}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{BFGS}_{k+1} = \widetilde^\mathrm{BFGS}_k  + \frac{y_k y^{\mathrm{T}}_k }{s^{\mathrm{T}}_k y_k} - \frac{\widetilde^\mathrm{BFGS}_k s_k s^{\mathrm{T}}_k \widetilde^\mathrm{BFGS}_k }{ s^{\mathrm{T}}_k \widetilde^\mathrm{BFGS}_k s_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{ and }\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal M,\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L29-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.DFP" href="#Manopt.DFP"><code>Manopt.DFP</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DFP &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in an <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian DFP update is used in the Riemannian quasi-Newton method.</p><p>Denote by <span>$\widetilde_k^\mathrm{DFP}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{DFP}_{k+1} = \Bigl(
  \mathrm{Id}_{T_{x_{k+1}} \mathcal M} - \frac{y_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
\Bigr)
\widetilde^\mathrm{DFP}_k
\Bigl(
  \mathrm{Id}_{T_{x_{k+1}} \mathcal M} - \frac{s_k y^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
\Bigr) + \frac{y_k y^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal M,\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L81-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.Broyden" href="#Manopt.Broyden"><code>Manopt.Broyden</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Broyden &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian Broyden update is used in the Riemannian quasi-Newton method, which is as a convex combination of <a href="#Manopt.BFGS"><code>BFGS</code></a> and <a href="#Manopt.DFP"><code>DFP</code></a>.</p><p>Denote by <span>$\widetilde_k^\mathrm{Br}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{Br}_{k+1} = \widetilde^\mathrm{Br}_k
  - \frac{\widetilde^\mathrm{Br}_k s_k s^{\mathrm{T}}_k \widetilde^\mathrm{Br}_k}{s^{\mathrm{T}}_k \widetilde^\mathrm{Br}_k s_k} + rac{y_k y^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
  + œÜ_k s^{\mathrm{T}}_k \widetilde^\mathrm{Br}_k s_k
  \Bigl(
        \frac{y_k}{s^{\mathrm{T}}_k y_k} - \frac{\widetilde^\mathrm{Br}_k s_k}{s^{\mathrm{T}}_k \widetilde^\mathrm{Br}_k s_k}
  \Bigr)
  \Bigl(
        \frac{y_k}{s^{\mathrm{T}}_k y_k} - \frac{\widetilde^\mathrm{Br}_k s_k}{s^{\mathrm{T}}_k \widetilde^\mathrm{Br}_k s_k}
  \Bigr)^{\mathrm{T}}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal M,\]</p><p>respectively, and <span>$œÜ_k$</span> is the Broyden factor which is <code>:constant</code> by default but can also be set to <code>:Davidon</code>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">Broyden(œÜ, update_rule::Symbol = :constant)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L216-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.SR1" href="#Manopt.SR1"><code>Manopt.SR1</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SR1 &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian SR1 update is used in the Riemannian quasi-Newton method.</p><p>Denote by <span>$\widetilde_k^\mathrm{SR1}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[H^\mathrm{SR1}_{k+1} = \widetilde^\mathrm{SR1}_k
+ \frac{(y_k - \widetilde^\mathrm{SR1}_k s_k) (y_k - \widetilde^\mathrm{SR1}_k s_k)^{\mathrm{T}}}{(y_k - \widetilde^\mathrm{SR1}_k s_k)^{\mathrm{T}} s_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal M,\]</p><p>respectively.</p><p>This method can be stabilized by only performing the update if denominator is larger than <span>$r\lVert s_k \rVert_{x_{k+1}}\lVert y_k - \widetilde^\mathrm{SR1}_k s_k \rVert_{x_{k+1}}$</span> for some <span>$r&gt;0$</span>. For more details, see Section 6.2 in [<a href="../../references/#NocedalWright_2006">NW06</a>].</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SR1(r::Float64=-1.0)</code></pre><p>Generate the <code>SR1</code> update.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L134-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseBFGS" href="#Manopt.InverseBFGS"><code>Manopt.InverseBFGS</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InverseBFGS &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the inverse Riemannian BFGS update is used in the Riemannian quasi-Newton method.</p><p>Denote by <span>$\widetilde_k^\mathrm{BFGS}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{BFGS}_{k+1}  = \Bigl(
  \mathrm{Id}_{T_{x_{k+1}} \mathcal M} - \frac{s_k y^{\mathrm{T}}_k }{s^{\mathrm{T}}_k y_k}
\Bigr)
\widetilde^\mathrm{BFGS}_k
\Bigl(
  \mathrm{Id}_{T_{x_{k+1}} \mathcal M} - \frac{y_k s^{\mathrm{T}}_k }{s^{\mathrm{T}}_k y_k}
\Bigr) + \frac{s_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal M,\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L52-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseDFP" href="#Manopt.InverseDFP"><code>Manopt.InverseDFP</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InverseDFP &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the inverse Riemannian DFP update is used in the Riemannian quasi-Newton method.</p><p>Denote by <span>$\widetilde_k^\mathrm{DFP}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{DFP}_{k+1} = \widetilde^\mathrm{DFP}_k + \frac{s_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
  - \frac{\widetilde^\mathrm{DFP}_k y_k y^{\mathrm{T}}_k \widetilde^\mathrm{DFP}_k}{y^{\mathrm{T}}_k \widetilde^\mathrm{DFP}_k y_k}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal M,\]</p><p>respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L110-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseBroyden" href="#Manopt.InverseBroyden"><code>Manopt.InverseBroyden</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InverseBroyden &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>Indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the Riemannian Broyden update is used in the Riemannian quasi-Newton method, which is as a convex combination of <a href="#Manopt.InverseBFGS"><code>InverseBFGS</code></a> and <a href="#Manopt.InverseDFP"><code>InverseDFP</code></a>.</p><p>Denote by <span>$\widetilde_k^{\mathrm{Br}}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{Br}_{k+1}
= \widetilde^\mathrm{Br}_k
   - \frac{\widetilde^\mathrm{Br}_k y_k y^{\mathrm{T}}_k \widetilde^\mathrm{Br}_k}{y^{\mathrm{T}}_k \widetilde^\mathrm{Br}_k y_k}
    + \frac{s_k s^{\mathrm{T}}_k}{s^{\mathrm{T}}_k y_k}
    + œÜ_k y^{\mathrm{T}}_k \widetilde^\mathrm{Br}_k y_k
    \Bigl(
        \frac{s_k}{s^{\mathrm{T}}_k y_k}
        - \frac{\widetilde^\mathrm{Br}_k y_k}{y^{\mathrm{T}}_k \widetilde^\mathrm{Br}_k y_k}
    \Bigr)
    \Bigl(
        \frac{s_k}{s^{\mathrm{T}}_k y_k}
        - \frac{\widetilde^\mathrm{Br}_k y_k}{y^{\mathrm{T}}_k \widetilde^\mathrm{Br}_k y_k}
     \Bigr)^{\mathrm{T}}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal M,\]</p><p>respectively, and <span>$œÜ_k$</span> is the Broyden factor which is <code>:constant</code> by default but can also be set to <code>:Davidon</code>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">InverseBroyden(œÜ, update_rule::Symbol = :constant)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L254-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InverseSR1" href="#Manopt.InverseSR1"><code>Manopt.InverseSR1</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InverseSR1 &lt;: AbstractQuasiNewtonUpdateRule</code></pre><p>indicates in <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> that the inverse Riemannian SR1 update is used in the Riemannian quasi-Newton method.</p><p>Denote by <span>$\widetilde_k^\mathrm{SR1}$</span> the operator concatenated with a vector transport and its inverse before and after to act on <span>$x_{k+1} = R_{x_k}(Œ±_k Œ∑_k)$</span>. Then the update formula reads</p><p class="math-container">\[B^\mathrm{SR1}_{k+1} = \widetilde^\mathrm{SR1}_k
+ rac{
  (s_k - \widetilde^\mathrm{SR1}_k y_k) (s_k - \widetilde^\mathrm{SR1}_k y_k)^{\mathrm{T}}
}{
  (s_k - \widetilde^\mathrm{SR1}_k y_k)^{\mathrm{T}} y_k
}\]</p><p>where <span>$s_k$</span> and <span>$y_k$</span> are the coordinate vectors with respect to the current basis (from <a href="#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a>) of</p><p class="math-container">\[T^{S}_{x_k, Œ±_k Œ∑_k}(Œ±_k Œ∑_k) \quad\text{and}\quad
\operatorname{grad}f(x_{k+1}) - T^{S}_{x_k, Œ±_k Œ∑_k}(\operatorname{grad}f(x_k)) ‚àà T_{x_{k+1}} \mathcal M,\]</p><p>respectively.</p><p>This method can be stabilized by only performing the update if denominator is larger than <span>$r\lVert y_k \rVert_{x_{k+1}}\lVert s_k - \widetilde^\mathrm{SR1}_k y_k \rVert_{x_{k+1}}$</span> for some <span>$r&gt;0$</span>. For more details, see Section 6.2 in [<a href="../../references/#NocedalWright_2006">NW06</a>].</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">InverseSR1(r::Float64=-1.0)</code></pre><p>Generate the <code>InverseSR1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/plans/quasi_newton_plan.jl#L176-L203">source</a></section></article><h2 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h2><p>The quasi Newton algorithm is based on a <a href="../../plans/problem/#Manopt.DefaultManoptProblem"><code>DefaultManoptProblem</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.QuasiNewtonState" href="#Manopt.QuasiNewtonState"><code>Manopt.QuasiNewtonState</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonState &lt;: AbstractManoptSolverState</code></pre><p>The <a href="../../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> represent any quasi-Newton based method and stores all necessary fields.</p><p><strong>Fields</strong></p><ul><li><code>direction_update</code>:              an <a href="#Manopt.AbstractQuasiNewtonDirectionUpdate"><code>AbstractQuasiNewtonDirectionUpdate</code></a> rule.</li><li><code>Œ∑</code>:                             the current update direction</li><li><code>nondescent_direction_behavior</code>: a <code>Symbol</code> to specify how to handle direction that are not descent ones.</li><li><code>nondescent_direction_value</code>:    the value from the last inner product from checking for descent directions</li><li><code>p::P</code>: a point on the manifold <span>$\mathcal M$</span> storing the current iterate</li><li><code>p_old</code>:                         the last iterate</li><li><code>preconditioner</code>                 an <a href="#Manopt.QuasiNewtonPreconditioner"><code>QuasiNewtonPreconditioner</code></a></li><li><code>sk</code>:                            the current step</li><li><code>yk</code>:                            the current gradient difference</li><li><code>retraction_method::AbstractRetractionMethod</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stepsize::Stepsize</code>: a functor inheriting from <a href="../../plans/stepsize/#Manopt.Stepsize"><code>Stepsize</code></a> to determine a step size</li><li><code>stop::StoppingCriterion</code>: a functor indicating that the stopping criterion is fulfilled</li><li><code>X::T</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>storing the gradient at the current iterate</li><li><code>X_old</code>:                         the last gradient</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">QuasiNewtonState(M::AbstractManifold, p; kwargs...)</code></pre><p>Generate the Quasi Newton state on the manifold <code>M</code> with start point <code>p</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>direction_update=</code><a href="#Manopt.QuasiNewtonLimitedMemoryDirectionUpdate"><code>QuasiNewtonLimitedMemoryDirectionUpdate</code></a><code>(M, p, InverseBFGS(), memory_size; vector_transport_method=vector_transport_method)</code></li><li><code>stopping_criterion=</code><a href="../../plans/stopping_criteria/#Manopt.StopAfterIteration"><code>StopAfterIteration</code></a><code>(1000)</code><a href="../../plans/stopping_criteria/#Manopt.StopWhenAny"><code>|</code></a><a href="../../plans/stopping_criteria/#Manopt.StopWhenGradientNormLess"><code>StopWhenGradientNormLess</code></a><code>(1e-6)</code>: a functor indicating that the stopping criterion is fulfilled</li><li><code>initial_scale=1.0</code>: a realtive initial scale. By default deactivated when using a preconditioner.</li><li><code>memory_size=20</code>: a shortcut to set the memory in the default direction update</li><li><code>preconditioner::Union{</code><a href="#Manopt.QuasiNewtonPreconditioner"><code>QuasiNewtonPreconditioner</code></a><code>, Nothing} = nothing</code> specify a preconditioner or deactivate by passing <code>nothing</code>.</li><li><code>retraction_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a><code>(M, typeof(p))</code>: a retraction <span>$\operatorname{retr}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/">the section on retractions</a></li><li><code>stepsize=</code><a href="../../plans/stepsize/#Manopt.default_stepsize-Tuple{AbstractManifold, Type{&lt;:AbstractManoptSolverState}}"><code>default_stepsize</code></a><code>(M, QuasiNewtonState)</code>: a functor inheriting from <a href="../../plans/stepsize/#Manopt.Stepsize"><code>Stepsize</code></a> to determine a step size</li><li><code>vector_transport_method=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a><code>(M, typeof(p))</code>: a vector transport <span>$\mathcal T_{‚ãÖ‚Üê‚ãÖ}$</span> to use, see <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/">the section on vector transports</a></li><li><code>X=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M, p)</code>: a tangent vector at the point <span>$p$</span> on the manifold <span>$\mathcal M$</span>to specify the representation of a tangent vector</li></ul><p><strong>See also</strong></p><p><a href="#Manopt.quasi_Newton"><code>quasi_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/563041c1a69abec434f3b524e58d10d30c0fc6a5/src/solvers/quasi_Newton.jl#L1-L46">source</a></section></article><h2 id="sec-qn-technical-details"><a class="docs-heading-anchor" href="#sec-qn-technical-details">Technical details</a><a id="sec-qn-technical-details-1"></a><a class="docs-heading-anchor-permalink" href="#sec-qn-technical-details" title="Permalink"></a></h2><p>The <a href="#Manopt.quasi_Newton"><code>quasi_Newton</code></a> solver requires the following functions of a manifold to be available</p><ul><li>A <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/"><code>retract!</code></a><code>(M, q, p, X)</code>; it is recommended to set the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/#ManifoldsBase.default_retraction_method-Tuple%7BAbstractManifold%7D"><code>default_retraction_method</code></a> to a favourite retraction. If this default is set, a <code>retraction_method=</code> does not have to be specified.</li><li>A <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/"><code>vector_transport_to!</code></a><code>M, Y, p, X, q)</code>; it is recommended to set the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple%7BAbstractManifold%7D"><code>default_vector_transport_method</code></a> to a favourite retraction. If this default is set, a <code>vector_transport_method=</code> or <code>vector_transport_method_dual=</code> (for <span>$\mathcal N$</span>) does not have to be specified.</li><li>By default quasi Newton uses <a href="../../plans/stepsize/#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a> which requires <a href="../../extensions/#Manopt.max_stepsize-Tuple{FixedRankMatrices, Any}"><code>max_stepsize</code></a><code>(M)</code> to be set and an implementation of <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.inner-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%2C%20Any%7D"><code>inner</code></a><code>(M, p, X)</code>.</li><li>the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#LinearAlgebra.norm-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D"><code>norm</code></a> as well, to stop when the norm of the gradient is small, but if you implemented <code>inner</code>, the norm is provided already.</li><li>A <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.copyto%21-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D"><code>copyto!</code></a><code>(M, q, p)</code> and <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.copy-Tuple%7BAbstractManifold%2C%20Any%7D"><code>copy</code></a><code>(M,p)</code> for points and similarly <code>copy(M, p, X)</code> for tangent vectors.</li><li>By default the tangent vector storing the gradient is initialized calling <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.zero_vector-Tuple%7BAbstractManifold%2C%20Any%7D"><code>zero_vector</code></a><code>(M,p)</code>.</li></ul><p>Most Hessian approximations further require <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.get_coordinates"><code>get_coordinates</code></a><code>(M, p, X, b)</code> with respect to the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a> <code>b</code> provided, which is <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.DefaultOrthonormalBasis"><code>DefaultOrthonormalBasis</code></a> by default from the <code>basis=</code> keyword.</p><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[HAG18]</dt><dd><div>W.¬†Huang, P.-A.¬†Absil and K.¬†A.¬†Gallivan. <em>A Riemannian BFGS method without differentiated retraction for nonconvex optimization problems</em>. <a href="https://doi.org/10.1137/17M1127582">SIAM¬†Journal¬†on¬†Optimization <strong>28</strong>, 470‚Äì495</a> (2018).</div></dd><dt>[HGA15]</dt><dd><div>W.¬†Huang, K.¬†A.¬†Gallivan and P.-A.¬†Absil. <em>A Broyden class of quasi-Newton methods for Riemannian optimization</em>. <a href="https://doi.org/10.1137/140955483">SIAM¬†Journal¬†on¬†Optimization <strong>25</strong>, 1660‚Äì1685</a> (2015).</div></dd><dt>[NW06]</dt><dd><div>J.¬†Nocedal and S.¬†J.¬†Wright. <a href="https://doi.org/10.1007/978-0-387-40065-5"><em>Numerical Optimization</em></a>. 2¬†Edition (Springer, New York, 2006).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../proximal_gradient_method/">¬´ Proximal Gradient Method</a><a class="docs-footer-nextpage" href="../stochastic_gradient_descent/">Stochastic Gradient Descent ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 9 October 2025 02:01">Thursday 9 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
