<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>List of Solvers ¬∑ Manopt.jl</title><meta name="title" content="List of Solvers ¬∑ Manopt.jl"/><meta property="og:title" content="List of Solvers ¬∑ Manopt.jl"/><meta property="twitter:title" content="List of Solvers ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../tutorials/Optimize/">üèîÔ∏è Get started: optimize.</a></li><li><a class="tocitem" href="../tutorials/InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../tutorials/AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../tutorials/EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../tutorials/CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../tutorials/HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../tutorials/ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../tutorials/ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../tutorials/ConstrainedOptimization/">Do constrained optimization</a></li><li><a class="tocitem" href="../tutorials/GeodesicRegression/">Do geodesic regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li class="is-active"><a class="tocitem" href>List of Solvers</a><ul class="internal"><li><a class="tocitem" href="#Derivative-free"><span>Derivative free</span></a></li><li><a class="tocitem" href="#First-order"><span>First order</span></a></li><li><a class="tocitem" href="#Second-order"><span>Second order</span></a></li><li><a class="tocitem" href="#Splitting-based"><span>Splitting based</span></a></li><li><a class="tocitem" href="#Constrained"><span>Constrained</span></a></li><li><a class="tocitem" href="#On-the-tangent-space"><span>On the tangent space</span></a></li><li><a class="tocitem" href="#Alphabetical-list-List-of-algorithms"><span>Alphabetical list List of algorithms</span></a></li><li><a class="tocitem" href="#Technical-details"><span>Technical details</span></a></li><li><a class="tocitem" href="#API-for-solvers"><span>API for solvers</span></a></li></ul></li><li><a class="tocitem" href="adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="cma_es/">CMA-ES</a></li><li><a class="tocitem" href="conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="conjugate_residual/">Conjugate Residual</a></li><li><a class="tocitem" href="convex_bundle_method/">Convex bundle method</a></li><li><a class="tocitem" href="cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="interior_point_Newton/">Interior Point Newton</a></li><li><a class="tocitem" href="LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="proximal_bundle_method/">Proximal bundle method</a></li><li><a class="tocitem" href="quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="subgradient/">Subgradient method</a></li><li><a class="tocitem" href="truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../plans/problem/">Problem</a></li><li><a class="tocitem" href="../plans/objective/">Objective</a></li><li><a class="tocitem" href="../plans/state/">Solver State</a></li><li><a class="tocitem" href="../plans/stepsize/">Stepsize</a></li><li><a class="tocitem" href="../plans/stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../plans/debug/">Debug Output</a></li><li><a class="tocitem" href="../plans/record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>List of Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>List of Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/solvers/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Available-solvers-in-Manopt.jl"><a class="docs-heading-anchor" href="#Available-solvers-in-Manopt.jl">Available solvers in Manopt.jl</a><a id="Available-solvers-in-Manopt.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Available-solvers-in-Manopt.jl" title="Permalink"></a></h1><p>Optimisation problems can be classified with respect to several criteria. The following list of the algorithms is a grouped with respect to the ‚Äúinformation‚Äù available about a optimisation problem</p><p class="math-container">\[\operatorname*{arg\,min}_{p‚àà\mathbb M} f(p)\]</p><p>Within each group short notes on advantages of the individual solvers, and required properties the cost <span>$f$</span> should have, are provided. In that list a üèÖ is used to indicate state-of-the-art solvers, that usually perform best in their corresponding group and ü´è for a maybe not so fast, maybe not so state-of-the-art method, that nevertheless gets the job done most reliably.</p><h2 id="Derivative-free"><a class="docs-heading-anchor" href="#Derivative-free">Derivative free</a><a id="Derivative-free-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-free" title="Permalink"></a></h2><p>For derivative free only function evaluations of <span>$f$</span> are used.</p><ul><li><a href="NelderMead/">Nelder-Mead</a> a simplex based variant, that is using <span>$d+1$</span> points, where <span>$d$</span> is the dimension of the manifold.</li><li><a href="particle_swarm/">Particle Swarm</a> ü´è use the evolution of a set of points, called swarm, to explore the domain of the cost and find a minimizer.</li><li><a href="cma_es/">CMA-ES</a> uses a stochastic evolutionary strategy to perform minimization robust to local minima of the objective.</li></ul><h2 id="First-order"><a class="docs-heading-anchor" href="#First-order">First order</a><a id="First-order-1"></a><a class="docs-heading-anchor-permalink" href="#First-order" title="Permalink"></a></h2><h3 id="Gradient"><a class="docs-heading-anchor" href="#Gradient">Gradient</a><a id="Gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient" title="Permalink"></a></h3><ul><li><a href="gradient_descent/">Gradient Descent</a> uses the gradient from <span>$f$</span> to determine a descent direction. Here, the direction can also be changed to be Averaged, Momentum-based, based on Nesterovs rule.</li><li><a href="conjugate_gradient_descent/">Conjugate Gradient Descent</a> uses information from the previous descent direction to improve the current (gradient-based) one including several such update rules.</li><li>The <a href="quasi_Newton/">Quasi-Newton Method</a> üèÖ uses gradient evaluations to approximate the Hessian, which is then used in a Newton-like scheme, where both a limited memory and a full Hessian approximation are available with several different update rules.</li><li><a href="truncated_conjugate_gradient_descent/#tCG">Steihaug-Toint Truncated Conjugate-Gradient Method</a> a solver for a constrained problem defined on a tangent space.</li></ul><h3 id="Subgradient"><a class="docs-heading-anchor" href="#Subgradient">Subgradient</a><a id="Subgradient-1"></a><a class="docs-heading-anchor-permalink" href="#Subgradient" title="Permalink"></a></h3><p>The following methods require the Riemannian subgradient <span>$‚àÇf$</span> to be available. While the subgradient might be set-valued, the function should provide one of the subgradients.</p><ul><li>The <a href="subgradient/">Subgradient Method</a> takes the negative subgradient as a step direction and can be combined with a step size.</li><li>The <a href="convex_bundle_method/">Convex Bundle Method</a> (CBM) uses a former collection of sub gradients at the previous iterates and iterate candidates to solve a local approximation to <code>f</code> in every iteration by solving a quadratic problem in the tangent space.</li><li>The <a href="proximal_bundle_method/">Proximal Bundle Method</a> works similar to CBM, but solves a proximal map-based problem in every iteration.</li></ul><h2 id="Second-order"><a class="docs-heading-anchor" href="#Second-order">Second order</a><a id="Second-order-1"></a><a class="docs-heading-anchor-permalink" href="#Second-order" title="Permalink"></a></h2><ul><li><a href="adaptive-regularization-with-cubics/">Adaptive Regularisation with Cubics</a> üèÖ locally builds a cubic model to determine the next descent direction.</li><li>The <a href="trust_regions/">Riemannian Trust-Regions Solver</a> builds a quadratic model within a trust region to determine the next descent direction.</li></ul><h2 id="Splitting-based"><a class="docs-heading-anchor" href="#Splitting-based">Splitting based</a><a id="Splitting-based-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-based" title="Permalink"></a></h2><p>For splitting methods, the algorithms are based on splitting the cost into different parts, usually in a sum of two or more summands. This is usually very well tailored for non-smooth objectives.</p><h3 id="Smooth"><a class="docs-heading-anchor" href="#Smooth">Smooth</a><a id="Smooth-1"></a><a class="docs-heading-anchor-permalink" href="#Smooth" title="Permalink"></a></h3><p>The following methods require that the splitting, for example into several summands, is smooth in the sense that for every summand of the cost, the gradient should still exist everywhere</p><ul><li><a href="LevenbergMarquardt/">Levenberg-Marquardt</a> minimizes the square norm of <span>$f: \mathcal M‚Üí‚Ñù^d$</span> provided the gradients of the component functions, or in other words the Jacobian of <span>$f$</span>.</li><li><a href="stochastic_gradient_descent/">Stochastic Gradient Descent</a> is based on a splitting of <span>$f$</span> into a sum of several components <span>$f_i$</span> whose gradients are provided. Steps are performed according to gradients of randomly selected components.</li><li>The <a href="alternating_gradient_descent/#solver-alternating-gradient-descent">Alternating Gradient Descent</a> alternates gradient descent steps on the components of the product manifold. All these components should be smooth as it is required, that the gradient exists, and is (locally) convex.</li></ul><h3 id="Nonsmooth"><a class="docs-heading-anchor" href="#Nonsmooth">Nonsmooth</a><a id="Nonsmooth-1"></a><a class="docs-heading-anchor-permalink" href="#Nonsmooth" title="Permalink"></a></h3><p>If the gradient does not exist everywhere, that is if the splitting yields summands that are nonsmooth, usually methods based on proximal maps are used.</p><ul><li>The <a href="ChambollePock/">Chambolle-Pock</a> algorithm uses a splitting <span>$f(p) = F(p) + G(Œõ(p))$</span>, where <span>$G$</span> is defined on a manifold <span>$\mathcal N$</span> and the proximal map of its Fenchel dual is required. Both these functions can be non-smooth.</li><li>The <a href="cyclic_proximal_point/">Cyclic Proximal Point</a> ü´è uses proximal maps of the functions from splitting <span>$f$</span> into summands <span>$f_i$</span></li><li><a href="difference_of_convex/#solver-difference-of-convex">Difference of Convex Algorithm</a> (DCA) uses a splitting of the (non-convex) function <span>$f = g - h$</span> into a difference of two functions; for each of these it is required to have access to the gradient of <span>$g$</span> and the subgradient of <span>$h$</span> to state a sub problem in every iteration to be solved.</li><li><a href="difference_of_convex/#solver-difference-of-convex-proximal-point">Difference of Convex Proximal Point</a> uses a splitting of the (non-convex) function <span>$f = g - h$</span> into a difference of two functions; provided the proximal map of <span>$g$</span> and the subgradient of <span>$h$</span>, the next iterate is computed. Compared to DCA, the corresponding sub problem is here written in a form that yields the proximal map.</li><li><a href="DouglasRachford/">Douglas‚ÄîRachford</a> uses a splitting <span>$f(p) = F(x) + G(x)$</span> and their proximal maps to compute a minimizer of <span>$f$</span>, which can be non-smooth.</li><li><a href="primal_dual_semismooth_Newton/#solver-pdrssn">Primal-dual Riemannian semismooth Newton Algorithm</a> extends Chambolle-Pock and requires the differentials of the proximal maps additionally.</li><li>The <a href="proximal_point/">Proximal Point</a> uses the proximal map of <span>$f$</span> iteratively.</li></ul><h2 id="Constrained"><a class="docs-heading-anchor" href="#Constrained">Constrained</a><a id="Constrained-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained" title="Permalink"></a></h2><p>Constrained problems of the form</p><p class="math-container">\[\begin{align*}
\operatorname*{arg\,min}_{p‚àà\mathbb M}&amp; f(p)\\
\text{such that } &amp; g(p) \leq 0\\&amp;h(p) = 0
\end{align*}\]</p><p>For these you can use</p><ul><li>The <a href="augmented_Lagrangian_method/">Augmented Lagrangian Method</a> (ALM), where both <code>g</code> and <code>grad_g</code> as well as <code>h</code> and <code>grad_h</code> are keyword arguments, and one of these pairs is mandatory.</li><li>The <a href="exact_penalty_method/">Exact Penalty Method</a> (EPM) uses a penalty term instead of augmentation, but has the same interface as ALM.</li><li>The <a href="interior_point_Newton/">Interior Point Newton Method</a> (IPM) rephrases the KKT system of a constrained problem into an Newton iteration being performed in every iteration.</li><li><a href="FrankWolfe/">Frank-Wolfe algorithm</a>, where besides the gradient of <span>$f$</span> either a closed form solution or a (maybe even automatically generated) sub problem solver for <span>$\operatorname*{arg\,min}_{q ‚àà C} ‚ü®\operatorname{grad} f(p_k), \log_{p_k}q‚ü©$</span> is required, where <span>$p_k$</span> is a fixed point on the manifold (changed in every iteration).</li></ul><h2 id="On-the-tangent-space"><a class="docs-heading-anchor" href="#On-the-tangent-space">On the tangent space</a><a id="On-the-tangent-space-1"></a><a class="docs-heading-anchor-permalink" href="#On-the-tangent-space" title="Permalink"></a></h2><ul><li><a href="conjugate_residual/">Conjugate Residual</a> a solver for a linear system <span>$\mathcal A[X] + b = 0$</span> on a tangent space.</li><li><a href="truncated_conjugate_gradient_descent/">Steihaug-Toint Truncated Conjugate-Gradient Method</a> a solver for a constrained problem defined on a tangent space.</li></ul><h2 id="Alphabetical-list-List-of-algorithms"><a class="docs-heading-anchor" href="#Alphabetical-list-List-of-algorithms">Alphabetical list List of algorithms</a><a id="Alphabetical-list-List-of-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Alphabetical-list-List-of-algorithms" title="Permalink"></a></h2><table><tr><th style="text-align: left">Solver</th><th style="text-align: left">Function</th><th style="text-align: left">State</th></tr><tr><td style="text-align: left"><a href="adaptive-regularization-with-cubics/">Adaptive Regularisation with Cubics</a></td><td style="text-align: left"><a href="adaptive-regularization-with-cubics/#Manopt.adaptive_regularization_with_cubics"><code>adaptive_regularization_with_cubics</code></a></td><td style="text-align: left"><a href="adaptive-regularization-with-cubics/#Manopt.AdaptiveRegularizationState"><code>AdaptiveRegularizationState</code></a></td></tr><tr><td style="text-align: left"><a href="augmented_Lagrangian_method/">Augmented Lagrangian Method</a></td><td style="text-align: left"><a href="augmented_Lagrangian_method/#Manopt.augmented_Lagrangian_method"><code>augmented_Lagrangian_method</code></a></td><td style="text-align: left"><a href="augmented_Lagrangian_method/#Manopt.AugmentedLagrangianMethodState"><code>AugmentedLagrangianMethodState</code></a></td></tr><tr><td style="text-align: left"><a href="ChambollePock/">Chambolle-Pock</a></td><td style="text-align: left"><a href="ChambollePock/#Manopt.ChambollePock"><code>ChambollePock</code></a></td><td style="text-align: left"><a href="ChambollePock/#Manopt.ChambollePockState"><code>ChambollePockState</code></a></td></tr><tr><td style="text-align: left"><a href="conjugate_gradient_descent/">Conjugate Gradient Descent</a></td><td style="text-align: left"><a href="conjugate_gradient_descent/#Manopt.conjugate_gradient_descent"><code>conjugate_gradient_descent</code></a></td><td style="text-align: left"><a href="conjugate_gradient_descent/#Manopt.ConjugateGradientDescentState"><code>ConjugateGradientDescentState</code></a></td></tr><tr><td style="text-align: left"><a href="conjugate_residual/">Conjugate Residual</a></td><td style="text-align: left"><a href="conjugate_residual/#Manopt.conjugate_residual"><code>conjugate_residual</code></a></td><td style="text-align: left"><a href="conjugate_residual/#Manopt.ConjugateResidualState"><code>ConjugateResidualState</code></a></td></tr><tr><td style="text-align: left"><a href="convex_bundle_method/">Convex Bundle Method</a></td><td style="text-align: left"><a href="convex_bundle_method/#Manopt.convex_bundle_method"><code>convex_bundle_method</code></a></td><td style="text-align: left"><a href="convex_bundle_method/#Manopt.ConvexBundleMethodState"><code>ConvexBundleMethodState</code></a></td></tr><tr><td style="text-align: left"><a href="cyclic_proximal_point/">Cyclic Proximal Point</a></td><td style="text-align: left"><a href="cyclic_proximal_point/#Manopt.cyclic_proximal_point"><code>cyclic_proximal_point</code></a></td><td style="text-align: left"><a href="cyclic_proximal_point/#Manopt.CyclicProximalPointState"><code>CyclicProximalPointState</code></a></td></tr><tr><td style="text-align: left"><a href="difference_of_convex/#solver-difference-of-convex">Difference of Convex Algorithm</a></td><td style="text-align: left"><a href="difference_of_convex/#Manopt.difference_of_convex_algorithm"><code>difference_of_convex_algorithm</code></a></td><td style="text-align: left"><a href="difference_of_convex/#Manopt.DifferenceOfConvexState"><code>DifferenceOfConvexState</code></a></td></tr><tr><td style="text-align: left"><a href="difference_of_convex/#solver-difference-of-convex-proximal-point">Difference of Convex Proximal Point</a></td><td style="text-align: left"><a href="difference_of_convex/#Manopt.difference_of_convex_proximal_point"><code>difference_of_convex_proximal_point</code></a></td><td style="text-align: left"><a href="difference_of_convex/#Manopt.DifferenceOfConvexProximalState"><code>DifferenceOfConvexProximalState</code></a></td></tr><tr><td style="text-align: left"><a href="DouglasRachford/">Douglas‚ÄîRachford</a></td><td style="text-align: left"><a href="DouglasRachford/#Manopt.DouglasRachford"><code>DouglasRachford</code></a></td><td style="text-align: left"><a href="DouglasRachford/#Manopt.DouglasRachfordState"><code>DouglasRachfordState</code></a></td></tr><tr><td style="text-align: left"><a href="exact_penalty_method/">Exact Penalty Method</a></td><td style="text-align: left"><a href="exact_penalty_method/#Manopt.exact_penalty_method"><code>exact_penalty_method</code></a></td><td style="text-align: left"><a href="exact_penalty_method/#Manopt.ExactPenaltyMethodState"><code>ExactPenaltyMethodState</code></a></td></tr><tr><td style="text-align: left"><a href="FrankWolfe/">Frank-Wolfe algorithm</a></td><td style="text-align: left"><a href="FrankWolfe/#Manopt.Frank_Wolfe_method"><code>Frank_Wolfe_method</code></a></td><td style="text-align: left"><a href="FrankWolfe/#Manopt.FrankWolfeState"><code>FrankWolfeState</code></a></td></tr><tr><td style="text-align: left"><a href="gradient_descent/">Gradient Descent</a></td><td style="text-align: left"><a href="gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a></td><td style="text-align: left"><a href="gradient_descent/#Manopt.GradientDescentState"><code>GradientDescentState</code></a></td></tr><tr><td style="text-align: left"><a href="interior_point_Newton/">Interior Point Newton</a></td><td style="text-align: left"><a href="interior_point_Newton/#Manopt.interior_point_Newton"><code>interior_point_Newton</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="LevenbergMarquardt/">Levenberg-Marquardt</a></td><td style="text-align: left"><a href="LevenbergMarquardt/#Manopt.LevenbergMarquardt"><code>LevenbergMarquardt</code></a></td><td style="text-align: left"><a href="LevenbergMarquardt/#Manopt.LevenbergMarquardtState"><code>LevenbergMarquardtState</code></a></td></tr><tr><td style="text-align: left"><a href="NelderMead/">Nelder-Mead</a></td><td style="text-align: left"><a href="NelderMead/#Manopt.NelderMead"><code>NelderMead</code></a></td><td style="text-align: left"><a href="NelderMead/#Manopt.NelderMeadState"><code>NelderMeadState</code></a></td></tr><tr><td style="text-align: left"><a href="particle_swarm/">Particle Swarm</a></td><td style="text-align: left"><a href="particle_swarm/#Manopt.particle_swarm"><code>particle_swarm</code></a></td><td style="text-align: left"><a href="particle_swarm/#Manopt.ParticleSwarmState"><code>ParticleSwarmState</code></a></td></tr><tr><td style="text-align: left"><a href="primal_dual_semismooth_Newton/#solver-pdrssn">Primal-dual Riemannian semismooth Newton Algorithm</a></td><td style="text-align: left"><a href="primal_dual_semismooth_Newton/#Manopt.primal_dual_semismooth_Newton"><code>primal_dual_semismooth_Newton</code></a></td><td style="text-align: left"><a href="primal_dual_semismooth_Newton/#Manopt.PrimalDualSemismoothNewtonState"><code>PrimalDualSemismoothNewtonState</code></a></td></tr><tr><td style="text-align: left"><a href="proximal_bundle_method/">Proximal Bundle Method</a></td><td style="text-align: left"><a href="proximal_bundle_method/#Manopt.proximal_bundle_method"><code>proximal_bundle_method</code></a></td><td style="text-align: left"><a href="proximal_bundle_method/#Manopt.ProximalBundleMethodState"><code>ProximalBundleMethodState</code></a></td></tr><tr><td style="text-align: left"><a href="proximal_point/">Proximal Point</a></td><td style="text-align: left"><a href="proximal_point/#Manopt.proximal_point"><code>proximal_point</code></a></td><td style="text-align: left"><a href="proximal_point/#Manopt.ProximalPointState"><code>ProximalPointState</code></a></td></tr><tr><td style="text-align: left"><a href="quasi_Newton/">Quasi-Newton Method</a></td><td style="text-align: left"><a href="quasi_Newton/#Manopt.quasi_Newton"><code>quasi_Newton</code></a></td><td style="text-align: left"><a href="quasi_Newton/#Manopt.QuasiNewtonState"><code>QuasiNewtonState</code></a></td></tr><tr><td style="text-align: left"><a href="truncated_conjugate_gradient_descent/#tCG">Steihaug-Toint Truncated Conjugate-Gradient Method</a></td><td style="text-align: left"><a href="truncated_conjugate_gradient_descent/#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a></td><td style="text-align: left"><a href="truncated_conjugate_gradient_descent/#Manopt.TruncatedConjugateGradientState"><code>TruncatedConjugateGradientState</code></a></td></tr><tr><td style="text-align: left"><a href="subgradient/">Subgradient Method</a></td><td style="text-align: left"><a href="subgradient/#Manopt.subgradient_method"><code>subgradient_method</code></a></td><td style="text-align: left"><a href="subgradient/#Manopt.SubGradientMethodState"><code>SubGradientMethodState</code></a></td></tr><tr><td style="text-align: left"><a href="stochastic_gradient_descent/">Stochastic Gradient Descent</a></td><td style="text-align: left"><a href="stochastic_gradient_descent/#Manopt.stochastic_gradient_descent"><code>stochastic_gradient_descent</code></a></td><td style="text-align: left"><a href="stochastic_gradient_descent/#Manopt.StochasticGradientDescentState"><code>StochasticGradientDescentState</code></a></td></tr><tr><td style="text-align: left"><a href="trust_regions/">Riemannian Trust-Regions</a></td><td style="text-align: left"><a href="trust_regions/#Manopt.trust_regions"><code>trust_regions</code></a></td><td style="text-align: left"><a href="trust_regions/#Manopt.TrustRegionsState"><code>TrustRegionsState</code></a></td></tr></table><p>Note that the solvers (their <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a>, to be precise) can also be decorated to enhance your algorithm by general additional properties, see <a href="../plans/debug/#sec-debug">debug output</a> and <a href="../plans/record/#sec-record">recording values</a>. This is done using the <code>debug=</code> and <code>record=</code> keywords in the function calls. Similarly, a <code>cache=</code> keyword is available in any of the function calls, that wraps the <a href="../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> in a cache for certain parts of the objective.</p><h2 id="Technical-details"><a class="docs-heading-anchor" href="#Technical-details">Technical details</a><a id="Technical-details-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-details" title="Permalink"></a></h2><p>The main function a solver calls is</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.solve!-Tuple{AbstractManoptProblem, AbstractManoptSolverState}" href="#Manopt.solve!-Tuple{AbstractManoptProblem, AbstractManoptSolverState}"><code>Manopt.solve!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(p::AbstractManoptProblem, s::AbstractManoptSolverState)</code></pre><p>run the solver implemented for the <a href="../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a><code>p</code> and the <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a><code>s</code> employing <a href="#Manopt.initialize_solver!"><code>initialize_solver!</code></a>, <a href="#Manopt.step_solver!"><code>step_solver!</code></a>, as well as the <a href="../plans/debug/#Manopt.stop_solver!-Tuple{AbstractManoptProblem, DebugSolverState, Int64}"><code>stop_solver!</code></a> of the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/3afe5d2c782ee0ba65830744b042cab55df0508e/src/solvers/solver.jl#L125-L131">source</a></section></article><p>which is a framework that you in general should not change or redefine. It uses the following methods, which also need to be implemented on your own algorithm, if you want to provide one.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.initialize_solver!" href="#Manopt.initialize_solver!"><code>Manopt.initialize_solver!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_solver!(ams::AbstractManoptProblem, amp::AbstractManoptSolverState)</code></pre><p>Initialize the solver to the optimization <a href="../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> by initializing the necessary values in the <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>amp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/3afe5d2c782ee0ba65830744b042cab55df0508e/src/solvers/solver.jl#L113-L118">source</a></section><section><div><pre><code class="language-julia hljs">initialize_solver!(amp::AbstractManoptProblem, dss::DebugSolverState)</code></pre><p>Extend the initialization of the solver by a hook to run the <a href="../plans/debug/#Manopt.DebugAction"><code>DebugAction</code></a> that was added to the <code>:Start</code> entry of the debug lists. All others are triggered (with iteration number <code>0</code>) to trigger possible resets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/3afe5d2c782ee0ba65830744b042cab55df0508e/src/solvers/debug_solver.jl#L1-L7">source</a></section><section><div><pre><code class="language-julia hljs">initialize_solver!(ams::AbstractManoptProblem, rss::RecordSolverState)</code></pre><p>Extend the initialization of the solver by a hook to run records that were added to the <code>:Start</code> entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/3afe5d2c782ee0ba65830744b042cab55df0508e/src/solvers/record_solver.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.step_solver!" href="#Manopt.step_solver!"><code>Manopt.step_solver!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">step_solver!(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, k)</code></pre><p>Do one iteration step (the <code>i</code>th) for an <a href="../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a><code>p</code> by modifying the values in the <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/3afe5d2c782ee0ba65830744b042cab55df0508e/src/solvers/solver.jl#L142-L147">source</a></section><section><div><pre><code class="language-julia hljs">step_solver!(amp::AbstractManoptProblem, dss::DebugSolverState, k)</code></pre><p>Extend the <code>i</code>th step of the solver by a hook to run debug prints, that were added to the <code>:BeforeIteration</code> and <code>:Iteration</code> entries of the debug lists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/3afe5d2c782ee0ba65830744b042cab55df0508e/src/solvers/debug_solver.jl#L22-L27">source</a></section><section><div><pre><code class="language-julia hljs">step_solver!(amp::AbstractManoptProblem, rss::RecordSolverState, k)</code></pre><p>Extend the <code>i</code>th step of the solver by a hook to run records, that were added to the <code>:Iteration</code> entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/3afe5d2c782ee0ba65830744b042cab55df0508e/src/solvers/record_solver.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_solver_result" href="#Manopt.get_solver_result"><code>Manopt.get_solver_result</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_solver_result(ams::AbstractManoptSolverState)
get_solver_result(tos::Tuple{AbstractManifoldObjective,AbstractManoptSolverState})
get_solver_result(o::AbstractManifoldObjective, s::AbstractManoptSolverState)</code></pre><p>Return the final result after all iterations that is stored within the <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code>, which was modified during the iterations.</p><p>For the case the objective is passed as well, but default, the objective is ignored, and the solver result for the state is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/3afe5d2c782ee0ba65830744b042cab55df0508e/src/plans/solver_state.jl#L233-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_solver_return" href="#Manopt.get_solver_return"><code>Manopt.get_solver_return</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_solver_return(s::AbstractManoptSolverState)
get_solver_return(o::AbstractManifoldObjective, s::AbstractManoptSolverState)</code></pre><p>determine the result value of a call to a solver. By default this returns the same as <a href="#Manopt.get_solver_result"><code>get_solver_result</code></a>.</p><pre><code class="nohighlight hljs">get_solver_return(s::ReturnSolverState)
get_solver_return(o::AbstractManifoldObjective, s::ReturnSolverState)</code></pre><p>return the internally stored state of the <a href="../plans/state/#Manopt.ReturnSolverState"><code>ReturnSolverState</code></a> instead of the minimizer. This means that when the state are decorated like this, the user still has to call <a href="#Manopt.get_solver_result"><code>get_solver_result</code></a> on the internal state separately.</p><pre><code class="nohighlight hljs">get_solver_return(o::ReturnManifoldObjective, s::AbstractManoptSolverState)</code></pre><p>return both the objective and the state as a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/3afe5d2c782ee0ba65830744b042cab55df0508e/src/plans/solver_state.jl#L124-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.stop_solver!-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Any}" href="#Manopt.stop_solver!-Tuple{AbstractManoptProblem, AbstractManoptSolverState, Any}"><code>Manopt.stop_solver!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stop_solver!(amp::AbstractManoptProblem, ams::AbstractManoptSolverState, k)</code></pre><p>depending on the current <a href="../plans/problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>, the current state of the solver stored in <a href="../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a> <code>ams</code> and the current iterate <code>i</code> this function determines whether to stop the solver, which by default means to call the internal <a href="../plans/stopping_criteria/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a>. <code>ams.stop</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/3afe5d2c782ee0ba65830744b042cab55df0508e/src/solvers/solver.jl#L153-L160">source</a></section></article><h2 id="API-for-solvers"><a class="docs-heading-anchor" href="#API-for-solvers">API for solvers</a><a id="API-for-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#API-for-solvers" title="Permalink"></a></h2><p>this is a short overview of the different types of high-level functions are usually available for a solver. Assume the solver is called <code>new_solver</code> and requires a cost <code>f</code> and some first order information <code>df</code> as well as a starting point <code>p</code> on <code>M</code>. <code>f</code> and <code>df</code> form the objective together called <code>obj</code>.</p><p>Then there are basically two different variants to call</p><h3 id="The-easy-to-access-call"><a class="docs-heading-anchor" href="#The-easy-to-access-call">The easy to access call</a><a id="The-easy-to-access-call-1"></a><a class="docs-heading-anchor-permalink" href="#The-easy-to-access-call" title="Permalink"></a></h3><pre><code class="nohighlight hljs">new_solver(M, f, df, p=rand(M); kwargs...)
new_solver!(M, f, df, p; kwargs...)</code></pre><p>Where the start point should be optional. Keyword arguments include the type of evaluation, decorators like <code>debug=</code> or <code>record=</code> as well as algorithm specific ones. If you provide an immutable point <code>p</code> or the <code>rand(M)</code> point is immutable, like on the <code>Circle()</code> this method should turn the point into a mutable one as well.</p><p>The third variant works in place of <code>p</code>, so it is mandatory.</p><p>This first interface would set up the objective and pass all keywords on the objective based call.</p><h3 id="Objective-based-calls-to-solvers"><a class="docs-heading-anchor" href="#Objective-based-calls-to-solvers">Objective based calls to solvers</a><a id="Objective-based-calls-to-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-based-calls-to-solvers" title="Permalink"></a></h3><pre><code class="nohighlight hljs">new_solver(M, obj, p=rand(M); kwargs...)
new_solver!(M, obj, p; kwargs...)</code></pre><p>Here the objective would be created beforehand for example to compare different solvers on the same objective, and for the first variant the start point is optional. Keyword arguments include decorators like <code>debug=</code> or <code>record=</code> as well as algorithm specific ones.</p><p>This variant would generate the <code>problem</code> and the <code>state</code> and verify validity of all provided keyword arguments that affect the state. Then it would call the iterate process.</p><h3 id="Manual-calls"><a class="docs-heading-anchor" href="#Manual-calls">Manual calls</a><a id="Manual-calls-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-calls" title="Permalink"></a></h3><p>If you generate the corresponding <code>problem</code> and <code>state</code> as the previous step does, you can also use the third (lowest level) and just call</p><pre><code class="nohighlight hljs">solve!(problem, state)</code></pre><h3 id="Closed-form-subsolvers"><a class="docs-heading-anchor" href="#Closed-form-subsolvers">Closed-form subsolvers</a><a id="Closed-form-subsolvers-1"></a><a class="docs-heading-anchor-permalink" href="#Closed-form-subsolvers" title="Permalink"></a></h3><p>If a subsolver solution is available in closed form, <code>ClosedFormSubSolverState</code> is used to indicate that.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ClosedFormSubSolverState" href="#Manopt.ClosedFormSubSolverState"><code>Manopt.ClosedFormSubSolverState</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ClosedFormSubSolverState{E&lt;:AbstractEvaluationType} &lt;: AbstractManoptSolverState</code></pre><p>Subsolver state indicating that a closed-form solution is available with <a href="../plans/objective/#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ClosedFormSubSolverState(; evaluation=AllocatingEvaluation())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/3afe5d2c782ee0ba65830744b042cab55df0508e/src/plans/solver_state.jl#L19-L28">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/GeodesicRegression/">¬´ Do geodesic regression</a><a class="docs-footer-nextpage" href="adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 23 October 2024 10:08">Wednesday 23 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
