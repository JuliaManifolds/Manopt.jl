<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Objective ¬∑ Manopt.jl</title><meta name="title" content="Objective ¬∑ Manopt.jl"/><meta property="og:title" content="Objective ¬∑ Manopt.jl"/><meta property="twitter:title" content="Objective ¬∑ Manopt.jl"/><meta name="description" content="Documentation for Manopt.jl."/><meta property="og:description" content="Documentation for Manopt.jl."/><meta property="twitter:description" content="Documentation for Manopt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/getstarted/">üèîÔ∏è Get started with Manopt.jl</a></li><li><a class="tocitem" href="../../tutorials/InplaceGradient/">Speedup using in-place computations</a></li><li><a class="tocitem" href="../../tutorials/AutomaticDifferentiation/">Use automatic differentiation</a></li><li><a class="tocitem" href="../../tutorials/EmbeddingObjectives/">Define objectives in the embedding</a></li><li><a class="tocitem" href="../../tutorials/CountAndCache/">Count and use a cache</a></li><li><a class="tocitem" href="../../tutorials/HowToDebug/">Print debug output</a></li><li><a class="tocitem" href="../../tutorials/HowToRecord/">Record values</a></li><li><a class="tocitem" href="../../tutorials/ImplementASolver/">Implement a solver</a></li><li><a class="tocitem" href="../../tutorials/ImplementOwnManifold/">Optimize on your own manifold</a></li><li><a class="tocitem" href="../../tutorials/ConstrainedOptimization/">Do constrained optimization</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">List of Solvers</a></li><li><a class="tocitem" href="../../solvers/adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/cma_es/">CMA-ES</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/conjugate_residual/">Conjugate Residual</a></li><li><a class="tocitem" href="../../solvers/convex_bundle_method/">Convex bundle method</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas‚ÄîRachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/interior_point_Newton/">Interior Point Newton</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg‚ÄìMarquardt</a></li><li><a class="tocitem" href="../../solvers/mesh_adaptive_direct_search/">Mesh Adaptive Direct Search</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder‚ÄìMead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/projected_gradient_method/">Projected Gradient Method</a></li><li><a class="tocitem" href="../../solvers/proximal_bundle_method/">Proximal bundle method</a></li><li><a class="tocitem" href="../../solvers/proximal_gradient_method/">Proximal Gradient Method</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../">Specify a Solver</a></li><li><a class="tocitem" href="../problem/">Problem</a></li><li class="is-active"><a class="tocitem" href>Objective</a><ul class="internal"><li><a class="tocitem" href="#Decorators-for-objectives"><span>Decorators for objectives</span></a></li><li><a class="tocitem" href="#Specific-Objective-typed-and-their-access-functions"><span>Specific Objective typed and their access functions</span></a></li></ul></li><li><a class="tocitem" href="../state/">Solver State</a></li><li><a class="tocitem" href="../stepsize/">Stepsize</a></li><li><a class="tocitem" href="../stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../debug/">Debug Output</a></li><li><a class="tocitem" href="../record/">Recording values</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plans</a></li><li class="is-active"><a href>Objective</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Objective</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/plans/objective.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="A-manifold-objective"><a class="docs-heading-anchor" href="#A-manifold-objective">A manifold objective</a><a id="A-manifold-objective-1"></a><a class="docs-heading-anchor-permalink" href="#A-manifold-objective" title="Permalink"></a></h1><p>The Objective describes that actual cost function and all its properties.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractManifoldObjective" href="#Manopt.AbstractManifoldObjective"><code>Manopt.AbstractManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldObjective{E&lt;:AbstractEvaluationType}</code></pre><p>Describe the collection of the optimization function <span>$f: \mathcal M ‚Üí ‚Ñù$</span> (or even a vectorial range) and its corresponding elements, which might for example be a gradient or (one or more) proximal maps.</p><p>All these elements should usually be implemented as functions <code>(M, p) -&gt; ...</code>, or <code>(M, X, p) -&gt; ...</code> that is</p><ul><li>the first argument of these functions should be the manifold <code>M</code> they are defined on</li><li>the argument <code>X</code> is present, if the computation is performed in-place of <code>X</code> (see <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>)</li><li>the argument <code>p</code> is the place the function (<span>$f$</span> or one of its elements) is evaluated <strong>at</strong>.</li></ul><p>the type <code>T</code> indicates the global <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/objective.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractDecoratedManifoldObjective" href="#Manopt.AbstractDecoratedManifoldObjective"><code>Manopt.AbstractDecoratedManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractDecoratedManifoldObjective{E&lt;:AbstractEvaluationType,O&lt;:AbstractManifoldObjective}</code></pre><p>A common supertype for all decorators of <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a>s to simplify dispatch.     The second parameter should refer to the undecorated objective (the most inner one).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/objective.jl#L25-L30">source</a></section></article><p>Which has two main different possibilities for its containing functions concerning the evaluation mode, not necessarily the cost, but for example gradient in an <a href="#Manopt.AbstractManifoldFirstOrderObjective"><code>AbstractManifoldFirstOrderObjective</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractEvaluationType" href="#Manopt.AbstractEvaluationType"><code>Manopt.AbstractEvaluationType</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractEvaluationType</code></pre><p>An abstract type to specify the kind of evaluation a <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> supports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/objective.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AllocatingEvaluation" href="#Manopt.AllocatingEvaluation"><code>Manopt.AllocatingEvaluation</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AllocatingEvaluation &lt;: AbstractEvaluationType</code></pre><p>A parameter for a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> or a <code>Function</code> indicating that the problem contains or the function(s) allocate memory for their result, they work out of place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/objective.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AllocatingInplaceEvaluation" href="#Manopt.AllocatingInplaceEvaluation"><code>Manopt.AllocatingInplaceEvaluation</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AllocatingInplaceEvaluation &lt;: AbstractEvaluationType</code></pre><p>A parameter for a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> or a <code>Function</code> indicating that the problem contains or the function(s) that provides both an allocating variant and one, that does not allocate memory but work on their input, in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/objective.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.InplaceEvaluation" href="#Manopt.InplaceEvaluation"><code>Manopt.InplaceEvaluation</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InplaceEvaluation &lt;: AbstractEvaluationType</code></pre><p>A parameter for a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> or a <code>Function</code> indicating that the problem contains or the function(s) do not allocate memory but work on their input, in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/objective.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ParentEvaluationType" href="#Manopt.ParentEvaluationType"><code>Manopt.ParentEvaluationType</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParentEvaluationType &lt;: AbstractEvaluationType</code></pre><p>A parameter for a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> or a <code>Function</code> indicating that the problem contains or the function(s) do inherit their property from a parent <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> or function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/objective.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.evaluation_type" href="#Manopt.evaluation_type"><code>Manopt.evaluation_type</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluation_type(mp::AbstractManoptProblem)</code></pre><p>Get the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> of the objective in <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>mp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/problem.jl#L32-L37">source</a></section><section><div><pre><code class="language-julia hljs">evaluation_type(::AbstractManifoldObjective{Teval})</code></pre><p>Get the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> of the objective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/problem.jl#L39-L43">source</a></section></article><h2 id="Decorators-for-objectives"><a class="docs-heading-anchor" href="#Decorators-for-objectives">Decorators for objectives</a><a id="Decorators-for-objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Decorators-for-objectives" title="Permalink"></a></h2><p>An objective can be decorated using the following trait and function to initialize</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.dispatch_objective_decorator" href="#Manopt.dispatch_objective_decorator"><code>Manopt.dispatch_objective_decorator</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dispatch_objective_decorator(o::AbstractManoptSolverState)</code></pre><p>Indicate internally, whether an <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>o</code> to be of decorating type, it stores (encapsulates) an object in itself, by default in the field <code>o.objective</code>.</p><p>Decorators indicate this by returning <code>Val{true}</code> for further dispatch.</p><p>The default is <code>Val{false}</code>, so by default an state is not decorated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/objective.jl#L142-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.is_objective_decorator" href="#Manopt.is_objective_decorator"><code>Manopt.is_objective_decorator</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_object_decorator(s::AbstractManifoldObjective)</code></pre><p>Indicate, whether <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>s</code> are of decorator type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/objective.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.decorate_objective!" href="#Manopt.decorate_objective!"><code>Manopt.decorate_objective!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decorate_objective!(M, o::AbstractManifoldObjective)</code></pre><p>decorate the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a><code>o</code> with specific decorators.</p><p><strong>Optional arguments</strong></p><p>optional arguments provide necessary details on the decorators. A specific one is used to activate certain decorators.</p><ul><li><code>cache=missing</code>: specify a cache. Currently <code>:Simple</code> is supported and <code>:LRU</code> if you load <a href="https://github.com/JuliaCollections/LRUCache.jl"><code>LRUCache.jl</code></a>. For this case a tuple specifying what to cache and how many can be provided, has to be specified. For example <code>(:LRU, [:Cost, :Gradient], 10)</code> states that the last 10 used cost function evaluations and gradient evaluations should be stored. See <a href="#Manopt.objective_cache_factory"><code>objective_cache_factory</code></a> for details.</li><li><code>count=missing</code>: specify calls to the objective to be called, see <a href="#Manopt.ManifoldCountObjective"><code>ManifoldCountObjective</code></a> for the full list</li><li><code>objective_type=:Riemannian</code>: specify that an objective is <code>:Riemannian</code> or <code>:Euclidean</code>. The <code>:Euclidean</code> symbol is equivalent to specifying it as <code>:Embedded</code>, since in the end, both refer to converting an objective from the embedding (whether its Euclidean or not) to the Riemannian one.</li></ul><p><strong>See also</strong></p><p><a href="#Manopt.objective_cache_factory"><code>objective_cache_factory</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/solvers/solver.jl#L76-L100">source</a></section></article><h3 id="subsection-embedded-objectives"><a class="docs-heading-anchor" href="#subsection-embedded-objectives">Embedded objectives</a><a id="subsection-embedded-objectives-1"></a><a class="docs-heading-anchor-permalink" href="#subsection-embedded-objectives" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.EmbeddedManifoldObjective" href="#Manopt.EmbeddedManifoldObjective"><code>Manopt.EmbeddedManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EmbeddedManifoldObjective{P, T, E, O2, O1&lt;:AbstractManifoldObjective{E}} &lt;:
   AbstractDecoratedManifoldObjective{E,O2}</code></pre><p>Declare an objective to be defined in the embedding. This also declares the gradient to be defined in the embedding, and especially being the Riesz representer with respect to the metric in the embedding. The types can be used to still dispatch on also the undecorated objective type <code>O2</code>.</p><p><strong>Fields</strong></p><ul><li><code>objective</code>: the objective that is defined in the embedding</li><li><code>p=nothing</code>: a point in the embedding.</li><li><code>X=nothing</code>: a tangent vector in the embedding</li></ul><p>When a point in the embedding <code>p</code> is provided, <code>embed!</code> is used in place of this point to reduce memory allocations. Similarly <code>X</code> is used when embedding tangent vectors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/embedded_objective.jl#L1-L18">source</a></section></article><h3 id="subsection-scaled-objectives"><a class="docs-heading-anchor" href="#subsection-scaled-objectives">Scaled objectives</a><a id="subsection-scaled-objectives-1"></a><a class="docs-heading-anchor-permalink" href="#subsection-scaled-objectives" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ScaledManifoldObjective" href="#Manopt.ScaledManifoldObjective"><code>Manopt.ScaledManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScaledManifoldObjective{E, O2, O1&lt;:AbstractManifoldObjective{E},F} &lt;:
   AbstractDecoratedManifoldObjective{E,O2}</code></pre><p>Declare an objective to be defined as a scaled version of an existing objective.</p><p>This rescales all involved functions.</p><p>For now the functions rescaled are</p><ul><li>the cost</li><li>the gradient</li><li>the Hessian</li></ul><p><strong>Fields</strong></p><ul><li><code>objective</code>: the objective that is defined in the embedding</li><li><code>scale=1</code>: the scaling applied</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ScaledManifoldObjective(objective, scale::Real=1)
-objective
scale*objective</code></pre><p>Generate a scaled manifold objective based on <code>objective</code> with <code>scale</code> being <code>1</code> by default in the first, <code>scale=-1</code> in the second case. The multiplication from the left with a scalar is also overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/scaled_objective.jl#L1-L29">source</a></section></article><h3 id="subsection-cache-objective"><a class="docs-heading-anchor" href="#subsection-cache-objective">Cache objective</a><a id="subsection-cache-objective-1"></a><a class="docs-heading-anchor-permalink" href="#subsection-cache-objective" title="Permalink"></a></h3><p>Since single function calls, for example to the cost or the gradient, might be expensive, a simple cache objective exists as a decorator, that caches one cost value or gradient.</p><p>It can be activated/used with the <code>cache=</code> keyword argument available for every solver.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.reset_counters!" href="#Manopt.reset_counters!"><code>Manopt.reset_counters!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset_counters(co::ManifoldCountObjective, value::Integer=0)</code></pre><p>Reset all values in the count objective to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/count.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.objective_cache_factory" href="#Manopt.objective_cache_factory"><code>Manopt.objective_cache_factory</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">objective_cache_factory(M::AbstractManifold, o::AbstractManifoldObjective, cache::Symbol)</code></pre><p>Generate a cached variant of the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>o</code> on the <code>AbstractManifold M</code> based on the symbol <code>cache</code>.</p><p>The following caches are available</p><ul><li><code>:Simple</code> generates a <a href="#Manopt.SimpleManifoldCachedObjective"><code>SimpleManifoldCachedObjective</code></a></li><li><code>:LRU</code> generates a <a href="#Manopt.ManifoldCachedObjective"><code>ManifoldCachedObjective</code></a> where you should use the form <code>(:LRU, [:Cost, :Gradient])</code> to specify what should be cached or <code>(:LRU, [:Cost, :Gradient], 100)</code> to specify the cache size. Here this variant defaults to <code>(:LRU, [:Cost, :Gradient], 100)</code>, caching up to 100 cost and gradient values.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/cache.jl#L998-L1015">source</a></section><section><div><pre><code class="language-julia hljs">objective_cache_factory(M::AbstractManifold, o::AbstractManifoldObjective, cache::Tuple{Symbol, Array, Array})
objective_cache_factory(M::AbstractManifold, o::AbstractManifoldObjective, cache::Tuple{Symbol, Array})</code></pre><p>Generate a cached variant of the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> <code>o</code> on the <code>AbstractManifold M</code> based on the symbol <code>cache[1]</code>, where the second element <code>cache[2]</code> are further arguments to the cache and the optional third is passed down as keyword arguments.</p><p>For all available caches see the simpler variant with symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/cache.jl#L1023-L1033">source</a></section></article><h4 id="A-simple-cache"><a class="docs-heading-anchor" href="#A-simple-cache">A simple cache</a><a id="A-simple-cache-1"></a><a class="docs-heading-anchor-permalink" href="#A-simple-cache" title="Permalink"></a></h4><p>A first generic cache is always available, but it only caches one gradient and one cost function evaluation (for the same point).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.SimpleManifoldCachedObjective" href="#Manopt.SimpleManifoldCachedObjective"><code>Manopt.SimpleManifoldCachedObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> SimpleManifoldCachedObjective{O&lt;:AbstractManifoldFirstOrderObjective{E}, P, T,C} &lt;: AbstractDecoratedManifoldObjective{E,O}</code></pre><p>Provide a simple cache for an <a href="#Manopt.AbstractManifoldFirstOrderObjective"><code>AbstractManifoldFirstOrderObjective</code></a> that is, this cache stores a point <code>p</code> and a gradient <span>$\operatorname{grad} f(p)$</span> in <code>X</code> as well as a cost value <span>$f(p)$</span> in <code>c</code>. It can also easily evaluate the differential based on the cached gradient.</p><p>Both <code>X</code> and <code>c</code> are accompanied by booleans to keep track of their validity.</p><p>While this does not provide a cache for the differential, it uses the cached gradient as a help to evaluate the differential, if an up-to-date gradient is available. It otherwise does call the original differential.</p><p>This simple cache does not take into account, that some first order objectives have a common function for cost &amp; grad. It only caches the function that is actually called.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SimpleManifoldCachedObjective(M::AbstractManifold, obj::AbstractManifoldFirstOrderObjective; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on the manifold to initialize the cache with</li><li><code>X=get_gradient(M, obj, p)</code> or <code>zero_vector(M,p)</code>: a tangent vector to store the gradient in, see also <code>initialize=</code></li><li><code>c=[</code>get_cost<code>](@ref)</code>(M, obj, p)<code>or</code>0.0<code>: a value to store the cost function in</code>initialize`</li><li><code>initialized=true</code>: whether to initialize the cached <code>X</code> and <code>c</code> or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/cache.jl#L4-L31">source</a></section></article><h4 id="A-generic-cache"><a class="docs-heading-anchor" href="#A-generic-cache">A generic cache</a><a id="A-generic-cache-1"></a><a class="docs-heading-anchor-permalink" href="#A-generic-cache" title="Permalink"></a></h4><p>For the more advanced cache, you need to implement some type of cache yourself, that provides a <code>get!</code> and implement <a href="#Manopt.init_caches"><code>init_caches</code></a>. This is for example provided if you load <a href="https://github.com/JuliaCollections/LRUCache.jl"><code>LRUCache.jl</code></a>. Then you obtain</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldCachedObjective" href="#Manopt.ManifoldCachedObjective"><code>Manopt.ManifoldCachedObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldCachedObjective{E,P,O&lt;:AbstractManifoldObjective{&lt;:E},C&lt;:NamedTuple{}} &lt;: AbstractDecoratedManifoldObjective{E,P}</code></pre><p>Create a cache for an objective, based on a <code>NamedTuple</code> that stores some kind of cache.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldCachedObjective(M, o::AbstractManifoldObjective, caches::Vector{Symbol}; kwargs...)</code></pre><p>Create a cache for the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> where the Symbols in <code>caches</code> indicate, which function evaluations to cache.</p><p><strong>Supported symbols</strong></p><table><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Caches calls to (incl. <code>!</code> variants)</th><th style="text-align: left">Comment</th></tr><tr><td style="text-align: left"><code>:Cost</code></td><td style="text-align: left"><a href="#Manopt.get_cost"><code>get_cost</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:Differential</code></td><td style="text-align: left"><a href="#Manopt.get_differential"><code>get_differential</code></a><code>(M, p, X)</code>.</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:EqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraint"><code>get_equality_constraint</code></a><code>(M, p, i)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:EqualityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraint"><code>get_equality_constraint</code></a><code>(M, p, :)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:GradEqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_grad_equality_constraint"><code>get_grad_equality_constraint</code></a></td><td style="text-align: left">tangent vector per (p,i)</td></tr><tr><td style="text-align: left"><code>:GradInequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">tangent vector per (p,i)</td></tr><tr><td style="text-align: left"><code>:Gradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M,p)</code></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:Hessian</code></td><td style="text-align: left"><a href="#Manopt.get_hessian"><code>get_hessian</code></a></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:InequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a><code>(M, p, j)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:InequalityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a><code>(M, p, :)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:Preconditioner</code></td><td style="text-align: left"><a href="#Manopt.get_preconditioner"><code>get_preconditioner</code></a></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:ProximalMap</code></td><td style="text-align: left"><a href="#Manopt.get_proximal_map"><code>get_proximal_map</code></a></td><td style="text-align: left">point per <code>(p,Œª,i)</code></td></tr><tr><td style="text-align: left"><code>:StochasticGradients</code></td><td style="text-align: left"><a href="#Manopt.get_gradients"><code>get_gradients</code></a></td><td style="text-align: left">vector of tangent vectors</td></tr><tr><td style="text-align: left"><code>:StochasticGradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M, p, i)</code></td><td style="text-align: left">tangent vector per (p,i)</td></tr><tr><td style="text-align: left"><code>:SubGradient</code></td><td style="text-align: left"><a href="#Manopt.get_subgradient"><code>get_subgradient</code></a></td><td style="text-align: left">tangent vectors</td></tr><tr><td style="text-align: left"><code>:SubtrahendGradient</code></td><td style="text-align: left"><a href="../../solvers/difference_of_convex/#Manopt.get_subtrahend_gradient"><code>get_subtrahend_gradient</code></a></td><td style="text-align: left">tangent vectors</td></tr></table><p><strong>Keyword arguments</strong></p><ul><li><code>p=rand(M)</code>: the type of the keys to be used in the caches. Defaults to the default representation on <code>M</code>.</li><li><code>value=get_cost(M, objective, p)</code>: the type of values for numeric values in the cache</li><li><code>X=zero_vector(M,p)</code>: the type of values to be cached for gradient and Hessian calls.</li><li><code>cache=[:Cost]</code>: a vector of symbols indicating which function calls should be cached.</li><li><code>cache_size=10</code>: number of (least recently used) calls to cache</li><li><code>cache_sizes=Dict{Symbol,Int}()</code>: a named tuple or dictionary specifying the sizes individually for each cache.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/cache.jl#L168-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.init_caches" href="#Manopt.init_caches"><code>Manopt.init_caches</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_caches(caches, T::Type{LRU}; kwargs...)</code></pre><p>Given a vector of symbols <code>caches</code>, this function sets up the <code>NamedTuple</code> of caches, where <code>T</code> is the type of cache to use.</p><p><strong>Keyword arguments</strong></p><ul><li><code>p=</code><a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.rand-Tuple%7BAbstractManifold%7D"><code>rand</code></a><code>(M)</code>: a point on a manifold, to both infer its type for keys and initialize caches</li><li><code>value=0.0</code>:  a value both typing and initialising number-caches, the default is for (Float) values like the cost.</li><li><code>X=zero_vector(M, p)</code>: a tangent vector at <code>p</code> to both type and initialize tangent vector caches</li><li><code>cache_size=10</code>: a default cache size to use</li><li><code>cache_sizes=Dict{Symbol,Int}()</code>: a dictionary of sizes for the <code>caches</code> to specify different (non-default) sizes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/ext/ManoptLRUCacheExt.jl#L15-L32">source</a></section><section><div><pre><code class="language-julia hljs">init_caches(M::AbstractManifold, caches, T; kwargs...)</code></pre><p>Given a vector of symbols <code>caches</code>, this function sets up the <code>NamedTuple</code> of caches for points/vectors on <code>M</code>, where <code>T</code> is the type of cache to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/cache.jl#L252-L258">source</a></section></article><h3 id="subsection-count-objective"><a class="docs-heading-anchor" href="#subsection-count-objective">Count objective</a><a id="subsection-count-objective-1"></a><a class="docs-heading-anchor-permalink" href="#subsection-count-objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldCountObjective" href="#Manopt.ManifoldCountObjective"><code>Manopt.ManifoldCountObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldCountObjective{E,P,O&lt;:AbstractManifoldObjective,I&lt;:Integer} &lt;: AbstractDecoratedManifoldObjective{E,P}</code></pre><p>A wrapper for any <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> of type <code>O</code> to count different calls to parts of the objective.</p><p><strong>Fields</strong></p><ul><li><code>counts</code> a dictionary of symbols mapping to integers keeping the counted values</li><li><code>objective</code> the wrapped objective</li></ul><p><strong>Supported symbols</strong></p><table><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Counts calls to (incl. <code>!</code> variants)</th><th style="text-align: left">Comment</th></tr><tr><td style="text-align: left"><code>:Cost</code></td><td style="text-align: left"><a href="#Manopt.get_cost"><code>get_cost</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:Differential</code></td><td style="text-align: left"><a href="#Manopt.get_differential"><code>get_differential</code></a>.</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:EqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraint"><code>get_equality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:EqualityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_equality_constraint"><code>get_equality_constraint</code></a></td><td style="text-align: left">when evaluating all of them with <code>:</code></td></tr><tr><td style="text-align: left"><code>:GradEqualityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_grad_equality_constraint"><code>get_grad_equality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:GradEqualityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_grad_equality_constraint"><code>get_grad_equality_constraint</code></a></td><td style="text-align: left">when evaluating all of them with <code>:</code></td></tr><tr><td style="text-align: left"><code>:GradInequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:GradInequalityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">when evaluating all of them with <code>:</code></td></tr><tr><td style="text-align: left"><code>:Gradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M,p)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:Hessian</code></td><td style="text-align: left"><a href="#Manopt.get_hessian"><code>get_hessian</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:InequalityConstraint</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">requires vector of counters</td></tr><tr><td style="text-align: left"><code>:InequalityConstraints</code></td><td style="text-align: left"><a href="#Manopt.get_inequality_constraint"><code>get_inequality_constraint</code></a></td><td style="text-align: left">when evaluating all of them with <code>:</code></td></tr><tr><td style="text-align: left"><code>:Preconditioner</code></td><td style="text-align: left"><a href="#Manopt.get_preconditioner"><code>get_preconditioner</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:ProximalMap</code></td><td style="text-align: left"><a href="#Manopt.get_proximal_map"><code>get_proximal_map</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:StochasticGradients</code></td><td style="text-align: left"><a href="#Manopt.get_gradients"><code>get_gradients</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:StochasticGradient</code></td><td style="text-align: left"><a href="#Manopt.get_gradient"><code>get_gradient</code></a><code>(M, p, i)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:SubGradient</code></td><td style="text-align: left"><a href="#Manopt.get_subgradient"><code>get_subgradient</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>:SubtrahendGradient</code></td><td style="text-align: left"><a href="../../solvers/difference_of_convex/#Manopt.get_subtrahend_gradient"><code>get_subtrahend_gradient</code></a></td><td style="text-align: left"></td></tr></table><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldCountObjective(objective::AbstractManifoldObjective, counts::Dict{Symbol, &lt;:Integer})</code></pre><p>Initialise the <code>ManifoldCountObjective</code> to wrap <code>objective</code> initializing the set of counts</p><pre><code class="nohighlight hljs">ManifoldCountObjective(M::AbstractManifold, objective::AbstractManifoldObjective, count::AbstractVecor{Symbol}, init=0)</code></pre><p>Count function calls on <code>objective</code> using the symbols in <code>count</code> initialising all entries to <code>init</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/count.jl#L1-L44">source</a></section></article><h4 id="Internal-decorators-and-functions"><a class="docs-heading-anchor" href="#Internal-decorators-and-functions">Internal decorators and functions</a><a id="Internal-decorators-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-decorators-and-functions" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ReturnManifoldObjective" href="#Manopt.ReturnManifoldObjective"><code>Manopt.ReturnManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReturnManifoldObjective{E,O2,O1&lt;:AbstractManifoldObjective{E}} &lt;:
   AbstractDecoratedManifoldObjective{E,O2}</code></pre><p>A wrapper to indicate that <code>get_solver_result</code> should return the inner objective.</p><p>The types are such that one can still dispatch on the undecorated type <code>O2</code> of the original objective as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/objective.jl#L68-L76">source</a></section></article><h2 id="Specific-Objective-typed-and-their-access-functions"><a class="docs-heading-anchor" href="#Specific-Objective-typed-and-their-access-functions">Specific Objective typed and their access functions</a><a id="Specific-Objective-typed-and-their-access-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-Objective-typed-and-their-access-functions" title="Permalink"></a></h2><h3 id="Cost-objective"><a class="docs-heading-anchor" href="#Cost-objective">Cost objective</a><a id="Cost-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Cost-objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractManifoldCostObjective" href="#Manopt.AbstractManifoldCostObjective"><code>Manopt.AbstractManifoldCostObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldCostObjective{T&lt;:AbstractEvaluationType} &lt;: AbstractManifoldObjective{T}</code></pre><p>Representing objectives on manifolds with a cost function implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/cost_plan.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldCostObjective" href="#Manopt.ManifoldCostObjective"><code>Manopt.ManifoldCostObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldCostObjective{T, TC} &lt;: AbstractManifoldCostObjective{T, TC}</code></pre><p>specify an <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> that does only have information about the cost function <span>$f:  \mathbb M ‚Üí ‚Ñù$</span> implemented as a function <code>(M, p) -&gt; c</code> to compute the cost value <code>c</code> at <code>p</code> on the manifold <code>M</code>.</p><ul><li><code>cost</code>: a function <span>$f: \mathcal M ‚Üí ‚Ñù$</span> to minimize</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldCostObjective(f)</code></pre><p>Generate a problem. While this Problem does not have any allocating functions, the type <code>T</code> can be set for consistency reasons with other problems.</p><p><strong>Used with</strong></p><p><a href="../../solvers/NelderMead/#Manopt.NelderMead"><code>NelderMead</code></a>, <a href="../../solvers/particle_swarm/#Manopt.particle_swarm"><code>particle_swarm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/cost_plan.jl#L9-L27">source</a></section></article><h4 id="Access-functions"><a class="docs-heading-anchor" href="#Access-functions">Access functions</a><a id="Access-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Access-functions" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_cost" href="#Manopt.get_cost"><code>Manopt.get_cost</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_cost(amp::AbstractManoptProblem, p)</code></pre><p>evaluate the cost function <code>f</code> stored within the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at the point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/problem.jl#L67-L72">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(M::AbstractManifold, obj::AbstractManifoldObjective, p)</code></pre><p>evaluate the cost function <code>f</code> defined on <code>M</code> stored within the <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> at the point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/problem.jl#L77-L81">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(M::AbstractManifold, mco::AbstractManifoldCostObjective, p)</code></pre><p>Evaluate the cost function from within the <a href="#Manopt.AbstractManifoldCostObjective"><code>AbstractManifoldCostObjective</code></a> on <code>M</code> at <code>p</code>.</p><p>By default this implementation assumed that the cost is stored within <code>mco.cost</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/cost_plan.jl#L35-L42">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(TpM, trmo::TrustRegionModelObjective, X)</code></pre><p>Evaluate the tangent space <a href="../../solvers/truncated_conjugate_gradient_descent/#Manopt.TrustRegionModelObjective"><code>TrustRegionModelObjective</code></a></p><p class="math-container">\[m(X) = f(p) + ‚ü®\operatorname{grad} f(p), X ‚ü©_p + \frac{1}{2} ‚ü®\operatorname{Hess} f(p)[X], X‚ü©_p.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/trust_regions_plan.jl#L37-L45">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(TpM, trmo::AdaptiveRagularizationWithCubicsModelObjective, X)</code></pre><p>Evaluate the tangent space <a href="../../solvers/adaptive-regularization-with-cubics/#Manopt.AdaptiveRagularizationWithCubicsModelObjective"><code>AdaptiveRagularizationWithCubicsModelObjective</code></a></p><p class="math-container">\[m(X) = f(p) + ‚ü®\operatorname{grad} f(p), X ‚ü©_p + \frac{1}{2} ‚ü®\operatorname{Hess} f(p)[X], X‚ü©_p
       +  \frac{œÉ}{3} \lVert X \rVert^3,\]</p><p>at <code>X</code>, cf. Eq. (33) in [<a href="../../references/#AgarwalBoumalBullinsCartis_2020">ABBC20</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/adabtive_regularization_with_cubics_plan.jl#L50-L61">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(TpM::TangentSpace, slso::SymmetricLinearSystemObjective, X)</code></pre><p>evaluate the cost</p><p class="math-container">\[f(X) = \frac{1}{2} \lVert \mathcal A[X] + b \rVert_{p}^2,\qquad X ‚àà T_{p}\mathcal M,\]</p><p>at <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/conjugate_residual_plan.jl#L56-L64">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p, i)</code></pre><p>Evaluate the <code>i</code>th summand of the cost.</p><p>If you use a single function for the stochastic cost, then only the index <code>√¨=1</code>` is available to evaluate the whole cost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/stochastic_gradient_plan.jl#L60-L67">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(M::AbstractManifold,emo::EmbeddedManifoldObjective, p)</code></pre><p>Evaluate the cost function of an objective defined in the embedding by first embedding <code>p</code> before calling the cost function stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/embedded_objective.jl#L60-L65">source</a></section><section><div><pre><code class="language-julia hljs">get_cost(M::AbstractManifold, scaled_objective::ScaledManifoldObjective, p)</code></pre><p>Evaluate the scaled objective. <span>$s*f(p)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/scaled_objective.jl#L56-L60">source</a></section></article><p>and internally</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_cost_function" href="#Manopt.get_cost_function"><code>Manopt.get_cost_function</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_cost_function(amco::AbstractManifoldCostObjective; recursive=false)</code></pre><p>return the function to evaluate (just) the cost <span>$f(p)=c$</span> as a function <code>(M,p) -&gt; c</code>. If <code>amco</code> has more than one decorator, <code>recursive</code> determines whether just one (<code>false</code>) or all wrappers (<code>true</code>) should be ‚Äúunwrapped‚Äù at once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/cost_plan.jl#L50-L56">source</a></section></article><h3 id="First-order-objectives"><a class="docs-heading-anchor" href="#First-order-objectives">First order objectives</a><a id="First-order-objectives-1"></a><a class="docs-heading-anchor-permalink" href="#First-order-objectives" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractManifoldFirstOrderObjective" href="#Manopt.AbstractManifoldFirstOrderObjective"><code>Manopt.AbstractManifoldFirstOrderObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldFirstOrderObjective{E&lt;:AbstractEvaluationType, FGD} &lt;: AbstractManifoldCostObjective{E, FGD}</code></pre><p>An abstract type for all objectives that provide</p><ul><li>a cost</li><li>first order information, so either a (full) gradient or a differential, where</li></ul><p><code>E</code> is a <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> for the gradient function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/first_order_plan.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldFirstOrderObjective" href="#Manopt.ManifoldFirstOrderObjective"><code>Manopt.ManifoldFirstOrderObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldFirstOrderObjective{E&lt;:AbstractEvaluationType, F} &lt;: AbstractManifoldFirstOrderObjective{E, F}</code></pre><p>specify an objective containing a cost and its gradient or differential, where the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code> indicates the type of evaluation for a gradient.</p><p><strong>Fields</strong></p><ul><li><code>functions::F</code>: a function or a tuple of functions containing the cost and first order information.</li></ul><p>Currently the following cases are covered, sorted by their popularity</p><ol><li>a single function <code>fg</code>, i.e. a function or a functor, represents a combined  function <code>(M, p) -&gt; (c, X)</code> that computes the cost <code>c=cost(M,p)</code> and gradient <code>X=grad_f(M,p)</code>;</li><li>a single function <code>fdf</code>, i.e. a function or a functor, represents a combined function  <code>(M, p) -&gt; (c, d)</code> that computes the cost <code>c=cost(M,p)</code> and differential <code>d=diff_f(M,p)</code>;</li><li>pairs of single functions <code>(f, g)</code>, <code>(f, df)</code> of a cost function <code>f</code> and either its  gradient <code>g</code> or its differential <code>d</code>, respectively</li><li>The function <code>(fg, d)</code> and <code>(fdf, g)</code>  from 1 and 2, respectively joined by  the other missing third information, the differential for the first or the gradient for the second</li><li>a tuple <code>(f, g, d)</code> of three functions, computing cost, <code>f</code>, gradient <code>g</code>,  and <code>differential</code>d` separately</li><li>a <code>(f, gd)</code> of a cost function and a combined function <code>(X, d) = gd(M, p, X)</code>  to compute gradient and differential together</li><li>a single function <code>(c, X, d) = fgd(M, p,X)</code></li></ol><p>For all cases where a gradient is present, also an in-place variant is possible, where the signature has the result <code>Y</code> in second place.</p><p>The cases of a common <code>fg</code> function for cost and gradient and the tuple <code>(f,g)</code> are the most common one. They can also be addressed by their alternate constructors <a href="#Manopt.ManifoldCostGradientObjective"><code>ManifoldCostGradientObjective</code></a><code>(fg)</code> and <a href="#Manopt.ManifoldGradientObjective"><code>ManifoldGradientObjective</code></a><code>(f,g)</code>, respectively.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldFirstOrderObjective(; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>cost = nothing</code> the cost function <code>c = f(M,p)</code></li><li><code>differential = nothing</code> the differential <code>d = df(M, p, X)</code></li><li><code>gradient=nothing</code> the gradient function <code>g(M, p)</code> or in-place <code>g!(M, X, p)</code></li><li><code>costgradient = nothing</code> the combined cost and gradient function <code>fg(M,p)</code> or in-place <code>fg!(M, X, p))</code></li><li><code>costdifferential = nothing</code> the combined cost and differential function  <code>fdf(M, p, X)</code></li><li><code>evaluation=</code><a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.</li></ul><p>Where:</p><ul><li>At least one of <code>cost</code>, <code>costgradient</code> or <code>costdifferential</code> must be provided.</li><li>Either <code>gradient</code>, <code>costgradient</code>, <code>differential</code> or <code>costdifferential</code> must be provided.</li><li>If more than one function provides the same thing (e.g. cost), it is assumed that all such functions return the same value. Optimization algorithms will attempt to make the most efficient use of provided functions.</li></ul><p><strong>Used with</strong></p><p><a href="../../solvers/gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a>, <a href="../../solvers/conjugate_gradient_descent/#Manopt.conjugate_gradient_descent"><code>conjugate_gradient_descent</code></a>, <a href="../../solvers/quasi_Newton/#Manopt.quasi_Newton"><code>quasi_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/first_order_plan.jl#L13-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldAlternatingGradientObjective" href="#Manopt.ManifoldAlternatingGradientObjective"><code>Manopt.ManifoldAlternatingGradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldAlternatingGradientObjective{E&lt;:AbstractEvaluationType,F,G} &lt;: AbstractManifoldFirstOrderObjective{E, Tuple{F,G}}</code></pre><p>An alternating gradient objective consists of</p><ul><li>a cost function <span>$F(x)$</span></li><li>a gradient <span>$\operatorname{grad}F$</span> that is either<ul><li>given as one function <span>$\operatorname{grad}F$</span> returning a tangent vector <code>X</code> on <code>M</code> or</li><li>an array of gradient functions <span>$\operatorname{grad}F_i$</span>, <code>√¨=1,‚Ä¶,n</code> s each returning a component of the gradient</li></ul>which might be allocating or mutating variants, but not a mix of both.</li></ul><div class="admonition is-info" id="Note-ec52a2e1783f06b2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ec52a2e1783f06b2" title="Permalink"></a></header><div class="admonition-body"><p>This Objective is usually defined using the <code>ProductManifold</code> from <code>Manifolds.jl</code>, so <code>Manifolds.jl</code> to be loaded.</p></div></div><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldAlternatingGradientObjective(F, gradF::Function;
    evaluation=AllocatingEvaluation()
)
ManifoldAlternatingGradientObjective(F, gradF::AbstractVector{&lt;:Function};
    evaluation=AllocatingEvaluation()
)</code></pre><p>Create a alternating gradient problem with an optional <code>cost</code> and the gradient either as one function (returning an array) or a vector of functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/alternating_gradient_plan.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldStochasticGradientObjective" href="#Manopt.ManifoldStochasticGradientObjective"><code>Manopt.ManifoldStochasticGradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldStochasticGradientObjective{E&lt;:AbstractEvaluationType, F, G} &lt;: AbstractManifoldFirstOrderObjective{E, Tuple{F,G}}</code></pre><p>A stochastic gradient objective consists of</p><ul><li>a(n optional) cost function <span>$f(p) = \displaystyle\sum_{i=1}^{n} f_i(p)$</span></li><li>an array of gradients, <span>$\operatorname{grad} f_i(p), i=1,‚Ä¶,n$</span> which can be given in two forms<ul><li>as one single function <span>$(\mathcal M, p) ‚Ü¶ (X_1,‚Ä¶,X_n) ‚àà (T_{p}\mathcal M)^n$</span></li><li>as a vector of functions <span>$\bigl( (\mathcal M, p) ‚Ü¶ X_1, ‚Ä¶, (\mathcal M, p) ‚Ü¶ X_n\bigr)$</span>.</li></ul></li></ul><p>Where both variants can also be provided as <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> functions <code>(M, X, p) -&gt; X</code>, where <code>X</code> is the vector of <code>X1,...,Xn</code> and <code>(M, X1, p) -&gt; X1, ..., (M, Xn, p) -&gt; Xn</code>, respectively.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ManifoldStochasticGradientObjective(
    grad_f::Function;
    cost=Missing(),
    evaluation=AllocatingEvaluation()
)
ManifoldStochasticGradientObjective(
    grad_f::AbstractVector{&lt;:Function};
    cost=Missing(), evaluation=AllocatingEvaluation()
)</code></pre><p>Create a Stochastic gradient problem with the gradient either as one function (returning an array of tangent vectors) or a vector of functions (each returning one tangent vector).</p><p>The optional cost can also be given as either a single function (returning a number) pr a vector of functions, each returning a value.</p><p><strong>Used with</strong></p><p><a href="../../solvers/stochastic_gradient_descent/#Manopt.stochastic_gradient_descent"><code>stochastic_gradient_descent</code></a></p><p>Note that this can also be used with a <a href="../../solvers/gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a>, since the (complete) gradient is just the sums of the single gradients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/stochastic_gradient_plan.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.NonlinearLeastSquaresObjective" href="#Manopt.NonlinearLeastSquaresObjective"><code>Manopt.NonlinearLeastSquaresObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonlinearLeastSquaresObjective{E&lt;:AbstractEvaluationType} &lt;: AbstractManifoldObjective{T}</code></pre><p>An objective to model the nonlinear least squares problem</p><p class="math-container">\[\operatorname*{arg\,min}_{p ‚àà \mathcal M} \frac{1}{2} \sum_{}^{}_{i=1}^m \lvert f_i(p) \rvert^2\]</p><p>where <span>$f: \mathcal M ‚Üí ‚Ñù^m$</span> is written with component functions <span>$f_i: \mathcal M ‚Üí ‚Ñù$</span>, <span>$i=1,‚Ä¶,m$</span>, and each component function is continuously differentiable.</p><p>Specify a nonlinear least squares problem</p><p><strong>Fields</strong></p><ul><li><code>objective</code>: a <a href="#Manopt.AbstractVectorGradientFunction"><code>AbstractVectorGradientFunction</code></a><code>{E}</code> containing both the vector of cost functions <span>$f_i$</span> (or a function returning a vector of costs) as well as their gradients <span>$\operatorname{grad} f_i$</span> (or Jacobian of the vector-valued function).</li></ul><p>This <code>NonlinearLeastSquaresObjective</code> then has the same <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>T</code> as the (inner) <code>objective</code>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">NonlinearLeastSquaresObjective(f, jacobian, range_dimension::Integer; kwargs...)
NonlinearLeastSquaresObjective(vf::AbstractVectorGradientFunction)</code></pre><p><strong>Arguments</strong></p><ul><li><code>f</code> the vectorial cost function <span>$f: \mathcal M ‚Üí ‚Ñù^m$</span></li><li><code>jacobian</code> the Jacobian, might also be a vector of gradients of the component functions of <code>f</code></li><li><code>range_dimension::Integer</code> the number of dimensions <code>m</code> the function <code>f</code> maps into</li></ul><p>These three can also be passed as a <a href="#Manopt.AbstractVectorGradientFunction"><code>AbstractVectorGradientFunction</code></a> <code>vf</code> already.</p><p><strong>Keyword arguments</strong></p><ul><li><code>evaluation=</code><a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.</li><li><code>function_type::</code><a href="#Manopt.AbstractVectorialType"><code>AbstractVectorialType</code></a><code>=</code><a href="#Manopt.FunctionVectorialType"><code>FunctionVectorialType</code></a><code>()</code>: specify the format the residuals are given in. By default a function returning a vector.</li><li><code>jacobian_tangent_basis::AbstractBasis=DefaultOrthonormalBasis()</code>; shortcut to specify the basis the Jacobian matrix is build with.</li><li><code>jacobian_type::</code><a href="#Manopt.AbstractVectorialType"><code>AbstractVectorialType</code></a><code>=</code><a href="#Manopt.CoordinateVectorialType"><code>CoordinateVectorialType</code></a><code>(jacobian_tangent_basis)</code>: specify the format the Jacobian is given in. By default a matrix of the differential with respect to a certain basis of the tangent space.</li></ul><p><strong>See also</strong></p><p><a href="../../solvers/LevenbergMarquardt/#Manopt.LevenbergMarquardt"><code>LevenbergMarquardt</code></a>, <a href="../../solvers/LevenbergMarquardt/#Manopt.LevenbergMarquardtState"><code>LevenbergMarquardtState</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/nonlinear_least_squares_plan.jl#L2-L47">source</a></section></article><p>While the <a href="#Manopt.ManifoldFirstOrderObjective"><code>ManifoldFirstOrderObjective</code></a> allows to provide different first order information, there are also its shortcuts, mainly for historical reasons, but also since these are the most commonly used ones.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldGradientObjective" href="#Manopt.ManifoldGradientObjective"><code>Manopt.ManifoldGradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldGradientObjective(cost, gradient; evaluation::E=AllocatingEvaluation() kwargs...)</code></pre><p>Generate an objective with a function <code>cost</code> and its <code>gradient</code>. Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code> the gradient can have to forms</p><ul><li>as a function <code>(M, p) -&gt; X</code> that allocates memory for <code>X</code>, an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a></li><li>as a function <code>(M, X, p) -&gt; X</code> that work in place of <code>X</code>, an <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a></li></ul><p>Internally this is stored in a <a href="#Manopt.ManifoldFirstOrderObjective"><code>ManifoldFirstOrderObjective</code></a>. The <code>kwargs...</code> are also passed to this representation, which allows to add a special function to evaluate the <code>differential</code>.</p><p><strong>Used with</strong></p><p><a href="../../solvers/gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a>, <a href="../../solvers/conjugate_gradient_descent/#Manopt.conjugate_gradient_descent"><code>conjugate_gradient_descent</code></a>, <a href="../../solvers/quasi_Newton/#Manopt.quasi_Newton"><code>quasi_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/first_order_plan.jl#L130-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldCostGradientObjective" href="#Manopt.ManifoldCostGradientObjective"><code>Manopt.ManifoldCostGradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldCostGradientObjective(costgrad; evaluation::E=AllocatingEvaluation(), kwargs...)</code></pre><p>create an objective containing one function to perform a combined computation of cost and its gradient</p><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code> the gradient can have to forms</p><ul><li>as a function <code>(M, p) -&gt; (c, X)</code> that allocates memory for the gradient <code>X</code>, an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a></li><li>as a function <code>(M, X, p) -&gt; (c, X)</code> that work in place of <code>X</code>, an <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a></li></ul><p>Internally this is stored in a <a href="#Manopt.ManifoldFirstOrderObjective"><code>ManifoldFirstOrderObjective</code></a>. The <code>kwargs...</code> are also passed to this representation, which allows to add a special function to evaluate the <code>differential</code>.</p><p><strong>Used with</strong></p><p><a href="../../solvers/gradient_descent/#Manopt.gradient_descent"><code>gradient_descent</code></a>, <a href="../../solvers/conjugate_gradient_descent/#Manopt.conjugate_gradient_descent"><code>conjugate_gradient_descent</code></a>, <a href="../../solvers/quasi_Newton/#Manopt.quasi_Newton"><code>quasi_Newton</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/first_order_plan.jl#L157-L173">source</a></section></article><h4 id="Access-functions-2"><a class="docs-heading-anchor" href="#Access-functions-2">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_gradient" href="#Manopt.get_gradient"><code>Manopt.get_gradient</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_gradient(s::AbstractManoptSolverState)</code></pre><p>return the (last stored) gradient within <a href="../state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a><code></code>s`. By default also undecorates the state beforehand</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/solver_state.jl#L183-L188">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(amp::AbstractManoptProblem, p)
get_gradient!(amp::AbstractManoptProblem, X, p)</code></pre><p>evaluate the gradient of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at the point <code>p</code>.</p><p>The evaluation is done in place of <code>X</code> for the <code>!</code>-variant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/first_order_plan.jl#L536-L543">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(agst::AbstractGradientSolverState)</code></pre><p>return the gradient stored within gradient options. THe default returns <code>agst.X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/first_order_plan.jl#L569-L574">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, mgo::ManifoldProximalGradientObjective, p)
get_gradient!(M::AbstractManifold, X, mgo::ManifoldProximalGradientObjective, p)</code></pre><p>Evaluate the gradient of the smooth part of a <a href="#Manopt.ManifoldProximalGradientObjective"><code>ManifoldProximalGradientObjective</code></a> <code>mgo</code> at <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/proximal_gradient_plan.jl#L46-L51">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, vgf::VectorGradientFunction, p, i)
get_gradient(M::AbstractManifold, vgf::VectorGradientFunction, p, i, range)
get_gradient!(M::AbstractManifold, X, vgf::VectorGradientFunction, p, i)
get_gradient!(M::AbstractManifold, X, vgf::VectorGradientFunction, p, i, range)</code></pre><p>Evaluate the gradients of the vector function <code>vgf</code> on the manifold <code>M</code> at <code>p</code> and the values given in <code>range</code>, specifying the representation of the gradients.</p><p>Since <code>i</code> is assumed to be a linear index, you can provide</p><ul><li>a single integer</li><li>a <code>UnitRange</code> to specify a range to be returned like <code>1:3</code></li><li>a <code>BitVector</code> specifying a selection</li><li>a <code>AbstractVector{&lt;:Integer}</code> to specify indices</li><li><code>:</code> to return the vector of all gradients</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L813-L828">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(TpM, trmo::TrustRegionModelObjective, X)</code></pre><p>Evaluate the gradient of the <a href="../../solvers/truncated_conjugate_gradient_descent/#Manopt.TrustRegionModelObjective"><code>TrustRegionModelObjective</code></a></p><p class="math-container">\[\operatorname{grad} m(X) = \operatorname{grad} f(p) + \operatorname{Hess} f(p)[X].\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/trust_regions_plan.jl#L54-L62">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(TpM, trmo::AdaptiveRagularizationWithCubicsModelObjective, X)</code></pre><p>Evaluate the gradient of the <a href="../../solvers/adaptive-regularization-with-cubics/#Manopt.AdaptiveRagularizationWithCubicsModelObjective"><code>AdaptiveRagularizationWithCubicsModelObjective</code></a></p><p class="math-container">\[\operatorname{grad} m(X) = \operatorname{grad} f(p) + \operatorname{Hess} f(p)[X]
       + œÉ\lVert X \rVert X,\]</p><p>at <code>X</code>, cf. Eq. (37) in [<a href="../../references/#AgarwalBoumalBullinsCartis_2020">ABBC20</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/adabtive_regularization_with_cubics_plan.jl#L75-L86">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(TpM::TangentSpace, slso::SymmetricLinearSystemObjective, X)
get_gradient!(TpM::TangentSpace, Y, slso::SymmetricLinearSystemObjective, X)</code></pre><p>evaluate the gradient of</p><p class="math-container">\[f(X) = \frac{1}{2} \lVert \mathcal A[X] + b \rVert_{p}^2,\qquad X ‚àà T_{p}\mathcal M,\]</p><p>Which is <span>$\operatorname{grad} f(X) = \mathcal A[X]+b$</span>. This can be computed in-place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/conjugate_residual_plan.jl#L101-L110">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p, k)
get_gradient!(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, Y, p, k)</code></pre><p>Evaluate one of the summands gradients <span>$\operatorname{grad}f_k$</span>, <span>$k‚àà\{1,‚Ä¶,n\}$</span>, at <code>x</code> (in place of <code>Y</code>).</p><p>If you use a single function for the stochastic gradient, that works in-place, then <a href="#Manopt.get_gradient"><code>get_gradient</code></a> is not available, since the length (or number of elements of the gradient required for allocation) can not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/stochastic_gradient_plan.jl#L177-L185">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p)
get_gradient!(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, X, p)</code></pre><p>Evaluate the complete gradient <span>$\operatorname{grad} f = \displaystyle\sum_{i=1}^n \operatorname{grad} f_i(p)$</span> at <code>p</code> (in place of <code>X</code>).</p><p>If you use a single function for the stochastic gradient, that works in-place, then <a href="#Manopt.get_gradient"><code>get_gradient</code></a> is not available, since the length (or number of elements of the gradient required for allocation) can not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/stochastic_gradient_plan.jl#L269-L277">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, emo::EmbeddedManifoldObjective, p)
get_gradient!(M::AbstractManifold, X, emo::EmbeddedManifoldObjective, p)</code></pre><p>Evaluate the gradient function of an objective defined in the embedding, that is embed <code>p</code> before calling the gradient function stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p><p>The returned gradient is then converted to a Riemannian gradient calling <a href="https://juliamanifolds.github.io/ManifoldDiff.jl/stable/library.html#ManifoldDiff.riemannian_gradient-Tuple{AbstractManifold,%20Any,%20Any}"><code>riemannian_gradient</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/embedded_objective.jl#L75-L84">source</a></section><section><div><pre><code class="language-julia hljs">get_gradient(M::AbstractManifold, scaled_objective::ScaledManifoldObjective, p)
get_gradient!(M::AbstractManifold, X, scaled_objective::ScaledManifoldObjective, p)</code></pre><p>Evaluate the scaled gradient. <span>$s*\operatorname{grad}f(p)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/scaled_objective.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_gradients" href="#Manopt.get_gradients"><code>Manopt.get_gradients</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_gradients(M::AbstractManifold, sgo::ManifoldStochasticGradientObjective, p)
get_gradients!(M::AbstractManifold, X, sgo::ManifoldStochasticGradientObjective, p)</code></pre><p>Evaluate all summands gradients <span>$\{\operatorname{grad}f_i\}_{i=1}^n$</span> at <code>p</code> (in place of <code>X</code>).</p><p>If you use a single function for the stochastic gradient, that works in-place, then <a href="#Manopt.get_gradient"><code>get_gradient</code></a> is not available, since the length (or number of elements of the gradient) can not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/stochastic_gradient_plan.jl#L82-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_differential" href="#Manopt.get_differential"><code>Manopt.get_differential</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> get_differential(amp::AbstractManoptProblem, p, X; kwargs...)
 get_differential(M::AbstractManifold, amfo:AbstractManifoldFirstOrderObjective, p, X; kwargs...)
 get_differential(M::AbstractManifold, amfo:AbstractDecoratedManifoldObjective, p, X; kwargs...)</code></pre><p>Evaluate the differential <span>$Df(p)[X]$</span> of the function <span>$f$</span> represented by the <a href="#Manopt.AbstractManifoldFirstOrderObjective"><code>AbstractManifoldFirstOrderObjective</code></a>. For <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> the inner manifold and objectives are used, similarly, any objective decorator would ‚Äúpass though‚Äù to its inner objective. By default this falls back to ``Df(p)[X] = ‚ü®\operatorname{grad}f(p), X‚ü©</p><p><strong>Keyword arguments</strong></p><ul><li><code>gradient=nothing</code> ‚Äì pass a tangent vector to be used internally as interims memory, e.g. in the default variant to evaluate the gradient in-place in.</li><li><code>evaluated=false</code> ‚Äì indicate whether <code>gradient</code> is just memory (<code>false</code>, default) or already contains the evaluated gradient (<code>true</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/first_order_plan.jl#L292-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_residuals" href="#Manopt.get_residuals"><code>Manopt.get_residuals</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_residuals(M::AbstractManifold, nlso::NonlinearLeastSquaresObjective, p)
get_residuals!(M::AbstractManifold, V, nlso::NonlinearLeastSquaresObjective, p)</code></pre><p>Compute the vector of residuals <span>$f_i(p)$</span>, <span>$i=1,‚Ä¶,m$</span> given the manifold <code>M</code>, the <a href="#Manopt.NonlinearLeastSquaresObjective"><code>NonlinearLeastSquaresObjective</code></a> <code>nlso</code> and a current point <span>$p$</span> on <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/nonlinear_least_squares_plan.jl#L145-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_residuals!" href="#Manopt.get_residuals!"><code>Manopt.get_residuals!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_residuals(M::AbstractManifold, nlso::NonlinearLeastSquaresObjective, p)
get_residuals!(M::AbstractManifold, V, nlso::NonlinearLeastSquaresObjective, p)</code></pre><p>Compute the vector of residuals <span>$f_i(p)$</span>, <span>$i=1,‚Ä¶,m$</span> given the manifold <code>M</code>, the <a href="#Manopt.NonlinearLeastSquaresObjective"><code>NonlinearLeastSquaresObjective</code></a> <code>nlso</code> and a current point <span>$p$</span> on <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/nonlinear_least_squares_plan.jl#L155-L161">source</a></section></article><p>and internally</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_differential_function" href="#Manopt.get_differential_function"><code>Manopt.get_differential_function</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> get_differential_function(admo::AbstractManifoldFirstOrderObjective, recursive::Bool=false)</code></pre><p>Return the function to evaluate (just) the differential <span>$Df(p)[X]$</span>. For a decorated objective, the <code>recursive</code> positional parameter determines whether to directly call this function on the next decorator or whether to get the ‚Äúmost inner‚Äù objective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/first_order_plan.jl#L350-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_gradient_function" href="#Manopt.get_gradient_function"><code>Manopt.get_gradient_function</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_gradient_function(amgo::AbstractManifoldFirstOrderObjective, recursive=false)</code></pre><p>return the function to evaluate (just) the gradient <span>$\operatorname{grad} f(p)$</span>, where either the gradient function using the decorator or without the decorator is used.</p><p>By default <code>recursive</code> is set to <code>false</code>, since usually to just pass the gradient function somewhere, one still wants for example the cached one or the one that still counts calls.</p><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code> this is a function</p><ul><li><code>(M, p) -&gt; X</code> for the <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a> case</li><li><code>(M, X, p) -&gt; X</code> for the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> working in-place of <code>X</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/first_order_plan.jl#L418-L431">source</a></section></article><h3 id="Subgradient-objective"><a class="docs-heading-anchor" href="#Subgradient-objective">Subgradient objective</a><a id="Subgradient-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Subgradient-objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldSubgradientObjective" href="#Manopt.ManifoldSubgradientObjective"><code>Manopt.ManifoldSubgradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldSubgradientObjective{T&lt;:AbstractEvaluationType,C,S} &lt;:AbstractManifoldCostObjective{T, C}</code></pre><p>A structure to store information about a objective for a subgradient based optimization problem</p><p><strong>Fields</strong></p><ul><li><code>cost</code>:        the function <span>$f$</span> to be minimized</li><li><code>subgradient</code>: a function returning a subgradient <span>$‚àÇf$</span> of <span>$f$</span></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldSubgradientObjective(f, ‚àÇf)</code></pre><p>Generate the <a href="#Manopt.ManifoldSubgradientObjective"><code>ManifoldSubgradientObjective</code></a> for a subgradient objective, consisting of a (cost) function <code>f(M, p)</code> and a function <code>‚àÇf(M, p)</code> that returns a not necessarily deterministic element from the subdifferential at <code>p</code> on a manifold <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/subgradient_plan.jl#L1-L18">source</a></section></article><h4 id="Access-functions-3"><a class="docs-heading-anchor" href="#Access-functions-3">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-3" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_subgradient" href="#Manopt.get_subgradient"><code>Manopt.get_subgradient</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X = get_subgradient(M::AbstractManifold, sgo::AbstractManifoldFirstOrderObjective, p)
get_subgradient!(M::AbstractManifold, X, sgo::AbstractManifoldFirstOrderObjective, p)</code></pre><p>Evaluate the subgradient, which for the case of a objective having a gradient, means evaluating the gradient itself.</p><p>While in general, the result might not be deterministic, for this case it is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/first_order_plan.jl#L551-L559">source</a></section><section><div><pre><code class="language-julia hljs">get_subgradient(amp::AbstractManoptProblem, p)
get_subgradient!(amp::AbstractManoptProblem, X, p)</code></pre><p>evaluate the subgradient of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at point <code>p</code>.</p><p>The evaluation is done in place of <code>X</code> for the <code>!</code>-variant. The result might not be deterministic, <em>one</em> element of the subdifferential is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/subgradient_plan.jl#L30-L38">source</a></section><section><div><pre><code class="language-julia hljs">X = get_subgradient(M;;AbstractManifold, sgo::ManifoldSubgradientObjective, p)
get_subgradient!(M;;AbstractManifold, X, sgo::ManifoldSubgradientObjective, p)</code></pre><p>Evaluate the (sub)gradient of a <a href="#Manopt.ManifoldSubgradientObjective"><code>ManifoldSubgradientObjective</code></a> <code>sgo</code> at the point <code>p</code>.</p><p>The evaluation is done in place of <code>X</code> for the <code>!</code>-variant. The result might not be deterministic, <em>one</em> element of the subdifferential is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/subgradient_plan.jl#L46-L55">source</a></section></article><p>and internally</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_subgradient_function" href="#Manopt.get_subgradient_function"><code>Manopt.get_subgradient_function</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_subgradient_function(amgo::ManifoldSubgradientObjective, recursive=false)</code></pre><p>return the function to evaluate (just) the gradient <span>$\operatorname{grad} f(p)$</span>, where either the gradient function using the decorator or without the decorator is used.</p><p>By default <code>recursive</code> is set to <code>false</code>, since usually to just pass the gradient function somewhere, one still wants for example the cached one or the one that still counts calls.</p><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code> this is a function</p><ul><li><code>(M, p) -&gt; X</code> for the <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a> case</li><li><code>(M, X, p) -&gt; X</code> for the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> working in-place of <code>X</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/subgradient_plan.jl#L89-L102">source</a></section></article><h3 id="Proximal-map-objective"><a class="docs-heading-anchor" href="#Proximal-map-objective">Proximal map objective</a><a id="Proximal-map-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Proximal-map-objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldProximalMapObjective" href="#Manopt.ManifoldProximalMapObjective"><code>Manopt.ManifoldProximalMapObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldProximalMapObjective{E&lt;:AbstractEvaluationType, TC, TP, V &lt;: Vector{&lt;:Integer}} &lt;: AbstractManifoldCostObjective{E, TC}</code></pre><p>specify a problem for solvers based on the evaluation of proximal maps, which represents proximal maps <span>$\operatorname{prox}_{Œªf_i}$</span> for summands <span>$f = f_1 + f_2+ ‚Ä¶ + f_N$</span> of the cost function <span>$f$</span>.</p><p><strong>Fields</strong></p><ul><li><code>cost</code>: a function <span>$f:\mathcal M‚Üí‚Ñù$</span> to minimize</li><li><code>proxes</code>: proximal maps <span>$\operatorname{prox}_{Œªf_i}:\mathcal M ‚Üí \mathcal M$</span> as functions <code>(M, Œª, p) -&gt; q</code> or in-place <code>(M, q, Œª, p)</code>.</li><li><code>number_of_proxes</code>: number of proximal maps per function, to specify when one of the maps is a combined one such that the proximal maps functions return more than one entry per function, you have to adapt this value. if not specified, it is set to one prox per function.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldProximalMapObjective(f, proxes_f::Union{Tuple,AbstractVector}, numer_of_proxes=onex(length(proxes));
   evaluation=Allocating)</code></pre><p>Generate a proximal problem with a tuple or vector of funtions, where by default every function computes a single prox of one component of <span>$f$</span>.</p><pre><code class="nohighlight hljs">ManifoldProximalMapObjective(f, prox_f); evaluation=Allocating)</code></pre><p>Generate a proximal objective for <span>$f$</span> and its proxial map <span>$\operatorname{prox}_{Œªf}$</span></p><p><strong>See also</strong></p><p><a href="../../solvers/cyclic_proximal_point/#Manopt.cyclic_proximal_point"><code>cyclic_proximal_point</code></a>, <a href="#Manopt.get_cost"><code>get_cost</code></a>, <a href="#Manopt.get_proximal_map"><code>get_proximal_map</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/proximal_plan.jl#L6-L38">source</a></section></article><h4 id="Access-functions-4"><a class="docs-heading-anchor" href="#Access-functions-4">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-4" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_proximal_map" href="#Manopt.get_proximal_map"><code>Manopt.get_proximal_map</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q = get_proximal_map(M::AbstractManifold, mpo::ManifoldProximalMapObjective, Œª, p)
get_proximal_map!(M::AbstractManifold, q, mpo::ManifoldProximalMapObjective, Œª, p)
q = get_proximal_map(M::AbstractManifold, mpo::ManifoldProximalMapObjective, Œª, p, i)
get_proximal_map!(M::AbstractManifold, q, mpo::ManifoldProximalMapObjective, Œª, p, i)</code></pre><p>evaluate the (<code>i</code>th) proximal map of the <a href="#Manopt.ManifoldProximalMapObjective"><code>ManifoldProximalMapObjective</code></a><code>mpo</code> at the point <code>p</code> of <code>M</code> with parameter <span>$Œª&gt;0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/proximal_plan.jl#L77-L85">source</a></section><section><div><pre><code class="language-julia hljs">q = get_proximal_map(M::AbstractManifold, mpo::ManifoldProximalGradientObjective, Œª, p)
get_proximal_map!(M::AbstractManifold, q, mpo::ManifoldProximalGradientObjective, Œª, p)</code></pre><p>Evaluate proximal map of the nonsmooth component <span>$h$</span> of the <a href="#Manopt.ManifoldProximalGradientObjective"><code>ManifoldProximalGradientObjective</code></a><code>mpo</code> at the point <code>p</code> on <code>M</code> with parameter <span>$Œª&gt;0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/proximal_gradient_plan.jl#L91-L97">source</a></section></article><h3 id="Hessian-objective"><a class="docs-heading-anchor" href="#Hessian-objective">Hessian objective</a><a id="Hessian-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Hessian-objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractManifoldHessianObjective" href="#Manopt.AbstractManifoldHessianObjective"><code>Manopt.AbstractManifoldHessianObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldHessianObjective{E&lt;:AbstractEvaluationType,F, G, H} &lt;: AbstractManifoldFirstOrderObjective{E,Tuple{F,G}}</code></pre><p>An abstract type for all objectives that provide a (full) Hessian, where <code>T</code> is a <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> for the gradient and Hessian functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/hessian_plan.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldHessianObjective" href="#Manopt.ManifoldHessianObjective"><code>Manopt.ManifoldHessianObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldHessianObjective{T&lt;:AbstractEvaluationType,C,G,H,Pre} &lt;: AbstractManifoldHessianObjective{T,C,G,H}</code></pre><p>specify a problem for Hessian based algorithms.</p><p><strong>Fields</strong></p><ul><li><code>cost</code>:           a function <span>$f:\mathcal M‚Üí‚Ñù$</span> to minimize</li><li><code>gradient</code>:       the gradient <span>$\operatorname{grad}f:\mathcal M ‚Üí \mathcal T\mathcal M$</span> of the cost function <span>$f$</span></li><li><code>hessian</code>:        the Hessian <span>$\operatorname{Hess}f(x)[‚ãÖ]: \mathcal T_{x} \mathcal M ‚Üí \mathcal T_{x} \mathcal M$</span> of the cost function <span>$f$</span></li><li><code>preconditioner</code>: the symmetric, positive definite preconditioner as an approximation of the inverse of the Hessian of <span>$f$</span>, a map with the same input variables as the <code>hessian</code> to numerically stabilize iterations when the Hessian is ill-conditioned</li></ul><p>Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>T</code> the gradient and can have to forms</p><ul><li>as a function <code>(M, p) -&gt; X</code>  and <code>(M, p, X) -&gt; Y</code>, resp., an <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a></li><li>as a function <code>(M, X, p) -&gt; X</code> and (M, Y, p, X), resp., an <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldHessianObjective(f, grad_f, Hess_f, preconditioner = (M, p, X) -&gt; X;
    evaluation=AllocatingEvaluation())</code></pre><p><strong>See also</strong></p><p><a href="../../solvers/truncated_conjugate_gradient_descent/#Manopt.truncated_conjugate_gradient_descent"><code>truncated_conjugate_gradient_descent</code></a>, <a href="../../solvers/trust_regions/#Manopt.trust_regions"><code>trust_regions</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/hessian_plan.jl#L18-L45">source</a></section></article><h4 id="Access-functions-5"><a class="docs-heading-anchor" href="#Access-functions-5">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-5" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_hessian" href="#Manopt.get_hessian"><code>Manopt.get_hessian</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y = get_hessian(amp::AbstractManoptProblem{T}, p, X)
get_hessian!(amp::AbstractManoptProblem{T}, Y, p, X)</code></pre><p>evaluate the Hessian of an <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code> at <code>p</code> applied to a tangent vector <code>X</code>, computing <span>$\operatorname{Hess}f(q)[X]$</span>, which can also happen in-place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/hessian_plan.jl#L98-L105">source</a></section><section><div><pre><code class="language-julia hljs">get_hessian(M::AbstractManifold, vgf::VectorHessianFunction, p, X, i)
get_hessian(M::AbstractManifold, vgf::VectorHessianFunction, p, X, i, range)
get_hessian!(M::AbstractManifold, X, vgf::VectorHessianFunction, p, X, i)
get_hessian!(M::AbstractManifold, X, vgf::VectorHessianFunction, p, X, i, range)</code></pre><p>Evaluate the Hessians of the vector function <code>vgf</code> on the manifold <code>M</code> at <code>p</code> in direction <code>X</code> and the values given in <code>range</code>, specifying the representation of the gradients.</p><p>Since <code>i</code> is assumed to be a linear index, you can provide</p><ul><li>a single integer</li><li>a <code>UnitRange</code> to specify a range to be returned like <code>1:3</code></li><li>a <code>BitVector</code> specifying a selection</li><li>a <code>AbstractVector{&lt;:Integer}</code> to specify indices</li><li><code>:</code> to return the vector of all Hessian evaluations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L310-L325">source</a></section><section><div><pre><code class="language-julia hljs">get_hessian(TpM, trmo::TrustRegionModelObjective, X)</code></pre><p>Evaluate the Hessian of the <a href="../../solvers/truncated_conjugate_gradient_descent/#Manopt.TrustRegionModelObjective"><code>TrustRegionModelObjective</code></a></p><p class="math-container">\[\operatorname{Hess} m(X)[Y] = \operatorname{Hess} f(p)[Y].\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/trust_regions_plan.jl#L75-L83">source</a></section><section><div><pre><code class="language-julia hljs">get_Hessian(TpM::TangentSpace, slso::SymmetricLinearSystemObjective, X, V)
get_Hessian!(TpM::TangentSpace, W, slso::SymmetricLinearSystemObjective, X, V)</code></pre><p>evaluate the Hessian of</p><p class="math-container">\[f(X) = \frac{1}{2} \lVert \mathcal A[X] + b \rVert_{p}^2,\qquad X ‚àà T_{p}\mathcal M,\]</p><p>Which is <span>$\operatorname{Hess} f(X)[Y] = \mathcal A[V]$</span>. This can be computed in-place of <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/conjugate_residual_plan.jl#L136-L145">source</a></section><section><div><pre><code class="language-julia hljs">get_hessian(M::AbstractManifold, emo::EmbeddedManifoldObjective, p, X)
get_hessian!(M::AbstractManifold, Y, emo::EmbeddedManifoldObjective, p, X)</code></pre><p>Evaluate the Hessian of an objective defined in the embedding, that is embed <code>p</code> and <code>X</code> before calling the Hessian function stored in the <a href="#Manopt.EmbeddedManifoldObjective"><code>EmbeddedManifoldObjective</code></a>.</p><p>The returned Hessian is then converted to a Riemannian Hessian calling  <a href="https://juliamanifolds.github.io/ManifoldDiff.jl/stable/library/#ManifoldDiff.riemannian_Hessian-Tuple{AbstractManifold,%20Any,%20Any,%20Any,%20Any}"><code>riemannian_Hessian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/embedded_objective.jl#L129-L138">source</a></section><section><div><pre><code class="language-julia hljs">get_hessian(M::AbstractManifold, scaled_objective::ScaledManifoldObjective, p, X)
get_hessian!(M::AbstractManifold, Y, scaled_objective::ScaledManifoldObjective, p, X)</code></pre><p>Evaluate the scaled Hessian <span>$s*\operatorname{Hess}f(p)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/scaled_objective.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_preconditioner" href="#Manopt.get_preconditioner"><code>Manopt.get_preconditioner</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_preconditioner(amp::AbstractManoptProblem, p, X)</code></pre><p>evaluate the symmetric, positive definite preconditioner (approximation of the inverse of the Hessian of the cost function <code>f</code>) of a <a href="../problem/#Manopt.AbstractManoptProblem"><code>AbstractManoptProblem</code></a> <code>amp</code>s objective at the point <code>p</code> applied to a tangent vector <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/hessian_plan.jl#L162-L169">source</a></section><section><div><pre><code class="language-julia hljs">get_preconditioner(M::AbstractManifold, mho::ManifoldHessianObjective, p, X)</code></pre><p>evaluate the symmetric, positive definite preconditioner (approximation of the inverse of the Hessian of the cost function <code>F</code>) of a <a href="#Manopt.ManifoldHessianObjective"><code>ManifoldHessianObjective</code></a> <code>mho</code> at the point <code>p</code> applied to a tangent vector <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/hessian_plan.jl#L177-L184">source</a></section></article><p>and internally</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_hessian_function" href="#Manopt.get_hessian_function"><code>Manopt.get_hessian_function</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hessian_function(amgo::ManifoldHessianObjective{E&lt;:AbstractEvaluationType})</code></pre><p>return the function to evaluate (just) the Hessian <span>$\operatorname{Hess} f(p)$</span>. Depending on the <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code> this is a function</p><ul><li><code>(M, p, X) -&gt; Y</code> for the <a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a> case</li><li><code>(M, Y, p, X) -&gt; X</code> for the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>, working in-place of <code>Y</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/hessian_plan.jl#L146-L154">source</a></section></article><h3 id="Primal-dual-based-objectives"><a class="docs-heading-anchor" href="#Primal-dual-based-objectives">Primal-dual based objectives</a><a id="Primal-dual-based-objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-dual-based-objectives" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractPrimalDualManifoldObjective" href="#Manopt.AbstractPrimalDualManifoldObjective"><code>Manopt.AbstractPrimalDualManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractPrimalDualManifoldObjective{E&lt;:AbstractEvaluationType,C,P} &lt;: AbstractManifoldCostObjective{E,C}</code></pre><p>A common abstract super type for objectives that consider primal-dual problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/primal_dual_plan.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.PrimalDualManifoldObjective" href="#Manopt.PrimalDualManifoldObjective"><code>Manopt.PrimalDualManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PrimalDualManifoldObjective{T&lt;:AbstractEvaluationType} &lt;: AbstractPrimalDualManifoldObjective{T}</code></pre><p>Describes an Objective linearized or exact Chambolle-Pock algorithm, cf. [<a href="../../references/#BergmannHerzogSilvaLouzeiroTenbrinckVidalNunez_2021">BHS+21</a>], [<a href="../../references/#ChambollePock_2011">CP11</a>]</p><p><strong>Fields</strong></p><p>All fields with <code>!!</code> can either be in-place or allocating functions, which should be set depending on the <code>evaluation=</code> keyword in the constructor and stored in <code>T &lt;: AbstractEvaluationType</code>.</p><ul><li><code>cost</code>:                          <span>$F + G(Œõ(‚ãÖ))$</span> to evaluate interim cost function values</li><li><code>linearized_forward_operator!!</code>: linearized operator for the forward operation in the algorithm <span>$DŒõ$</span></li><li><code>linearized_adjoint_operator!!</code>: the adjoint differential <span>$(DŒõ)^* : \mathcal N ‚Üí T\mathcal M$</span></li><li><code>prox_f!!</code>:                      the proximal map belonging to <span>$f$</span></li><li><code>prox_G_dual!!</code>:                 the proximal map belonging to <span>$g_n^*$</span></li><li><code>Œõ!!</code>:                           the  forward operator (if given) <span>$Œõ: \mathcal M ‚Üí \mathcal N$</span></li></ul><p>Either the linearized operator <span>$DŒõ$</span> or <span>$Œõ$</span> are required usually.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PrimalDualManifoldObjective(cost, prox_f, prox_G_dual, adjoint_linearized_operator;
    linearized_forward_operator::Union{Function,Missing}=missing,
    Œõ::Union{Function,Missing}=missing,
    evaluation::AbstractEvaluationType=AllocatingEvaluation()
)</code></pre><p>The last optional argument can be used to provide the 4 or 5 functions as allocating or mutating (in place computation) ones. Note that the first argument is always the manifold under consideration, the mutated one is the second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/primal_dual_plan.jl#L30-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.PrimalDualManifoldSemismoothNewtonObjective" href="#Manopt.PrimalDualManifoldSemismoothNewtonObjective"><code>Manopt.PrimalDualManifoldSemismoothNewtonObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PrimalDualManifoldSemismoothNewtonObjective{E&lt;:AbstractEvaluationType, TC, LO, ALO, PF, DPF, PG, DPG, L} &lt;: AbstractPrimalDualManifoldObjective{E, TC, PF}</code></pre><p>Describes a Problem for the Primal-dual Riemannian semismooth Newton algorithm. [<a href="../../references/#DiepeveenLellmann_2021">DL21</a>]</p><p><strong>Fields</strong></p><ul><li><code>cost</code>:                        <span>$F + G(Œõ(‚ãÖ))$</span> to evaluate interim cost function values</li><li><code>linearized_operator</code>:         the linearization <span>$DŒõ(‚ãÖ)[‚ãÖ]$</span> of the operator <span>$Œõ(‚ãÖ)$</span>.</li><li><code>linearized_adjoint_operator</code>: the adjoint differential <span>$(DŒõ)^* : \mathcal N ‚Üí T\mathcal M$</span></li><li><code>prox_F</code>:                      the proximal map belonging to <span>$F$</span></li><li><code>diff_prox_F</code>:                 the (Clarke Generalized) differential of the proximal maps of <span>$F$</span></li><li><code>prox_G_dual</code>:                 the proximal map belonging to <code>G^\ast_n</code>`</li><li><code>diff_prox_dual_G</code>:            the (Clarke Generalized) differential of the proximal maps of <span>$G^\ast_n$</span></li><li><code>Œõ</code>:                           the exact forward operator. This operator is required if <code>Œõ(m)=n</code> does not hold.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PrimalDualManifoldSemismoothNewtonObjective(cost, prox_F, prox_G_dual, forward_operator, adjoint_linearized_operator,Œõ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/higher_order_primal_dual_plan.jl#L1-L20">source</a></section></article><h4 id="Access-functions-6"><a class="docs-heading-anchor" href="#Access-functions-6">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-6" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.adjoint_linearized_operator" href="#Manopt.adjoint_linearized_operator"><code>Manopt.adjoint_linearized_operator</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X = adjoint_linearized_operator(N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, m, n, Y)
adjoint_linearized_operator(N::AbstractManifold, X, apdmo::AbstractPrimalDualManifoldObjective, m, n, Y)</code></pre><p>Evaluate the adjoint of the linearized forward operator of <span>$(DŒõ(m))^*[Y]$</span> stored within the <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a> (in place of <code>X</code>). Since <span>$Y‚ààT_n\mathcal N$</span>, both <span>$m$</span> and <span>$n=Œõ(m)$</span> are necessary arguments, mainly because the forward operator <span>$Œõ$</span> might be <code>missing</code> in <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/primal_dual_plan.jl#L405-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.forward_operator" href="#Manopt.forward_operator"><code>Manopt.forward_operator</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q = forward_operator(M::AbstractManifold, N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, p)
forward_operator!(M::AbstractManifold, N::AbstractManifold, q, apdmo::AbstractPrimalDualManifoldObjective, p)</code></pre><p>Evaluate the forward operator of <span>$Œõ(x)$</span> stored within the <a href="../problem/#Manopt.TwoManifoldProblem"><code>TwoManifoldProblem</code></a> (in place of <code>q</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/primal_dual_plan.jl#L335-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_differential_dual_prox" href="#Manopt.get_differential_dual_prox"><code>Manopt.get_differential_dual_prox</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Œ∑ = get_differential_dual_prox(N::AbstractManifold, pdsno::PrimalDualManifoldSemismoothNewtonObjective, n, œÑ, X, Œæ)
get_differential_dual_prox!(N::AbstractManifold, pdsno::PrimalDualManifoldSemismoothNewtonObjective, Œ∑, n, œÑ, X, Œæ)</code></pre><p>Evaluate the differential proximal map of <span>$G_n^*$</span> stored within <a href="#Manopt.PrimalDualManifoldSemismoothNewtonObjective"><code>PrimalDualManifoldSemismoothNewtonObjective</code></a></p><p class="math-container">\[D\operatorname{prox}_{œÑG_n^*}(X)[Œæ]\]</p><p>which can also be computed in place of <code>Œ∑</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/higher_order_primal_dual_plan.jl#L281-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_differential_primal_prox" href="#Manopt.get_differential_primal_prox"><code>Manopt.get_differential_primal_prox</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">y = get_differential_primal_prox(M::AbstractManifold, pdsno::PrimalDualManifoldSemismoothNewtonObjective œÉ, x)
get_differential_primal_prox!(p::TwoManifoldProblem, y, œÉ, x)</code></pre><p>Evaluate the differential proximal map of <span>$F$</span> stored within <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a></p><p class="math-container">\[D\operatorname{prox}_{œÉF}(x)[X]\]</p><p>which can also be computed in place of <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/higher_order_primal_dual_plan.jl#L200-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_dual_prox" href="#Manopt.get_dual_prox"><code>Manopt.get_dual_prox</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y = get_dual_prox(N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, n, œÑ, X)
get_dual_prox!(N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, Y, n, œÑ, X)</code></pre><p>Evaluate the proximal map of <span>$g_n^*$</span> stored within <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a></p><p class="math-container">\[  Y = \operatorname{prox}}_{œÑG_n^*}(X)\]</p><p>which can also be computed in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/primal_dual_plan.jl#L167-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_primal_prox" href="#Manopt.get_primal_prox"><code>Manopt.get_primal_prox</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q = get_primal_prox(M::AbstractManifold, p::AbstractPrimalDualManifoldObjective, œÉ, p)
get_primal_prox!(M::AbstractManifold, p::AbstractPrimalDualManifoldObjective, q, œÉ, p)</code></pre><p>Evaluate the proximal map of <span>$F$</span> stored within <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a></p><p class="math-container">\[\operatorname{prox}_{œÉF}(x)\]</p><p>which can also be computed in place of <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/primal_dual_plan.jl#L99-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.linearized_forward_operator" href="#Manopt.linearized_forward_operator"><code>Manopt.linearized_forward_operator</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y = linearized_forward_operator(M::AbstractManifold, N::AbstractManifold, apdmo::AbstractPrimalDualManifoldObjective, m, X, n)
linearized_forward_operator!(M::AbstractManifold, N::AbstractManifold, Y, apdmo::AbstractPrimalDualManifoldObjective, m, X, n)</code></pre><p>Evaluate the linearized operator (differential) <span>$DŒõ(m)[X]$</span> stored within the <a href="#Manopt.AbstractPrimalDualManifoldObjective"><code>AbstractPrimalDualManifoldObjective</code></a> (in place of <code>Y</code>), where <code>n = Œõ(m)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/primal_dual_plan.jl#L243-L249">source</a></section></article><h3 id="Constrained-objective"><a class="docs-heading-anchor" href="#Constrained-objective">Constrained objective</a><a id="Constrained-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ConstrainedManifoldObjective" href="#Manopt.ConstrainedManifoldObjective"><code>Manopt.ConstrainedManifoldObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConstrainedManifoldObjective{T&lt;:AbstractEvaluationType, C&lt;:ConstraintType} &lt;: AbstractManifoldObjective{T}</code></pre><p>Describes the constrained objective</p><p class="math-container">\[\begin{aligned}
 \operatorname*{arg\,min}_{p ‚àà\mathcal{M}} &amp; f(p)\\
 \text{subject to } &amp;g_i(p)\leq0 \quad \text{ for all } i=1,‚Ä¶,m,\\
 \quad &amp;h_j(p)=0 \quad \text{ for all } j=1,‚Ä¶,n.
\end{aligned}\]</p><p><strong>Fields</strong></p><ul><li><code>objective</code>: an <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> representing the unconstrained objective, that is containing cost <span>$f$</span>, the gradient of the cost <span>$f$</span> and maybe the Hessian.</li><li><code>equality_constraints</code>: an <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> representing the equality constraints</li></ul><p><span>$h: \mathcal M ‚Üí \mathbb R^n$</span> also possibly containing its gradient and/or Hessian</p><ul><li><code>equality_constraints</code>: an <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> representing the equality constraints</li></ul><p><span>$h: \mathcal M ‚Üí \mathbb R^n$</span> also possibly containing its gradient and/or Hessian</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConstrainedManifoldObjective(M::AbstractManifold, f, grad_f;
    g=nothing,
    grad_g=nothing,
    h=nothing,
    grad_h=nothing;
    hess_f=nothing,
    hess_g=nothing,
    hess_h=nothing,
    equality_constraints=nothing,
    inequality_constraints=nothing,
    evaluation=AllocatingEvaluation(),
    M = nothing,
    p = isnothing(M) ? nothing : rand(M),
)</code></pre><p>Generate the constrained objective based on all involved single functions <code>f</code>, <code>grad_f</code>, <code>g</code>, <code>grad_g</code>, <code>h</code>, <code>grad_h</code>, and optionally a Hessian for each of these. With <code>equality_constraints</code> and <code>inequality_constraints</code> you have to provide the dimension of the ranges of <code>h</code> and <code>g</code>, respectively. You can also provide a manifold <code>M</code> and a point <code>p</code> to use one evaluation of the constraints to automatically try to determine these sizes.</p><pre><code class="nohighlight hljs">ConstrainedManifoldObjective(M::AbstractManifold, mho::AbstractManifoldObjective;
    equality_constraints = nothing,
    inequality_constraints = nothing
)</code></pre><p>Generate the constrained objective either with explicit constraints <span>$g$</span> and <span>$h$</span>, and their gradients, or in the form where these are already encapsulated in <a href="#Manopt.VectorGradientFunction"><code>VectorGradientFunction</code></a>s.</p><p>Both variants require that at least one of the constraints (and its gradient) is provided. If any of the three parts provides a Hessian, the corresponding object, that is a <a href="#Manopt.ManifoldHessianObjective"><code>ManifoldHessianObjective</code></a> for <code>f</code> or a <a href="#Manopt.VectorHessianFunction"><code>VectorHessianFunction</code></a> for <code>g</code> or <code>h</code>, respectively, is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L54-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldConstrainedSetObjective" href="#Manopt.ManifoldConstrainedSetObjective"><code>Manopt.ManifoldConstrainedSetObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldConstrainedSetObjective{E, MO, PF, IF} &lt;: AbstractManifoldObjective{E}</code></pre><p>Model a constrained objective restricted to a set</p><p class="math-container">\[\operatorname*{arg\,min}_{p ‚àà \mathcal C} f(p)\]</p><p>where <span>$\mathcal C ‚äÇ \mathcal M$</span> is a convex closed subset.</p><p><strong>Fields</strong></p><ul><li><code>objective::AbstractManifoldObjective</code> the (unconstrained) objective, which contains <span>$f$</span> and for example ist gradient <span>$\operatorname{grad} f$</span>.</li><li><code>project!!::PF</code> a projection function <span>$\operatorname{proj}_{\mathcal C}: \mathcal M ‚Üí \mathcal C$</span> that projects onto the set <span>$\mathcal C$</span>.</li><li><code>indicator::IF</code> the indicator function ``Œπ_{\mathcal C}(p) = \begin{cases}   0 &amp;\text{ for }p‚àà\mathcal C\\    ‚àû &amp;\text{ else.}\end{cases}</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldConstrainedSetObjective(f, grad_f, project!!; kwargs...)</code></pre><p>Generate the constrained objective for a given function <code>f</code> its gradient <code>grad_f</code> and a projection <code>project!!</code> <span>$\operatorname{proj}_{\mathcal C}$</span>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>evaluation=</code><a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a><code>()</code>: specify whether the functions that return an array, for example a point or a tangent vector, work by allocating its result (<a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>) or whether they modify their input argument to return the result therein (<a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>). Since usually the first argument is the manifold, the modified argument is the second.</li><li><code>indicator=nothing</code>: the indicator function <span>$Œπ_{\mathcal C}(p)$</span>. If not provided a test, whether the projection yields the same point is performed. For the <a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a> this required one allocation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_set_plan.jl#L1-L30">source</a></section></article><p>It might be beneficial to use the adapted problem to specify different ranges for the gradients of the constraints</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ConstrainedManoptProblem" href="#Manopt.ConstrainedManoptProblem"><code>Manopt.ConstrainedManoptProblem</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConstrainedProblem{
    TM &lt;: AbstractManifold,
    O &lt;: AbstractManifoldObjective
    HR&lt;:Union{AbstractPowerRepresentation,Nothing},
    GR&lt;:Union{AbstractPowerRepresentation,Nothing},
    HHR&lt;:Union{AbstractPowerRepresentation,Nothing},
    GHR&lt;:Union{AbstractPowerRepresentation,Nothing},
} &lt;: AbstractManoptProblem{TM}</code></pre><p>A constrained problem might feature different ranges for the (vectors of) gradients of the equality and inequality constraints.</p><p>The ranges are required in a few places to allocate memory and access elements correctly, they work as follows:</p><p>Assume the objective is</p><p class="math-container">\[\begin{aligned}
 \operatorname*{arg\,min}_{p ‚àà\mathcal{M}} &amp; f(p)\\
 \text{subject to } &amp;g_i(p)\leq0 \quad \text{ for all } i=1,‚Ä¶,m,\\
 \quad &amp;h_j(p)=0 \quad \text{ for all } j=1,‚Ä¶,n.
\end{aligned}\]</p><p>then the gradients can (classically) be considered as vectors of the components gradients, for example <span>$\bigl(\operatorname{grad} g_1(p), \operatorname{grad} g_2(p), ‚Ä¶, \operatorname{grad} g_m(p) \bigr)$</span>.</p><p>In another interpretation, this can be considered a point on the tangent space at <span>$P = (p,‚Ä¶,p) \in \mathcal M^m$</span>, so in the tangent space to the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/metamanifolds/#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> <span>$\mathcal M^m$</span>. The case where this is a <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/metamanifolds/#ManifoldsBase.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a> this agrees with the interpretation from before, but on power manifolds, more efficient representations exist.</p><p>To then access the elements, the range has to be specified. That is what this problem is for.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ConstrainedManoptProblem(
    M::AbstractManifold,
    co::ConstrainedManifoldObjective;
    range=NestedPowerRepresentation(),
    gradient_equality_range=range,
    gradient_inequality_range=range
    hessian_equality_range=range,
    hessian_inequality_range=range
)</code></pre><p>Creates a constrained Manopt problem specifying an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/metamanifolds/#ManifoldsBase.AbstractPowerRepresentation"><code>AbstractPowerRepresentation</code></a> for both the <code>gradient_equality_range</code> and the <code>gradient_inequality_range</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L304-L354">source</a></section></article><p>as well as the helper functions</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractConstrainedFunctor" href="#Manopt.AbstractConstrainedFunctor"><code>Manopt.AbstractConstrainedFunctor</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractConstrainedFunctor{T}</code></pre><p>A common supertype for functors that model constraint functions.</p><p>This supertype provides access for the fields <span>$Œª$</span> and <span>$Œº$</span>, the dual variables of constraints of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractConstrainedSlackFunctor" href="#Manopt.AbstractConstrainedSlackFunctor"><code>Manopt.AbstractConstrainedSlackFunctor</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractConstrainedSlackFunctor{T,R}</code></pre><p>A common supertype for functors that model constraint functions with slack.</p><p>This supertype additionally provides access for the fields</p><ul><li><code>Œº::T</code> the dual for the inequality constraints</li><li><code>s::T</code> the slack parameter, and</li><li><code>Œ≤::R</code> the  the barrier parameter</li></ul><p>which is also of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L23-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.LagrangianCost" href="#Manopt.LagrangianCost"><code>Manopt.LagrangianCost</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LagrangianCost{CO,T} &lt;: AbstractConstrainedFunctor{T}</code></pre><p>Implement the Lagrangian of a <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>co</code>.</p><p class="math-container">\[\mathcal L(p; Œº, Œª)
= f(p) +  \sum_{i=1}^m Œº_ig_i(p) + \sum_{j=1}^n Œª_jh_j(p)\]</p><p><strong>Fields</strong></p><ul><li><code>co::CO</code>, <code>Œº::T</code>, <code>Œª::T</code> as mentioned, where <code>T</code> represents a vector type.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">LagrangianCost(co, Œº, Œª)</code></pre><p>Create a functor for the Lagrangian with fixed dual variables.</p><p><strong>Example</strong></p><p>When you directly want to evaluate the Lagrangian <span>$\mathcal L$</span> you can also call</p><pre><code class="nohighlight hljs">LagrangianCost(co, Œº, Œª)(M,p)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L399-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.LagrangianGradient" href="#Manopt.LagrangianGradient"><code>Manopt.LagrangianGradient</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LagrangianGradient{CO,T}</code></pre><p>The gradient of the Lagrangian of a <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>co</code> with respect to the variable <span>$p$</span>. The formula reads</p><p class="math-container">\[\operatorname{grad}_p \mathcal L(p; Œº, Œª)
= \operatorname{grad} f(p) +  \sum_{i=1}^m Œº_i \operatorname{grad} g_i(p) + \sum_{j=1}^n Œª_j \operatorname{grad} h_j(p)\]</p><p><strong>Fields</strong></p><ul><li><code>co::CO</code>, <code>Œº::T</code>, <code>Œª::T</code> as mentioned, where <code>T</code> represents a vector type.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">LagrangianGradient(co, Œº, Œª)</code></pre><p>Create a functor for the Lagrangian with fixed dual variables.</p><p><strong>Example</strong></p><p>When you directly want to evaluate the gradient of the Lagrangian <span>$\operatorname{grad}_p \mathcal L$</span> you can also call <code>LagrangianGradient(co, Œº, Œª)(M,p)</code> or <code>LagrangianGradient(co, Œº, Œª)(M,X,p)</code> for the in-place variant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L445-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.LagrangianHessian" href="#Manopt.LagrangianHessian"><code>Manopt.LagrangianHessian</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LagrangianHessian{CO, V, T}</code></pre><p>The Hesian of the Lagrangian of a <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>co</code> with respect to the variable <span>$p$</span>. The formula reads</p><p class="math-container">\[\operatorname{Hess}_p \mathcal L(p; Œº, Œª)[X]
= \operatorname{Hess} f(p) +  \sum_{i=1}^m Œº_i \operatorname{Hess} g_i(p)[X] + \sum_{j=1}^n Œª_j \operatorname{Hess} h_j(p)[X]\]</p><p><strong>Fields</strong></p><ul><li><code>co::CO</code>, <code>Œº::T</code>, <code>Œª::T</code> as mentioned, where <code>T</code> represents a vector type.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">LagrangianHessian(co, Œº, Œª)</code></pre><p>Create a functor for the Lagrangian with fixed dual variables.</p><p><strong>Example</strong></p><p>When you directly want to evaluate the Hessian of the Lagrangian <span>$\operatorname{Hess}_p \mathcal L$</span> you can also call <code>LagrangianHessian(co, Œº, Œª)(M, p, X)</code> or <code>LagrangianHessian(co, Œº, Œª)(M, Y, p, X)</code> for the in-place variant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L499-L524">source</a></section></article><h4 id="Access-functions-7"><a class="docs-heading-anchor" href="#Access-functions-7">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-7" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.equality_constraints_length" href="#Manopt.equality_constraints_length"><code>Manopt.equality_constraints_length</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">equality_constraints_length(co::ConstrainedManifoldObjective)</code></pre><p>Return the number of equality constraints of an <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a>. This acts transparently through <a href="#Manopt.AbstractDecoratedManifoldObjective"><code>AbstractDecoratedManifoldObjective</code></a>s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L553-L558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.inequality_constraints_length" href="#Manopt.inequality_constraints_length"><code>Manopt.inequality_constraints_length</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inequality_constraints_length(cmo::ConstrainedManifoldObjective)</code></pre><p>Return the number of inequality constraints of an <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code>. This acts transparently through <a href="#Manopt.AbstractDecoratedManifoldObjective"><code>AbstractDecoratedManifoldObjective</code></a>s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L971-L976">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_equality_constraint" href="#Manopt.get_equality_constraint"><code>Manopt.get_equality_constraint</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_equality_constraint(amp::AbstractManoptProblem, p, j=:)
get_equality_constraint(M::AbstractManifold, objective, p, j=:)</code></pre><p>Evaluate equality constraints of a <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>objective</code> at point <code>p</code> and indices <code>j</code> (by default <code>:</code> which corresponds to all indices).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L581-L587">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_grad_equality_constraint" href="#Manopt.get_grad_equality_constraint"><code>Manopt.get_grad_equality_constraint</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_grad_equality_constraint(amp::AbstractManoptProblem, p, j)
get_grad_equality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, j, range=NestedPowerRepresentation())
get_grad_equality_constraint!(amp::AbstractManoptProblem, X, p, j)
get_grad_equality_constraint!(M::AbstractManifold, X, co::ConstrainedManifoldObjective, p, j, range=NestedPowerRepresentation())</code></pre><p>Evaluate the gradient or gradients  of the equality constraint <span>$(\operatorname{grad} h(p))_j$</span> or <span>$\operatorname{grad} h_j(p)$</span>,</p><p>See also the <a href="#Manopt.ConstrainedManoptProblem"><code>ConstrainedManoptProblem</code></a> to specify the range of the gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L647-L656">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_grad_inequality_constraint" href="#Manopt.get_grad_inequality_constraint"><code>Manopt.get_grad_inequality_constraint</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_grad_inequality_constraint(amp::AbstractManoptProblem, p, j=:)
get_grad_inequality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, j=:, range=NestedPowerRepresentation())
get_grad_inequality_constraint!(amp::AbstractManoptProblem, X, p, j=:)
get_grad_inequality_constraint!(M::AbstractManifold, X, co::ConstrainedManifoldObjective, p, j=:, range=NestedPowerRepresentation())</code></pre><p>Evaluate the gradient or gradients of the inequality constraint <span>$(\operatorname{grad} g(p))_j$</span> or <span>$\operatorname{grad} g_j(p)$</span>,</p><p>See also the <a href="#Manopt.ConstrainedManoptProblem"><code>ConstrainedManoptProblem</code></a> to specify the range of the gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L726-L735">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_hess_equality_constraint" href="#Manopt.get_hess_equality_constraint"><code>Manopt.get_hess_equality_constraint</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hess_equality_constraint(amp::AbstractManoptProblem, p, j=:)
get_hess_equality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, j, range=NestedPowerRepresentation())
get_hess_equality_constraint!(amp::AbstractManoptProblem, X, p, j=:)
get_hess_equality_constraint!(M::AbstractManifold, X, co::ConstrainedManifoldObjective, p, j, range=NestedPowerRepresentation())</code></pre><p>Evaluate the Hessian or Hessians of the equality constraint <span>$(\operatorname{Hess} h(p))_j$</span> or <span>$\operatorname{Hess} h_j(p)$</span>,</p><p>See also the <a href="#Manopt.ConstrainedManoptProblem"><code>ConstrainedManoptProblem</code></a> to specify the range of the Hessian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L809-L818">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_hess_inequality_constraint" href="#Manopt.get_hess_inequality_constraint"><code>Manopt.get_hess_inequality_constraint</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hess_inequality_constraint(amp::AbstractManoptProblem, p, X, j=:)
get_hess_inequality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, j=:, range=NestedPowerRepresentation())
get_hess_inequality_constraint!(amp::AbstractManoptProblem, Y, p, j=:)
get_hess_inequality_constraint!(M::AbstractManifold, Y, co::ConstrainedManifoldObjective, p, X, j=:, range=NestedPowerRepresentation())</code></pre><p>Evaluate the Hessian or Hessians of the inequality constraint <span>$(\operatorname{Hess} g(p)[X])_j$</span> or <span>$\operatorname{Hess} g_j(p)[X]$</span>,</p><p>See also the <a href="#Manopt.ConstrainedManoptProblem"><code>ConstrainedManoptProblem</code></a> to specify the range of the Hessian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L886-L895">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_inequality_constraint" href="#Manopt.get_inequality_constraint"><code>Manopt.get_inequality_constraint</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_inequality_constraint(amp::AbstractManoptProblem, p, j=:)
get_inequality_constraint(M::AbstractManifold, co::ConstrainedManifoldObjective, p, j=:, range=NestedPowerRepresentation())</code></pre><p>Evaluate inequality constraints of a <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>objective</code> at point <code>p</code> and indices <code>j</code> (by default <code>:</code> which corresponds to all indices).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L620-L626">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_projected_point" href="#Manopt.get_projected_point"><code>Manopt.get_projected_point</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_projected_point(amp::AbstractManoptProblem, p)
get_projected_point!(amp::AbstractManoptProblem, q, p)
get_projected_point(M::AbstractManifold, cso::ManifoldConstrainedSetObjective, p)
get_projected_point!(M::AbstractManifold, q, cso::ManifoldConstrainedSetObjective, p)</code></pre><p>Project <code>p</code> with the projection that is stored within the <a href="#Manopt.ManifoldConstrainedSetObjective"><code>ManifoldConstrainedSetObjective</code></a>. This can be done in-place of <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_set_plan.jl#L97-L105">source</a></section><section><div><pre><code class="language-julia hljs">get_projected_point(amp::AbstractManoptProblem, p)
get_projected_point!(amp::AbstractManoptProblem, q, p)
get_projected_point(M::AbstractManifold, cso::ManifoldConstrainedSetObjective, p)
get_projected_point!(M::AbstractManifold, q, cso::ManifoldConstrainedSetObjective, p)</code></pre><p>Project <code>p</code> with the projection that is stored within the <a href="#Manopt.ManifoldConstrainedSetObjective"><code>ManifoldConstrainedSetObjective</code></a>. This can be done in-place of <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_set_plan.jl#L106-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_projected_point!" href="#Manopt.get_projected_point!"><code>Manopt.get_projected_point!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_projected_point(amp::AbstractManoptProblem, p)
get_projected_point!(amp::AbstractManoptProblem, q, p)
get_projected_point(M::AbstractManifold, cso::ManifoldConstrainedSetObjective, p)
get_projected_point!(M::AbstractManifold, q, cso::ManifoldConstrainedSetObjective, p)</code></pre><p>Project <code>p</code> with the projection that is stored within the <a href="#Manopt.ManifoldConstrainedSetObjective"><code>ManifoldConstrainedSetObjective</code></a>. This can be done in-place of <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_set_plan.jl#L101-L109">source</a></section><section><div><pre><code class="language-julia hljs">get_projected_point(amp::AbstractManoptProblem, p)
get_projected_point!(amp::AbstractManoptProblem, q, p)
get_projected_point(M::AbstractManifold, cso::ManifoldConstrainedSetObjective, p)
get_projected_point!(M::AbstractManifold, q, cso::ManifoldConstrainedSetObjective, p)</code></pre><p>Project <code>p</code> with the projection that is stored within the <a href="#Manopt.ManifoldConstrainedSetObjective"><code>ManifoldConstrainedSetObjective</code></a>. This can be done in-place of <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_set_plan.jl#L120-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_unconstrained_objective" href="#Manopt.get_unconstrained_objective"><code>Manopt.get_unconstrained_objective</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_unconstrained_objective(co::ConstrainedManifoldObjective)</code></pre><p>Returns the internally stored unconstrained <a href="#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> within the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L566-L571">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.is_feasible" href="#Manopt.is_feasible"><code>Manopt.is_feasible</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_feasible(M::AbstractManifold, cmo::ConstrainedManifoldObjective, p, kwargs...)</code></pre><p>Evaluate whether a boint <code>p</code> on <code>M</code> is feasible with respect to the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a> <code>cmo</code>. That is for the provided inequality constaints <span>$g: \mathcal M ‚Üí ‚Ñù^m$</span> and equality constaints <span>$h: \mathcal M \to ‚Ñù^m$</span> from within <code>cmo</code>, the point <span>$p ‚àà \mathcal M$</span> is feasible if</p><p class="math-container">\[g_i(p) ‚â§ 0, \text{ for all } i=1,‚Ä¶,m\quad\text{ and }\quad h_j(p) = 0, \text{ for all } j=1,‚Ä¶,n.\]</p><p><strong>Keyword arguments</strong></p><ul><li><code>check_point::Bool=true</code>: whether to also verify that `<code>p‚àà\mathcal M</code> holds, using <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.is_point-Tuple%7BAbstractManifold%2C%20Any%2C%20Bool%7D"><code>is_point</code></a></li><li><code>error::Symbol=:none</code>: if the point is not feasible, this symbol determines how to report the error.<ul><li><code>:error</code>: throws an error</li><li><code>:info</code>: displays the error message as an @info</li><li><code>:none</code>: (default) the function just returns true/false</li><li><code>:warn</code>: displays the error message as a @warning.</li></ul></li></ul><p>The keyword <code>error=</code> and all other <code>kwargs...</code> are passed on to <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.is_point-Tuple%7BAbstractManifold%2C%20Any%2C%20Bool%7D"><code>is_point</code></a> if the point is verfied (see <code>check_point</code>).</p><p>All other keywords are passed on to <code>is_poi</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L984-L1006">source</a></section></article><h4 id="Internal-functions"><a class="docs-heading-anchor" href="#Internal-functions">Internal functions</a><a id="Internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_feasibility_status" href="#Manopt.get_feasibility_status"><code>Manopt.get_feasibility_status</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_feasibility_status(
    M::AbstractManifold,
    cmo::ConstrainedManifoldObjective,
    g = get_inequality_constraints(M, cmo, p),
    h = get_equality_constraints(M, cmo, p),
)</code></pre><p>Generate a message about the feasibiliy of <code>p</code> with respect to the <a href="#Manopt.ConstrainedManifoldObjective"><code>ConstrainedManifoldObjective</code></a>. You can also provide the evaluated vectors for the values of <code>g</code> and <code>h</code> as keyword arguments, in case you had them evaluated before.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/constrained_plan.jl#L1024-L1035">source</a></section></article><h3 id="Vectorial-objectives"><a class="docs-heading-anchor" href="#Vectorial-objectives">Vectorial objectives</a><a id="Vectorial-objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorial-objectives" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractVectorFunction" href="#Manopt.AbstractVectorFunction"><code>Manopt.AbstractVectorFunction</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractVectorFunction{E, FT} &lt;: Function</code></pre><p>Represent an abstract vectorial function <span>$f:\mathcal M ‚Üí ‚Ñù^n$</span> with an <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code> and an <a href="#Manopt.AbstractVectorialType"><code>AbstractVectorialType</code></a> to specify the format <span>$f$</span> is implemented as.</p><p><strong>Representations of <span>$f$</span></strong></p><p>There are three different representations of <span>$f$</span>, which might be beneficial in one or the other situation:</p><ul><li>the <a href="#Manopt.FunctionVectorialType"><code>FunctionVectorialType</code></a> storing a single function <span>$f$</span> that returns a vector,</li><li>the <a href="#Manopt.ComponentVectorialType"><code>ComponentVectorialType</code></a> storing a vector of functions <span>$f_i$</span> that return a single value each,</li><li>the <a href="#Manopt.CoordinateVectorialType"><code>CoordinateVectorialType</code></a> storing functions with respect to a specific basis of the tangent space for gradients and Hessians. Gradients of this type are usually referred to as Jacobians.</li></ul><p>For the <a href="#Manopt.ComponentVectorialType"><code>ComponentVectorialType</code></a> imagine that <span>$f$</span> could also be written using its component functions,</p><p class="math-container">\[f(p) = \bigl( f_1(p), f_2(p), \ldots, f_n(p) \bigr)^{\mathrm{T}}\]</p><p>In this representation <code>f</code> is given as a vector <code>[f1(M,p), f2(M,p), ..., fn(M,p)]</code> of its component functions. An advantage is that the single components can be evaluated and from this representation one even can directly read of the number <code>n</code>. A disadvantage might be, that one has to implement a lot of individual (component) functions.</p><p>For the  <a href="#Manopt.FunctionVectorialType"><code>FunctionVectorialType</code></a> <span>$f$</span> is implemented as a single function <code>f(M, p)</code>, that returns an <code>AbstractArray</code>. And advantage here is, that this is a single function. A disadvantage might be, that if this is expensive even to compute a single component, all of <code>f</code> has to be evaluated</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L98-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractVectorGradientFunction" href="#Manopt.AbstractVectorGradientFunction"><code>Manopt.AbstractVectorGradientFunction</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorGradientFunction{E, FT, JT, F, J, I} &lt;: AbstractManifoldObjective{E}</code></pre><p>Represent an abstract vectorial function <span>$f:\mathcal M ‚Üí ‚Ñù^n$</span> that provides a (component wise) gradient. The <a href="#Manopt.AbstractEvaluationType"><code>AbstractEvaluationType</code></a> <code>E</code> indicates the evaluation type, and the <a href="#Manopt.AbstractVectorialType"><code>AbstractVectorialType</code></a>s <code>FT</code> and <code>JT</code> the formats in which the function and the gradient are provided, see <a href="#Manopt.AbstractVectorFunction"><code>AbstractVectorFunction</code></a> for an explanation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L135-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.VectorGradientFunction" href="#Manopt.VectorGradientFunction"><code>Manopt.VectorGradientFunction</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorGradientFunction{E, FT, JT, F, J, I} &lt;: AbstractVectorGradientFunction{E, FT, JT}</code></pre><p>Represent a function <span>$f:\mathcal M ‚Üí ‚Ñù^n$</span> including it first derivative, either as a vector of gradients of a Jacobian</p><p>And hence has a gradient `<code>\operatorname{grad} f_i(p) ‚àà T_{p}\mathcal M</code>. Putting these gradients into a vector the same way as the functions, yields a <a href="#Manopt.ComponentVectorialType"><code>ComponentVectorialType</code></a></p><p class="math-container">\[\operatorname{grad} f(p) = \Bigl( \operatorname{grad} f_1(p), \operatorname{grad} f_2(p), ‚Ä¶, \operatorname{grad} f_n(p) \Bigr)^\mathrm{T}
‚àà (T_{p}\mathcal M)^n\]</p><p>And advantage here is, that again the single components can be evaluated individually</p><p><strong>Fields</strong></p><ul><li><code>value!!::F</code>:          the cost function <span>$f$</span>, which can take different formats</li><li><code>cost_type::</code><a href="#Manopt.AbstractVectorialType"><code>AbstractVectorialType</code></a>:     indicating / storing data for the type of <code>f</code></li><li><code>jacobian!!::G</code>:     the Jacobian of <span>$f$</span></li><li><code>jacobian_type::</code><a href="#Manopt.AbstractVectorialType"><code>AbstractVectorialType</code></a>: indicating / storing data for the type of <span>$J_f$</span></li><li><code>parameters</code>:    the number <code>n</code> from, the size of the vector <span>$f$</span> returns.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">VectorGradientFunction(f, Jf, range_dimension;
    evaluation::AbstractEvaluationType=AllocatingEvaluation(),
    function_type::AbstractVectorialType=FunctionVectorialType(),
    jacobian_type::AbstractVectorialType=FunctionVectorialType(),
)</code></pre><p>Create a <code>VectorGradientFunction</code> of <code>f</code>  and its Jacobian (vector of gradients) <code>Jf</code>, where <code>f</code> maps into the Euclidean space of dimension <code>range_dimension</code>. Their types are specified by the <code>function_type</code>, and <code>jacobian_type</code>, respectively. The Jacobian can further be given as an allocating variant or an in-place variant, specified by the <code>evaluation=</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L148-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.VectorHessianFunction" href="#Manopt.VectorHessianFunction"><code>Manopt.VectorHessianFunction</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorHessianFunction{E, FT, JT, HT, F, J, H, I} &lt;: AbstractVectorGradientFunction{E, FT, JT}</code></pre><p>Represent a function <span>$f:\mathcal M M ‚Üí ‚Ñù^n$</span> including it first derivative, either as a vector of gradients of a Jacobian, and the Hessian, as a vector of Hessians of the component functions.</p><p>Both the Jacobian and the Hessian can map into either a sequence of tangent spaces or a single tangent space of the power manifold of length <code>n</code>.</p><p><strong>Fields</strong></p><ul><li><code>value!!::F</code>:          the cost function <span>$f$</span>, which can take different formats</li><li><code>cost_type::</code><a href="#Manopt.AbstractVectorialType"><code>AbstractVectorialType</code></a>:     indicating / string data for the type of <code>f</code></li><li><code>jacobian!!::G</code>:     the Jacobian <span>$J_f$</span> of <span>$f$</span></li><li><code>jacobian_type::</code><a href="#Manopt.AbstractVectorialType"><code>AbstractVectorialType</code></a>: indicating / storing data for the type of <span>$J_f$</span></li><li><code>hessians!!::H</code>:     the Hessians of <span>$f$</span> (in a component wise sense)</li><li><code>hessian_type::</code><a href="#Manopt.AbstractVectorialType"><code>AbstractVectorialType</code></a>:  indicating / storing data for the type of <span>$H_f$</span></li><li><code>range_dimension</code>:    the number <code>n</code> from, the size of the vector <span>$f$</span> returns.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">VectorHessianFunction(f, Jf, Hess_f, range_dimension;
    evaluation::AbstractEvaluationType=AllocatingEvaluation(),
    function_type::AbstractVectorialType=FunctionVectorialType(),
    jacobian_type::AbstractVectorialType=FunctionVectorialType(),
    hessian_type::AbstractVectorialType=FunctionVectorialType(),
)</code></pre><p>Create a <code>VectorHessianFunction</code> of <code>f</code>  and its Jacobian (vector of gradients) <code>Jf</code> and (vector of) Hessians, where <code>f</code> maps into the Euclidean space of dimension <code>range_dimension</code>. Their types are specified by the <code>function_type</code>, and <code>jacobian_type</code>, and <code>hessian_type</code>, respectively. The Jacobian and Hessian can further be given as an allocating variant or an inplace-variant, specified by the <code>evaluation=</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L258-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractVectorialType" href="#Manopt.AbstractVectorialType"><code>Manopt.AbstractVectorialType</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractVectorialType</code></pre><p>An abstract type for different representations of a vectorial function <span>$f: \mathcal M ‚Üí ‚Ñù^m$</span> and its (component-wise) gradient/Jacobian</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.CoordinateVectorialType" href="#Manopt.CoordinateVectorialType"><code>Manopt.CoordinateVectorialType</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoordinateVectorialType{B&lt;:AbstractBasis} &lt;: AbstractVectorialType</code></pre><p>A type to indicate that gradient of the constraints is implemented as a Jacobian matrix with respect to a certain basis, that is if the vector function is <span>$f: \mathcal M ‚Üí ‚Ñù^m$</span> and we have a basis <span>$\mathcal B$</span> of <span>$T_p\mathcal M$</span>, at <span>$p‚àà \mathcal M$</span> This can be written as <span>$J_g(p) = (c_1^{\mathrm{T}},‚Ä¶,c_m^{\mathrm{T}})^{\mathrm{T}} \in ‚Ñù^{m,d}$</span>, that is, every row <span>$c_i$</span> of this matrix is a set of coefficients such that <code>get_coefficients(M, p, c, B)</code> is the tangent vector <span>$\oepratorname{grad} g_i(p)$</span> for example <span>$g_i(p) ‚àà ‚Ñù^m$</span> or <span>$\operatorname{grad} g_i(p) ‚àà T_p\mathcal M$</span>,     <span>$i=1,‚Ä¶,m$</span>.</p><p><strong>Fields</strong></p><ul><li><code>basis</code> an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a> to indicate the basis in which Jacobian is expressed.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">CoordinateVectorialType(basis=DefaultOrthonormalBasis())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L9-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ComponentVectorialType" href="#Manopt.ComponentVectorialType"><code>Manopt.ComponentVectorialType</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ComponentVectorialType &lt;: AbstractVectorialType</code></pre><p>A type to indicate that constraints are implemented as component functions, for example <span>$g_i(p) ‚àà ‚Ñù^m$</span> or <span>$\operatorname{grad} g_i(p) ‚àà T_p\mathcal M$</span>, <span>$i=1,‚Ä¶,m$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.FunctionVectorialType" href="#Manopt.FunctionVectorialType"><code>Manopt.FunctionVectorialType</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FunctionVectorialType{P&lt;:AbstractPowerRepresentation} &lt;: AbstractVectorialType</code></pre><p>A type to indicate that constraints are implemented one whole functions, for example <span>$g(p) ‚àà ‚Ñù^m$</span> or <span>$\operatorname{grad} g(p) ‚àà (T_p\mathcal M)^m$</span>.</p><p>This type internally stores the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/metamanifolds/#ManifoldsBase.AbstractPowerRepresentation"><code>AbstractPowerRepresentation</code></a>, when it makes sense, especially for Hessian and gradient functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L71-L79">source</a></section></article><h4 id="Access-functions-8"><a class="docs-heading-anchor" href="#Access-functions-8">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-8" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_jacobian" href="#Manopt.get_jacobian"><code>Manopt.get_jacobian</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_jacobian(M::AbstractManifold, vgf::AbstractVectorGradientFunction, p; kwargs...)
get_jacobian(M::AbstractManifold, J, vgf::AbstractVectorGradientFunction, p; kwargs...)</code></pre><p>Compute the Jacobian <span>$J_F ‚àà ‚Ñù^{m√ón}$</span> of the <a href="#Manopt.AbstractVectorGradientFunction"><code>AbstractVectorGradientFunction</code></a> <span>$F$</span> at <code>p</code> on the <code>M</code>.</p><p>There are two interpretations of the Jacobian of a vectorial function <span>$F: \mathcal M ‚Üí ‚Ñù^m$</span> on a manifold. Both depend on choosing a basis on the tangent space <span>$T_{p}\mathcal M$</span> which we denote by <span>$Y_1,‚Ä¶,Y_n$</span>, where <code>n</code> is the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.manifold_dimension-Tuple%7BAbstractManifold%7D"><code>manifold_dimension</code></a><code>(M)</code><code>(M)</code>. We can write any tangent vector <span>$X = \displaystyle\sum_{}^{}_i c_iY_i$</span></p><ol><li>The Jacobian <span>$J_F$</span> is the matrix with respect to the basis <span>$Y_1,‚Ä¶,Y_n$</span> such that</li></ol><p>for any <span>$X‚ààT_{p}\mathcal M$</span> we have the equality of the differential <span>$DF(p)[X] = Jc$</span>.   In other words, the <code>j</code>th column of <span>$J$</span> is given by <span>$DF(p)[Y_j]$</span></p><ol><li>Given the gradients <span>$\operatorname{grad} F_i(p)$</span> of the component functions <span>$F_i: \mathcal M ‚Üí ‚Ñù$</span>,</li></ol><p>we define the jacobian function as</p><p><span>$math   J(X) = \begin{pmatrix} ‚ü®\operatorname{grad} F_1, X‚ü©_p\\ ‚ü®\operatorname{grad} F_1, X‚ü©_p\\ ‚ãÆ\\ ‚ü®\operatorname{grad} F_1, X‚ü©_p\end{pmatrix}$</span></p><p>Then either the <span>$j$</span>th column of <span>$J_F$</span> is given by <span>$J(Y_i)$</span> or the <span>$i$</span>th row is given by all inner products <span>$\operatorname{grad} F_1, Y_j‚ü©_p$</span> of the <span>$i$</span>th gradient function with all basis vectors <span>$Y_j$</span>.</p><p>The computation can be computed in-place of <code>J</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>basis::AbstractBasis =</code><a href="#ManifoldsBase.get_basis"><code>get_basis</code></a><code>(vgf)</code> for the <a href="#Manopt.CoordinateVectorialType"><code>CoordinateVectorialType</code></a> of the vectorial functions gradient, this might lead to a change of basis, if this basis and the one the coordinates are given in do not agree.</li><li><code>range::AbstractPowerRepresentation =</code><a href="#Manopt.get_range"><code>get_range</code></a><code>(vgf.jacobian_type)</code> specify the range of the gradients in the case of a <a href="#Manopt.FunctionVectorialType"><code>FunctionVectorialType</code></a>, that is, on which type of power manifold the gradient is given on.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L582-L616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_jacobian!" href="#Manopt.get_jacobian!"><code>Manopt.get_jacobian!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_jacobian(M::AbstractManifold, vgf::AbstractVectorGradientFunction, p; kwargs...)
get_jacobian(M::AbstractManifold, J, vgf::AbstractVectorGradientFunction, p; kwargs...)</code></pre><p>Compute the Jacobian <span>$J_F ‚àà ‚Ñù^{m√ón}$</span> of the <a href="#Manopt.AbstractVectorGradientFunction"><code>AbstractVectorGradientFunction</code></a> <span>$F$</span> at <code>p</code> on the <code>M</code>.</p><p>There are two interpretations of the Jacobian of a vectorial function <span>$F: \mathcal M ‚Üí ‚Ñù^m$</span> on a manifold. Both depend on choosing a basis on the tangent space <span>$T_{p}\mathcal M$</span> which we denote by <span>$Y_1,‚Ä¶,Y_n$</span>, where <code>n</code> is the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.manifold_dimension-Tuple%7BAbstractManifold%7D"><code>manifold_dimension</code></a><code>(M)</code><code>(M)</code>. We can write any tangent vector <span>$X = \displaystyle\sum_{}^{}_i c_iY_i$</span></p><ol><li>The Jacobian <span>$J_F$</span> is the matrix with respect to the basis <span>$Y_1,‚Ä¶,Y_n$</span> such that</li></ol><p>for any <span>$X‚ààT_{p}\mathcal M$</span> we have the equality of the differential <span>$DF(p)[X] = Jc$</span>.   In other words, the <code>j</code>th column of <span>$J$</span> is given by <span>$DF(p)[Y_j]$</span></p><ol><li>Given the gradients <span>$\operatorname{grad} F_i(p)$</span> of the component functions <span>$F_i: \mathcal M ‚Üí ‚Ñù$</span>,</li></ol><p>we define the jacobian function as</p><p><span>$math   J(X) = \begin{pmatrix} ‚ü®\operatorname{grad} F_1, X‚ü©_p\\ ‚ü®\operatorname{grad} F_1, X‚ü©_p\\ ‚ãÆ\\ ‚ü®\operatorname{grad} F_1, X‚ü©_p\end{pmatrix}$</span></p><p>Then either the <span>$j$</span>th column of <span>$J_F$</span> is given by <span>$J(Y_i)$</span> or the <span>$i$</span>th row is given by all inner products <span>$\operatorname{grad} F_1, Y_j‚ü©_p$</span> of the <span>$i$</span>th gradient function with all basis vectors <span>$Y_j$</span>.</p><p>The computation can be computed in-place of <code>J</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>basis::AbstractBasis =</code><a href="#ManifoldsBase.get_basis"><code>get_basis</code></a><code>(vgf)</code> for the <a href="#Manopt.CoordinateVectorialType"><code>CoordinateVectorialType</code></a> of the vectorial functions gradient, this might lead to a change of basis, if this basis and the one the coordinates are given in do not agree.</li><li><code>range::AbstractPowerRepresentation =</code><a href="#Manopt.get_range"><code>get_range</code></a><code>(vgf.jacobian_type)</code> specify the range of the gradients in the case of a <a href="#Manopt.FunctionVectorialType"><code>FunctionVectorialType</code></a>, that is, on which type of power manifold the gradient is given on.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L702-L736">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_value" href="#Manopt.get_value"><code>Manopt.get_value</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_value(M::AbstractManifold, vgf::AbstractVectorFunction, p[, i=:])
get_value!(M::AbstractManifold, V, vgf::AbstractVectorFunction, p[, i=:])</code></pre><p>Evaluate the vector function <a href="#Manopt.VectorGradientFunction"><code>VectorGradientFunction</code></a> <code>vgf</code> at <code>p</code>. The <code>range</code> can be used to specify a potential range, but is currently only present for consistency.</p><p>The <code>i</code> can be a linear index, you can provide</p><ul><li>a single integer</li><li>a <code>UnitRange</code> to specify a range to be returned like <code>1:3</code></li><li>a <code>BitVector</code> specifying a selection</li><li>a <code>AbstractVector{&lt;:Integer}</code> to specify indices</li><li><code>:</code> to return the vector of all gradients, which is also the default</li></ul><p>This function can perform the evaluation inplace of <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L1108-L1124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_value_function" href="#Manopt.get_value_function"><code>Manopt.get_value_function</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_value_function(vgf::VectorGradientFunction, recursive=false)</code></pre><p>return the internally stored function computing <a href="#Manopt.get_value"><code>get_value</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L1186-L1190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{VectorGradientFunction}" href="#Base.length-Tuple{VectorGradientFunction}"><code>Base.length</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">length(vgf::AbstractVectorFunction)</code></pre><p>Return the length of the vector the function <span>$f: \mathcal M ‚Üí ‚Ñù^n$</span> maps into, that is the number <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L1195-L1200">source</a></section></article><h4 id="Internal-functions-2"><a class="docs-heading-anchor" href="#Internal-functions-2">Internal functions</a><a class="docs-heading-anchor-permalink" href="#Internal-functions-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt._to_iterable_indices" href="#Manopt._to_iterable_indices"><code>Manopt._to_iterable_indices</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_to_iterable_indices(A::AbstractVector, i)</code></pre><p>Convert index <code>i</code> (integer, colon, vector of indices, etc.) for array <code>A</code> into an iterable structure of indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt._change_basis!" href="#Manopt._change_basis!"><code>Manopt._change_basis!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_change_basis!(M::AbstractManifold, JF, p, from_basis::B1, to_basis::B; X=zero_vector(M,p))</code></pre><p>Given a jacobian matrix <code>JF</code> on a manifold <code>M</code> at <code>p</code> with respect to the <code>from_basis</code> in the tangent space of <code>p</code> on <code>M</code>. Change the basis of the Jacobian to <code>to_basis</code> in place of <code>JF</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>X</code> a temporary vector to store a generated vector, before decomposing it again with respect to the new basis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L521-L529">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.get_basis" href="#ManifoldsBase.get_basis"><code>ManifoldsBase.get_basis</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_basis(::AbstractVectorialType)</code></pre><p>Return a basis that fits a vector function representation.</p><p>For the case, where some vectorial data is stored with respect to a basis, this function returns the corresponding basis, most prominently for the <a href="#Manopt.CoordinateVectorialType"><code>CoordinateVectorialType</code></a>.</p><p>If a type is not with respect to a certain basis, the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.DefaultOrthonormalBasis"><code>DefaultOrthonormalBasis</code></a> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L34-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_range" href="#Manopt.get_range"><code>Manopt.get_range</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_range(::AbstractVectorialType)</code></pre><p>Return an abstract power manifold representation that fits a vector function&#39;s range. Most prominently a <a href="#Manopt.FunctionVectorialType"><code>FunctionVectorialType</code></a> returns its internal range.</p><p>Otherwise the default <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/metamanifolds/#ManifoldsBase.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a><code>()</code> is used to work on a vector of data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/vectorial_plan.jl#L84-L92">source</a></section></article><h3 id="Subproblem-objective"><a class="docs-heading-anchor" href="#Subproblem-objective">Subproblem objective</a><a id="Subproblem-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Subproblem-objective" title="Permalink"></a></h3><p>This objective can be use when the objective of a sub problem solver still needs access to the (outer/main) objective.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.AbstractManifoldSubObjective" href="#Manopt.AbstractManifoldSubObjective"><code>Manopt.AbstractManifoldSubObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldSubObjective{O&lt;:AbstractManifoldObjective} &lt;: AbstractManifoldObjective</code></pre><p>An abstract type for objectives of sub problems within a solver but still store the original objective internally to generate generic objectives for sub solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/subsolver_plan.jl#L8-L13">source</a></section></article><h4 id="Access-functions-9"><a class="docs-heading-anchor" href="#Access-functions-9">Access functions</a><a class="docs-heading-anchor-permalink" href="#Access-functions-9" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_objective_cost" href="#Manopt.get_objective_cost"><code>Manopt.get_objective_cost</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_objective_cost(M, amso::AbstractManifoldSubObjective, p)</code></pre><p>Evaluate the cost of the (original) objective stored within the sub objective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/subsolver_plan.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_objective_gradient" href="#Manopt.get_objective_gradient"><code>Manopt.get_objective_gradient</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X = get_objective_gradient(M, amso::AbstractManifoldSubObjective, p)
get_objective_gradient!(M, X, amso::AbstractManifoldSubObjective, p)</code></pre><p>Evaluate the gradient of the (original) objective stored within the sub objective <code>amso</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/subsolver_plan.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_objective_hessian" href="#Manopt.get_objective_hessian"><code>Manopt.get_objective_hessian</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y = get_objective_Hessian(M, amso::AbstractManifoldSubObjective, p, X)
get_objective_Hessian!(M, Y, amso::AbstractManifoldSubObjective, p, X)</code></pre><p>Evaluate the Hessian of the (original) objective stored within the sub objective <code>amso</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/subsolver_plan.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.get_objective_preconditioner" href="#Manopt.get_objective_preconditioner"><code>Manopt.get_objective_preconditioner</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y = get_objective_preconditioner(M, amso::AbstractManifoldSubObjective, p, X)
get_objective_preconditioner(M, Y, amso::AbstractManifoldSubObjective, p, X)</code></pre><p>Evaluate the Hessian of the (original) objective stored within the sub objective <code>amso</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/subsolver_plan.jl#L75-L80">source</a></section></article><h3 id="Proximal-gradient-objective"><a class="docs-heading-anchor" href="#Proximal-gradient-objective">Proximal gradient objective</a><a id="Proximal-gradient-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Proximal-gradient-objective" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manopt.ManifoldProximalGradientObjective" href="#Manopt.ManifoldProximalGradientObjective"><code>Manopt.ManifoldProximalGradientObjective</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldProximalGradientObjective{E,&lt;:AbstractEvaluationType, TC, TG, TGG, TP} &lt;: AbstractManifoldObjective{E,TC,TGG}</code></pre><p>Model an objective of the form</p><p class="math-container">\[    f(p) = g(p) + h(p),\qquad p \in \mathcal M,\]</p><p>where <span>$g: \mathcal M ‚Üí \bar{‚Ñù}$</span> is a differentiable function and <span>$h: ‚Üí \bar{‚Ñù}$</span> is a (possibly) lower semicontinous, and proper function.</p><p>This objective provides the total cost <span>$f$</span>, its smooth component <span>$g$</span>, as well as <span>$\operatorname{grad} g$</span> and <span>$\operatorname{prox}_{Œª} h$</span>.</p><p><strong>Fields</strong></p><ul><li><code>cost</code>: the overall cost <span>$f = g + h$</span></li><li><code>cost_smooth</code>: the smooth cost component <span>$g$</span></li><li><code>gradient_g!!</code>: the gradient <span>$\operatorname{grad} g$</span></li><li><code>proximal_map_h!!</code>: the proximal map <span>$\operatorname{prox}_{Œª} h$</span></li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ManifoldProximalGradientObjective(f, g, grad_g, prox_h;
    evalauation=[`AllocatingEvaluation`](@ref)
)</code></pre><p>Generate the proximal gradient objective given the total cost <code>f = g + h</code>, smooth cost <code>g</code>, the gradient of the smooth component <code>grad_g</code>, and the proximal map of the nonsmooth component <code>prox_h</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>evaluation=</code><a href="#Manopt.AllocatingEvaluation"><code>AllocatingEvaluation</code></a>: whether the gradient and proximal map is given as an allocation function or an in-place (<a href="#Manopt.InplaceEvaluation"><code>InplaceEvaluation</code></a>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/866dee2e8a89b41b694c95694111820db807900d/src/plans/proximal_gradient_plan.jl#L1-L32">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>This cache requires <a href="https://github.com/JuliaCollections/LRUCache.jl"><code>LRUCache.jl</code></a> to be loaded as well.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problem/">¬´ Problem</a><a class="docs-footer-nextpage" href="../state/">Solver State ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Tuesday 8 July 2025 19:11">Tuesday 8 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
