<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implement a Solver · Manopt.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Manopt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../Optimize!/">Get started: Optimize!</a></li><li><a class="tocitem" href="../InplaceGradient/">Speedup using Inplace computations</a></li><li><a class="tocitem" href="../AutomaticDifferentiation/">Use Automatic Differentiation</a></li><li><a class="tocitem" href="../EmbeddingObjectives/">Define Objectives in the Embedding</a></li><li><a class="tocitem" href="../CountAndCache/">Count and use a Cache</a></li><li><a class="tocitem" href="../HowToDebug/">Print Debug Output</a></li><li><a class="tocitem" href="../HowToRecord/">Record values</a></li><li class="is-active"><a class="tocitem" href>Implement a Solver</a><ul class="internal"><li><a class="tocitem" href="#Our-Guiding-Example:-A-random-walk-Minimization"><span>Our Guiding Example: A random walk Minimization</span></a></li><li><a class="tocitem" href="#Preliminaries-–-Elements-a-Solver-works-on"><span>Preliminaries – Elements a Solver works on</span></a></li><li><a class="tocitem" href="#Implementing-the-Your-solver"><span>Implementing the Your solver</span></a></li><li><a class="tocitem" href="#Ease-of-Use-I:-The-high-level-interface(s)"><span>Ease of Use I: The high level interface(s)</span></a></li><li><a class="tocitem" href="#Ease-of-Use-II:-The-State-Summary"><span>Ease of Use II: The State Summary</span></a></li><li><a class="tocitem" href="#Conclusion-and-Beyond"><span>Conclusion &amp; Beyond</span></a></li></ul></li><li><a class="tocitem" href="../ConstrainedOptimization/">Do Contrained Optimization</a></li><li><a class="tocitem" href="../GeodesicRegression/">Do Geodesic Regression</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/">Introduction</a></li><li><a class="tocitem" href="../../solvers/adaptive-regularization-with-cubics/">Adaptive Regularization with Cubics</a></li><li><a class="tocitem" href="../../solvers/alternating_gradient_descent/">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/augmented_Lagrangian_method/">Augmented Lagrangian Method</a></li><li><a class="tocitem" href="../../solvers/ChambollePock/">Chambolle-Pock</a></li><li><a class="tocitem" href="../../solvers/conjugate_gradient_descent/">Conjugate gradient descent</a></li><li><a class="tocitem" href="../../solvers/cyclic_proximal_point/">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../../solvers/difference_of_convex/">Difference of Convex</a></li><li><a class="tocitem" href="../../solvers/DouglasRachford/">Douglas–Rachford</a></li><li><a class="tocitem" href="../../solvers/exact_penalty_method/">Exact Penalty Method</a></li><li><a class="tocitem" href="../../solvers/FrankWolfe/">Frank-Wolfe</a></li><li><a class="tocitem" href="../../solvers/gradient_descent/">Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/LevenbergMarquardt/">Levenberg–Marquardt</a></li><li><a class="tocitem" href="../../solvers/NelderMead/">Nelder–Mead</a></li><li><a class="tocitem" href="../../solvers/particle_swarm/">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../../solvers/primal_dual_semismooth_Newton/">Primal-dual Riemannian semismooth Newton</a></li><li><a class="tocitem" href="../../solvers/quasi_Newton/">Quasi-Newton</a></li><li><a class="tocitem" href="../../solvers/stochastic_gradient_descent/">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../../solvers/subgradient/">Subgradient method</a></li><li><a class="tocitem" href="../../solvers/truncated_conjugate_gradient_descent/">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../../solvers/trust_regions/">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="../../plans/">Specify a Solver</a></li><li><a class="tocitem" href="../../plans/problem/">Problem</a></li><li><a class="tocitem" href="../../plans/objective/">Objective</a></li><li><a class="tocitem" href="../../plans/state/">Solver State</a></li><li><a class="tocitem" href="../../plans/stepsize/">Stepsize</a></li><li><a class="tocitem" href="../../plans/stopping_criteria/">Stopping Criteria</a></li><li><a class="tocitem" href="../../plans/debug/">Debug Output</a></li><li><a class="tocitem" href="../../plans/record/">Recording values</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../functions/">Introduction</a></li><li><a class="tocitem" href="../../functions/bezier/">Bézier curves</a></li><li><a class="tocitem" href="../../functions/costs/">Cost functions</a></li><li><a class="tocitem" href="../../functions/differentials/">Differentials</a></li><li><a class="tocitem" href="../../functions/adjoint_differentials/">Adjoint Differentials</a></li><li><a class="tocitem" href="../../functions/gradients/">Gradients</a></li><li><a class="tocitem" href="../../functions/proximal_maps/">Proximal Maps</a></li><li><a class="tocitem" href="../../functions/manifold/">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../../helpers/checks/">Checks</a></li><li><a class="tocitem" href="../../helpers/data/">Data</a></li><li><a class="tocitem" href="../../helpers/errorMeasures/">Error Measures</a></li><li><a class="tocitem" href="../../helpers/exports/">Exports</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to...</a></li><li class="is-active"><a href>Implement a Solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implement a Solver</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/tutorials/ImplementASolver.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="How-to-implementing-your-own-solver"><a class="docs-heading-anchor" href="#How-to-implementing-your-own-solver">How to implementing your own solver</a><a id="How-to-implementing-your-own-solver-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-implementing-your-own-solver" title="Permalink"></a></h1><p>Ronny Bergmann</p><p>When you have used a few solvers from <code>Manopt.jl</code> for example like in the opening tutorial <a href="https://manoptjl.org/stable/tutorials/Optimize!.html">Get Started: Optimize!</a> you might come to the idea of implementing a solver yourself.</p><p>After a short introduction of the algorithm we will implement, this tutorial first discusses the structural details, i.e. what a solver consists of and “works with”. Afterwards, we will show how to implement the algorithm. Finally, we will discuss how to make the algorithm both nice for the user as well as initialized in a way, that it can benefit from features already available in <code>Manopt.jl</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you have implemented your own solver, we would be very happy to have that within <code>Manopt.jl</code> as well, so maybe consider <a href="https://github.com/JuliaManifolds/Manopt.jl">opening a Pull Request</a></p></div></div><pre><code class="language-julia hljs">using Manopt, Manifolds, Random</code></pre><h2 id="Our-Guiding-Example:-A-random-walk-Minimization"><a class="docs-heading-anchor" href="#Our-Guiding-Example:-A-random-walk-Minimization">Our Guiding Example: A random walk Minimization</a><a id="Our-Guiding-Example:-A-random-walk-Minimization-1"></a><a class="docs-heading-anchor-permalink" href="#Our-Guiding-Example:-A-random-walk-Minimization" title="Permalink"></a></h2><p>Since most serious algorithms should be implemented in <code>Manopt.jl</code> themselves directly, we will implement a solver that randomly walks on the manifold and keeps track of the lowest point visited. As for algorithms in <code>Manopt.jl</code> we aim to implement this <em>generically</em> for any manifold that is implemented using <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/"><code>ManifoldsBase.jl</code></a>.</p><p><strong>The Random Walk Minimization</strong></p><p>Given:</p><ul><li>a manifold <span>$\mathcal M$</span></li><li>a starting point <span>$p=p^{(0)}$</span></li><li>a cost function <span>$f: \mathcal M \to\mathbb R$</span>.</li><li>a parameter <span>$\sigma &gt; 0$</span>.</li><li>a retraction <span>$\operatorname{retr}_p(X)$</span> that maps <span>$X\in T_p\mathcal M$</span> to the manifold.</li></ul><p>We can run the following steps of the algorithm</p><ol><li>set <span>$k=0$</span></li><li>set our best point <span>$q = p^{(0)}$</span></li><li>Repeat until a stopping criterion is fulfilled<ol><li>Choose a random tangent vector <span>$X^{(k)} \in T_{p^{(k)}}\mathcal M$</span> of length <span>$\lVert X^{(k)} \rVert = \sigma$</span></li><li>“Walk” along this direction, i.e. <span>$p^{(k+1)} = \operatorname{retr}_{p^{(k)}}(X^{(k)})$</span></li><li>If <span>$f(p^{(k+1)}) &lt; f(q)$</span> set q = p^{(k+1)}<span>$</span> as our new best visited point</li></ol></li><li>Return <span>$q$</span> as the resulting best point we visited</li></ol><h2 id="Preliminaries-–-Elements-a-Solver-works-on"><a class="docs-heading-anchor" href="#Preliminaries-–-Elements-a-Solver-works-on">Preliminaries – Elements a Solver works on</a><a id="Preliminaries-–-Elements-a-Solver-works-on-1"></a><a class="docs-heading-anchor-permalink" href="#Preliminaries-–-Elements-a-Solver-works-on" title="Permalink"></a></h2><p>There are two main ingredients a solver needs: a problem to work on and the state of a solver, which “identifies” the solver and stores intermediate results.</p><h3 id="The-“Task”-–-An-AbstractManoptProblem"><a class="docs-heading-anchor" href="#The-“Task”-–-An-AbstractManoptProblem">The “Task” – An <code>AbstractManoptProblem</code></a><a id="The-“Task”-–-An-AbstractManoptProblem-1"></a><a class="docs-heading-anchor-permalink" href="#The-“Task”-–-An-AbstractManoptProblem" title="Permalink"></a></h3><p>A problem in <code>Manopt.jl</code> usually consists of a manifold (an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types.html#The-AbstractManifold"><code>AbstractManifold</code></a>) and an <a href="../../plans/objective/#Manopt.AbstractManifoldObjective"><code>AbstractManifoldObjective</code></a> describing the function we have and its features. In our case the objective is (just) a <a href="../../plans/objective/#Manopt.ManifoldCostObjective"><code>ManifoldCostObjective</code></a> that stores cost function <code>f(M,p) = ...</code>. More generally, it might for example store a gradient function or the Hessian or any other information we have about our task.</p><p>This is something independent of the solver itself, since it only identifies the problem we want to solve independent of how we want to solve it – or in other words, this type contains all information that is static and independent of the specific solver at hand.</p><p>Usually the problems variable is called <code>mp</code>.</p><h3 id="The-Solver-–-An-AbstractManoptSolverState"><a class="docs-heading-anchor" href="#The-Solver-–-An-AbstractManoptSolverState">The Solver – An <code>AbstractManoptSolverState</code></a><a id="The-Solver-–-An-AbstractManoptSolverState-1"></a><a class="docs-heading-anchor-permalink" href="#The-Solver-–-An-AbstractManoptSolverState" title="Permalink"></a></h3><p>Everything that is needed by a solver during the iterations, all its parameters, interims values that are needed beyond just one iteration, is stored in a subtype of the <a href="../../plans/state/#Manopt.AbstractManoptSolverState"><code>AbstractManoptSolverState</code></a>. This identifies the solver uniquely.</p><p>In our case we want to store five things</p><ul><li>the current iterate <code>p</code><span>$=p^{(k)}$</span></li><li>the best visited point <span>$q$</span></li><li>the variable <span>$\sigma &gt; 0$</span></li><li>the retraction <span>$\operatorname{retr}$</span> to use (cf. <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions.html">retractions and inverse retractions</a>)</li><li>a criterion, when to stop, i.e. a <a href="../../plans/stopping_criteria/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a></li></ul><p>We can defined this as</p><pre><code class="language-julia hljs">mutable struct RandomWalkState{
    P,
    R&lt;:AbstractRetractionMethod,
    S&lt;:StoppingCriterion,
} &lt;: AbstractManoptSolverState
  p::P
  q::P
  σ::Float64
  retraction_method::R
  stop::S
end</code></pre><p>The stopping criterion is usually stored in the state’s <code>stop</code> field. If you have a reason to do otherwise, you have one more function to implement (see next section). For ease of use, we can provide a constructor, that for example chooses a good default for the retraction based on a given manifold.</p><pre><code class="language-julia hljs">function RandomWalkState(M::AbstractManifold, p::P=rand(M);
    σ = 0.1,
    retraction_method::R=default_retraction_method(M),
    stopping_criterion::S=StopAfterIteration(200)
) where {P, R&lt;:AbstractRetractionMethod, S&lt;:StoppingCriterion}
    return RandomWalkState{P,R,S}(p, copy(M, p), σ, retraction_method, stopping_criterion)
end</code></pre><p>Parametrising the state avoid that we have abstract typed fields. The keyword arguments for the retraction and stopping criterion are the ones usually used in <code>Manopt.jl</code> and provide an easy way to construct this state now.</p><p>States usually have a shortened name as their variable, we will use <code>rws</code> for our state here.</p><h2 id="Implementing-the-Your-solver"><a class="docs-heading-anchor" href="#Implementing-the-Your-solver">Implementing the Your solver</a><a id="Implementing-the-Your-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-Your-solver" title="Permalink"></a></h2><p>There is basically only two methods we need to implement for our solver</p><ul><li><code>initialize_solver!(mp, rws)</code> which initialises the solver before the first iteration</li><li><code>step_solver!(mp, rws, i)</code> which implements the <code>i</code>th iteration, where <code>i</code> is given to you as the third parameter</li><li><code>get_iterate(rws)</code> which accesses the iterate from other places in the solver</li><li><code>get_solver_result(rws)</code> returning the solvers final (best) point we reached. By default this would return the last iterate <code>rws.p</code> (or more precisely calls <a href="../../plans/state/#Manopt.get_iterate"><code>get_iterate</code></a>), but since we randomly walk and remember our best point in <code>q</code>, this has to return <code>rws.q</code>.</li></ul><p>The first two functions are in-place functions, that is they modify our solver state <code>rws</code>. You implement these by multiple dispatch on the types after importing said functions from Manopt:</p><pre><code class="language-julia hljs">import Manopt: initialize_solver!, step_solver!, get_iterate, get_solver_result</code></pre><p>The state above has two fields where we use the common names used in <code>Manopt.jl</code>, that is the <a href="../../plans/stopping_criteria/#Manopt.StoppingCriterion"><code>StoppingCriterion</code></a> is usually in <code>stop</code> and the iterate in <code>p</code>. If your choice is different, you need to reimplement</p><ul><li><code>stop_solver!(mp, rws, i)</code> to determine whether or not to stop after the <code>i</code>th iteration.</li><li><code>get_iterate(rws)</code> to access the current iterate</li></ul><p>We recommend to follow the general scheme with the <code>stop</code> field. If you have specific criteria when to stop, consider implementing your own <a href="https://manoptjl.org/stable/plans/stopping_criteria/">stoping criterion</a> instead.</p><h3 id="Initialization-and-Iterate-Access"><a class="docs-heading-anchor" href="#Initialization-and-Iterate-Access">Initialization &amp; Iterate Access</a><a id="Initialization-and-Iterate-Access-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization-and-Iterate-Access" title="Permalink"></a></h3><p>For our solver, there is not so much to initialize, just to be safe we should copy over the initial value in <code>p</code> we start with, to <code>q</code>. We do not have to care about remembering the iterate, that is done by <code>Manopt.jl</code>. For the iterate access we just have to pass <code>p</code>.</p><pre><code class="language-julia hljs">function initialize_solver!(mp::AbstractManoptProblem, rws::RandomWalkState)
    copyto!(M, rws.q, rws.p) # Set p^{(0)} = q
    return rws
end
get_iterate(rws::RandomWalkState) = rws.p
get_solver_result(rws::RandomWalkState) = rws.q</code></pre><p>and similarly we implement the step. Here we make use of the fact that the problem (and also the objective in fact) have access functions for their elements, the one we need is <a href="../../plans/objective/#Manopt.get_cost"><code>get_cost</code></a>.</p><pre><code class="language-julia hljs">function step_solver!(mp::AbstractManoptProblem, rws::RandomWalkState, i)
    M = get_manifold(mp) # for ease of use get the manifold from the problem
    X = rand(M; vector_at=p)     # generate a direction
    X .*= rws.σ/norm(M, p, X)
    # Walk
    retract!(M, rws.p, rws.p, X, rws.retraction_method)
    # is the new point better? Then store it
    if get_cost(mp, rws.p) &lt; get_cost(mp, rws.q)
        copyto!(M, rws.p, rws.q)
    end
    return rws
end</code></pre><p>Performance wise we could improve the number of allocations by making <code>X</code> also a field of our <code>rws</code> but let’s keep it simple here. We could also store the cost of <code>q</code> in the state, but we will see how to easily also enable this solver to allow for <a href="https://manoptjl.org/stable/tutorials/CountAndCache/#How-to-Count-and-Cache-Function-Calls">caching</a>. In practice, however, it is preferable to cache intermediate values like cost of <code>q</code> in the state when it can be easily achieved. This way we do not have to deal with overheads of an external cache.</p><p>Now we can just run the solver already! We take the same example as for the other tutorials</p><p>We first define our task, the Riemannian Center of Mass from the <a href="https://manoptjl.org/stable/tutorials/Optimize!.html">Get Started: Optimize!</a> tutorial.</p><pre><code class="language-julia hljs">Random.seed!(23)
n = 100
σ = π / 8
M = Sphere(2)
p = 1 / sqrt(2) * [1.0, 0.0, 1.0]
data = [exp(M, p,  σ * rand(M; vector_at=p)) for i in 1:n];
f(M, p) = sum(1 / (2 * n) * distance.(Ref(M), Ref(p), data) .^ 2)</code></pre><p>We can now generate the problem with its objective and the state</p><pre><code class="language-julia hljs">mp = DefaultManoptProblem(M, ManifoldCostObjective(f))
s = RandomWalkState(M; σ = 0.2)

solve!(mp, s)
get_solver_result(s)</code></pre><pre><code class="nohighlight hljs">3-element Vector{Float64}:
 -0.2412674850987521
  0.8608618657176527
 -0.44800317943876844</code></pre><p>The function <code>solve!</code> works also in place of <code>s</code>, but the last line illustrates how to access the result in general; we could also just look at <code>s.p</code>, but the function <code>get_iterate</code> is also used in several other places.</p><p>We could for example easily set up a second solver to work from a specified starting point with a different <code>σ</code> like</p><pre><code class="language-julia hljs">s2 = RandomWalkState(M, [1.0, 0.0, 0.0];  σ = 0.1)
solve!(mp, s2)
get_solver_result(s2)</code></pre><pre><code class="nohighlight hljs">3-element Vector{Float64}:
 1.0
 0.0
 0.0</code></pre><h2 id="Ease-of-Use-I:-The-high-level-interface(s)"><a class="docs-heading-anchor" href="#Ease-of-Use-I:-The-high-level-interface(s)">Ease of Use I: The high level interface(s)</a><a id="Ease-of-Use-I:-The-high-level-interface(s)-1"></a><a class="docs-heading-anchor-permalink" href="#Ease-of-Use-I:-The-high-level-interface(s)" title="Permalink"></a></h2><p><code>Manopt.jl</code> offers a few additional features for solvers in their high level interfaces, for example <a href="../../plans/debug/#DebugSection"><code>debug=</code> for debug</a>, <a href="../../plans/record/#RecordSection"><code>record=</code></a> keywords for debug and recording within solver states or <a href="../../plans/objective/#ObjectiveSection"><code>count=</code> and <code>cache</code></a> keywords for the objective.</p><p>We can introduce these here as well with just a few lines of code. There are usually two steps. We further need three internal function from <code>Manopt.jl</code></p><pre><code class="language-julia hljs">using Manopt: get_solver_return, indicates_convergence, status_summary</code></pre><h3 id="A-high-level-interface-using-the-objective"><a class="docs-heading-anchor" href="#A-high-level-interface-using-the-objective">A high level interface using the objective</a><a id="A-high-level-interface-using-the-objective-1"></a><a class="docs-heading-anchor-permalink" href="#A-high-level-interface-using-the-objective" title="Permalink"></a></h3><p>This could be considered as an interims step to the high-level interface: If we already have the objective – in our case a <a href="../../plans/objective/#Manopt.ManifoldCostObjective"><code>ManifoldCostObjective</code></a> at hand, the high level interface consists of the steps</p><ol><li>possibly decorate the objective</li><li>generate the problem</li><li>generate and possiblz generate the state</li><li>call the solver</li><li>determine the return value</li></ol><p>We illustrate the step with an in-place variant here. A variant that keeps the given start point unchanged would just add a <code>copy(M, p)</code> upfront. <code>Manopt.jl</code> provides both variants.</p><pre><code class="language-julia hljs">function random_walk_algorithm!(
    M::AbstractManifold,
    mgo::ManifoldCostObjective,
    p;
    σ = 0.1,
    retraction_method::AbstractRetractionMethod=default_retraction_method(M, typeof(p)),
    stopping_criterion::StoppingCriterion=StopAfterIteration(200),
    kwargs...,
)
    dmgo = decorate_objective!(M, mgo; kwargs...)
    dmp = DefaultManoptProblem(M, dmgo)
    s = RandomWalkState(M, [1.0, 0.0, 0.0];
        σ=0.1,
        retraction_method=retraction_method, stopping_criterion=stopping_criterion,
    )
    ds = decorate_state!(s; kwargs...)
    solve!(dmp, ds)
    return get_solver_return(get_objective(dmp), ds)
end</code></pre><pre><code class="nohighlight hljs">random_walk_algorithm! (generic function with 1 method)</code></pre><h3 id="The-high-level-interface"><a class="docs-heading-anchor" href="#The-high-level-interface">The high level interface</a><a id="The-high-level-interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-high-level-interface" title="Permalink"></a></h3><p>Starting from the last section, the usual call a user would prefer is just passing a manifold <code>M</code> the cost <code>f</code> and maybe a start point <code>p</code>.</p><pre><code class="language-julia hljs">function random_walk_algorithm!(M::AbstractManifold, f, p=rand(M); kwargs...)
    mgo = ManifoldCostObjective(f)
    return random_walk_algorithm!(M, mgo, p; kwargs...)
end</code></pre><pre><code class="nohighlight hljs">random_walk_algorithm! (generic function with 3 methods)</code></pre><h2 id="Ease-of-Use-II:-The-State-Summary"><a class="docs-heading-anchor" href="#Ease-of-Use-II:-The-State-Summary">Ease of Use II: The State Summary</a><a id="Ease-of-Use-II:-The-State-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Ease-of-Use-II:-The-State-Summary" title="Permalink"></a></h2><p>For the case that you set <code>return_state=true</code> the solver should return a summary of the run. When a <code>show</code> method is provided, users can easily read such summary in a terminal. It should reflect its main parameters, if they are not too verbose and provide information about the reason it stopped and whether this indicates convergence.</p><p>Here it would for example look like</p><pre><code class="language-julia hljs">import Base: show
function show(io::IO, rws::RandomWalkState)
    i = get_count(rws, :Iterations)
    Iter = (i &gt; 0) ? &quot;After $i iterations\n&quot; : &quot;&quot;
    Conv = indicates_convergence(rws.stop) ? &quot;Yes&quot; : &quot;No&quot;
    s = &quot;&quot;&quot;
    # Solver state for `Manopt.jl`s Tutorial Random Walk
    $Iter
    ## Parameters
    * retraction method: $(rws.retraction_method)
    * σ                : $(rws.σ)

    ## Stopping Criterion
    $(status_summary(rws.stop))
    This indicates convergence: $Conv&quot;&quot;&quot;
    return print(io, s)
end</code></pre><pre><code class="nohighlight hljs">show (generic function with 671 methods)</code></pre><p>Now the algorithm can be easily called and provides – if wanted – all features of a <code>Manopt.jl</code> algorithm. For example to see the summary, we could now just call</p><pre><code class="language-julia hljs">q = random_walk_algorithm!(M, f; return_state=true)</code></pre><pre><code class="nohighlight hljs"># Solver state for `Manopt.jl`s Tutorial Random Walk
After 200 iterations

## Parameters
* retraction method: ExponentialRetraction()
* σ                : 0.1

## Stopping Criterion
Max Iteration 200:  reached
This indicates convergence: No</code></pre><h2 id="Conclusion-and-Beyond"><a class="docs-heading-anchor" href="#Conclusion-and-Beyond">Conclusion &amp; Beyond</a><a id="Conclusion-and-Beyond-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion-and-Beyond" title="Permalink"></a></h2><p>We saw in this tutorial how to implement a simple cost-based algorithm, to illustrate how optimization algorithms are covered in <code>Manopt.jl</code>.</p><p>One feature we did not cover is that most algorithms allow for inplace and allocation functions, as soon as they work on more than just the cost, e.g. gradients, proximal maps or Hessians. This is usually a keyword argument of the objective and hence also part of the high-level interfaces.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../HowToRecord/">« Record values</a><a class="docs-footer-nextpage" href="../ConstrainedOptimization/">Do Contrained Optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 20 September 2023 19:19">Wednesday 20 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
